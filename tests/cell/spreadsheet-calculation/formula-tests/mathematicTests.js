/*
 * (c) Copyright Ascensio System SIA 2010-2025
 *
 * This program is a free software product. You can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License (AGPL)
 * version 3 as published by the Free Software Foundation. In accordance with
 * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect
 * that Ascensio System SIA expressly excludes the warranty of non-infringement
 * of any third-party rights.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For
 * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html
 *
 * You can contact Ascensio System SIA at 20A-6 Ernesta Birznieka-Upish
 * street, Riga, Latvia, EU, LV-1050.
 *
 * The  interactive user interfaces in modified source and object code versions
 * of the Program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU AGPL version 3.
 *
 * Pursuant to Section 7(b) of the License you must retain the original Product
 * logo when distributing the program. Pursuant to Section 7(e) we decline to
 * grant you any rights under trademark law for use of our trademarks.
 *
 * All the Product's GUI elements, including illustrations and icon sets, as
 * well as technical writing content are licensed under the terms of the
 * Creative Commons Attribution-ShareAlike 4.0 International. See the License
 * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode
 *
 */


$(function () {
	// Mocks for API Testing
	Asc.spreadsheet_api.prototype._init = function () {
		this._loadModules();
	};
	Asc.spreadsheet_api.prototype._loadFonts = function (fonts, callback) {
		callback();
	};
	AscCommonExcel.WorkbookView.prototype._calcMaxDigitWidth = function () {
	};
	AscCommonExcel.WorkbookView.prototype._init = function () {
	};
	AscCommonExcel.WorkbookView.prototype._isLockedUserProtectedRange = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorkbookView.prototype._onWSSelectionChanged = function () {
	};
	AscCommonExcel.WorkbookView.prototype.showWorksheet = function () {
	};
	AscCommonExcel.WorkbookView.prototype.recalculateDrawingObjects = function () {
	};
	AscCommonExcel.WorkbookView.prototype.restoreFocus = function () {
	};
	AscCommonExcel.WorksheetView.prototype._init = function () {
	};
	AscCommonExcel.WorksheetView.prototype.updateRanges = function () {
	};
	AscCommonExcel.WorksheetView.prototype._autoFitColumnsWidth = function () {
	};
	AscCommonExcel.WorksheetView.prototype.cleanSelection = function () {
	};
	AscCommonExcel.WorksheetView.prototype._drawSelection = function () {
	};
	AscCommonExcel.WorksheetView.prototype._scrollToRange = function () {
	};
	AscCommonExcel.WorksheetView.prototype.draw = function () {
	};
	AscCommonExcel.WorksheetView.prototype._prepareDrawingObjects = function () {
	};
	AscCommonExcel.WorksheetView.prototype._initCellsArea = function () {
	};
	AscCommonExcel.WorksheetView.prototype.getZoom = function () {
	};
	AscCommonExcel.WorksheetView.prototype._prepareCellTextMetricsCache = function () {
	};

	AscCommon.baseEditorsApi.prototype._onEndLoadSdk = function () {
	};

	AscCommon.baseEditorsApi.prototype._onEndLoadSdk = function () {
	};
	Asc.ReadDefTableStyles = function () {
	};
	AscCommonExcel.WorksheetView.prototype._isLockedCells = function (oFromRange, subType, callback) {
		callback(true);
		return true;
	};
	AscCommonExcel.WorksheetView.prototype._isLockedAll = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorksheetView.prototype._isLockedFrozenPane = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorksheetView.prototype._updateVisibleColsCount = function () {
	};
	AscCommonExcel.WorksheetView.prototype._calcActiveCellOffset = function () {
	};

	// Init basic data
	const parserFormula = AscCommonExcel.parserFormula;
	const g_oIdCounter = AscCommon.g_oIdCounter;
    const c_msPerDay = AscCommonExcel.c_msPerDay;
	const GetDiffDate360 = AscCommonExcel.GetDiffDate360;
	const fSortAscending = AscCommon.fSortAscending;
	const ParseResult = AscCommonExcel.ParseResult;
	const c_oAscError = Asc.c_oAscError;

	let oParser, wb, ws, sData = AscCommon.getEmpty(), tmp, dif = 1e-9;

	if (AscCommon.c_oSerFormat.Signature === sData.substring(0, AscCommon.c_oSerFormat.Signature.length)) {

		Asc.spreadsheet_api.prototype._init = function() {
			this.isLoadFullApi = true;
		};


		let api = new Asc.spreadsheet_api({
			'id-view': 'editor_sdk'
		});
		api.FontLoader = {
			LoadDocumentFonts: function () {
			}
		};

		let docInfo = new Asc.asc_CDocInfo();
		docInfo.asc_putTitle("TeSt.xlsx");
		api.DocInfo = docInfo;


		window["Asc"]["editor"] = api;
		AscCommon.g_oTableId.init(api);
		api._onEndLoadSdk();
		api.isOpenOOXInBrowser = false;
		api.OpenDocumentFromBin(null, AscCommon.getEmpty());
		api.initCollaborativeEditing({});
		wb = new AscCommonExcel.Workbook(new AscCommonExcel.asc_CHandlersList(), api, true);
		api.wbModel = wb;
		api.wb = new AscCommonExcel.WorkbookView(api.wbModel, api.controller, api.handlers, api.HtmlElement,
			api.topLineEditorElement, api, api.collaborativeEditing, api.fontRenderingMode);
		AscCommon.History.init(wb);
		// There is no operation with history, disabled to avoid unnecessary serializations.
		AscCommon.History.TurnOff();
		wb.maxDigitWidth = 7;
		wb.paddingPlusBorder = 5;

		api.initCollaborativeEditing({});

		if (this.User) {
			g_oIdCounter.Set_UserId(this.User.asc_getId());
		}

		AscCommonExcel.g_oUndoRedoCell = new AscCommonExcel.UndoRedoCell(wb);
		AscCommonExcel.g_oUndoRedoWorksheet = new AscCommonExcel.UndoRedoWoorksheet(wb);
		AscCommonExcel.g_oUndoRedoWorkbook = new AscCommonExcel.UndoRedoWorkbook(wb);
		AscCommonExcel.g_oUndoRedoCol = new AscCommonExcel.UndoRedoRowCol(wb, false);
		AscCommonExcel.g_oUndoRedoRow = new AscCommonExcel.UndoRedoRowCol(wb, true);
		AscCommonExcel.g_oUndoRedoComment = new AscCommonExcel.UndoRedoComment(wb);
		AscCommonExcel.g_oUndoRedoAutoFilters = new AscCommonExcel.UndoRedoAutoFilters(wb);
		AscCommonExcel.g_DefNameWorksheet = new AscCommonExcel.Worksheet(wb, -1);
		g_oIdCounter.Set_Load(false);

		const oBinaryFileReader = new AscCommonExcel.BinaryFileReader();
		oBinaryFileReader.Read(sData, wb);
		ws = wb.getWorksheet(wb.getActive());
		AscCommonExcel.getFormulasInfo();
	}

	// Init basic functions
	function testArrayFormula(assert, func, dNotSupportAreaArg) {

		const getValue = function (ref) {
			oParser = new parserFormula(func + "(" + ref + ")", "A2", ws);
			assert.ok(oParser.parse(), 'Formula is parsed');
			return oParser.calculate().getValue();
		};
		const description = `Test: testArrayFormula. ${func}. `;

		//***array-formula***
		ws.getRange2("A100").setValue("1");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("C100").setValue("-4");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B101").setValue("4");
		ws.getRange2("C101").setValue("5");


		oParser = new parserFormula(func + "(A100:C101)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
		assert.ok(oParser.parse(), 'Formula is parsed.');
		let array = oParser.calculate();
		if (AscCommonExcel.cElementType.array === array.type) {
			assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue("A100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue("B100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue("C100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 0).getValue(), getValue("A101"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 1).getValue(), getValue("B101"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 2).getValue(), getValue("C101"), description + 'Reference Link. Area.');
		} else {
			if (!dNotSupportAreaArg) {
				assert.strictEqual(false, true, 'func: ' + func + ' don\'t support area argument.');
			}
			//consoleLog("func: " + func + " don't return area array");
		}

		oParser = new parserFormula(func + "({1,2,-3})", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
		assert.ok(oParser.parse(), 'Formula is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue(1), description + 'Number.');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue(2), description + 'Number.');
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue(-3), description + 'Number.');
	}
	//returnOnlyValue - those functions that must always be fed arrays as input and that return a single value
	function testArrayFormula2(assert, func, minArgCount, maxArgCount, dNotSupportAreaArg, returnOnlyValue) {

		const getValue = function (ref, countArg) {
			let argStr = "(";
			for (let j = 1; j <= countArg; j++) {
				argStr += ref;
				if (i !== j) {
					argStr += ",";
				} else {
					argStr += ")";
				}
			}
			oParser = new parserFormula(func + argStr, "A2", ws);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + argStr + ' is parsed.');
			return oParser.calculate().getValue();
		};


		//***array-formula***
		ws.getRange2("A100").setValue("1");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("C100").setValue("-4");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B101").setValue("4");
		ws.getRange2("C101").setValue("5");

		//формируем массив значений
		const randomArray = [];
		let randomStrArray = "{";
		let maxArg = 4;
		for (let i = 1; i <= maxArg; i++) {
			let randVal = Math.random();
			randomArray.push(randVal);
			randomStrArray += randVal;
			if (i !== maxArg) {
				randomStrArray += ",";
			} else {
				randomStrArray += "}";
			}
		}

		for (var i = minArgCount; i <= maxArgCount; i++) {
			let argStrArr = "(";
			let randomArgStrArr = "(";
			for (let j = 1; j <= i; j++) {
				argStrArr += "A100:C101";
				randomArgStrArr += randomStrArray;
				if (i !== j) {
					argStrArr += ",";
					randomArgStrArr += ",";
				} else {
					argStrArr += ")";
					randomArgStrArr += ")";
				}
			}

			oParser = new parserFormula(func + argStrArr, "A1", ws);
			oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + argStrArr + ' is parsed.');
			let array = oParser.calculate();
			if (AscCommonExcel.cElementType.array === array.type) {
				assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue("A100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue("B100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue("C100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 0).getValue(), getValue("A101", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 1).getValue(), getValue("B101", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 2).getValue(), getValue("C101", i), 'Test: testArrayFormula2. Area.');
			} else {
				if (!(dNotSupportAreaArg || returnOnlyValue)) {
					assert.strictEqual(false, true);
				}
				//consoleLog("func: " + func + " don't return area array");
			}

			oParser = new parserFormula(func + randomArgStrArr, "A1", ws);
			oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + randomArgStrArr + ' is parsed.');
			array = oParser.calculate();
			if (AscCommonExcel.cElementType.array === array.type) {
				assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue(randomArray[0], i), 'Test: testArrayFormula2. Random array');
				assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue(randomArray[1], i), 'Test: testArrayFormula2. Random array');
				assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue(randomArray[2], i), 'Test: testArrayFormula2. Random array');
			} else {
				if (!returnOnlyValue) {
					assert.strictEqual(false, true);
				}
				//consoleLog("func: " + func + " don't return array");
			}
		}
	}

	function difBetween(a, b) {
		return Math.abs(a - b) < dif
	}

	function numDivFact(num, fact) {
		let res = num / Math.fact(fact);
		res = res.toString();
		return res;
	}


	/**
	 * Function creates table or edit existed table.
	 * * Creating happened when the function was called for the first time in the code totally.
	 * In that case, you should set range coordinates like you're creating table, select needed range.
	 * * For editing table you should consider that you have constant row with header and one data row as minimum required.
	 * In that case your minimum row coordinates must be equal 2 rows.
	 * For filling data use cells A601:L6**
	 * @param {number} r1
	 * @param {number} c1
	 * @param {number} r2
	 * @param {number} c2
	 * @returns {TablePart}
	 */
	function getTableType(r1, c1, r2, c2) {
		const range = new window["Asc"].Range(c1, r1, c2, r2);
		const  tableName = 'Table1';
		const tableParts = ws.TableParts;
		/** @type {TablePart} */
		const foundedTable = tableParts.find(function(table) { return table.DisplayName === tableName});
		if (foundedTable) {
			// Change table
			ws.autoFilters.changeTableRange(tableName, range);
			return foundedTable;
		}
		// Create table
		const tableOptFormat = ws.autoFilters.getAddFormatTableOptions(range);
		const styleName = 'TableStyleMedium2';
		ws.autoFilters.addAutoFilter(styleName, range, tableOptFormat);

		return tableParts[tableParts.length - 1]
	}
	function getSecondSheet () {
		let ws2 = wb.getWorksheetByName('Sheet2');
		if (!ws2) {
			ws2 = wb.createWorksheet(null, 'Sheet2');
		}

		return ws2;
	}
	function initDefNames() {
		const defName = new Asc.asc_CDefName('TestName', ws.getName() + '!$A$201');
		const defName2 = new Asc.asc_CDefName('TestName1', ws.getName() + '!$A$202');
		const defName3 = new Asc.asc_CDefName('TestName2', ws.getName() + '!$A$203');
		const defName4 = new Asc.asc_CDefName('TestName3', ws.getName() + '!$A$204');
		const defName5 = new Asc.asc_CDefName('TestName4', ws.getName() + '!$A$205');
		const defNameArea = new Asc.asc_CDefName('TestNameArea', ws.getName() + '!$A$206:$A$207');
		const defNameArea2 = new Asc.asc_CDefName('TestNameArea2', ws.getName() + '!$A$208:$B$208');
		const ws2 = getSecondSheet();
		const defName3D = new Asc.asc_CDefName('TestName3D', ws2.getName() + '!$A$11');
		const defName3D2 = new Asc.asc_CDefName('TestName3D1', ws2.getName() + '!$A$12');
		const defName3D3 = new Asc.asc_CDefName('TestName3D2', ws2.getName() + '!$A$13');
		const defName3D4 = new Asc.asc_CDefName('TestName3D3', ws2.getName() + '!$A$14');
		const defName3D5 = new Asc.asc_CDefName('TestName3D4', ws2.getName() + '!$A$15');
		const defNameArea3D = new Asc.asc_CDefName('TestNameArea3D', ws2.getName() + '!$A$16:$A$17');
		const defNameArea3D2 = new Asc.asc_CDefName('TestNameArea3D2', ws2.getName() + '!$A$18:$B$18');

		wb.editDefinesNames(null, defName);
		wb.editDefinesNames(null, defName2);
		wb.editDefinesNames(null, defName3);
		wb.editDefinesNames(null, defName4);
		wb.editDefinesNames(null, defName5);
		wb.editDefinesNames(null, defNameArea);
		wb.editDefinesNames(null, defNameArea2);
		wb.editDefinesNames(null, defName3D);
		wb.editDefinesNames(null, defName3D2);
		wb.editDefinesNames(null, defName3D3);
		wb.editDefinesNames(null, defName3D4);
		wb.editDefinesNames(null, defName3D5);
		wb.editDefinesNames(null, defNameArea3D);
		wb.editDefinesNames(null, defNameArea3D2);
	}

	wb.dependencyFormulas.lockRecal();
	getTableType(599, 0, 599, 0); // Init table
	initDefNames();

	QUnit.module('Mathematic formulas');

	QUnit.test("Test: \"ABS\"", function (assert) {
		// Positive cases:
		// Case #1: Number. Integer positive number
		oParser = new parserFormula("ABS(2)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Integer positive number. Result: 2');
		// Case #2: Number. Integer negative number
		oParser = new parserFormula("ABS(-2)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Integer negative number. Result: 2');
		// Case #3: Reference link. Integer negative number from ref.
		ws.getRange2("A22").setValue("-4");
		oParser = new parserFormula("ABS(A22)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Reference link. Integer negative number from ref. Result: 4');
		// Case #4: Reference link. Float negative number from ref with formula.
		ws.getRange2("A22").setValue("=2-3.5");
		oParser = new parserFormula("ABS(A22)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Reference link. Float negative number from ref with formula. Result: 1.5');
		// Case #5: Boolean. Non-standard case.
		oParser = new parserFormula("ABS(TRUE)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean. Non-standard case. Result: 1');
		// Case #6: Boolean. Non-standard case.
		oParser = new parserFormula("ABS(FALSE)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean. Non-standard case. Result: 0');
		// Case #7: Reference link. Non-standard case. Empty cell.
		ws.getRange2("A22").setValue("");
		oParser = new parserFormula("ABS(A22)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Non-standard case. Empty cell. Result: 0');
		// Case #8: String. Non-standard case. Number in string type.
		oParser = new parserFormula("ABS(\"-2\")", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String. Non-standard case. Number in string type. Result: 2');
		// Case #9: Formula. Non-standard case. Getting date using DATE formula.
		oParser = new parserFormula("ABS(-DATE(2024,1,1))", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 45292, 'Test: Positive case: Formula. Non-standard case. Getting date using DATE formula. Result: 45292');
		// Case #10: String. Non-standard case. Float number with regional separator
		oParser = new parserFormula("ABS(\"-2.5\")", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: String. Non-standard case. Float number with regional separator. Result: 2.5');
		// Case #11: String. Non-standard case.  Number with separator for date.
		oParser = new parserFormula("ABS(\"5/5\")", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 45782, 'Test: Positive case: String. Non-standard case.  Number with separator for date. Result: 45782');
		// Case #12: String. Non-standard case. Date.
		oParser = new parserFormula("ABS(\"12/12/2000\")", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 36872, 'Test: Positive case: String. Non-standard case. Date. Result: 36872');
		// Case #13: Reference link. Date.
		ws.getRange2("A22").setValue("12/12/2000");
		oParser = new parserFormula("ABS(A22)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 36872, 'Test: Positive case: Reference link. Date. Result: 36872');
		// Case #14: Formula. Nested formula which return a number.
		oParser = new parserFormula("ABS(-SQRT(16))", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Nested formula which return a number. Result: 4');
		// Case #15: Formula. Non-standard case. Getting time using formula TIME.
		oParser = new parserFormula("ABS(-TIME(12,0,0))", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Non-standard case. Getting time using formula TIME. Result: 0.5');
		// Case #16: String. Non-standard case. Time.
		oParser = new parserFormula("ABS(\"12:00:00\")", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Non-standard case. Time. Result: 0.5');
		// Case #17: Reference link. Non-standard case. Time.
		ws.getRange2("A22").setValue("12:00:00");
		oParser = new parserFormula("ABS(A22)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. Non-standard case. Time. Result: 0.5');
		// Case #18: Formula. Non-standard case. Formula with number to string type.
		oParser = new parserFormula("ABS(\"1\"+\"1\")", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Non-standard case. Formula with number to string type. Result: 2');
		// Case #19: Area. Non-standard case.  Range of cells with numbers.
		ws.getRange2("A22").setValue("-11");
		ws.getRange2("B22").setValue("-1");
		oParser = new parserFormula("ABS(A22:B22)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Area. Non-standard case.  Range of cells with numbers. Result: 11');
		// Case #20: Formula. ABS is an argument of the parent formula that expects an "Area" type as input.
		oParser = new parserFormula("SUM(ABS(A22:B22))", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Formula. ABS is an argument of the parent formula that expects an "Area" type as input. Result: 12');
		// Case #21: Formula. ABS is an argument with array data of the parent formula that expects an array type as input.
		oParser = new parserFormula('SUM(ABS({-1, -2, -3, -4}))', "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. ABS is an argument with array data of the parent formula that expects an array type as input. Result: 10');
		// Negative cases:
		// Case #1: String. Text.
		oParser = new parserFormula("ABS(\"test\")", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Text. Result: #VALUE!');
		// Case #2: String. Float number with not correct separator.
		oParser = new parserFormula("ABS(\"-2,5\")", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Float number with not correct separator. Result: #VALUE!');
		// Case #3: Formula. Nested formula which return a string
		oParser = new parserFormula("ABS(-REPT(\"a\", 2))", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Nested formula which return a string. Result: #VALUE!');
		// Case #4: Formula. Wrong formula which return the error - #DIV/0!
		oParser = new parserFormula("ABS(-1/0)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Wrong formula which return a error. Result: #DIV/0!');
		// Case #5: Formula. Nested formula which return the error - #NUM!
		oParser = new parserFormula("ABS(SQRT(-1))", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula which return a error. Result: #NUM!');
		// Case #6: Formula. Nested formula which return the error - #REF!
		oParser = new parserFormula("ABS(INDIRECT(\"A0\"))", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Formula. Nested formula which return a error. Result: #REF!');
		// Case #7: Formula. Nested formula which return the error - #N/A
		// TODO Uncomment test and check work after finish work with VLOOKUP formula
		/*oParser = new parserFormula("ABS(VLOOKUP(1,A1:A2,2,FALSE))", "A3", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Nested formula which return a error. Result: #N/A');*/
		// Case #8: Reference link. Incorrect cross which return the error - #NULL!
		oParser = new parserFormula("ABS(A22 B22)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link. Incorrect cross which return the error. Result: #NULL!');
		// Case #9: Formula. String + number.
		oParser = new parserFormula("ABS(\"test\"+1)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. String + number. Result: #VALUE!');
		// Case #10: String. Empty string
		oParser = new parserFormula("ABS(\"\")", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string. Result: #VALUE!');
		// Case #11: Reference link. Cell with text.
		ws.getRange2("A22").setValue("test");
		oParser = new parserFormula("ABS(A22)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Cell with text. Result: #VALUE!');
		// Case #12: Array. Empty array.
		oParser = new parserFormula("ABS({})", "A1", ws);
		parseResult = new ParseResult(undefined, undefined);
		assert.notOk(oParser.parse(null, null, parseResult), 'Formula isn\'t parsed');
		assert.strictEqual(parseResult.error, c_oAscError.ID.FrmlAnotherParsingError, 'Test: Negative case: Array. Empty array. Error: -301');
		parseResult = null;
		// Case #13: Empty. Without args.
		oParser = new parserFormula("ABS()", "A1", ws);
		parseResult = new ParseResult(undefined, undefined);
		assert.notOk(oParser.parse(null, null, parseResult), 'Formula isn\'t parsed');
		assert.strictEqual(parseResult.error, c_oAscError.ID.FrmlWrongCountArgument , 'Test: Negative case: Empty. Without args. Error: -303');
		parseResult = null;
		// Case #14: Number. Extra not expected arg.
		oParser = new parserFormula("ABS(1,2)", "A1", ws);
		parseResult = new ParseResult(undefined, undefined);
		assert.notOk(oParser.parse(null, null, parseResult), 'Test: Negative case: Number. Extra not expected arg. Formula isn\'t parsed');
		assert.strictEqual(parseResult.error, c_oAscError.ID.FrmlWrongMaxArgument, 'Test: Negative case: Number. Extra not expected arg. Error: -302');
		parseResult = null;
		// Bounded cases:
		// Case #1: Number. Bounded positive case maximum number
		oParser = new parserFormula("ABS(9.99999999999999E+307)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number. Bounded positive case maximum number. Result: 9.99999999999999e+307');
		// Case #2: Number. Bounded  positive case minimum number
		oParser = new parserFormula("ABS(-9.99999999999999E+307)", "A1", ws);
		assert.ok(oParser.parse(), 'Formula is parsed');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number. Bounded positive case minimum number. Result: 9.99999999999999e+307');

		testArrayFormula(assert, "ABS");
	});

	QUnit.test("Test: \"ACOS\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:

		// Case #0: Number. Basic valid input. Negative number. Argument in [-1,1] range.
		oParser = new parserFormula('ACOS(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.094395102, 'Test: Positive case: Number. Basic valid input. Negative number. Argument in [-1,1] range.');
		// Case #1: Number. Basic valid input. Argument in [-1,1] range.
		oParser = new parserFormula('ACOS(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: Number. Basic valid input. Argument in [-1,1] range.');
		// Case #2: String. Numeric string converted to number.
		oParser = new parserFormula('ACOS("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: String. Numeric string converted to number.');
		// Case #3: Formula. Nested function calculation.
		oParser = new parserFormula('ACOS(SQRT(0.25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(SQRT(0.25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: Formula. Nested function calculation.');
		// Case #4: Reference link. Cell reference argument.
		oParser = new parserFormula('ACOS(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: Reference link. Cell reference argument.');
		// Case #5: Area. Non-standard case. Single-cell range argument.
		oParser = new parserFormula('ACOS(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: Area. Non-standard case. Single-cell range argument.');
		// Case #6: Array. Non-standard case. Array with single element.
		oParser = new parserFormula('ACOS({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: Array. Non-standard case. Array with single element.');
		// Case #7: Formula. Non-standard case. Nested formula date.
		oParser = new parserFormula('ACOS(DATE(1900,1,1)-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(DATE(1900,1,1)-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Formula. Non-standard case. Nested formula date.');
		// Case #8: Time. Non-standard case. Nested formula Time.
		oParser = new parserFormula('ACOS(TIME(12,0,0)/24)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(TIME(12,0,0)/24) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.549961486, 'Test: Positive case: Time. Non-standard case. Nested formula Time.');
		// Case #9: Empty. Non-standard case. Empty cell treated as 0.
		oParser = new parserFormula('ACOS(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Empty. Non-standard case. Empty cell treated as 0.');
		// Case #10: Boolean. Non-standard case. Boolean TRUE treated as 1.
		oParser = new parserFormula('ACOS(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean. Non-standard case. Boolean TRUE treated as 1.');
		// Case #11: Boolean. Non-standard case. Boolean FALSE treated as 0.
		oParser = new parserFormula('ACOS(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Boolean. Non-standard case. Boolean FALSE treated as 0.');
		// Case #12: Formula. Nested SUM function.
		oParser = new parserFormula('ACOS(SUM(0.3,0.2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(SUM(0.3,0.2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: Formula. Nested SUM function.');
		// Case #13: String. Non-standard case.  Date in string.
		oParser = new parserFormula('ACOS("01/01/1900")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS("01/01/1900") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Non-standard case.  Date in string.');
		// Case #14: String. Non-standard case. Time in string.
		oParser = new parserFormula('ACOS("12:00:00")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS("12:00:00") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: String. Non-standard case. Time in string.');
		// Case #15: Number. Zero value.
		oParser = new parserFormula('ACOS(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Number. Zero value.');
		// Case #16: Formula. ACOS inside another function.
		oParser = new parserFormula('SUM(ACOS(0.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(ACOS(0.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.047197551, 'Test: Positive case: Formula. ACOS inside another function.');
		// Case #17: Ref3D. Reference link to another Sheet, argument is number.
		oParser = new parserFormula('ACOS(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: Ref3D. Reference link to another Sheet, argument is number.');
		// Case #18: Array. Multi-element array.
		oParser = new parserFormula('ACOS({-0.5;0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS({-0.5;0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 2.094395102, 'Test: Positive case: Array. Multi-element array.');
		// Case #19: Formula. Formula: Number in string  and Number, operand plus.
		oParser = new parserFormula('ACOS("0.5"+0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS("0.5"+0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula. Formula: Number in string  and Number, operand plus.');
		// Case #20: Formula. Formula: Numbers in string operand multiply.
		oParser = new parserFormula('ACOS("0.5"*"0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS("0.5"*"0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.318116072, 'Test: Positive case: Formula. Formula: Numbers in string operand multiply.');
		// TODO Need to fix. Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs - Row #4
		// Different result with MS
		// Case #21: Area. Multi-cell range.
		/*oParser = new parserFormula('ACOS(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/!*.toFixed(9) - 0*!/, 1.047197551, 'Test: Positive case: Area. Multi-cell range.');*/
		// Different result with MS
		// Case #22: Area3D. Multi-cell  range to another sheet.
		/*oParser = new parserFormula('ACOS(Sheet2!B1:C1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(Sheet2!B1:C1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/!*.toFixed(9) - 0*!/, 3.141592654, 'Test: Positive case: Area3D. Multi-cell  range to another sheet.');*/
		// Case #23: Name. Name reference, number
		oParser = new parserFormula('ACOS(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.094395102, 'Test: Positive case: Name. Name reference, number');
		// Case #24: Name3D. Name reference, number to another sheet
		oParser = new parserFormula('ACOS(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.094395102, 'Test: Positive case: Name3D. Name reference, number to another sheet');
		// Case #25: Table. Data in table
		oParser = new parserFormula('ACOS(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Data in table');
		// Case #26: Name. Def. Name with area.
		oParser = new parserFormula('ACOS(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.643501109, 'Test: Positive case: Name. Def. Name with area.');
		// Case #27: Name3D. Name with area to another sheet
		oParser = new parserFormula('ACOS(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.643501109, 'Test: Positive case: Name3D. Name with area to another sheet');

		// Negative cases:

		// Case #1: Number. Value above valid range.
		oParser = new parserFormula('ACOS(1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(1.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value above valid range.');
		// Case #2: Number. Value below valid range.
		oParser = new parserFormula('ACOS(-1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(-1.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value below valid range.');
		// Case #3: String. Non-numeric string.
		oParser = new parserFormula('ACOS("text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS("text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string.');
		// Case #4: Error. Error value as argument (#N/A).
		oParser = new parserFormula('ACOS(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value as argument (#N/A).');
		// Case #5: String. Data greater than 1.
		oParser = new parserFormula('ACOS("12/12/2000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS("12/12/2000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Data greater than 1.');
		// Case #6: String. Empty string argument.
		oParser = new parserFormula('ACOS("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string argument.');
		// Case #7: Reference link. Cell with text.
		oParser = new parserFormula('ACOS(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Cell with text.');
		// Case #9: Array. Array with invalid element (#VALUE!).
		oParser = new parserFormula('ACOS({"text"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS({"text"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#VALUE!', 'Test: Negative case: Array. Array with invalid element (#VALUE!).');
		// Case #10: Formula. Division by zero (#DIV/0!).
		oParser = new parserFormula('ACOS(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero (#DIV/0!).');
		// Case #11: Formula. Formula DATE greater than 1.
		oParser = new parserFormula('ACOS(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula DATE greater than 1.');
		// Case #12: Number. Value >1.
		oParser = new parserFormula('ACOS(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value >1.');
		// Case #13: Time. Time + 1.
		oParser = new parserFormula('ACOS(TIME(12,0,0) + 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(TIME(12,0,0) + 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time + 1.');
		// Case #14: Number. Value slightly above 1.
		oParser = new parserFormula('ACOS(1.0000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(1.0000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value slightly above 1.');
		// Case #15: Number. Value slightly below -1.
		oParser = new parserFormula('ACOS(-1.0000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(-1.0000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value slightly below -1.');
		// Case #15: String. Short date in string
		oParser = new parserFormula('ACOS("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS("12/12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Short date in string');

		// Bounded cases:

		// Case #1: Number. Minimum valid value (-1).
		oParser = new parserFormula('ACOS(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.141592654, 'Test: Bounded case: Number. Minimum valid value (-1).');
		// Case #2: Number. Maximum valid value (1).
		oParser = new parserFormula('ACOS(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid value (1).');
		// Case #3: Number. Largest valid value <1.
		oParser = new parserFormula('ACOS(0.99999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(0.99999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4136482746161737e-7, 'Test: Bounded case: Number. Largest valid value <1.');
		// Case #4: Number. Smallest valid value >-1.
		oParser = new parserFormula('ACOS(-0.99999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(-0.99999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.141592512, 'Test: Bounded case: Number. Smallest valid value >-1.');
		// Case #5: Number. Smallest positive number.
		oParser = new parserFormula('ACOS(2.22044604925031E-16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(2.22044604925031E-16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Smallest positive number.');
		// Case #6: Number. Smallest negative number.
		oParser = new parserFormula('ACOS(-2.22044604925031E-16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(-2.22044604925031E-16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Smallest negative number.');
		// Case #7: Date. Earliest Excel date (value=1).
		oParser = new parserFormula('ACOS(DATE(1900,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(DATE(1900,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0, 'Test: Bounded case: Date. Earliest Excel date (value=1).');
		// Case #8: Time. Latest time value.
		oParser = new parserFormula('ACOS(TIME(23,59,59)/24)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(TIME(23,59,59)/24) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.529118077, 'Test: Bounded case: Time. Latest time value.');
		// Case #9: Formula. Nested PI function.
		oParser = new parserFormula('ACOS(PI()/4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(PI()/4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.667457216, 'Test: Bounded case: Formula. Nested PI function.');
		// Case #10: Reference link. Cell with boundary value.
		oParser = new parserFormula('ACOS(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACOS(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.141592654, 'Test: Bounded case: Reference link. Cell with boundary value.');

		testArrayFormula(assert, "ACOS");
	});

	QUnit.test("Test: \"ACOSH\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("2"); // Column1
		ws.getRange2("B601").setValue("error"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1.543");
		ws2.getRange2("A2").setValue("abc");
		ws2.getRange2("A3").setValue("");
		ws2.getRange2("A4").setValue("10");
		ws2.getRange2("A5").setValue("1");
		ws2.getRange2("B5").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("2"); // TestName
		ws.getRange2("A202").setValue("invalid"); // TestName2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("3") // TestName3D
		ws2.getRange2("A16").setValue("invalid"); // TestNameArea3D
		ws2.getRange2("A17").setValue(""); // TestNameArea3D

		// Positive cases:

		// Case #0: Number. Basic valid input: integer >1. 1 argument used.
		oParser = new parserFormula('ACOSH(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.993222846, 'Test: Positive case: Number. Basic valid input: integer >1. 1 argument used.');
		// Case #1: Number. Basic valid input: integer >1. 1 argument used.
		oParser = new parserFormula('ACOSH(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.316957897, 'Test: Positive case: Number. Basic valid input: integer >1. 1 argument used.');
		// Case #2: Number. Float input. 1 argument used.
		oParser = new parserFormula('ACOSH(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.96242365, 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #3: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('ACOSH("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.316957897, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #4: Formula. Nested formula. 1 argument used.
		oParser = new parserFormula('ACOSH(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.316957897, 'Test: Positive case: Formula. Nested formula. 1 argument used.');
		// Case #5: Reference link. Ref to cell with valid number. 1 argument used.
		oParser = new parserFormula('ACOSH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.316957897, 'Test: Positive case: Reference link. Ref to cell with valid number. 1 argument used.');
		// Case #6: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('ACOSH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.96242365, 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #7: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('ACOSH({2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH({2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 1.316957897, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #8: Name. Named range. 1 argument used.
		oParser = new parserFormula('ACOSH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.316957897, 'Test: Positive case: Name. Named range. 1 argument used.');
		// Case #9: Name3D. 3D named range. 1 argument used.
		oParser = new parserFormula('ACOSH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.762747174, 'Test: Positive case: Name3D. 3D named range. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell. 1 argument used.
		oParser = new parserFormula('ACOSH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.999931383, 'Test: Positive case: Ref3D. 3D reference to cell. 1 argument used.');
		// Case #11: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('ACOSH(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.999931383, 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #12: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('ACOSH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.316957897, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #13: Formula. Date as serial number (>=1). 1 argument used.
		oParser = new parserFormula('ACOSH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 11.4220813, 'Test: Positive case: Formula. Date as serial number (>=1). 1 argument used.');
		// Case #14: Time. Time formula adjusted to >=1. 1 argument used.
		oParser = new parserFormula('ACOSH(TIME(0,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(TIME(0,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0, 'Test: Positive case: Time. Time formula adjusted to >=1. 1 argument used.');
		// Case #15: Formula. ACOSH inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(ACOSH(2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(ACOSH(2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.316957897, 'Test: Positive case: Formula. ACOSH inside SUM formula. 1 argument used.');
		// Case #16: Number. Value slightly above 1. 1 argument used.
		oParser = new parserFormula('ACOSH(1.00000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(1.00000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4136482739957e-7, 'Test: Positive case: Number. Value slightly above 1. 1 argument used.');
		// Case #17: String. Short Date in string. 1 argument used.
		oParser = new parserFormula('ACOSH("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH("12/12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 11.42960907, 'Test: Positive case: String. Short Date in string. 1 argument used.');
		// Case #18: Array. Multi-element array. 1 argument used.
		oParser = new parserFormula('ACOSH({1, 2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH({1, 2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 0, 'Test: Positive case: Array. Multi-element array. 1 argument used.');
		// Case #19: Formula. Nested IF returning valid value. 1 argument used.
		oParser = new parserFormula('ACOSH(IF(TRUE, 2, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(IF(TRUE, 2, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.316957897, 'Test: Positive case: Formula. Nested IF returning valid value. 1 argument used.');
		// Case #20: String. String of min valid value. 1 argument used.
		oParser = new parserFormula('ACOSH("1.00000000000001")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH("1.000000000000001") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4136482739957e-7, 'Test: Positive case: String. String of min valid value. 1 argument used.');
		// Case #21: Area3D. 3D multi-cell range.
		oParser = new parserFormula('ACOSH(Sheet2!A5:B5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(Sheet2!A5:B5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D multi-cell range.');

		// Negative cases:

		// Case #1: Number. Number <1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('ACOSH(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number <1 returns #NUM!. 1 argument used.');
		// Case #2: Number. Negative number returns #NUM!. 1 argument used.
		oParser = new parserFormula('ACOSH(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number returns #NUM!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOSH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: String. String convertible to number <1. 1 argument used.
		oParser = new parserFormula('ACOSH("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to number <1. 1 argument used.');
		// Case #5: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('ACOSH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #6: Area3D. Multi-cell range returns #VALUE! error.
		oParser = new parserFormula('ACOSH(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE! error.');
		// Case #7: Empty. Reference link is empty.
		oParser = new parserFormula('ACOSH(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Reference link is empty.');
		// Case #8: String. Empty string returns #VALUE!.
		oParser = new parserFormula('ACOSH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #9: Boolean. Boolean FALSE (0) returns #NUM!.
		oParser = new parserFormula('ACOSH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!.');
		// Case #10: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('ACOSH(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #11: Name3D. Named range with text returns #VALUE!.
		oParser = new parserFormula('ACOSH(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #12: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('ACOSH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #13: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('ACOSH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #14: Number. Zero returns #NUM!.
		oParser = new parserFormula('ACOSH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero returns #NUM!.');
		// Case #15: Array. Array with boolean returns #NUM!.
		oParser = new parserFormula('ACOSH({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!.');
		// Case #16: Number. Value slightly below 1 returns #NUM!.
		oParser = new parserFormula('ACOSH(1-1e-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(1-1e-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value slightly below 1 returns #NUM!.');
		// Case #17: Number. Large negative number returns #NUM!.
		oParser = new parserFormula('ACOSH(-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large negative number returns #NUM!.');
		// Case #18: String. Date string convert to negative number.
		oParser = new parserFormula('ACOSH(-"01/01/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(-"01/01/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Date string convert to negative number.');
		// Case #19: Time. Time value (0.5) returns #NUM!.
		oParser = new parserFormula('ACOSH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time value (0.5) returns #NUM!.');

		// Bounded cases:

		// Case #1: Number. Min valid value (1). 1 argument used.
		oParser = new parserFormula('ACOSH(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Min valid value (1). 1 argument used.');
		// Case #2: Number. Smallest valid value above 1. 1 argument used.
		oParser = new parserFormula('ACOSH(1.00000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(1.00000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4136482739957e-7, 'Test: Bounded case: Number. Smallest valid value above 1. 1 argument used.');
		// Case #3: Number. Max valid Excel number. 1 argument used.
		oParser = new parserFormula('ACOSH(9.99999999999999E+153)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOSH(9.99999999999999E+153) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 355.2912515, 'Test: Bounded case: Number. Max valid Excel number. 1 argument used.');

		testArrayFormula(assert, "ACOSH");
	});

	QUnit.test("Test: \"ACOT\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("0.5");
		ws.getRange2("A102").setValue("");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("B103").setValue("2");
		ws.getRange2("A105").setValue("abc");
		ws.getRange2("A106").setValue("=1/0");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Column1
		ws.getRange2("B601").setValue("abc"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("0.5");
		ws2.getRange2("A3").setValue("abc");
		ws2.getRange2("B3").setValue("");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1"); // TestName
		ws.getRange2("A206").setValue("abc"); // TestNameArea
		ws.getRange2("A207").setValue(""); // TestNameArea
		ws.getRange2("A208").setValue("1"); // TestNameArea2
		ws.getRange2("B208").setValue("2"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1") // TestName3D
		ws2.getRange2("A12").setValue("abc") // TestName3D1
		ws2.getRange2("A16").setValue("abc"); // TestNameArea3D
		ws2.getRange2("A17").setValue(""); // TestNameArea3D

		// Positive cases:

		// Case #1: Number. Basic valid input: int number. 1 argument used.
		oParser = new parserFormula('ACOT(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.463647609, 'Test: Positive case: Number. Basic valid input: int number. 1 argument used.');
		// Case #2: Number. Integer number. 1 argument used.
		oParser = new parserFormula('ACOT(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Number. Integer number. 1 argument used.');
		// Case #3: Number. Float input. 1 argument used.
		oParser = new parserFormula('ACOT(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.107148718, 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #4: Number. Negative number. 1 argument used.
		oParser = new parserFormula('ACOT(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 2.35619449, 'Test: Positive case: Number. Negative number. 1 argument used.');
		// Case #5: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('ACOT("1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT("1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #6: Formula. Nested formula. 1 argument used.
		oParser = new parserFormula('ACOT(SQRT(3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(SQRT(3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Formula. Nested formula. 1 argument used.');
		// Case #7: Reference link. Ref to cell with number. 1 argument used.
		oParser = new parserFormula('ACOT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Reference link. Ref to cell with number. 1 argument used.');
		// Case #8: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('ACOT(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.107148718, 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #9: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('ACOT({1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT({1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #10: Name. Named range. 1 argument used.
		oParser = new parserFormula('ACOT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name. Named range. 1 argument used.');
		// Case #11: Name3D. 3D named range. 1 argument used.
		oParser = new parserFormula('ACOT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name3D. 3D named range. 1 argument used.');
		// Case #12: Ref3D. 3D reference to cell. 1 argument used.
		oParser = new parserFormula('ACOT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Ref3D. 3D reference to cell. 1 argument used.');
		// Case #13: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('ACOT(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.107148718, 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #14: Table. Table structured reference (1 row). 1 argument used.
		oParser = new parserFormula('ACOT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Table. Table structured reference (1 row). 1 argument used.');
		// Case #15: Formula. Date convert to number. 1 argument used.
		oParser = new parserFormula('ACOT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000021902, 'Test: Positive case: Formula. Date convert to number. 1 argument used.');
		// Case #16: Formula. Time convert to number (0.5). 1 argument used.
		oParser = new parserFormula('ACOT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.107148718, 'Test: Positive case: Formula. Time convert to number (0.5). 1 argument used.');
		// Case #17: Formula. ACOT inside SUM. 1 argument used.
		oParser = new parserFormula('SUM(ACOT(1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(ACOT(1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.785398163, 'Test: Positive case: Formula. ACOT inside SUM. 1 argument used.');
		// Case #18: Number. Value close to 0 (positive). 1 argument used.
		oParser = new parserFormula('ACOT(0.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(0.000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Number. Value close to 0 (positive). 1 argument used.');
		// Case #19: Number. Value close to 0 (negative). 1 argument used.
		oParser = new parserFormula('ACOT(-0.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(-0.000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Number. Value close to 0 (negative). 1 argument used.');
		// Case #20: Number. Large positive number. 1 argument used.
		// Different result with MS
		/*oParser = new parserFormula('ACOT(1000000000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(1000000000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-15, 'Test: Positive case: Number. Large positive number. 1 argument used.');*/
		// Case #21: Number. Large negative number. 1 argument used.
		oParser = new parserFormula('ACOT(-1000000000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(-1000000000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.141592654, 'Test: Positive case: Number. Large negative number. 1 argument used.');
		// Case #22: Boolean. Boolean TRUE (1). 1 argument used.
		oParser = new parserFormula('ACOT(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Boolean. Boolean TRUE (1). 1 argument used.');
		// Case #23: Boolean. Boolean FALSE (0). 1 argument used.
		oParser = new parserFormula('ACOT(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Boolean. Boolean FALSE (0). 1 argument used.');
		// Case #24: Empty. Ref to empty cell (0). 1 argument used.
		oParser = new parserFormula('ACOT(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Empty. Ref to empty cell (0). 1 argument used.');
		// Case #25: Area. Multi-cell range. 1 argument used.
		oParser = new parserFormula('ACOT(A103:B103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(A103:B103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Area. Multi-cell range. 1 argument used.');
		// Case #26: Name. Name with multi-cell range. 1 argument used.
		oParser = new parserFormula('ACOT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name. Name with multi-cell range. 1 argument used.');

		// Negative cases:

		// Case #1: String. Non-numeric string. 1 argument used.
		oParser = new parserFormula('ACOT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string. 1 argument used.');
		// Case #2: String. Empty string. 1 argument used.
		oParser = new parserFormula('ACOT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string. 1 argument used.');
		// Case #3: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('ACOT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #4: Area. Multi-cell range. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range. Returns #VALUE!. 1 argument used.');
		// Case #5: Reference link. Ref to text cell. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Ref to text cell. Returns #VALUE!. 1 argument used.');
		// Case #6: Ref3D. 3D ref to text. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text. Returns #VALUE!. 1 argument used.');
		// Case #7: Name. Name with area type contains string. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Name with area type contains string. Returns #VALUE!. 1 argument used.');
		// Case #8: Table. Table column with text. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text. Returns #VALUE!. 1 argument used.');
		// Case #9: Formula. Formula resulting in #NUM!. 1 argument used.
		oParser = new parserFormula('ACOT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM!. 1 argument used.');
		// Case #10: Array. Array with mixed types. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT({"abc",1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT({"abc",1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#VALUE!', 'Test: Negative case: Array. Array with mixed types. Returns #VALUE!. 1 argument used.');
		// Case #11: Area3D. 3D multi-cell range. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT(Sheet2!A3:B3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(Sheet2!A3:B3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range. Returns #VALUE!. 1 argument used.');
		// Case #12: Name3D. 3D name with text. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT(TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D name with text. Returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Nested IF returning text. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT(IF(TRUE;"abc";1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(IF(TRUE;"abc";1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Nested IF returning text. Returns #VALUE!. 1 argument used.');
		// Case #14: String. String with dot (invalid locale). 1 argument used.
		oParser = new parserFormula('ACOT("0,5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT("0,5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String with dot (invalid locale). 1 argument used.');
		// Case #15: Reference link. Ref to error cell (#DIV/0!). 1 argument used.
		oParser = new parserFormula('ACOT(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Ref to error cell (#DIV/0!). 1 argument used.');
		// Case #16: Table. Table with multi-row column. Returns #VALUE!. 1 argument used.
		getTableType(599, 0, 601, 1);
		oParser = new parserFormula('ACOT(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table with multi-row column. Returns #VALUE!. 1 argument used.');
		// Case #17: Name3D. 3D name with multi-cell range. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOT(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D name with multi-cell range. Returns #VALUE!. 1 argument used.');

		// Bounded cases:

		// Case #1: Number. Min valid value (0). 1 argument used.
		oParser = new parserFormula('ACOT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Min valid value (0). 1 argument used.');
		// Case #2: Number. Smallest positive value. 1 argument used.
		oParser = new parserFormula('ACOT(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Smallest positive value. 1 argument used.');
		// Case #3: Number. Smallest negative value. 1 argument used.
		oParser = new parserFormula('ACOT(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Smallest negative value. 1 argument used.');
		// Case #4: Number. Max positive number. 1 argument used.
		// Different result with MS
		/*oParser = new parserFormula('ACOT(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Max positive number. 1 argument used.');*/
		// Case #5: Number. Max negative number. 1 argument used.
		oParser = new parserFormula('ACOT(-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOT(-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.141592654, 'Test: Bounded case: Number. Max negative number. 1 argument used.');

		testArrayFormula(assert, "ACOT");
	});

	QUnit.test("Test: \"ACOTH\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("1");
		ws.getRange2("B102").setValue("1");
		ws.getRange2("A104").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("2"); // Column1
		ws.getRange2("B601").setValue("0.5"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("2");
		ws2.getRange2("A2").setValue("abc");
		ws2.getRange2("A3").setValue("1.5");
		ws2.getRange2("B3").setValue("5");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1.5"); // TestName
		ws.getRange2("A206").setValue("invalid"); // TestNameArea
		ws.getRange2("A207").setValue("abc"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("3") // TestName3D
		ws2.getRange2("A18").setValue("1"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("1"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Number. Basic valid input: int number > 1.
		oParser = new parserFormula('ACOTH(6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.168236118, 'Test: Positive case: Number. Basic valid input: int number > 1.');
		// Case #2: Number. Basic valid input: integer > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Number. Basic valid input: integer > 1. 1 argument used.');
		// Case #3: Number. Float input > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.804718956, 'Test: Positive case: Number. Float input > 1. 1 argument used.');
		// Case #4: String. String convertible to number > 1. 1 argument used.
		oParser = new parserFormula('ACOTH("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: String. String convertible to number > 1. 1 argument used.');
		// Case #5: Formula. Nested formula resulting in value > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Formula. Nested formula resulting in value > 1. 1 argument used.');
		// Case #6: Reference link. Reference to cell with valid number > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Reference link. Reference to cell with valid number > 1. 1 argument used.');
		// Case #7: Area. Single-cell range with value > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.100335348, 'Test: Positive case: Area. Single-cell range with value > 1. 1 argument used.');
		// Case #8: Array. Array with single element > 1. 1 argument used.
		oParser = new parserFormula('ACOTH({2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH({2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Array. Array with single element > 1. 1 argument used.');
		// Case #9: Name. Named range with value > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.804718956, 'Test: Positive case: Name. Named range with value > 1. 1 argument used.');
		// Case #10: Name3D. 3D named range with value > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.34657359, 'Test: Positive case: Name3D. 3D named range with value > 1. 1 argument used.');
		// Case #11: Ref3D. 3D reference to cell with value > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Ref3D. 3D reference to cell with value > 1. 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with value > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Area3D. 3D single-cell range with value > 1. 1 argument used.');
		// Case #13: Table. Table structured reference with value > 1. 1 argument used.
		oParser = new parserFormula('ACOTH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Table. Table structured reference with value > 1. 1 argument used.');
		// Case #14: Number. Negative valid input: integer < -1. 1 argument used.
		oParser = new parserFormula('ACOTH(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.549306144, 'Test: Positive case: Number. Negative valid input: integer < -1. 1 argument used.');
		// Case #15: Number. Negative float input < -1. 1 argument used.
		oParser = new parserFormula('ACOTH(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.804718956, 'Test: Positive case: Number. Negative float input < -1. 1 argument used.');
		// Case #16: Formula. ACOTH inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(ACOTH(2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(ACOTH(2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.549306144, 'Test: Positive case: Formula. ACOTH inside SUM formula. 1 argument used.');
		// Case #17: Formula. ACOTH with ABS formula. 1 argument used.
		oParser = new parserFormula('ACOTH(ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Formula. ACOTH with ABS formula. 1 argument used.');
		// Case #18: Formula. ACOTH with IF returning valid value. 1 argument used.
		oParser = new parserFormula('ACOTH(IF(TRUE,2,0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(IF(TRUE,2,0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Formula. ACOTH with IF returning valid value. 1 argument used.');
		// Case #19: String. String convertible to negative number < -1. 1 argument used.
		oParser = new parserFormula('ACOTH("-2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH("-2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.549306144, 'Test: Positive case: String. String convertible to negative number < -1. 1 argument used.');
		// Case #20: Array. Multi-element array with valid values. 1 argument used.
		oParser = new parserFormula('ACOTH({1.5, 2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH({1.5, 2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 0.804718956, 'Test: Positive case: Array. Multi-element array with valid values. 1 argument used.');
		// Case #21: Formula. Date as serial number (>1). 1 argument used.
		oParser = new parserFormula('ACOTH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000021902, 'Test: Positive case: Formula. Date as serial number (>1). 1 argument used.');
		// Case #22: Formula. ACOTH inside ROUND formula. 1 argument used.
		oParser = new parserFormula('ROUND(ACOTH(2),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ROUND(ACOTH(2),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 0.5493, 'Test: Positive case: Formula. ACOTH inside ROUND formula. 1 argument used.');
		// Case #23: Formula. Time value adjusted to >1. 1 argument used.
		oParser = new parserFormula('ACOTH(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.804718956, 'Test: Positive case: Formula. Time value adjusted to >1. 1 argument used.');
		// Case #24: Area3D. Area with value > 1.
		oParser = new parserFormula('ACOTH(Sheet2!A3:B3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(Sheet2!A3:B3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.804718956, 'Test: Positive case: Area3D. Area with value > 1.');

		// Negative cases:

		// Case #1: Number. 1 value returns #NUM!. 1 argument used.
		oParser = new parserFormula('ACOTH(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. 1 value returns #NUM!. 1 argument used.');
		// Case #2: Number. Number between -1 and 1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('ACOTH(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number between -1 and 1 returns #NUM!. 1 argument used.');
		// Case #3: Number. Zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('ACOTH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero returns #NUM!. 1 argument used.');
		// Case #4: Number. "-1" value returns #NUM!. 1 argument used.
		oParser = new parserFormula('ACOTH(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. "-1" value returns #NUM!. 1 argument used.');
		// Case #5: Number. Negative number between -1 and 1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('ACOTH(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number between -1 and 1 returns #NUM!. 1 argument used.');
		// Case #6: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ACOTH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #7: String. String convertible to number between -1 and 1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('ACOTH("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to number between -1 and 1 returns #NUM!. 1 argument used.');
		// Case #8: Error. #N/A error. 1 argument used.
		oParser = new parserFormula('ACOTH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. #N/A error. 1 argument used.');
		// Case #9: Area. Multi-cell range value 1 returns #NUM! error.
		oParser = new parserFormula('ACOTH(A102:B102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(A102:B102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range value 1 returns #NUM! error.');
		// Case #10: Empty. Reference to empty cell -> 0. Returns #NUM!.
		oParser = new parserFormula('ACOTH(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Reference to empty cell -> 0. Returns #NUM!.');
		// Case #11: String. Empty string returns #VALUE!.
		oParser = new parserFormula('ACOTH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #12: Boolean. Boolean FALSE (0) returns #NUM!.
		oParser = new parserFormula('ACOTH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!.');
		// Case #13: Boolean. Boolean TRUE (1) returns #NUM!.
		oParser = new parserFormula('ACOTH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean TRUE (1) returns #NUM!.');
		// Case #14: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('ACOTH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #15: Ref3D. 3D reference to text returns #VALUE!.
		oParser = new parserFormula('ACOTH(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!.');
		// Case #16: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('ACOTH(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #17: Table. Table column with values between -1 and 1 returns #NUM!.
		oParser = new parserFormula('ACOTH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table. Table column with values between -1 and 1 returns #NUM!.');
		// Case #18: Formula. Value slightly below 1 returns #NUM!.
		oParser = new parserFormula('ACOTH(1-1e-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(1-1e-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Value slightly below 1 returns #NUM!.');
		// Case #19: Formula. IF returning value between -1 and 1 returns #NUM!.
		oParser = new parserFormula('ACOTH(IF(TRUE,0.5,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(IF(TRUE,0.5,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. IF returning value between -1 and 1 returns #NUM!.');
		// Case #20: Array. Array with element between -1 and 1 returns #NUM!.
		oParser = new parserFormula('ACOTH({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with element between -1 and 1 returns #NUM!.');
		// Case #21: Array. Array with boolean returns #NUM!.
		oParser = new parserFormula('ACOTH({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!.');
		// Case #22: Formula. Time value (0.5) returns #NUM!.
		oParser = new parserFormula('ACOTH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Time value (0.5) returns #NUM!.');
		// Case #23: Number. Smallest  unaccepted value above 1. 1 argument used.
		oParser = new parserFormula('ACOTH(1.0000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(1.0000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Smallest  unaccepted value above 1. 1 argument used.');
		// Case #24: Number. Largest unaccepted value below -1. 1 argument used.
		oParser = new parserFormula('ACOTH(-1.0000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(-1.0000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Largest unaccepted value below -1. 1 argument used.');
		// Case #25: Name3D. Multi-cell range value 1 returns #NUM! error.
		oParser = new parserFormula('ACOTH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. Multi-cell range value 1 returns #NUM! error.');

		// Bounded cases:

		// Case #1: Number. Smallest  value above 1. 1 argument used.
		oParser = new parserFormula('ACOTH(1.00000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(1.00000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 16.46506904, 'Test: Bounded case: Number. Smallest  value above 1. 1 argument used.');
		// Case #2: Number. Largest  value below -1. 1 argument used.
		oParser = new parserFormula('ACOTH(-1.00000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(-1.00000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -16.46506904, 'Test: Bounded case: Number. Largest  value below -1. 1 argument used.');
		// Case #3: Number. Max valid Excel number. 1 argument used.
		oParser = new parserFormula('ACOTH(9E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(9E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Max valid Excel number. 1 argument used.');
		// Case #4: Number. Min valid Excel number. 1 argument used.
		oParser = new parserFormula('ACOTH(-9E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ACOTH(-9E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Min valid Excel number. 1 argument used.');

		testArrayFormula(assert, "ACOTH");
	});

	QUnit.test("Test: \"AGGREGATE\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A101").setValue("TEST");
		ws.getRange2("A102").setValue("72");
		ws.getRange2("A103").setValue("30");
		ws.getRange2("A104").setValue("TEST2");
		ws.getRange2("A105").setValue("31");
		ws.getRange2("A106").setValue("96");
		ws.getRange2("A107").setValue("32");
		ws.getRange2("A108").setValue("81");
		ws.getRange2("A109").setValue("33");
		ws.getRange2("A110").setValue("53");
		ws.getRange2("A111").setValue("34");

		ws.getRange2("B101").setValue("82");
		ws.getRange2("B102").setValue("65");
		ws.getRange2("B103").setValue("95");
		ws.getRange2("B104").setValue("63");
		ws.getRange2("B105").setValue("53");
		ws.getRange2("B106").setValue("71");
		ws.getRange2("B107").setValue("55");
		ws.getRange2("B108").setValue("83");
		ws.getRange2("B109").setValue("100");
		ws.getRange2("B110").setValue("91");
		ws.getRange2("B111").setValue("89");

		// for bug 38994
		ws.getRange2("C101").setValue("");
		ws.getRange2("C102").setValue("0");
		ws.getRange2("C103").setValue("0");
		ws.getRange2("C104").setValue("1");
		ws.getRange2("C105").setValue("0");
		ws.getRange2("C106").setValue("0");
		ws.getRange2("C107").setValue("1");

		ws.getRange2("D101").setValue("#DIV/0!");
		ws.getRange2("D102").setValue("#DIV/0!");
		ws.getRange2("D103").setValue("#DIV/0!");
		ws.getRange2("D104").setValue("3");
		ws.getRange2("D105").setValue("#DIV/0!");
		ws.getRange2("D106").setValue("#DIV/0!");
		ws.getRange2("D107").setValue("37");

		ws.getRange2("E101").setValue("");
		ws.getRange2("E102").setValue("1");
		ws.getRange2("E103").setValue("2");
		ws.getRange2("E104").setValue("3");
		ws.getRange2("E105").setValue("4");
		ws.getRange2("E106").setValue("5");
		ws.getRange2("E107").setValue("999");
		// Table type. Use A601:L6**
		getTableType(599, 0, 606, 6);
		// Column1
		ws.getRange2("A601").setValue("");
		ws.getRange2("A602").setValue("0");
		ws.getRange2("A603").setValue("0");
		ws.getRange2("A604").setValue("1");
		ws.getRange2("A605").setValue("0");
		ws.getRange2("A606").setValue("0");
		ws.getRange2("A607").setValue("1");
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("TEST");
		ws2.getRange2("A2").setValue("72");
		ws2.getRange2("A3").setValue("30");
		ws2.getRange2("A4").setValue("TEST2");
		ws2.getRange2("A5").setValue("31");
		ws2.getRange2("A6").setValue("96");
		ws2.getRange2("A7").setValue("32");
		ws2.getRange2("A8").setValue("81");
		ws2.getRange2("A9").setValue("33");
		ws2.getRange2("A10").setValue("53");

		ws2.getRange2("B1").setValue("82");
		ws2.getRange2("B2").setValue("65");
		ws2.getRange2("B3").setValue("95");
		ws2.getRange2("B4").setValue("63");
		ws2.getRange2("B5").setValue("53");
		ws2.getRange2("B6").setValue("71");
		ws2.getRange2("B7").setValue("55");
		ws2.getRange2("B8").setValue("83");
		ws2.getRange2("B9").setValue("100");
		ws2.getRange2("B10").setValue("91");;

		ws2.getRange2("B12").setValue("1");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1"); // TestName
		ws.getRange2("A202").setValue("0"); // TestName1
		ws.getRange2("A203").setValue("3"); // TestName2
		ws.getRange2("A206").setValue("72"); // TestNameArea
		ws.getRange2("A207").setValue("30"); // TestNameArea
		ws.getRange2("A208").setValue("65"); // TestNameArea2
		ws.getRange2("B208").setValue("95"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1") // TestName3D
		ws2.getRange2("A12").setValue("0") // TestName3D1
		ws2.getRange2("A13").setValue("3") // TestName3D2
		ws2.getRange2("A16").setValue("72"); // TestNameArea3D
		ws2.getRange2("A17").setValue("30"); // TestNameArea3D
		ws2.getRange2("A18").setValue("65"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("95"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Number(2), Area. Function_num is AVERAGE (4), options is 6 (ignore errors), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(4, 6, A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(4, 6, A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 96, 'Test: Positive case: Number(2), Area. Function_num is AVERAGE (4), options is 6 (ignore errors), ref is area with numbers');
		// Case #2: Number(2), Area. Function_num is LARGE (14), options is 6 (ignore errors), ref is area with numbers, k is 3
		oParser = new parserFormula('AGGREGATE(14, 6, A101:A111, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14, 6, A101:A111, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 72, 'Test: Positive case: Number(2), Area. Function_num is LARGE (14), options is 6 (ignore errors), ref is area with numbers, k is 3');
		// Case #3: Number(2), Area(2). Function_num is PRODUCT (12), options is 6 (ignore errors), two area references as arguments
		oParser = new parserFormula('AGGREGATE(12, 6, A101:A111, B101:B111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(12, 6, A101:A111, B101:B111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 68, 'Test: Positive case: Number(2), Area(2). Function_num is PRODUCT (12), options is 6 (ignore errors), two area references as arguments');
		// Case #4: Number(2), Area. Function_num is AVERAGE (1), options is 1 (ignore nested SUBTOTAL and AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(1,1,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(1,1,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 61.375, 'Test: Positive case: Number(2), Area. Function_num is AVERAGE (1), options is 1 (ignore nested SUBTOTAL and AGGREGATE), ref is area with numbers');
		// Case #5: Number(2), Area. Function_num is COUNT (2), options is 1 (ignore nested SUBTOTAL and AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(2,1,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(2,1,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Number(2), Area. Function_num is COUNT (2), options is 1 (ignore nested SUBTOTAL and AGGREGATE), ref is area with numbers');
		// Case #6: Number(2), Area. Function_num is COUNTA (3), options is 1 (ignore nested SUBTOTAL and AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(3,1,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(3,1,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(2), Area. Function_num is COUNTA (3), options is 1 (ignore nested SUBTOTAL and AGGREGATE), ref is area with numbers');
		// Case #7: Number(2), Area. Function_num is MAX (4), options is 1 (ignore nested SUBTOTAL and AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(4,1,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(4,1,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95, 'Test: Positive case: Number(2), Area. Function_num is MAX (4), options is 1 (ignore nested SUBTOTAL and AGGREGATE), ref is area with numbers');
		// Case #8: Number(2), Area. Function_num is MIN (5), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(5,3,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(5,3,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Number(2), Area. Function_num is MIN (5), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers');
		// Case #9: Number(2), Area. Function_num is STDEV.S (7), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(7,3,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(7,3,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 22.87192602, 'Test: Positive case: Number(2), Area. Function_num is STDEV.S (7), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers');
		// Case #10: Number(2), Area. Function_num is STDEV.P (8), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(8,3,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(8,3,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 21.39472774, 'Test: Positive case: Number(2), Area. Function_num is STDEV.P (8), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers');
		// Case #11: Number(2), Area. Function_num is SUM (9), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(9,3,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(9,3,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 491, 'Test: Positive case: Number(2), Area. Function_num is SUM (9), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers');
		// Case #12: Number(2), Area. Function_num is VAR.S (10), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(10,3,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(10,3,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 523.125, 'Test: Positive case: Number(2), Area. Function_num is VAR.S (10), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers');
		// Case #13: Number(2), Area. Function_num is VAR.P (11), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(11,3,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(11,3,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 457.734375, 'Test: Positive case: Number(2), Area. Function_num is VAR.P (11), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers');
		// Case #14: Number(2), Area. Function_num is MEDIAN (12), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers
		oParser = new parserFormula('AGGREGATE(12,3,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(12,3,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 64, 'Test: Positive case: Number(2), Area. Function_num is MEDIAN (12), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers');
		// Case #15: Number(2), Area(2). Function_num is MODE.SNGL (13), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), two area references as arguments
		// Different result with MS
		oParser = new parserFormula('AGGREGATE(13,3,A101:B105,A101:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(13,3,A101:B105,A101:B105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Number(2), Area(2). Function_num is MODE.SNGL (13), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), two area references as arguments'); // ms result: 82
		// Case #16: Number(2), Area. Function_num is LARGE (14), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 2
		oParser = new parserFormula('AGGREGATE(14,3,A101:B105,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14,3,A101:B105,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 82, 'Test: Positive case: Number(2), Area. Function_num is LARGE (14), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 2');
		// Case #17: Number(2), Area. Function_num is SMALL (15), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 2
		oParser = new parserFormula('AGGREGATE(15,3,A101:B105,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,3,A101:B105,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Positive case: Number(2), Area. Function_num is SMALL (15), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 2');
		// Case #18: Number(2), Area. Function_num is PERCENTILE.INC (16), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 1
		oParser = new parserFormula('AGGREGATE(16,3,A101:B105,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(16,3,A101:B105,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95, 'Test: Positive case: Number(2), Area. Function_num is PERCENTILE.INC (16), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 1');
		// Case #19: Number(2), Area. Function_num is QUARTILE.INC (17), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 3
		oParser = new parserFormula('AGGREGATE(17,3,A101:B105,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(17,3,A101:B105,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 74.5, 'Test: Positive case: Number(2), Area. Function_num is QUARTILE.INC (17), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 3');
		// Case #20: Number(2), Area. Function_num is PERCENTILE.EXC (18), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 0.2
		oParser = new parserFormula('AGGREGATE(18,3,A101:B105,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(18,3,A101:B105,0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 30.8, 'Test: Positive case: Number(2), Area. Function_num is PERCENTILE.EXC (18), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 0.2');
		// Case #21: Number(2), Area. Function_num is QUARTILE.EXC (19), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 2
		oParser = new parserFormula('AGGREGATE(19,3,A101:B105,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(19,3,A101:B105,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 64, 'Test: Positive case: Number(2), Area. Function_num is QUARTILE.EXC (19), options is 3 (ignore hidden rows, errors, and nested SUBTOTAL/AGGREGATE), ref is area with numbers, k is 2');
		// Case #22: Number(2), Formula, Number. Function_num is SMALL (15), options is 6 (ignore errors), array argument is result of ROW function, k is 1
		oParser = new parserFormula('AGGREGATE(15,6,ROW(C101:C107),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,6,ROW(C101:C107),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 101, 'Test: Positive case: Number(2), Formula, Number. Function_num is SMALL (15), options is 6 (ignore errors), array argument is result of ROW function, k is 1');
		// Case #23: Number(2), Formula, Number. Function_num is SMALL (15), options is 6 (ignore errors), array argument is complex formula with division, k is 1
		oParser = new parserFormula('AGGREGATE(15,6,ROW(C101:C107)/(C102:C107=1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,6,ROW(C101:C107)/(C102:C107=1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 103, 'Test: Positive case: Number(2), Formula, Number. Function_num is SMALL (15), options is 6 (ignore errors), array argument is complex formula with division, k is 1');
		// Case #24: Number(2), Area, Number. Function_num is SMALL (15), options is 6 (ignore errors), ref is area with numbers, k is 1
		oParser = new parserFormula('AGGREGATE(15,6,D101:D107,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,6,D101:D107,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2), Area, Number. Function_num is SMALL (15), options is 6 (ignore errors), ref is area with numbers, k is 1');
		// Case #25: Number, Area(2), Number. Function_num is SMALL (15), options is area with numbers, ref is area with numbers, k is 1
		// cross test
		let bbox = ws.getRange2("G103").bbox;
		let cellWithFormula = new window['AscCommonExcel'].CCellWithFormula(ws, bbox.r1, bbox.c1);
		oParser = new parserFormula('AGGREGATE(15,E101:E107,D101:D107,1)', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,E101:E107,D101:D107,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number, Area(2), Number. Function_num is SMALL (15), options is area with numbers, ref is area with numbers, k is 1');
		// Case #26: Number, Area(2), Number. Function_num is SMALL (15), options is area with numbers, ref is area with numbers, k is 1
		// cross test
		bbox = ws.getRange2("G104").bbox;
		cellWithFormula = new window['AscCommonExcel'].CCellWithFormula(ws, bbox.r1, bbox.c1);
		oParser = new parserFormula('AGGREGATE(15,E101:E107,D101:D107,1)', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,E101:E107,D101:D107,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number, Area(2), Number. Function_num is SMALL (15), options is area with numbers, ref is area with numbers, k is 1');
		// Case #27: String(2), Number, Area. Function_num and options as strings that convert to numbers, ref is area with numbers
		oParser = new parserFormula('AGGREGATE("6", "0", A101:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE("6", "0", A101:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 66960, 'Test: Positive case: String(2), Number, Area. Function_num and options as strings that convert to numbers, ref is area with numbers');
		// Case #28: String(2), Area. Funtion_num and options as date and time in string, ref is area with numbers
		oParser = new parserFormula('AGGREGATE("01/03/1900","12:00:00", A101:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE("01/03/1900","12:00:00", A101:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String(2), Area. Function_num and options as date and time in string, ref is area with numbers');
		// Case #29: Formula, Number, Area. Function_num as date converted to number (6), options is 2 (ignore hidden rows), ref is area
		oParser = new parserFormula('AGGREGATE(DATE(1900,1,6),2,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(DATE(1900,1,6),2,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 990810046955520, 'Test: Positive case: Formula, Number, Area. Function_num as date converted to number (6), options is 2 (ignore hidden rows), ref is area');
		// Case #30: Formula, Number, Area. Function_num as time converted to number (9), options is 5 (ignore hidden rows and errors), ref is area
		oParser = new parserFormula('AGGREGATE(TIME(12,0,0)+9,5,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(TIME(12,0,0)+9,5,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 462, 'Test: Positive case: Formula, Number, Area. Function_num as time converted to number (9), options is 5 (ignore hidden rows and errors), ref is area');
		// Case #31: Formula(2), Reference link. Function_num and options from formulas, ref is reference link
		oParser = new parserFormula('AGGREGATE(INT(9.8),ROUND(3.1,0),A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(INT(9.8),ROUND(3.1,0),A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 72, 'Test: Positive case: Formula(2), Reference link. Function_num and options from formulas, ref is reference link');
		// Case #32: Reference link(2), Area. Function_num and options from reference links, ref is area
		oParser = new parserFormula('AGGREGATE(E103,E106,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(E103,E106,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Reference link(2), Area. Function_num and options from reference links, ref is area');
		// Case #33: Array(2), Area. Function_num and options as arrays with single elements, ref is area
		// TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#10
		/*oParser = new parserFormula('AGGREGATE({7},{2},A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE({7},{2},A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/!*.toFixed(8) - 0*!/, 25.45584412, 'Test: Positive case: Array(2), Area. Function_num and options as arrays with single elements, ref is area');*/
		// Case #34: Number(2), Area3D(2). Function_num is PRODUCT (12), options is 6 (ignore errors), ref is area3D, k area3D
		oParser = new parserFormula('AGGREGATE(12,6,Sheet2!A1:A10,Sheet2!B1:B10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(12,6,Sheet2!A1:A10,Sheet2!B1:B10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 68, 'Test: Positive case: Number(2), Area3D(2). Function_num is PRODUCT (12), options is 6 (ignore errors), ref is area3D, k area3D');
		// Case #35: Name(4). Function_num is AVERAGE (1), options is 0 (default behavior), ref is named range, k is 1. All arguments name type
		oParser = new parserFormula('AGGREGATE(TestName,TestName1,TestNameArea,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(TestName,TestName1,TestNameArea,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 35, 'Test: Positive case: Name(4). Function_num is AVERAGE (1), options is 0 (default behavior), ref is named range, k is 1. All arguments name type');
		// Case #36: Number, Name3D, Number(2). Function_num is PRODUCT (6), options from 3D named range, ref is area
		oParser = new parserFormula('AGGREGATE(4,TestName3D,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(4,TestName3D,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 96, 'Test: Positive case: Number, Name3D, Number(2). Function_num is PRODUCT (6), options from 3D named range, ref is area.');
		// Case #37: Number, Ref3D, Area, Number. Function_num is LARGE (14), options is 1 (Name3D), ref is Area, k is 2
		oParser = new parserFormula('AGGREGATE(14,Sheet2!B12,A101:A111,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14,Sheet2!B12,A101:A111,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 81, 'Test: Positive case: Number, Ref3D, Area, Number. Function_num is LARGE (14), options is 1 (Name3D), ref is Area, k is 2');
		// Case #38: Number(2), Area3D, Number. Function_num is SMALL (15), options is 0 (default behavior), ref is 3D area, k is 3
		oParser = new parserFormula('AGGREGATE(14,0,Sheet2!A1:A10,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14,0,Sheet2!A1:A10,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 72, 'Test: Positive case: Number(2), Area3D, Number. Function_num is SMALL (15), options is 0 (default behavior), ref is 3D area, k is 3');
		// Case #39: Number(2), Table, Number. Function_num is PERCENTILE.INC (16), options is 0 (default behavior), ref is table column, k is 0.5
		oParser = new parserFormula('AGGREGATE(16,0,Table1[Column1],0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(16,0,Table1[Column1],0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2), Table, Number. Function_num is PERCENTILE.INC (16), options is 0 (default behavior), ref is table column, k is 0.5');
		// Case #40: Number, Empty, Area. Function_num is AVERAGE (1), options is empty (defaults to 0), ref is area
		oParser = new parserFormula('AGGREGATE(1,,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(1,,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 51.33333333, 'Test: Positive case: Number, Empty, Area. Function_num is AVERAGE (1), options is empty (defaults to 0), ref is area');
		// Case #41: Formula, Number, Area. Function_num is from SUM formula (4), options is 7 (ignore everything), ref is area
		oParser = new parserFormula('AGGREGATE(SUM(1,3),7,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(SUM(1,3),7,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 96, 'Test: Positive case: Formula, Number, Area. Function_num is from SUM formula (4), options is 7 (ignore everything), ref is area');
		// Case #42: Number, Boolean, Area. Function_num is SUM (9), options is boolean TRUE (converts to 1), ref is area
		oParser = new parserFormula('AGGREGATE(9,TRUE,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(9,TRUE,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 462, 'Test: Positive case: Number, Boolean, Area. Function_num is SUM (9), options is boolean TRUE (converts to 1), ref is area');
		// Case #43: Number(2), Area(2). Function_num is SUM (6), options is 7 (ignore everything), two single-cell areas
		oParser = new parserFormula('AGGREGATE(6,7,A101:A101,B101:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(6,7,A101:A101,B101:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 82, 'Test: Positive case: Number(2), Area(2). Function_num is SUM (6), options is 7 (ignore everything), two single-cell areas');
		// Case #44: Number(2), Area, Formula. Function_num is LARGE (14), options is 6 (ignore errors), ref is area, k from MIN formula
		oParser = new parserFormula('AGGREGATE(14,6,A101:A111,MIN(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14,6,A101:A111,MIN(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 81, 'Test: Positive case: Number(2), Area, Formula. Function_num is LARGE (14), options is 6 (ignore errors), ref is area, k from MIN formula');
		// Case #45: Number(2), Area, Formula. Function_num is SMALL (15), options is 6 (ignore errors), ref is area, k from SQRT formula
		oParser = new parserFormula('AGGREGATE(15,6,A101:A111,SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,6,A101:A111,SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 32, 'Test: Positive case: Number(2), Area, Formula. Function_num is SMALL (15), options is 6 (ignore errors), ref is area, k from SQRT formula');
		// Case #46: Formula(2),Area. All arguments (except ref) are formulas returning numbers
		oParser = new parserFormula('AGGREGATE(INT(1.5),ROUND(2.6,0),A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(INT(1.5),ROUND(2.6,0),A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 51.33333333, 'Test: Positive case: Formula(2),Area. All arguments (except ref) are formulas returning numbers');
		// Case #47: Formula. AGGREGATE inside another formula (SUM)
		oParser = new parserFormula('SUM(AGGREGATE(9,0,A101:A111),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(AGGREGATE(9,0,A101:A111),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 472, 'Test: Positive case: Formula. AGGREGATE inside another formula (SUM)');
		// Case #48: Formula. AGGREGATE inside another formula (AVERAGE)
		oParser = new parserFormula('AVERAGE(AGGREGATE(9,0,A101:A111),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(AGGREGATE(9,0,A101:A111),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 236, 'Test: Positive case: Formula. AGGREGATE inside another formula (AVERAGE)');
		// Case #49: Number(2), Formula. Function_num is LARGE (14), options is 6 (ignore errors), array with error, k is 2
		//TODO Need to fix. https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #13
		/*oParser = new parserFormula('AGGREGATE(1,6,IF(TRUE,A101:A111,""))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(1,6,IF(TRUE,A101:A111,"")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/!*.toFixed(8) - 0*!/, 51.33333333, 'Test: Positive case: Number(2), Formula. Function_num is LARGE (14), options is 6 (ignore errors), array with error, k is 2');
		*/
		// Negative cases:

		// Case #1: Number(2), Area. Function_num is SMALL (15) which requires k parameter, options is 6 (ignore errors), ref is area
		oParser = new parserFormula('AGGREGATE(15, 6, A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15, 6, A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area. Function_num is SMALL (15) which requires k parameter, options is 6 (ignore errors), ref is area');
		// Case #2: Number(3). Function_num is SUM (6) with single value, options is 1, incorrect type for array argument
		oParser = new parserFormula('AGGREGATE(6,1,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(6,1,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3). Function_num is SUM (6) with single value, options is 1, incorrect type for array argument');
		// Case #3: Number, Area(2), Number. Function_num is SMALL (15), options is area with value 1, ref is area, k is 1
		// cross test
		bbox = ws.getRange2("G101").bbox;
		cellWithFormula = new window['AscCommonExcel'].CCellWithFormula(ws, bbox.r1, bbox.c1);
		oParser = new parserFormula('AGGREGATE(15,E101:E107,D101:D107,1)', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,E101:E107,D101:D107,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Area(2), Number. Function_num is SMALL (15), options is area with value 1, ref is area, k is 1');
		// Case #4: Number, Area(2), Number. Function_num is SMALL (15), options is area with DIV/0 error, ref is area, k is 1
		// Different result with MS
		bbox = ws.getRange2("G107").bbox;
		cellWithFormula = new window['AscCommonExcel'].CCellWithFormula(ws, bbox.r1, bbox.c1);
		oParser = new parserFormula('AGGREGATE(15,D101:D107,C101:C107,1)', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,D101:D107,C101:C107,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area(2), Number. Function_num is SMALL (15), options is area with DIV/0 error, ref is area, k is 1');// #VALUE!
		// Case #5: Number(2), String. Function_num is SMALL (15), options is 6 (ignore errors), non-numeric string in array argument
		oParser = new parserFormula('AGGREGATE(15,6,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,6,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String. Function_num is SMALL (15), options is 6 (ignore errors), non-numeric string in array argument');
		// Case #6: Number(2), Error. Function_num is SUM (6), options is 0 (default behavior), error value as array
		// TODO Need to fix it. Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #12
		/*oParser = new parserFormula('AGGREGATE(6,0,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(6,0,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error. Function_num is SUM (6), options is 0 (default behavior), error value as array');
		*/// Case #7: String, Number, Area, Number. Function_num is non-numeric string, options is 6 (ignore errors), ref is area, k is 2
		oParser = new parserFormula('AGGREGATE("x",6,A101:A111,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE("x",6,A101:A111,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Area, Number. Function_num is non-numeric string, options is 6 (ignore errors), ref is area, k is 2');
		// Case #8: Number, String, Area, Number. Function_num is LARGE (14), options is non-numeric string, ref is area, k is 2
		oParser = new parserFormula('AGGREGATE(14,"y",A101:A111,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14,"y",A101:A111,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Area, Number. Function_num is LARGE (14), options is non-numeric string, ref is area, k is 2');
		// Case #9: Number(2), Area, String. Function_num is LARGE (14), options is 6 (ignore errors), ref is area, k is non-numeric string
		oParser = new parserFormula('AGGREGATE(14,6,A101:A111,"z")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14,6,A101:A111,"z") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, String. Function_num is LARGE (14), options is 6 (ignore errors), ref is area, k is non-numeric string');
		// Case #10: Number(3), Area. Function_num is 20 (exceeds maximum of 19), options is 6 (ignore errors), ref is area
		// TODO Need to fix it. Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #12
		/*oParser = new parserFormula('AGGREGATE(20,6,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(20,6,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Function_num is 20 (exceeds maximum of 19), options is 6 (ignore errors), ref is area');*/
		// Case #11: Number(3), Area. Function_num is 0 (below minimum of 1), options is 6 (ignore errors), ref is area
		/*oParser = new parserFormula('AGGREGATE(0,6,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(0,6,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Function_num is 0 (below minimum of 1), options is 6 (ignore errors), ref is area');
		*/// Case #12: Number, Number(2), Area. Function_num is SUM (9), options is 8 (exceeds maximum of 7), ref is area
		/*oParser = new parserFormula('AGGREGATE(9,8,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(9,8,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number(2), Area. Function_num is SUM (9), options is 8 (exceeds maximum of 7), ref is area');
		*/// Case #13: Number, Number(2), Area. Function_num is SUM (9), options is -1 (below minimum of 0), ref is area
		/*oParser = new parserFormula('AGGREGATE(9,-1,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(9,-1,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number(2), Area. Function_num is SUM (9), options is -1 (below minimum of 0), ref is area');
		*/// Case #14: Number(2), Area. Function_num is LARGE (14) which requires k parameter, missing k parameter
		oParser = new parserFormula('AGGREGATE(14,6,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14,6,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area. Function_num is LARGE (14) which requires k parameter, missing k parameter');
		// Case #15: Number(2), Area(3). Function_num is LARGE (14), options is 6, ref is area, ref2 is area, extra argument
		oParser = new parserFormula('AGGREGATE(14,6,A101:A111,0,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14,6,A101:A111,0,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area(3). Function_num is LARGE (14), options is 6, ref is area, ref2 is area, extra argument');
		// Case #16: Number(2),Empty. Function_num is SUM (9), options is 6 (ignore errors), missing array argument
		oParser = new parserFormula('AGGREGATE(9,6,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(9,6,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2),Empty. Function_num is SUM (9), options is 6 (ignore errors), missing array argument');
		// Case #17: Number, Empty(2). Function_num is SUM (9), missing options and array arguments
		oParser = new parserFormula('AGGREGATE(9,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(9,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Empty(2). Function_num is SUM (9), missing options and array arguments');
		// Case #18: String(3). All arguments as strings that convert to numbers
		oParser = new parserFormula('AGGREGATE("9", "4", "100")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE("9", "4", "100") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). All arguments as strings that convert to numbers');
		// Case #19: Number(2), Area, Number. Function_num is LARGE (14), options is 6 (ignore errors), ref is area, k is 0 (invalid for LARGE)
		// TODO Need to fix it. Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #12
		/*oParser = new parserFormula('AGGREGATE(14,6,A101:A111,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(14,6,A101:A111,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Area, Number. Function_num is LARGE (14), options is 6 (ignore errors), ref is area, k is 0 (invalid for LARGE)');
		*/// Case #20: Number(2), Area, Number. Function_num is SMALL (15), options is 6 (ignore errors), ref is area, k is 0 (invalid for SMALL)
		oParser = new parserFormula('AGGREGATE(15,6,A101:A111,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(15,6,A101:A111,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Area, Number. Function_num is SMALL (15), options is 6 (ignore errors), ref is area, k is 0 (invalid for SMALL)');
		// Case #21: Number(2), Area, Number. Function_num is QUARTILE.INC (17), options is 6 (ignore errors), ref is area, k is 5 (invalid for quartile)
		oParser = new parserFormula('AGGREGATE(17,6,A101:A111,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(17,6,A101:A111,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Area, Number. Function_num is QUARTILE.INC (17), options is 6 (ignore errors), ref is area, k is 5 (invalid for quartile)');
		// Case #22: Number(2), Area, Number. Function_num is QUARTILE.EXC (19), options is 6 (ignore errors), ref is area, k is 5 (invalid for quartile)
		oParser = new parserFormula('AGGREGATE(19,6,A101:A111,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(19,6,A101:A111,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Area, Number. Function_num is QUARTILE.EXC (19), options is 6 (ignore errors), ref is area, k is 5 (invalid for quartile)');
		// Case #23: Number(2), Area, Number. Function_num is PERCENTILE.INC (16), options is 6 (ignore errors), ref is area, k is 1.5 (exceeds max of 1)
		oParser = new parserFormula('AGGREGATE(16,6,A101:A111,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(16,6,A101:A111,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Area, Number. Function_num is PERCENTILE.INC (16), options is 6 (ignore errors), ref is area, k is 1.5 (exceeds max of 1)');
		// Case #24: Number(2), Area, Number. Function_num is PERCENTILE.EXC (18), options is 6 (ignore errors), ref is area, k is 1.5 (exceeds max of 1)
		oParser = new parserFormula('AGGREGATE(18,6,A101:A111,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(18,6,A101:A111,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Area, Number. Function_num is PERCENTILE.EXC (18), options is 6 (ignore errors), ref is area, k is 1.5 (exceeds max of 1)');
		// Case #25: Empty, Number, Area. Function_num is empty (error expected), options is 4, ref is area
		// TODO Need to fix it. Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #12
		/*oParser = new parserFormula('AGGREGATE(,4,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(,4,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty, Number, Area. Function_num is empty (error expected), options is 4, ref is area');
		*/
		// Bounded cases:

		// Case #1: Number(3), Area. Function_num is minimum valid value (1), options is minimum valid value (0), ref is area
		oParser = new parserFormula('AGGREGATE(1,0,A101:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(1,0,A101:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 51.33333333, 'Test: Bounded case: Number(3), Area. Function_num is minimum valid value (1), options is minimum valid value (0), ref is area');
		// Case #2: Number(3), Area, Number. Function_num is maximum valid value (19), options is maximum valid value (7), ref is area
		oParser = new parserFormula('AGGREGATE(19,7,A101:B111,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(19,7,A101:B111,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38.75, 'Test: Bounded case: Number(3), Area, Number. Function_num is maximum valid value (19), options is maximum valid value (7), ref is area');
		// Case #3: Number(2), Area, Number. Function_num is PERCENTILE.INC (16), options is 6 (ignore errors), ref is area, k is minimum valid value (0)
		oParser = new parserFormula('AGGREGATE(16,6,A101:A111,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(16,6,A101:A111,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Bounded case: Number(2), Area, Number. Function_num is PERCENTILE.INC (16), options is 6 (ignore errors), ref is area, k is minimum valid value (0)');
		// Case #4: Number(2), Area, Number. Function_num is PERCENTILE.INC (16), options is 6 (ignore errors), ref is area, k is maximum valid value (1)
		oParser = new parserFormula('AGGREGATE(16,6,A101:A111,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(16,6,A101:A111,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 96, 'Test: Bounded case: Number(2), Area, Number. Function_num is PERCENTILE.INC (16), options is 6 (ignore errors), ref is area, k is maximum valid value (1)');
		// Case #5: Number(2), Area, Number. Function_num is QUARTILE.INC (17), options is 6 (ignore errors), ref is area, k is minimum valid value (0)
		oParser = new parserFormula('AGGREGATE(17,6,A101:A111,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(17,6,A101:A111,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Bounded case: Number(2), Area, Number. Function_num is QUARTILE.INC (17), options is 6 (ignore errors), ref is area, k is minimum valid value (0)');
		// Case #6: Number(2), Area, Number. Function_num is QUARTILE.INC (17), options is 6 (ignore errors), ref is area, k is maximum valid value (4)
		oParser = new parserFormula('AGGREGATE(17,6,A101:A111,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AGGREGATE(17,6,A101:A111,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 96, 'Test: Bounded case: Number(2), Area, Number. Function_num is QUARTILE.INC (17), options is 6 (ignore errors), ref is area, k is maximum valid value (4)');


	});

	QUnit.test("Test: \"ARABIC\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("IV");
		ws.getRange2("A101").setValue("MMXXV");
		ws.getRange2("A102").setValue("mmxxv");
		ws.getRange2("A103").setValue("MmXxV");
		ws.getRange2("A104").setValue("IA");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("IV"); // Column1
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("IV");
		ws2.getRange2("A2").setValue("MMXXV");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("IV"); // TestName
		ws.getRange2("A202").setValue("XA"); // TestName1
		ws.getRange2("A206").setValue("IV"); // TestNameArea
		ws.getRange2("A207").setValue("MMXXV"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("IV") // TestName3D
		ws2.getRange2("A16").setValue("IV"); // TestNameArea3D
		ws2.getRange2("A17").setValue("MMXXV"); // TestNameArea3D

		// Positive cases:

		// Case #1: String. Text LVII
		oParser = new parserFormula('ARABIC("LVII")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("LVII") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 57, 'Test: Positive case: String. Text LVII');
		// Case #2: String. Basic valid Roman numeral IV converts to 4
		oParser = new parserFormula('ARABIC("IV")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("IV") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: String. Basic valid Roman numeral IV converts to 4');
		// Case #3: String. Valid Roman numeral MMXXV converts to 2025
		oParser = new parserFormula('ARABIC("MMXXV")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("MMXXV") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2025, 'Test: Positive case: String. Valid Roman numeral MMXXV converts to 2025');
		// Case #4: String. Case insensitive - lowercase mmxxv converts to 2025
		oParser = new parserFormula('ARABIC("mmxxv")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("mmxxv") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2025, 'Test: Positive case: String. Case insensitive - lowercase mmxxv converts to 2025');
		// Case #5: String. Mixed case MmXxV converts to 2025
		oParser = new parserFormula('ARABIC("MmXxV")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("MmXxV") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2025, 'Test: Positive case: String. Mixed case MmXxV converts to 2025');
		// Case #6: String. Negative Roman numeral -X converts to -10
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #15
		/*oParser = new parserFormula('ARABIC("-X")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("-X") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -10, 'Test: Positive case: String. Negative Roman numeral -X converts to -10');*/
		// Case #7: String. Leading and trailing spaces are ignored
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #16
		/*oParser = new parserFormula('ARABIC(" X ")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(" X ") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String. Leading and trailing spaces are ignored');*/
		// Case #8: String. Empty string returns 0
		oParser = new parserFormula('ARABIC("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Tse: String. Empty string returns 0');
		// Case #9: Formula. Nested formula generating XI returns 11
		oParser = new parserFormula('ARABIC(CONCATENATE("X","I"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(CONCATENATE("X","I")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Formula. Nested formula generating XI returns 11');
		// Case #10: Formula. Nested formula generating XI returns 11
		oParser = new parserFormula('ARABIC(LEFT("XIV",2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(LEFT("XIV",2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Formula. Nested formula generating XI returns 11');
		// Case #11: Formula. Nested formula generating ML returns 950
		oParser = new parserFormula('ARABIC(MID("MCMLXIV",3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(MID("MCMLXIV",3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1050, 'Test: Positive case: Formula. Nested formula generating ML returns 950');
		// Case #12: Reference link. Reference to cell with valid Roman numeral
		oParser = new parserFormula('ARABIC(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Reference link. Reference to cell with valid Roman numeral');
		// Case #13: Area. Single-cell range with valid Roman numeral
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #17
		/*oParser = new parserFormula('ARABIC(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2025, 'Test: Positive case: Area. Single-cell range with valid Roman numeral');*/
		// Case #14: Name. Named range with valid Roman numeral
		oParser = new parserFormula('ARABIC(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Name. Named range with valid Roman numeral');
		// Case #15: Name3D. 3D named range with valid Roman numeral
		oParser = new parserFormula('ARABIC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Name3D. 3D named range with valid Roman numeral');
		// Case #16: Ref3D. 3D reference to cell with valid Roman numeral
		oParser = new parserFormula('ARABIC(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Ref3D. 3D reference to cell with valid Roman numeral');
		// Case #17: Area3D. 3D single-cell range with valid Roman numeral
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #17
		/*oParser = new parserFormula('ARABIC(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2025, 'Test: Positive case: Area3D. 3D single-cell range with valid Roman numeral');*/
		// Case #18: Formula. ARABIC inside another formula returns 15
		oParser = new parserFormula('SUM(ARABIC("V"),ARABIC("X"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(ARABIC("V"),ARABIC("X")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Formula. ARABIC inside another formula returns 15');
		// Case #19: String. Complex Roman numeral MCMXCIX converts to 1999
		oParser = new parserFormula('ARABIC("MCMXCIX")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("MCMXCIX") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1999, 'Test: Positive case: String. Complex Roman numeral MCMXCIX converts to 1999');
		// Case #20: String. Large Roman numeral MMMCMXCIX converts to 3999
		oParser = new parserFormula('ARABIC("MMMCMXCIX")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("MMMCMXCIX") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3999, 'Test: Positive case: String. Large Roman numeral MMMCMXCIX converts to 3999');
		// Case #21: String. Minimum valid Roman numeral I converts to 1
		oParser = new parserFormula('ARABIC("I")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("I") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. Minimum valid Roman numeral I converts to 1');
		// Case #22: Formula. Nested IF formula returning X converts to 10
		oParser = new parserFormula('ARABIC(IF(TRUE,"X","V"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(IF(TRUE,"X","V")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Nested IF formula returning X converts to 10');
		// Case #23: Table. Table reference with valid Roman numeral
		oParser = new parserFormula('ARABIC(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Table. Table reference with valid Roman numeral');
		// Case #24: Array. Array with single Roman numeral element X converts to 10
		oParser = new parserFormula('ARABIC({"X"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC({"X"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 10, 'Test: Positive case: Array. Array with single Roman numeral element X converts to 10');
		// Case #25: Formula. Nested formula with ARABIC as arguments returns 2^2=4
		oParser = new parserFormula('POWER(ARABIC("II"),ARABIC("II"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula POWER(ARABIC("II"),ARABIC("II")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Nested formula with ARABIC as arguments returns 2^2=4');
		// Case #26: String. Non-standard but acceptable Roman numeral IIII converts to 4
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #18
		/*oParser = new parserFormula('ARABIC("IIII")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("IIII") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: String. Non-standard but acceptable Roman numeral IIII converts to 4');
		// Case #27: String. Incorrectly formed Roman numeral
		oParser = new parserFormula('ARABIC("IVIV")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("IVIV") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: String. Incorrectly formed Roman numeral');
		// Case #28: String. Incorrectly ordered Roman numeral
		oParser = new parserFormula('ARABIC("XM")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("XM") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 990, 'Test: Positive case: String. Incorrectly ordered Roman numeral');
		// Case #29: String. Roman numeral with repeated M more than 3 times
		oParser = new parserFormula('ARABIC("MMMM")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("MMMM") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4000, 'Test: Positive case: String. Roman numeral with repeated M more than 3 times');
		// Case #30: String. Roman numeral with incorrect order
		oParser = new parserFormula('ARABIC("IXI")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("IXI") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String. Roman numeral with incorrect order');
		// Case #31: String. Roman numeral with repeated V
		oParser = new parserFormula('ARABIC("VV")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("VV") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String. Roman numeral with repeated V');
		// Case #32: String. Roman numeral with repeated L
		oParser = new parserFormula('ARABIC("LL")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("LL") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: String. Roman numeral with repeated L');
		// Case #33: String. Roman numeral with repeated D
		oParser = new parserFormula('ARABIC("DD")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("DD") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Positive case: String. Roman numeral with repeated D');
		// Case #34: String. Roman numeral with I repeated more than 4 times
		oParser = new parserFormula('ARABIC("IIIII")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("IIIII") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. Roman numeral with I repeated more than 4 times');
		// Case #35: String. Roman numeral with X repeated more than 4 times
		oParser = new parserFormula('ARABIC("XXXXX")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("XXXXX") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: String. Roman numeral with X repeated more than 4 times');
		// Case #36: String. Roman numeral with C repeated more than 4 times
		oParser = new parserFormula('ARABIC("CCCCCC")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("CCCCCC") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 600, 'Test: Positive case: String. Roman numeral with C repeated more than 4 times');*/
		// Case #37: Area. Multi-cell range
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #17
		/*oParser = new parserFormula('ARABIC(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2025, 'Test: Positive case: Area. Multi-cell range');
		// Case #38: Name. Name with area. Valid Roman number
		oParser = new parserFormula('ARABIC(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Name. Name with area. Valid Roman number');
		// Case #39: Name3D. Name 3D with area. Valid Roman number
		oParser = new parserFormula('ARABIC(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Name3D. Name 3D with area. Valid Roman number');*/

		// Negative cases:

		// Case #1: String. Invalid Roman numeral returns #VALUE!
		oParser = new parserFormula('ARABIC("ABC")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("ABC") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Invalid Roman numeral returns #VALUE!');
		// Case #2: String. Roman numeral with extra text returns #VALUE!
		oParser = new parserFormula('ARABIC("IV text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("IV text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Roman numeral with extra text returns #VALUE!');
		// Case #3: Number. Numeric input returns #VALUE!
		oParser = new parserFormula('ARABIC(123)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(123) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Numeric input returns #VALUE!');
		// Case #4: Date. Date input returns #VALUE!
		oParser = new parserFormula('ARABIC(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Date. Date input returns #VALUE!');
		// Case #5: Error. Error input propagates the error (#N/A)
		oParser = new parserFormula('ARABIC(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error input propagates the error (#N/A)');
		// Case #6: Reference link. Reference to cell with invalid Roman numeral returns #VALUE!
		oParser = new parserFormula('ARABIC(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to cell with invalid Roman numeral returns #VALUE!');
		// Case #7: Name. Named range with invalid Roman numeral returns #VALUE!
		oParser = new parserFormula('ARABIC(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with invalid Roman numeral returns #VALUE!');
		// Case #8: Boolean. Boolean input returns #VALUE!
		oParser = new parserFormula('ARABIC(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean input returns #VALUE!');
		// Case #9: String. Roman numeral with special characters returns #VALUE!
		oParser = new parserFormula('ARABIC("$X")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("$X") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Roman numeral with special characters returns #VALUE!');
		// Case #10: String. Text instead of Roman number
		oParser = new parserFormula('ARABIC("Text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("Text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Text instead of Roman number');

		// Bounded cases:

		// Case #1: String. Roman numeral M converts to 1000
		oParser = new parserFormula('ARABIC("M")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("M") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Bounded case: String. Roman numeral M converts to 1000');
		// Case #2: String. Maximum length Roman numeral (255 M\'s) converts to 255000
		oParser = new parserFormula('ARABIC(REPT("M",255))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC(REPT("M",255)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255000, 'Test: Bounded case: String. Maximum length Roman numeral (255 M\'s) converts to 255000');
		// Case #3: String. Largest standard Roman numeral MMMCMXCIX converts to 3999
		oParser = new parserFormula('ARABIC("MMMCMXCIX")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("MMMCMXCIX") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3999, 'Test: Bounded case: String. Largest standard Roman numeral MMMCMXCIX converts to 3999');
		// Case #4: String. Largest negative standard Roman numeral -MMMCMXCIX converts to -3999
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row #15
		/*oParser = new parserFormula('ARABIC("-MMMCMXCIX")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ARABIC("-MMMCMXCIX") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3999, 'Test: Bounded case: String. Largest negative standard Roman numeral -MMMCMXCIX converts to -3999');*/
	});

	QUnit.test("Test: \"ASIN\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("4");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("2");
		ws.getRange2("B103").setValue("-2");
		ws.getRange2("A105").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("-0.5"); // Column1
		ws.getRange2("B601").setValue("Text"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("Text");
		ws2.getRange2("B2").setValue("10");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.5"); // TestName
		ws.getRange2("A208").setValue("Text"); // TestNameArea2
		ws.getRange2("B208").setValue("Test"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("-0.5") // TestName3D
		ws2.getRange2("A18").setValue("0.5"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.5"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Number. Example from documentation
		oParser = new parserFormula('ASIN(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.523598776, 'Test: Positive case: Number. Example from documentation');
		// Case #2: Number. Basic usage with a positive number in valid range [-1, 1].
		oParser = new parserFormula('ASIN(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Number. Basic usage with a positive number in valid range [-1, 1].');
		// Case #3: Number. Zero value - valid argument.
		oParser = new parserFormula('ASIN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero value - valid argument.');
		// Case #4: String. String representation of number converts to number.
		oParser = new parserFormula('ASIN("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: String. String representation of number converts to number.');
		// Case #5: Formula. Nested formula returns valid value (0.5).
		oParser = new parserFormula('ASIN(SQRT(0.25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(SQRT(0.25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Formula. Nested formula returns valid value (0.5).');
		// Case #6: Reference link. Reference to cell with valid value.
		oParser = new parserFormula('ASIN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Reference link. Reference to cell with valid value.');
		// Case #7: Area. Single-cell range with valid value.
		oParser = new parserFormula('ASIN(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Area. Single-cell range with valid value.');
		// Case #8: Array. Array with single element.
		oParser = new parserFormula('ASIN({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Array. Array with single element.');
		// Case #9: Name. Named range with valid value.
		oParser = new parserFormula('ASIN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Name. Named range with valid value.');
		// Case #10: Name3D. 3D named range with valid value.
		oParser = new parserFormula('ASIN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.523598776, 'Test: Positive case: Name3D. 3D named range with valid value.');
		// Case #11: Ref3D. 3D reference to cell with valid value.
		oParser = new parserFormula('ASIN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Ref3D. 3D reference to cell with valid value.');
		// Case #12: Area3D. 3D single-cell range with valid value.
		oParser = new parserFormula('ASIN(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Area3D. 3D single-cell range with valid value.');
		// Case #13: Table. Table reference with valid value.
		oParser = new parserFormula('ASIN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.523598776, 'Test: Positive case: Table. Table reference with valid value.');
		// Case #14: Formula. ASIN used inside another formula.
		oParser = new parserFormula('SIN(ASIN(0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SIN(ASIN(0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Formula. ASIN used inside another formula.');
		// Case #15: Array. Array with multiple elements in valid range.
		oParser = new parserFormula('ASIN({-0.5, 0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN({-0.5, 0}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, -0.523598776, 'Test: Positive case: Array. Array with multiple elements in valid range.');
		// Case #17: Formula. Nested IF returns valid value.
		oParser = new parserFormula('ASIN(IF(TRUE, 0.5, 2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(IF(TRUE, 0.5, 2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Formula. Nested IF returns valid value.');
		// Case #18: Formula. Nested trigonometric formula returns valid value.
		oParser = new parserFormula('ASIN(SIN(PI()/4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(SIN(PI()/4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Formula. Nested trigonometric formula returns valid value.');
		// Case #19: Formula. Testing with cosine that returns value in valid range.
		oParser = new parserFormula('ASIN(COS(PI()/3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(COS(PI()/3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Formula. Testing with cosine that returns value in valid range.');
		// Case #20: Number. Value close to upper boundary of valid range.
		oParser = new parserFormula('ASIN(0.999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(0.999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.569382113, 'Test: Positive case: Number. Value close to upper boundary of valid range.');
		// Case #21: Number. Value close to lower boundary of valid range.
		oParser = new parserFormula('ASIN(-0.999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(-0.999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.569382113, 'Test: Positive case: Number. Value close to lower boundary of valid range.');
		// Case #22: Formula. Converting result from radians to degrees.
		oParser = new parserFormula('ROUND(ASIN(0.5)*180/PI(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ROUND(ASIN(0.5)*180/PI(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Formula. Converting result from radians to degrees.');
		// Case #23: Formula. Combination of trigonometric functions and degrees to radians conversion.
		oParser = new parserFormula('ASIN(SIN(RADIANS(30)))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(SIN(RADIANS(30))) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Formula. Combination of trigonometric functions and degrees to radians conversion.');
		// Case #24: Reference link, Formula. Arithmetic expression based on references.
		oParser = new parserFormula('ASIN((A101+A102)/10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN((A101+A102)/10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.643501109, 'Test: Positive case: Reference link, Formula. Arithmetic expression based on references.');
		// Case #25: Formula. Nested AVERAGE function with array values.
		oParser = new parserFormula('ASIN(AVERAGE({-0.2, 0.3, 0.7}))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(AVERAGE({-0.2, 0.3, 0.7})) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.269932796, 'Test: Positive case: Formula. Nested AVERAGE function with array values.');
		// Case #26: Number. Number very close to but less than 1.
		oParser = new parserFormula('ASIN(1-1E-10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(1-1E-10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570782185, 'Test: Positive case: Number. Number very close to but less than 1.');
		// Case #27: Reference link. Reference link with empty cell
		oParser = new parserFormula('ASIN(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference link with empty cell');
		// Case #28: Boolean. Boolean TRUE converts to 1 (valid value).
		oParser = new parserFormula('ASIN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Boolean. Boolean TRUE converts to 1 (valid value).');
		// Case #29: Boolean. Boolean FALSE converts to 0 (valid value).
		oParser = new parserFormula('ASIN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean. Boolean FALSE converts to 0 (valid value).');
		// Case #30: Formula. Time value (0.5) is in valid range.
		oParser = new parserFormula('ASIN(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Formula. Time value (0.5) is in valid range.');
		// Case #31: Name3D. Named range with correct numbers
		oParser = new parserFormula('ASIN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Name3D. Named range with correct numbers');

		// Negative cases:

		// Case #1: Number. Value greater than 1 returns #NUM! error.
		oParser = new parserFormula('ASIN(1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(1.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value greater than 1 returns #NUM! error.');
		// Case #2: Number. Value less than -1 returns #NUM! error.
		oParser = new parserFormula('ASIN(-1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(-1.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value less than -1 returns #NUM! error.');
		// Case #3: String. Non-numeric string returns #VALUE! error.
		oParser = new parserFormula('ASIN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE! error.');
		// Case #4: Error. Passing #N/A error propagates the error.
		oParser = new parserFormula('ASIN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Passing #N/A error propagates the error.');
		// Case #5: Area. Multi-cell range returns error.
		oParser = new parserFormula('ASIN(A103:B103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(A103:B103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range returns error.');
		// Case #6: String. Empty string returns #VALUE! error.
		oParser = new parserFormula('ASIN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE! error.');
		// Case #7: Ref3D. 3D reference to cell with text returns #VALUE! error.
		oParser = new parserFormula('ASIN(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE! error.');
		// Case #8: Name. Named range with text returns #VALUE! error.
		oParser = new parserFormula('ASIN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE! error.');
		// Case #9: Table. Table column with text returns #VALUE! error.
		oParser = new parserFormula('ASIN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE! error.');
		// Case #10: Formula. Formula resulting in #NUM! error propagates the error.
		oParser = new parserFormula('ASIN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error propagates the error.');
		// Case #11: Number. Value much greater than 1 returns #NUM! error.
		oParser = new parserFormula('ASIN(100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value much greater than 1 returns #NUM! error.');
		// Case #12: Number. Value much less than -1 returns #NUM! error.
		oParser = new parserFormula('ASIN(-100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(-100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Value much less than -1 returns #NUM! error.');
		// Case #13: String. Date string converts to number greater than 1, returns #NUM! error.
		oParser = new parserFormula('ASIN("01/01/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN("01/01/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Date string converts to number greater than 1, returns #NUM! error.');
		// Case #14: Area3D. 3D multi-cell range returns error.
		oParser = new parserFormula('ASIN(Sheet2!A2:B2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(Sheet2!A2:B2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns error.');
		// Case #15: Formula. Number slightly greater than 1 returns #NUM! error.
		oParser = new parserFormula('ASIN(1+1E-10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(1+1E-10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Number slightly greater than 1 returns #NUM! error.');
		// Case #16: Formula. Number slightly less than -1 returns #NUM! error.
		oParser = new parserFormula('ASIN(-1-1E-10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(-1-1E-10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Number slightly less than -1 returns #NUM! error.');

		// Bounded cases:

		// Case #1: Number. Minimum valid value (-1).
		oParser = new parserFormula('ASIN(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.570796327, 'Test: Bounded case: Number. Minimum valid value (-1).');
		// Case #2: Number. Value very close to minimum valid value.
		oParser = new parserFormula('ASIN(-0.9999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(-0.9999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -1.57079588, 'Test: Bounded case: Number. Value very close to minimum valid value.');
		// Case #3: Number. Maximum valid value (1).
		oParser = new parserFormula('ASIN(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Maximum valid value (1).');
		// Case #4: Number. Value very close to maximum valid value.
		oParser = new parserFormula('ASIN(0.9999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASIN(0.9999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 1.57079588, 'Test: Bounded case: Number. Value very close to maximum valid value.');


		testArrayFormula(assert, "ASIN");
	});

	QUnit.test("Test: \"ASINH\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("-2.5");
		ws.getRange2("A101").setValue("test");
		ws.getRange2("B101").setValue("text");
		ws.getRange2("A102").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("10"); // Column1
		ws.getRange2("B601").setValue("Text"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("2");
		ws2.getRange2("A2").setValue("Test");
		ws2.getRange2("A3").setValue("#N/A");
		ws2.getRange2("B3").setValue("abc");

		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("10"); // TestName
		ws.getRange2("A208").setValue("#N/A"); // TestNameArea2
		ws.getRange2("B208").setValue("abc"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("-1") // TestName3D
		ws2.getRange2("A18").setValue("Test"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("Text"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Number. Example from documentation. Number is -2.5
		oParser = new parserFormula('ASINH(-2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(-2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.647231146, 'Test: Positive case: Number. Example from documentation. Number is -2.5');
		// Case #2: Number. Example from documentation. Number is 10
		oParser = new parserFormula('ASINH(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 2.99822295, 'Test: Positive case: Number. Example from documentation. Number is 10');
		// Case #3: Number. Basic valid input: zero.
		oParser = new parserFormula('ASINH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: zero.');
		// Case #4: Number. Basic valid input: positive integer.
		oParser = new parserFormula('ASINH(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.881373587, 'Test: Positive case: Number. Basic valid input: positive integer.');
		// Case #5: Number. Basic valid input: negative integer.
		oParser = new parserFormula('ASINH(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.881373587, 'Test: Positive case: Number. Basic valid input: negative integer.');
		// Case #6: Number. Float input: positive number.
		oParser = new parserFormula('ASINH(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.194763217, 'Test: Positive case: Number. Float input: positive number.');
		// Case #7: Number. Float input: negative number.
		oParser = new parserFormula('ASINH(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.194763217, 'Test: Positive case: Number. Float input: negative number.');
		// Case #8: String. String convertible to number.
		oParser = new parserFormula('ASINH("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.443635475, 'Test: Positive case: String. String convertible to number.');
		// Case #9: String. String convertible to negative number.
		oParser = new parserFormula('ASINH("-2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH("-2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.443635475, 'Test: Positive case: String. String convertible to negative number.');
		// Case #10: Formula. Nested formula returning 2.
		oParser = new parserFormula('ASINH(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.443635475, 'Test: Positive case: Formula. Nested formula returning 2.');
		// Case #11: Formula. Nested LN formula.
		oParser = new parserFormula('ASINH(LN(10))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(LN(10)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.571308801, 'Test: Positive case: Formula. Nested LN formula.');
		// Case #12: Reference link. Reference to cell with valid number.
		oParser = new parserFormula('ASINH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.647231146, 'Test: Positive case: Reference link. Reference to cell with valid number.');
		// Case #13: Area. Single-cell range.
		oParser = new parserFormula('ASINH(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.647231146, 'Test: Positive case: Area. Single-cell range.');
		// Case #14: Array. Array with single element.
		oParser = new parserFormula('ASINH({2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH({2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 1.443635475, 'Test: Positive case: Array. Array with single element.');
		// Case #15: Array. Array with two elements (negative and positive).
		oParser = new parserFormula('ASINH({-1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH({-1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, -0.881373587, 'Test: Positive case: Array. Array with two elements (negative and positive).');
		// Case #16: Name. Named range with single value.
		oParser = new parserFormula('ASINH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 2.99822295, 'Test: Positive case: Name. Named range with single value.');
		// Case #17: Name3D. 3D named range.
		oParser = new parserFormula('ASINH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.881373587, 'Test: Positive case: Name3D. 3D named range.');
		// Case #18: Ref3D. 3D reference to cell.
		oParser = new parserFormula('ASINH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.443635475, 'Test: Positive case: Ref3D. 3D reference to cell.');
		// Case #19: Area3D. 3D single-cell range.
		oParser = new parserFormula('ASINH(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.443635475, 'Test: Positive case: Area3D. 3D single-cell range.');
		// Case #20: Table. Table structured reference.
		oParser = new parserFormula('ASINH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 2.99822295, 'Test: Positive case: Table. Table structured reference.');
		// Case #21: Formula. Date as serial number.
		oParser = new parserFormula('ASINH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 11.4220813, 'Test: Positive case: Formula. Date as serial number.');
		// Case #22: Formula. Time as serial number (0.5).
		oParser = new parserFormula('ASINH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.481211825, 'Test: Positive case: Formula. Time as serial number (0.5).');
		// Case #23: Formula. ASINH inside SUM formula.
		oParser = new parserFormula('SUM(ASINH(2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(ASINH(2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.443635475, 'Test: Positive case: Formula. ASINH inside SUM formula.');
		// Case #24: Formula. ASINH inside POWER formula.
		oParser = new parserFormula('POWER(ASINH(3),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula POWER(ASINH(3),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.306747525, 'Test: Positive case: Formula. ASINH inside POWER formula.');
		// Case #25: String. Short date in string.
		oParser = new parserFormula('ASINH("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH("12/12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 11.42960907, 'Test: Positive case: String. Short date in string.');
		// Case #26: Formula. Nested IF formula returning 2.
		oParser = new parserFormula('ASINH(IF(TRUE,2,0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(IF(TRUE,2,0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.443635475, 'Test: Positive case: Formula. Nested IF formula returning 2.');
		// Case #27: Number. Very small positive number.
		oParser = new parserFormula('ASINH(1E-100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(1E-100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Very small positive number.');
		// Case #28: Number. Very small negative number.
		oParser = new parserFormula('ASINH(-1E-100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(-1E-100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Very small negative number.');
		// Case #29: Number. Very large positive number.
		oParser = new parserFormula('ASINH(1E+100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(1E+100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 230.9516565, 'Test: Positive case: Number. Very large positive number.');
		// Case #30: Number. Very large negative number.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#35
		/*oParser = new parserFormula('ASINH(-1E+100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(-1E+100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/!*.toFixed(7) - 0*!/, -230.9516565, 'Test: Positive case: Number. Very large negative number.');*/
		// Case #31: Boolean. Boolean TRUE (1).
		oParser = new parserFormula('ASINH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.881373587, 'Test: Positive case: Boolean. Boolean TRUE (1).');
		// Case #32: Boolean. Boolean FALSE (0).
		oParser = new parserFormula('ASINH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean. Boolean FALSE (0).');

		// Negative cases:

		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('ASINH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: String. Text with numbers returns #VALUE!.
		oParser = new parserFormula('ASINH("text123")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH("text123") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Text with numbers returns #VALUE!.');
		// Case #3: Error. Propagates #N/A error.
		oParser = new parserFormula('ASINH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #4: Error. Propagates #DIV/0! error.
		oParser = new parserFormula('ASINH(#DIV/0!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(#DIV/0!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Propagates #DIV/0! error.');
		// Case #5: Error. Propagates #VALUE! error.
		oParser = new parserFormula('ASINH(#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error. Propagates #VALUE! error.');
		// Case #6: Error. Propagates #REF! error.
		oParser = new parserFormula('ASINH(#REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(#REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Error. Propagates #REF! error.');
		// Case #7: Error. Propagates #NAME? error.
		oParser = new parserFormula('ASINH(NAME)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(NAME) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Error. Propagates #NAME? error.');
		// Case #8: Error. Propagates #NUM! error.
		oParser = new parserFormula('ASINH(#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(#NUM!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Error. Propagates #NUM! error.');
		// Case #9: Area. Multi-cell range returns #VALUE! error.
		oParser = new parserFormula('ASINH(A101:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(A101:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE! error.');
		// Case #10: Empty. Reference to empty cell returns 0.
		oParser = new parserFormula('ASINH(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Reference to empty cell returns 0.');
		// Case #11: String. Empty string
		oParser = new parserFormula('ASINH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string');
		// Case #12: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('ASINH(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #13: Name3D. Named range with text returns #VALUE!.
		oParser = new parserFormula('ASINH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. Named range with text returns #VALUE!.');
		// Case #14: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('ASINH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #15: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('ASINH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #16: Formula. Formula resulting in #DIV/0! error.
		oParser = new parserFormula('ASINH(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! error.');
		// Case #17: Array. Array with text returns #VALUE!.
		oParser = new parserFormula('ASINH({"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH({"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#VALUE!', 'Test: Negative case: Array. Array with text returns #VALUE!.');
		// Case #18: Array. Array with mixed types returns #VALUE!.
		oParser = new parserFormula('ASINH({"abc", TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH({"abc", TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#VALUE!', 'Test: Negative case: Array. Array with mixed types returns #VALUE!.');
		// Case #19: Formula. Formula resulting in #VALUE! error.
		oParser = new parserFormula('ASINH(FIND("x","y"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(FIND("x","y")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Formula resulting in #VALUE! error.');
		// Case #20: Number. Number exceeding Excel\'s maximum returns #NUM!.
		oParser = new parserFormula('ASINH(1E+155)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(1E+155) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number exceeding Excel\'s maximum returns #NUM!.');
		// Case #21: Number. Number below Excel\'s minimum returns #NUM!.
		oParser = new parserFormula('ASINH(-1E+155)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(-1E+155) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number below Excel\'s minimum returns #NUM!.');
		// Case #22: String. String evaluating to error returns #VALUE!.
		oParser = new parserFormula('ASINH("0/1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH("0/1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String evaluating to error returns #VALUE!.');
		// Case #23: Formula. Formula returning #N/A error.
		oParser = new parserFormula('ASINH(MATCH("x",{"a","b"},0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(MATCH("x",{"a","b"},0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Formula returning #N/A error.');
		// Case #24: Name. Named range with non-numeric data.
		oParser = new parserFormula('ASINH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with non-numeric data.');
		// Case #25: Area3D. 3D multi-cell range.
		oParser = new parserFormula('ASINH(Sheet2!A3:B3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(Sheet2!A3:B3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area3D. 3D multi-cell range.');

		// Bounded cases:

		// Case #1: Number. Near minimum valid Excel number.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#35
		/*oParser = new parserFormula('ASINH(-9.99999999999999E+153)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(-9.99999999999999E+153) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -355.2912515, 'Test: Bounded case: Number. Near minimum valid Excel number.');*/
		// Case #2: Number. Near maximum valid Excel number.
		oParser = new parserFormula('ASINH(9.99999999999999E+153)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(9.99999999999999E+153) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 355.2912515, 'Test: Bounded case: Number. Near maximum valid Excel number.');
		// Case #3: Number. Smallest positive Excel number.
		oParser = new parserFormula('ASINH(2.2250738585072E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(2.2250738585072E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive Excel number.');
		// Case #4: Number. Smallest negative Excel number.
		oParser = new parserFormula('ASINH(-2.2250738585072E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ASINH(-2.2250738585072E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest negative Excel number.');

		testArrayFormula(assert, "ASINH");
	});

	QUnit.test("Test: \"ATAN\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("-1");
		ws.getRange2("A102").setValue("Text");
		ws.getRange2("B102").setValue("#NULL!");
		ws.getRange2("A103").setValue("\"\"");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("-1"); // Column1
		ws.getRange2("B601").setValue("test"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("10");
		ws2.getRange2("A3").setValue("-1");
		ws2.getRange2("A4").setValue("Text");
		ws2.getRange2("B4").setValue("\"\"");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1"); // TestName
		ws.getRange2("A208").setValue("Test"); // TestNameArea2
		ws.getRange2("B208").setValue("\"\""); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1") // TestName3D

		// Positive cases:

		// Case #1: Number. Example form documentation. Number is 1
		oParser = new parserFormula('ATAN(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Number. Example form documentation. Number is 1');
		// Case #2: Number. Basic numeric input - returns π/4 (approximately 0.785398) radians.
		oParser = new parserFormula('ATAN(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Number. Basic numeric input - returns π/4 (approximately 0.785398) radians.');
		// Case #3: Number. Zero input - returns 0 radians.
		oParser = new parserFormula('ATAN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero input - returns 0 radians.');
		// Case #4: Number. Negative input - returns -π/4 (approximately -0.785398) radians.
		oParser = new parserFormula('ATAN(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.785398163, 'Test: Positive case: Number. Negative input - returns -π/4 (approximately -0.785398) radians.');
		// Case #5: Number. Large positive value - approaches π/2.
		oParser = new parserFormula('ATAN(100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 1.56079666, 'Test: Positive case: Number. Large positive value - approaches π/2.');
		// Case #6: Number. Large negative value - approaches -π/2.
		oParser = new parserFormula('ATAN(-100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(-100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -1.56079666, 'Test: Positive case: Number. Large negative value - approaches -π/2.');
		// Case #7: Number. Tangent of 30° (π/6 radians) - returns approx. 0.5236.
		oParser = new parserFormula('ATAN(0.5773502692)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(0.5773502692) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523598776, 'Test: Positive case: Number. Tangent of 30° (π/6 radians) - returns approx. 0.5236.');
		// Case #8: Number. Tangent of 60° (π/3 radians) - returns approx. 1.0472.
		oParser = new parserFormula('ATAN(1.732050808)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(1.732050808) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: Number. Tangent of 60° (π/3 radians) - returns approx. 1.0472.');
		// Case #9: String. String convertible to number.
		oParser = new parserFormula('ATAN("1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN("1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: String. String convertible to number.');
		// Case #10: String. String decimal convertible to number.
		oParser = new parserFormula('ATAN("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.463647609, 'Test: Positive case: String. String decimal convertible to number.');
		// Case #11: String. Negative number in string format.
		oParser = new parserFormula('ATAN("-1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN("-1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.785398163, 'Test: Positive case: String. Negative number in string format.');
		// Case #12: Formula. Formula calculating tangent - should return 0.5.
		oParser = new parserFormula('ATAN(SIN(0.5)/COS(0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(SIN(0.5)/COS(0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Formula. Formula calculating tangent - should return 0.5.');
		// Case #13: Formula. Formula using TAN function - should return 1.
		oParser = new parserFormula('ATAN(TAN(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(TAN(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Formula using TAN function - should return 1.');
		// Case #14: Formula. Square root of 3 (tangent of 60°).
		oParser = new parserFormula('ATAN(SQRT(3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(SQRT(3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.047197551, 'Test: Positive case: Formula. Square root of 3 (tangent of 60°).');
		// Case #15: Reference link. Reference to cell with value.
		oParser = new parserFormula('ATAN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Reference link. Reference to cell with value.');
		// Case #16: Reference link. Reference to cell with value.
		oParser = new parserFormula('ATAN(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.785398163, 'Test: Positive case: Reference link. Reference to cell with value.');
		// Case #17: Area. Single-cell range.
		oParser = new parserFormula('ATAN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.785398163, 'Test: Positive case: Area. Single-cell range.');
		// Case #18: Array. Array with single value.
		oParser = new parserFormula('ATAN({1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN({1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Array. Array with single value.');
		// Case #19: Array. Array with multiple values.
		oParser = new parserFormula('ATAN({0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN({0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 0, 'Test: Positive case: Array. Array with multiple values.');
		// Case #20: Name. Named range with value.
		oParser = new parserFormula('ATAN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name. Named range with value.');
		// Case #21: Name3D. 3D named range with value.
		oParser = new parserFormula('ATAN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name3D. 3D named range with value.');
		// Case #22: Ref3D. 3D reference to cell.
		oParser = new parserFormula('ATAN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Ref3D. 3D reference to cell.');
		// Case #23: Area3D. 3D single-cell range.
		oParser = new parserFormula('ATAN(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Area3D. 3D single-cell range.');
		// Case #24: Table. Table reference.
		oParser = new parserFormula('ATAN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.785398163, 'Test: Positive case: Table. Table reference.');
		// Case #25: Date. Date value converted to serial number.
		oParser = new parserFormula('ATAN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570774425, 'Test: Positive case: Date. Date value converted to serial number.');
		// Case #26: Time. Time value converted to decimal.
		oParser = new parserFormula('ATAN(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.463647609, 'Test: Positive case: Time. Time value converted to decimal.');
		// Case #27: Formula. Pi value - returns approx. 1.2626.
		oParser = new parserFormula('ATAN(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.262627256, 'Test: Positive case: Formula. Pi value - returns approx. 1.2626.');
		// Case #28: Formula. Pi/4 value.
		oParser = new parserFormula('ATAN(PI()/4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(PI()/4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.66577375, 'Test: Positive case: Formula. Pi/4 value.');
		// Case #29: Formula. Converting ATAN result to degrees - returns 45°.
		oParser = new parserFormula('DEGREES(ATAN(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45, 'Test: Positive case: Formula. Converting ATAN result to degrees - returns 45°.');
		// Case #30: Formula. Converting ATAN of SQRT(3) to degrees - returns 60°.
		oParser = new parserFormula('DEGREES(ATAN(SQRT(3)))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN(SQRT(3))) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 60, 'Test: Positive case: Formula. Converting ATAN of SQRT(3) to degrees - returns 60°.');
		// Case #31: Formula. Converting ATAN of 1/SQRT(3) to degrees - returns 30°.
		oParser = new parserFormula('DEGREES(ATAN(1/SQRT(3)))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN(1/SQRT(3))) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 30, 'Test: Positive case: Formula. Converting ATAN of 1/SQRT(3) to degrees - returns 30°.');
		// Case #32: Formula. IF function inside ATAN.
		oParser = new parserFormula('ATAN(IF(TRUE,1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(IF(TRUE,1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Formula. IF function inside ATAN.');
		// Case #33: Formula. ATAN inside SUM function.
		oParser = new parserFormula('SUM(ATAN(1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(ATAN(1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.785398163, 'Test: Positive case: Formula. ATAN inside SUM function.');
		// Case #34: Formula. ROUND function inside ATAN.
		oParser = new parserFormula('ATAN(ROUND(0.567,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(ROUND(0.567,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.518068528, 'Test: Positive case: Formula. ROUND function inside ATAN.');
		// Case #35: Formula. ABS function inside ATAN.
		oParser = new parserFormula('ATAN(ABS(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(ABS(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Formula. ABS function inside ATAN.');
		// Case #36: Number. Very small positive number - approaches 0.
		oParser = new parserFormula('ATAN(0.00000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(0.00000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-8, 'Test: Positive case: Number. Very small positive number - approaches 0.');
		// Case #37: Number. Very small negative number - approaches 0.
		oParser = new parserFormula('ATAN(-0.00000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(-0.00000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-8, 'Test: Positive case: Number. Very small negative number - approaches 0.');
		// Case #38: Boolean. Boolean TRUE (1) - returns π/4.
		oParser = new parserFormula('ATAN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Boolean. Boolean TRUE (1) - returns π/4.');
		// Case #39: Boolean. Boolean FALSE (0) - returns 0.
		oParser = new parserFormula('ATAN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean. Boolean FALSE (0) - returns 0.');
		// Case #40: Formula. RADIANS function inside ATAN.
		oParser = new parserFormula('ATAN(RADIANS(45))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(RADIANS(45)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.66577375, 'Test: Positive case: Formula. RADIANS function inside ATAN.');
		// Case #41: String. Date string converted to number.
		oParser = new parserFormula('ATAN("01/01/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN("01/01/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570774425, 'Test: Positive case: String. Date string converted to number.');
		// Case #42: Formula. Converting ATAN result to degrees manually - returns 45°.
		oParser = new parserFormula('DEGREES(ATAN(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45, 'Test: Positive case: Formula. Converting ATAN result to degrees manually - returns 45°.');
		// Case #43: Formula. Converting ATAN of SQRT(3) to degrees manually - returns 60°.
		oParser = new parserFormula('DEGREES(ATAN(SQRT(3)))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN(SQRT(3))) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 60, 'Test: Positive case: Formula. Converting ATAN of SQRT(3) to degrees manually - returns 60°.');
		// Case #44: Formula. Converting ATAN of 1/SQRT(3) to degrees manually - returns 30°.
		oParser = new parserFormula('DEGREES(ATAN(1/SQRT(3)))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN(1/SQRT(3))) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 30, 'Test: Positive case: Formula. Converting ATAN of 1/SQRT(3) to degrees manually - returns 30°.');
		// Case #45: Formula. Converting ATAN of 0 to degrees manually - returns 0°.
		oParser = new parserFormula('DEGREES(ATAN(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula. Converting ATAN of 0 to degrees manually - returns 0°.');
		// Case #46: Formula. INT function inside ATAN.
		oParser = new parserFormula('ATAN(INT(5.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(INT(5.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.373400767, 'Test: Positive case: Formula. INT function inside ATAN.');
		// Case #47: Formula. MIN function inside ATAN.
		oParser = new parserFormula('ATAN(MIN(1,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(MIN(1,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Formula. MIN function inside ATAN.');
		// Case #48: Formula. MAX function inside ATAN.
		oParser = new parserFormula('ATAN(MAX(1,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(MAX(1,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.249045772, 'Test: Positive case: Formula. MAX function inside ATAN.');
		// Case #49: Area. Single-cell range.
		oParser = new parserFormula('ATAN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.785398163, 'Test: Positive case: Area. Single-cell range.');
		// Case #50: Ref3D. 3D reference to cell.
		oParser = new parserFormula('ATAN(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.471127674, 'Test: Positive case: Ref3D. 3D reference to cell.');
		// Case #51: Ref3D. 3D reference to cell.
		oParser = new parserFormula('ATAN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.785398163, 'Test: Positive case: Ref3D. 3D reference to cell.');

		// Negative cases:

		// Case #1: String. Non-numeric string - returns #VALUE!.
		oParser = new parserFormula('ATAN("text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN("text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string - returns #VALUE!.');
		// Case #2: String. Empty string - returns #VALUE!.
		oParser = new parserFormula('ATAN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string - returns #VALUE!.');
		// Case #3: Error. Division by zero error propagates - returns #DIV/0!.
		oParser = new parserFormula('ATAN(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Division by zero error propagates - returns #DIV/0!.');
		// Case #5: Error. N/A error propagates - returns #N/A.
		oParser = new parserFormula('ATAN(#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. N/A error propagates - returns #N/A.');
		// Case #6: Error. NULL error propagates - returns #NULL!.
		oParser = new parserFormula('ATAN(#NULL!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(#NULL!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Error. NULL error propagates - returns #NULL!.');
		// Case #7: Reference link. Reference with empty string- returns #VALUE!.
		oParser = new parserFormula('ATAN(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to empty cell - returns #VALUE!.');
		// Case #8: Reference link. Reference to cell with text - returns #VALUE!.
		oParser = new parserFormula('ATAN(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to cell with text - returns #VALUE!.');
		// Case #9: Area. Multi-cell range - returns #VALUE!.
		oParser = new parserFormula('ATAN(A102:B102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(A102:B102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range - returns #VALUE!.');
		// Case #10: Name. Named range with multiple cells - returns #VALUE!.
		oParser = new parserFormula('ATAN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with multiple cells - returns #VALUE!.');
		// Case #11: Formula. Formula resulting in error - returns #NUM!.
		oParser = new parserFormula('ATAN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in error - returns #NUM!.');
		// Case #12: Formula. Division by zero - returns #DIV/0!.
		oParser = new parserFormula('ATAN(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero - returns #DIV/0!.');
		// Case #13: Area3D. 3D multi-cell range - returns #VALUE!.
		oParser = new parserFormula('ATAN(Sheet2!A4:B4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(Sheet2!A4:B5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range - returns #VALUE!.');
		// Case #14: Ref3D. 3D reference to text cell - returns #VALUE!.
		oParser = new parserFormula('ATAN(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text cell - returns #VALUE!.');
		// Case #15: Table. Table reference with text - returns #VALUE!.
		oParser = new parserFormula('ATAN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table reference with text - returns #VALUE!.');
		// Case #16: Formula. Formula returning #N/A error - returns #N/A.
		oParser = new parserFormula('ATAN(MATCH("xyz",{"a","b"},0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(MATCH("xyz",{"a","b"},0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Formula returning #N/A error - returns #N/A.');
		// Case #17: Formula. Expression with #DIV/0! error - returns #DIV/0!.
		oParser = new parserFormula('ATAN(1+#DIV/0!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(1+#DIV/0!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Expression with #DIV/0! error - returns #DIV/0!.');
		// Case #18: Formula. IF statement returning #VALUE! error - returns #VALUE!.
		oParser = new parserFormula('ATAN(IF(TRUE,#VALUE!,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(IF(TRUE,#VALUE!,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. IF statement returning #VALUE! error - returns #VALUE!.');
		// Case #19: String. String with expression (treated as text) - returns #VALUE!.
		oParser = new parserFormula('ATAN("1+1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN("1+1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String with expression (treated as text) - returns #VALUE!.');
		// Case #20: Formula. FIND function not finding match - returns #VALUE!.
		oParser = new parserFormula('ATAN(FIND("x","y"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(FIND("x","y")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. FIND function not finding match - returns #VALUE!.');

		// Bounded cases:

		// Case #1: Number. Maximum Excel number - approaches π/2 (approx. 1.5708).
		oParser = new parserFormula('ATAN(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Maximum Excel number - approaches π/2 (approx. 1.5708).');
		// Case #2: Number. Minimum Excel number - approaches -π/2 (approx. -1.5708).
		oParser = new parserFormula('ATAN(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.570796327, 'Test: Bounded case: Number. Minimum Excel number - approaches -π/2 (approx. -1.5708).');
		// Case #3: Number. Smallest positive number Excel can handle - approaches 0.
		oParser = new parserFormula('ATAN(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Smallest positive number Excel can handle - approaches 0.');
		// Case #4: Number. Smallest negative number Excel can handle - approaches 0.
		oParser = new parserFormula('ATAN(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-307, 'Test: Bounded case: Number. Smallest negative number Excel can handle - approaches 0.');
		// Case #5: Formula. Near maximum Excel number - approaches π/2.
		oParser = new parserFormula('ATAN(1.7976931348623157E+308/1E+154)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(1.7976931348623157E+308/1E+154) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Formula. Near maximum Excel number - approaches π/2.');
		// Case #6: Formula. Near minimum Excel number - approaches -π/2.
		oParser = new parserFormula('ATAN(-1.7976931348623157E+308/1E+154)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN(-1.7976931348623157E+308/1E+154) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.570796327, 'Test: Bounded case: Formula. Near minimum Excel number - approaches -π/2.');
		// Case #7: Formula. Converting ATAN of max value to degrees - approaches 90°.
		oParser = new parserFormula('DEGREES(ATAN(9.99999999999999E+307))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN(9.99999999999999E+307)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 90, 'Test: Bounded case: Formula. Converting ATAN of max value to degrees - approaches 90°.');
		// Case #8: Formula. Converting ATAN of min value to degrees - approaches -90°.
		oParser = new parserFormula('DEGREES(ATAN(-9.99999999999999E+307))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN(-9.99999999999999E+307)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -90, 'Test: Bounded case: Formula. Converting ATAN of min value to degrees - approaches -90°.');


		testArrayFormula(assert, "ATAN");
	});

	QUnit.test("Test: \"ATAN2\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A102").setValue("-1");
		ws.getRange2("A103").setValue("-1");
		ws.getRange2("A104").setValue("Test");
		ws.getRange2("B104").setValue("abc");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Column1
		ws.getRange2("B601").setValue("1"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("1");
		ws2.getRange2("A3").setValue("#N/A");
		ws2.getRange2("A4").setValue("-1");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1"); // TestName
		ws.getRange2("A202").setValue("1"); // TestName1
		ws.getRange2("A203").setValue("-1"); // TestName2
		ws.getRange2("A204").setValue("Test"); // TestName3
		ws.getRange2("A208").setValue("1"); // TestNameArea2
		ws.getRange2("B208").setValue("1"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1") // TestName3D
		ws2.getRange2("A12").setValue("1") // TestName3D1
		ws2.getRange2("A13").setValue("Test") // TestName3D2
		ws2.getRange2("A14").setValue("-1") // TestName3D3
		ws2.getRange2("A18").setValue("1"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("1"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Number(2). Example from documentation. Coords - 1, 1. 2 of 2 arguments used.
		oParser = new parserFormula('ATAN2(1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Number(2). Example from documentation. Coords - 1, 1. 2 of 2 arguments used.');
		// Case #2: Number(2). Example from documentation. Coords - 1, -1. 2 of 2 arguments used.
		oParser = new parserFormula('ATAN2(-1, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(-1, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -2.35619449, 'Test: Positive case: Number(2). Example from documentation. Coords - 1, -1. 2 of 2 arguments used.');
		// Case #3: Number(2). Example from documentation. Coords - 1, -1 to degrees. 2 of 2 arguments used.
		oParser = new parserFormula('ATAN2(-1, -1)*180/PI()', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(-1, -1)*180/PI() is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -135, 'Test: Positive case: Number(2). Example from documentation. Coords - 1, -1 to degrees. 2 of 2 arguments used.');
		// Case #4: Formula. Example from documentation. Coords - 1, 1 to degrees. 2 of 2 arguments used.
		oParser = new parserFormula('DEGREES(ATAN2(-1, -1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(ATAN2(-1, -1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -135, 'Test: Positive case: Formula. Example from documentation. Coords - 1, 1 to degrees. 2 of 2 arguments used.');
		// Case #5: Number(2). Both arguments are positive numbers. Point in first quadrant. Should return π/4 (approximately 0.7853981634)
		oParser = new parserFormula('ATAN2(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Number(2). Both arguments are positive numbers. Point in first quadrant. Should return π/4 (approximately 0.7853981634)');
		// Case #6: Number(2). First argument is negative, second is positive. Point in second quadrant. Should return 3π/4 (approximately 2.35619449)
		oParser = new parserFormula('ATAN2(-1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(-1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 2.35619449, 'Test: Positive case: Number(2). First argument is negative, second is positive. Point in second quadrant. Should return 3π/4 (approximately 2.35619449)');
		// Case #7: Number(2). Both arguments are negative numbers. Point in third quadrant. Should return -3π/4 (approximately -2.35619449)
		oParser = new parserFormula('ATAN2(-1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(-1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -2.35619449, 'Test: Positive case: Number(2). Both arguments are negative numbers. Point in third quadrant. Should return -3π/4 (approximately -2.35619449)');
		// Case #8: Number(2). First argument is positive, second is negative. Point in fourth quadrant. Should return -π/4 (approximately -0.7853981634)
		oParser = new parserFormula('ATAN2(1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.785398163, 'Test: Positive case: Number(2). First argument is positive, second is negative. Point in fourth quadrant. Should return -π/4 (approximately -0.7853981634)');
		// Case #9: Number(2). Point on positive X axis. Should return 0
		oParser = new parserFormula('ATAN2(1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Point on positive X axis. Should return 0');
		// Case #10: Number(2). Point on negative X axis. Should return π (approximately 3.14159265359)
		oParser = new parserFormula('ATAN2(-1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(-1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.141592654, 'Test: Positive case: Number(2). Point on negative X axis. Should return π (approximately 3.14159265359)');
		// Case #11: Number(2). Point on positive Y axis. Should return π/2 (approximately 1.5707963268)
		oParser = new parserFormula('ATAN2(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Number(2). Point on positive Y axis. Should return π/2 (approximately 1.5707963268)');
		// Case #12: Number(2). Point on negative Y axis. Should return -π/2 (approximately -1.5707963268)
		oParser = new parserFormula('ATAN2(0,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(0,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.570796327, 'Test: Positive case: Number(2). Point on negative Y axis. Should return -π/2 (approximately -1.5707963268)');
		// Case #13: Number(2). Both arguments are fractional numbers. Should correctly calculate arctangent
		oParser = new parserFormula('ATAN2(0.5,0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(0.5,0.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.463647609, 'Test: Positive case: Number(2). Both arguments are fractional numbers. Should correctly calculate arctangent');
		// Case #14: String(2). Strings with numeric values should be converted to numbers and processed correctly
		oParser = new parserFormula('ATAN2("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2("2","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.982793723, 'Test: Positive case: String(2). Strings with numeric values should be converted to numbers and processed correctly');
		// Case #15: Formula(2). Arguments are results of other formulas. Should correctly use calculated values
		oParser = new parserFormula('ATAN2(SIN(0.5),COS(0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(SIN(0.5),COS(0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.070796327, 'Test: Positive case: Formula(2). Arguments are results of other formulas. Should correctly use calculated values');
		// Case #16: Formula. ATAN2 is used inside another formula. Should correctly calculate the inner formula
		oParser = new parserFormula('SIN(ATAN2(1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SIN(ATAN2(1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.894427191, 'Test: Positive case: Formula. ATAN2 is used inside another formula. Should correctly calculate the inner formula');
		// Case #17: Reference link(2). Arguments are cell references. Should use values from specified cells
		oParser = new parserFormula('ATAN2(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Reference link(2). Arguments are cell references. Should use values from specified cells');
		// Case #18: Area(2). Arguments are range. When using a range, should work as with an array
		oParser = new parserFormula('ATAN2(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -2.35619449, 'Test: Positive case: Area(2). Arguments are range. When using a range, should work as with an array');
		// Case #19: Ref3D(2). Arguments are references to cells from another sheet
		oParser = new parserFormula('ATAN2(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Ref3D(2). Arguments are references to cells from another sheet');
		// Case #20: Name(2). Arguments are named ranges. Should use values from named ranges
		oParser = new parserFormula('ATAN2(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name(2). Arguments are named ranges. Should use values from named ranges');
		// Case #21: Name3D(2). Arguments are named ranges from another sheet
		oParser = new parserFormula('ATAN2(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name3D(2). Arguments are named ranges from another sheet');
		// Case #22: Table(2). Arguments are table references. Should use values from specified table cells
		oParser = new parserFormula('ATAN2(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Table(2). Arguments are table references. Should use values from specified table cells');
		// Case #23: Formula, Number. Date is converted to serial number (44927 for 01.01.2023) and used as a number
		oParser = new parserFormula('ATAN2(DATE(2023,1,1),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(DATE(2023,1,1),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000111292, 'Test: Positive case: Formula, Number. Date is converted to serial number (44927 for 01.01.2023) and used as a number');
		// Case #24: Formula(2). Time is converted to decimal part of day (0.5 for 12:00 and 0.25 for 6:00)
		oParser = new parserFormula('ATAN2(TIME(12,0,0),TIME(6,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TIME(12,0,0),TIME(6,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.463647609, 'Test: Positive case: Formula(2). Time is converted to decimal part of day (0.5 for 12:00 and 0.25 for 6:00)');
		// Case #25: Empty, Number. Empty first argument. Should use 0 and correctly calculate the result
		oParser = new parserFormula('ATAN2(,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Empty, Number. Empty first argument. Should use 0 and correctly calculate the result');
		// Case #26: Number, Empty. Empty second argument. Should use 0 and correctly calculate the result
		oParser = new parserFormula('ATAN2(1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Empty. Empty second argument. Should use 0 and correctly calculate the result');
		// Case #27: Boolean(2). Logical values as arguments. TRUE converts to 1, FALSE to 0. Should return #DIV/0! error due to second argument equal to 0
		oParser = new parserFormula('ATAN2(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean(2). Logical values as arguments. TRUE converts to 1, FALSE to 0. Should return #DIV/0! error due to second argument equal to 0');
		// Case #28: Number(2). Too large value for first argument.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#36
		/*oParser = new parserFormula('ATAN2(10^308,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(10^308,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Too large value for first argument.');*/
		// Case #29: Number(2). Too large value for second argument.
		oParser = new parserFormula('ATAN2(1,10^308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1,10^308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Positive case: Number(2). Too large value for second argument. May return #NUM! error or correctly calculate the result depending on Excel limitations');
		// Case #30: Name(2). One of arguments is Name with Area
		oParser = new parserFormula('ATAN2(TestNameArea2, TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TestNameArea2, TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name(2). One of arguments is Name with Area');
		// Case #31: Name(2). One of argument is Name with Area
		oParser = new parserFormula('ATAN2(TestName, TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TestName, TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name(2). One of argument is Name with Area');
		// Case #32: Name3D(2). One of argument is Name3D with Area
		oParser = new parserFormula('ATAN2(TestNameArea3D2, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TestNameArea3D2, TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name3D(2). One of argument is Name3D with Area');
		// Case #33: Name3D(2). One of argument is Name3D with Area
		oParser = new parserFormula('ATAN2(TestName3D, TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TestName3D, TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Name3D(2). One of argument is Name3D with Area');
		// Case #33: Array(2). Coordinates in array
		oParser = new parserFormula('ATAN2({1}, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2({1}, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 0.785398163, 'Test: Positive case: Array(2). Coordinates in array');

		// Negative cases:

		// Case #1: Number(2). Both arguments are zero. Should return #DIV/0! error
		oParser = new parserFormula('ATAN2(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Both arguments are zero. Should return #DIV/0! error');
		// Case #2: String, Number. Non-numeric text as argument. Should return #VALUE! error
		oParser = new parserFormula('ATAN2("text",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2("text",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric text as argument. Should return #VALUE! error');
		// Case #3: Error, Number. Error as argument. Should return the same error #DIV/0!
		oParser = new parserFormula('ATAN2(#DIV/0!,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(#DIV/0!,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error, Number. Error as argument. Should return the same error #DIV/0!');
		// Case #4: Empty(2). Both arguments are empty (equivalent to ATAN2(0,0)). Should return #DIV/0! error
		oParser = new parserFormula('ATAN2(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty(2). Both arguments are empty (equivalent to ATAN2(0,0)). Should return #DIV/0! error');
		// Case #5: String(2). Both arguments are non-numeric text. Should return #VALUE! error
		oParser = new parserFormula('ATAN2("text","number")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2("text","number") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Both arguments are non-numeric text. Should return #VALUE! error');
		// Case #6: Reference link(2). First reference contains non-numeric value. Should return #VALUE! error
		oParser = new parserFormula('ATAN2(A104,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(A104,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(2). First reference contains non-numeric value. Should return #VALUE! error');
		// Case #7: Area(2). Range contains both non-numeric values. Should return #VALUE! error
		oParser = new parserFormula('ATAN2(A104:B104,A104:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(A104:B104,A104:B104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2). Range contains both non-numeric values. Should return #VALUE! error');
		// Case #8: Ref3D(2). One of the references on another sheet contains an error. Should return the same error
		oParser = new parserFormula('ATAN2(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D(2). One of the references on another sheet contains an error. Should return the same error');
		// Case #9: Name(2). One of the named ranges contains a non-numeric value. Should return #VALUE! error
		oParser = new parserFormula('ATAN2(TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name(2). One of the named ranges contains a non-numeric value. Should return #VALUE! error');
		// Case #10: Name3D(2). One of the named ranges on another sheet contains an error. Should return the same error
		oParser = new parserFormula('ATAN2(TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D(2). One of the named ranges on another sheet contains an error. Should return the same error');
		// Case #11: Formula, Number. Division by zero in first argument. Should return #DIV/0! error
		oParser = new parserFormula('ATAN2(1/0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1/0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, Number. Division by zero in first argument. Should return #DIV/0! error');
		// Case #12: Number, Formula. Division by zero in second argument. Should return #DIV/0! error
		oParser = new parserFormula('ATAN2(1,1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1,1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Formula. Division by zero in second argument. Should return #DIV/0! error');

		// Bounded cases:

		// Case #1: Number. Maximum possible number in Excel for first argument. Should correctly calculate the result, close to π/2
		oParser = new parserFormula('ATAN2(1.79769E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1.79769E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.562694346633735e-308, 'Test: Bounded case: Number. Maximum possible number in Excel for first argument. Should correctly calculate the result, close to π/2');
		// Case #2: Number. Maximum possible number in Excel for second argument. Should correctly calculate the result, close to 0
		oParser = new parserFormula('ATAN2(1,1.79769E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1,1.79769E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Maximum possible number in Excel for second argument. Should correctly calculate the result, close to 0');
		// Case #3: Number. Minimum possible number in Excel for first argument. Should correctly calculate the result, close to π/2
		oParser = new parserFormula('ATAN2(-1.79769E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(-1.79769E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.141592654, 'Test: Bounded case: Number. Minimum possible number in Excel for first argument. Should correctly calculate the result, close to π/2');
		// Case #4: Number. Minimum possible number in Excel for second argument. Should correctly calculate the result, close to π
		oParser = new parserFormula('ATAN2(1,-1.79769E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1,-1.79769E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.570796327, 'Test: Bounded case: Number. Minimum possible number in Excel for second argument. Should correctly calculate the result, close to π');
		// Case #5: Number. Very small number for first argument, close to machine epsilon. Should correctly calculate the result, close to 0
		oParser = new parserFormula('ATAN2(2.2251E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(2.2251E-307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Very small number for first argument, close to machine epsilon. Should correctly calculate the result, close to 0');
		// Case #6: Number. Very small number for second argument, close to machine epsilon. Should correctly calculate the result, close to π/2
		oParser = new parserFormula('ATAN2(1,2.2251E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1,2.2251E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2251e-307, 'Test: Bounded case: Number. Very small number for second argument, close to machine epsilon. Should correctly calculate the result, close to π/2');
		// Case #7: Number. Maximum possible number for first argument and minimum possible for second. Large difference between arguments. Should correctly calculate the result, close to π/2
		oParser = new parserFormula('ATAN2(1.79769E+307,2.2251E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(1.79769E+307,2.2251E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum possible number for first argument and minimum possible for second. Large difference between arguments. Should correctly calculate the result, close to π/2');
		// Case #8: Number. Minimum possible number for first argument and maximum possible for second. Large difference between arguments. Should correctly calculate the result, close to 0
		oParser = new parserFormula('ATAN2(2.2251E-154,1.79769E+154)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATAN2(2.2251E-154,1.79769E+154) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.570796327, 'Test: Bounded case: Number. Minimum possible number for first argument and maximum possible for second. Large difference between arguments. Should correctly calculate the result, close to 0');


		testArrayFormula2(assert, "ATAN2", 2, 2);
	});

	QUnit.test("Test: \"ATANH\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("0.3");
		ws.getRange2("A102").setValue("");
		ws.getRange2("A103").setValue("Test");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("1.5");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("0.25"); // Column1
		ws.getRange2("B601").setValue("1.5"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.8");
		ws2.getRange2("A2").setValue("-0.8");
		ws2.getRange2("A3").setValue("1.2");
		ws2.getRange2("A4").setValue("Test");
		ws2.getRange2("A5").setValue("");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.4"); // TestName
		ws.getRange2("A202").setValue("2"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.6") // TestName3D
		ws2.getRange2("A12").setValue("-2") // TestName3D1

		// Positive cases:

		// Case #1: Number. Example from documentation.  X - 0.76159416
		oParser = new parserFormula('ATANH(0.76159416)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(0.76159416) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 1.00000001, 'Test: Positive case: Number. Example from documentation.  X - 0.76159416');
		// Case #2: Number. Example from documentation.  X - -0.1
		oParser = new parserFormula('ATANH(-0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(-0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.100335348, 'Test: Positive case: Number. Example from documentation.  X - -0.1');
		// Case #3: Number. Basic valid input: number between -1 and 1.
		oParser = new parserFormula('ATANH(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Number. Basic valid input: number between -1 and 1.');
		// Case #4: Number. Negative number in valid range.
		oParser = new parserFormula('ATANH(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.549306144, 'Test: Positive case: Number. Negative number in valid range.');
		// Case #5: Number. Zero as input.
		oParser = new parserFormula('ATANH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero as input.');
		// Case #6: String. String convertible to number.
		oParser = new parserFormula('ATANH("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: String. String convertible to number.');
		// Case #7: String. Negative number as string.
		oParser = new parserFormula('ATANH("-0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH("-0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.549306144, 'Test: Positive case: String. Negative number as string.');
		// Case #8: Formula. Nested formula returning valid number (0.5).
		oParser = new parserFormula('ATANH(SQRT(0.25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(SQRT(0.25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Formula. Nested formula returning valid number (0.5).');
		// Case #9: Formula. Trigonometric formula returning valid number (0.5).
		oParser = new parserFormula('ATANH(SIN(0.5236))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(SIN(0.5236)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549307558, 'Test: Positive case: Formula. Trigonometric formula returning valid number (0.5).');
		// Case #10: Reference link. Reference to cell with valid number (0.5).
		oParser = new parserFormula('ATANH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Reference link. Reference to cell with valid number (0.5).');
		// Case #11: Area. Single-cell range with valid number (0.3).
		oParser = new parserFormula('ATANH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.309519604, 'Test: Positive case: Area. Single-cell range with valid number (0.3).');
		// Case #12: Array. Array with single valid element.
		oParser = new parserFormula('ATANH({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Array. Array with single valid element.');
		// Case #13: Array. Array with two valid elements.
		oParser = new parserFormula('ATANH({0.5,0.7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH({0.5,0.7}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Array. Array with two valid elements.');
		// Case #14: Name. Named range with valid number (0.4).
		oParser = new parserFormula('ATANH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.42364893, 'Test: Positive case: Name. Named range with valid number (0.4).');
		// Case #15: Name3D. 3D named range with valid number (0.6).
		oParser = new parserFormula('ATANH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.693147181, 'Test: Positive case: Name3D. 3D named range with valid number (0.6).');
		// Case #16: Ref3D. 3D reference to cell with valid number (0.8).
		oParser = new parserFormula('ATANH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.098612289, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (0.8).');
		// Case #17: Area3D. 3D single-cell range with valid number (-0.8).
		oParser = new parserFormula('ATANH(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.098612289, 'Test: Positive case: Area3D. 3D single-cell range with valid number (-0.8).');
		// Case #18: Table. Table structured reference with valid number (0.25).
		oParser = new parserFormula('ATANH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.255412812, 'Test: Positive case: Table. Table structured reference with valid number (0.25).');
		// Case #19: Boolean. Boolean FALSE converts to 0.
		oParser = new parserFormula('ATANH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean. Boolean FALSE converts to 0.');
		// Case #20: Formula. ATANH used inside another formula.
		oParser = new parserFormula('SUM(ATANH(0.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(ATANH(0.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.549306144, 'Test: Positive case: Formula. ATANH used inside another formula.');
		// Case #21: Empty. Reference to empty cell (treated as 0).
		oParser = new parserFormula('ATANH(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty. Reference to empty cell (treated as 0).');
		// Case #22: Formula. Nested IF returning valid value.
		oParser = new parserFormula('ATANH(IF(TRUE,0.5,1.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(IF(TRUE,0.5,1.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Formula. Nested IF returning valid value.');
		// Case #23: Formula. Complex formula returning valid value.
		oParser = new parserFormula('ATANH((1-1/EXP(1))/(1+1/EXP(1)))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH((1-1/EXP(1))/(1+1/EXP(1))) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Formula. Complex formula returning valid value.');
		// Case #24: Formula. Date and time calculation resulting in -1<x<1.
		oParser = new parserFormula('ATANH(DATE(2022,1,2)-DATE(2022,1,1)-TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(DATE(2022,1,2)-DATE(2022,1,1)-TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Formula. Date and time calculation resulting in -1<x<1.');
		// Case #25: Formula. Statistical function as argument.
		oParser = new parserFormula('ATANH(AVERAGE({0.3,0.7}))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(AVERAGE({0.3,0.7})) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.549306144, 'Test: Positive case: Formula. Statistical function as argument.');
		// Case #26: Number. Very small positive number.
		oParser = new parserFormula('ATANH(0.0000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(0.0000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.000000082640371e-10, 'Test: Positive case: Number. Very small positive number.');
		// Case #27: Number. Very small negative number.
		oParser = new parserFormula('ATANH(-0.0000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(-0.0000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.000000082840371e-10, 'Test: Positive case: Number. Very small negative number.');

		// Negative cases:

		// Case #1: Number. Upper boundary (x=1) returns #NUM!.
		oParser = new parserFormula('ATANH(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Upper boundary (x=1) returns #NUM!.');
		// Case #2: Number. Lower boundary (x=-1) returns #NUM!.
		oParser = new parserFormula('ATANH(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Lower boundary (x=-1) returns #NUM!.');
		// Case #3: Number. Number > 1 returns #NUM!.
		oParser = new parserFormula('ATANH(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number > 1 returns #NUM!.');
		// Case #4: Number. Number < -1 returns #NUM!.
		oParser = new parserFormula('ATANH(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number < -1 returns #NUM!.');
		// Case #5: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('ATANH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #6: String. Empty string returns #VALUE!.
		oParser = new parserFormula('ATANH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #7: String. String convertible to invalid number (>1).
		oParser = new parserFormula('ATANH("1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH("1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to invalid number (>1).');
		// Case #8: String. String convertible to invalid number (<-1).
		oParser = new parserFormula('ATANH("-1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH("-1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to invalid number (<-1).');
		// Case #9: Boolean. Boolean TRUE converts to 1 (boundary case).
		oParser = new parserFormula('ATANH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean TRUE converts to 1 (boundary case).');
		// Case #10: Error. Error value propagates through.
		oParser = new parserFormula('ATANH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value propagates through.');
		// Case #11: Formula. Formula resulting in error.
		oParser = new parserFormula('ATANH(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in error.');
		// Case #12: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('ATANH(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #13: Array. Array with invalid element (>1).
		oParser = new parserFormula('ATANH({1.2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH({1.2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with invalid element (>1).');
		// Case #14: Array. Array with invalid elements.
		oParser = new parserFormula('ATANH({1,1.2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH({1,1.2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with invalid elements.');
		// Case #15: Reference link. Reference to cell with invalid number (1.5).
		oParser = new parserFormula('ATANH(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Reference to cell with invalid number (1.5).');
		// Case #16: Name. Named range with invalid value (2).
		oParser = new parserFormula('ATANH(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with invalid value (2).');
		// Case #17: Name3D. 3D named range with invalid value (-2).
		oParser = new parserFormula('ATANH(TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with invalid value (-2).');
		// Case #18: Ref3D. 3D reference to cell with invalid number (1.2).
		oParser = new parserFormula('ATANH(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to cell with invalid number (1.2).');
		// Case #19: Area3D. 3D multi-cell range.
		oParser = new parserFormula('ATANH(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range.');
		// Case #20: Table. Table reference with invalid value (1.5).
		oParser = new parserFormula('ATANH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table. Table reference with invalid value (1.5).');
		// Case #21: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('ATANH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #22: Formula. Formula resulting in value > 1.
		oParser = new parserFormula('ATANH(1+SMALL({0.1,0.2},1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(1+SMALL({0.1,0.2},1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in value > 1.');
		// Case #23: Formula. Nested formula with error.
		oParser = new parserFormula('ATANH(LN(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(LN(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula with error.');
		// Case #24: Formula. Nested IF returning invalid value.
		oParser = new parserFormula('ATANH(IF(TRUE,1.5,0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(IF(TRUE,1.5,0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid value.');
		// Case #25: Date. Date calculation resulting in value > 1.
		oParser = new parserFormula('ATANH(DATE(2022,1,3)-DATE(2022,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(DATE(2022,1,3)-DATE(2022,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date calculation resulting in value > 1.');

		// Bounded cases:

		// Case #1: Number. Very close to upper boundary (1).
		oParser = new parserFormula('ATANH(0.9999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(0.9999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 15.31322125, 'Test: Bounded case: Number. Very close to upper boundary (1).');
		// Case #2: Number. Very close to lower boundary (-1).
		oParser = new parserFormula('ATANH(-0.9999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(-0.9999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -15.31322125, 'Test: Bounded case: Number. Very close to lower boundary (-1).');
		// Case #3: Number. Close to upper boundary.
		oParser = new parserFormula('ATANH(0.9999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(0.9999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 8.405621391, 'Test: Bounded case: Number. Close to upper boundary.');
		// Case #4: Number. Close to lower boundary.
		oParser = new parserFormula('ATANH(-0.9999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(-0.9999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -8.405621391, 'Test: Bounded case: Number. Close to lower boundary.');
		// Case #5: Formula. Formula resulting in value very close to 1.
		oParser = new parserFormula('ATANH(1-1E-14)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(1-1E-14) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 16.46506904, 'Test: Bounded case: Formula. Formula resulting in value very close to 1.');
		// Case #6: Formula. Formula resulting in value very close to -1.
		oParser = new parserFormula('ATANH(-1+1E-14)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH(-1+1E-14) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -16.46506904, 'Test: Bounded case: Formula. Formula resulting in value very close to -1.');
		// Case #7: String. String of value near upper boundary.
		oParser = new parserFormula('ATANH("0.9999999999999")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH("0.9999999999999") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 15.31322125, 'Test: Bounded case: String. String of value near upper boundary.');
		// Case #8: String. String of value near lower boundary.
		oParser = new parserFormula('ATANH("-0.9999999999999")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ATANH("-0.9999999999999") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -15.31322125, 'Test: Bounded case: String. String of value near lower boundary.');

		testArrayFormula(assert, "ATANH");
	});

	QUnit.test("Test: \"BASE\"", function (assert) {

        ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("10");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("abc");
		ws.getRange2("A103").setValue("#N/A");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("10"); // Column1
		ws.getRange2("B601").setValue("4"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("10");
		ws2.getRange2("A2").setValue("abc");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("10"); // TestName
		ws.getRange2("A206").setValue("10"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("10") // TestName3D

		// Positive cases:

		// Case #1: Number(2). Example from documentation dec 7 to base binary. 2 of 3 arguments used.
		oParser = new parserFormula('BASE(7,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(7,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111', 'Test: Positive case: Number(2). Example from documentation dec 7 to base binary. 2 of 3 arguments used.');
		// Case #2: Number(2). Example from documentation dec 100 to base 16. 2 of 3 arguments used.
		oParser = new parserFormula('BASE(100,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(100,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '64', 'Test: Positive case: Number(2). Example from documentation dec 100 to base 16. 2 of 3 arguments used.');
		// Case #3: Number(3). Example from documentation dec 15 to base binary, with a len of 10. 3 of 3 arguments used.
		oParser = new parserFormula('BASE(15,2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(15,2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0000001111', 'Test: Positive case: Number(3). Example from documentation dec 15 to base binary, with a len of 10. 3 of 3 arguments used.');
		// Case #4: Number, Number. Basic valid input: number and radix. 2 arguments used.
		oParser = new parserFormula('BASE(10, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Number, Number. Basic valid input: number and radix. 2 arguments used.');
		// Case #5: Number, Number, Number. With min_length. 3 arguments used.
		oParser = new parserFormula('BASE(10, 2, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, 2, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '01010', 'Test: Positive case: Number, Number, Number. With min_length. 3 arguments used.');
		// Case #6: String, String. String inputs convertible to numbers. 2 arguments used.
		oParser = new parserFormula('BASE("10", "2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE("10", "2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: String, String. String inputs convertible to numbers. 2 arguments used.');
		// Case #7: String, String, String. String inputs for all arguments. 3 arguments used.
		oParser = new parserFormula('BASE("10", "2", "5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE("10", "2", "5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '01010', 'Test: Positive case: String, String, String. String inputs for all arguments. 3 arguments used.');
		// Case #8: Formula, Number. Formula for number. 2 arguments used.
		oParser = new parserFormula('BASE(SQRT(100), 16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(SQRT(100), 16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'A', 'Test: Positive case: Formula, Number. Formula for number. 2 arguments used.');
		// Case #9: Formula, Formula. Formulas for number and radix. 2 arguments used.
		oParser = new parserFormula('BASE(SQRT(100), SQRT(256))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(SQRT(100), SQRT(256)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'A', 'Test: Positive case: Formula, Formula. Formulas for number and radix. 2 arguments used.');
		// Case #10: Reference link, Number. Reference to cell with number. 2 arguments used.
		oParser = new parserFormula('BASE(A100, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(A100, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Reference link, Number. Reference to cell with number. 2 arguments used.');
		// Case #11: Reference link, Reference link. References for number and radix. 2 arguments used.
		oParser = new parserFormula('BASE(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Reference link, Reference link. References for number and radix. 2 arguments used.');
		// Case #12: Area, Number. Single-cell area for number. 2 arguments used.
		oParser = new parserFormula('BASE(A101:A101, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(A101:A101, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '10', 'Test: Positive case: Area, Number. Single-cell area for number. 2 arguments used.');
		// Case #13: Area, Area. Single-cell areas for number and radix. 2 arguments used.
		oParser = new parserFormula('BASE(A100:A100, A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(A100:A100, A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Area, Area. Single-cell areas for number and radix. 2 arguments used.');
		// Case #14: Array, Number. Array with single element for number. 2 arguments used.
		oParser = new parserFormula('BASE({10}, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE({10}, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '1010', 'Test: Positive case: Array, Number. Array with single element for number. 2 arguments used.');
		// Case #15: Array, Array. Arrays for number and radix. 2 arguments used.
		oParser = new parserFormula('BASE({10}, {2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE({10}, {2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '1010', 'Test: Positive case: Array, Array. Arrays for number and radix. 2 arguments used.');
		// Case #16: Name, Number. Name reference for number. 2 arguments used.
		oParser = new parserFormula('BASE(TestName, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(TestName, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Name, Number. Name reference for number. 2 arguments used.');
		// Case #17: Name3D, Number. Name3D reference for number. 2 arguments used.
		oParser = new parserFormula('BASE(TestName3D, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(TestName3D, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Name3D, Number. Name3D reference for number. 2 arguments used.');
		// Case #18: Ref3D, Number. Ref3D reference for number. 2 arguments used.
		oParser = new parserFormula('BASE(Sheet2!A1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(Sheet2!A1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Ref3D, Number. Ref3D reference for number. 2 arguments used.');
		// Case #19: Area3D, Number. Area3D reference for number. 2 arguments used.
		oParser = new parserFormula('BASE(Sheet2!A1:A1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(Sheet2!A1:A1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Area3D, Number. Area3D reference for number. 2 arguments used.');
		// Case #20: Table, Number. Table reference for number. 2 arguments used.
		oParser = new parserFormula('BASE(Table1[Column1], 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(Table1[Column1], 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Table, Number. Table reference for number. 2 arguments used.');
		// Case #21: Table, Table. Table references for number and radix. 2 arguments used.
		oParser = new parserFormula('BASE(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '22', 'Test: Positive case: Table, Table. Table references for number and radix. 2 arguments used.');
		// Case #22: Formula, Number. Date serial number for number. 2 arguments used.
		oParser = new parserFormula('BASE(DATE(2025,1,1), 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(DATE(2025,1,1), 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '45658', 'Test: Positive case: Formula, Number. Date serial number for number. 2 arguments used.');
		// Case #24: Formula. BASE inside another formula. 2 arguments used for BASE.
		oParser = new parserFormula('SUM(LEN(BASE(10,2)),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(LEN(BASE(10,2)),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. BASE inside another formula. 2 arguments used for BASE.');
		// Case #25: Area, Number. Multi-cell area for number.  2 arguments used.
		oParser = new parserFormula('BASE(A100:A101, 2)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BASE(A100:A101, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '1010', 'Test: Positive case: Area, Number. Multi-cell area for number.  2 arguments used.');
		// Case #26: Name, Number. Name with area for number.  2 arguments used.
		oParser = new parserFormula('BASE(TestNameArea, 2)', 'A2', ws);
         oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BASE(TestNameArea, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '1010', 'Test: Positive case: Name, Number. Name with area for number.  2 arguments used.');

		// Negative cases:

		// Case #1: Number, Number. Negative number for number. #NUM! error. 2 arguments used.
		oParser = new parserFormula('BASE(-1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(-1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative number for number. #NUM! error. 2 arguments used.');
		// Case #1: Number, Number. Radix less than 2. #NUM! error. 2 arguments used.
		oParser = new parserFormula('BASE(10, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Radix less than 2. #NUM! error. 2 arguments used.');
		// Case #2: Number, Number. Radix greater than 36. #NUM! error. 2 arguments used.
		oParser = new parserFormula('BASE(10, 37)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, 37) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Radix greater than 36. #NUM! error. 2 arguments used.');
		// Case #3: Number, Number, Number. Negative min_length. #NUM! error. 3 arguments used.
		oParser = new parserFormula('BASE(10, 2, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, 2, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number. Negative min_length. #NUM! error. 3 arguments used.');
		// Case #4: String, Number. Non-numeric string for number. #VALUE! error. 2 arguments used.
		oParser = new parserFormula('BASE("abc", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE("abc", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string for number. #VALUE! error. 2 arguments used.');
		// Case #5: Number, String. Non-numeric string for radix. #VALUE! error. 2 arguments used.
		oParser = new parserFormula('BASE(10, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for radix. #VALUE! error. 2 arguments used.');
		// Case #6: Error, Number. Error value for number. #N/A error. 2 arguments used.
		oParser = new parserFormula('BASE(NA(), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(NA(), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error value for number. #N/A error. 2 arguments used.');
		// Case #7: Number, Error. Error value for radix. #N/A error. 2 arguments used.
		oParser = new parserFormula('BASE(10, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error value for radix. #N/A error. 2 arguments used.');
		// Case #8: Reference link, Number. Reference to cell with text. #VALUE! error. 2 arguments used.
		oParser = new parserFormula('BASE(A102, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(A102, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to cell with text. #VALUE! error. 2 arguments used.');
		// Case #9: Ref3D, Number. Ref3D to cell with text. #VALUE! error. 2 arguments used.
		oParser = new parserFormula('BASE(Sheet2!A2, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(Sheet2!A2, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Number. Ref3D to cell with text. #VALUE! error. 2 arguments used.');
		// Case #10: Array, Number. Array with negative number. #NUM! error. 2 arguments used.
		oParser = new parserFormula('BASE({-1,0}, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE({-1,0}, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#NUM!', 'Test: Negative case: Array, Number. Array with negative number. #NUM! error. 2 arguments used.');
		// Case #11: Number, Number. Number too large. #NUM! error. 2 arguments used.
		oParser = new parserFormula('BASE(2^53, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(2^53, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Number too large. #NUM! error. 2 arguments used.');
		// Case #12: Number, Number. Radix too large. #NUM! error. 2 arguments used.
		oParser = new parserFormula('BASE(10, 37)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, 37) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Radix too large. #NUM! error. 2 arguments used.');
		// Case #13: Number, Number. Negative  number. #NUM! error. 2 arguments used.
		oParser = new parserFormula('BASE(-1, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(-1, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative  number. #NUM! error. 2 arguments used.');
		// Case #14: Number, Number. Negative double number. #NUM! error. 2 arguments used.
		oParser = new parserFormula('BASE(-0.5, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(-0.5, 10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative double number. #NUM! error. 2 arguments used.');
		// Case #15: Formula, Number. Formula resulting in error. #NUM! error. 2 arguments used.
		oParser = new parserFormula('BASE(SQRT(-1), 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(SQRT(-1), 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in error. #NUM! error. 2 arguments used.');
		// Case #16: Reference link, Number. Reference to error value. #N/A error. 2 arguments used.
		oParser = new parserFormula('BASE(A103, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(A103, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link, Number. Reference to error value. #N/A error. 2 arguments used.');
		// Case #17: Array, Number. Array with text. #VALUE! error. 2 arguments used.
		oParser = new parserFormula('BASE({"abc"}, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE({"abc"}, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#VALUE!', 'Test: Negative case: Array, Number. Array with text. #VALUE! error. 2 arguments used.');

		// Bounded cases:

		// Case #1: Number, Number. Minimum number. 2 arguments used.
		oParser = new parserFormula('BASE(0, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(0, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number, Number. Minimum number. 2 arguments used.');
		// Case #2: Number, Number. Maximum number. 2 arguments used.
		oParser = new parserFormula('BASE(2^53-1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(2^53-1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11111111111111111111111111111111111111111111111111111', 'Test: Bounded case: Number, Number. Maximum number. 2 arguments used.');
		// Case #3: Number, Number. Minimum radix. 2 arguments used.
		oParser = new parserFormula('BASE(1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number, Number. Minimum radix. 2 arguments used.');
		// Case #4: Number, Number. Maximum radix. 2 arguments used.
		oParser = new parserFormula('BASE(35, 36)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(35, 36) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'Z', 'Test: Bounded case: Number, Number. Maximum radix. 2 arguments used.');
		// Case #5: Number, Number, Number. Minimum min_length. 3 arguments used.
		oParser = new parserFormula('BASE(10, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Bounded case: Number, Number, Number. Minimum min_length. 3 arguments used.');
		// Case #6: Number, Number, Number. Large min_length. 3 arguments used.
		oParser = new parserFormula('BASE(10, 2, 255)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BASE(10, 2, 255) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010', 'Test: Bounded case: Number, Number, Number. Large min_length. 3 arguments used.');

        // Need to fix:
        // Case #11: Number, Number. Number too large. #NUM! error. 2 arguments used.
        // Case #14: Number, Number. Negative double number. #NUM! error. 2 arguments used.

		testArrayFormula2(assert, "BASE", 2, 3);
	});

	QUnit.test("Test: \"CEILING\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2.5");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A102").setValue("-2.5");
		ws.getRange2("A103").setValue("-2");
		ws.getRange2("A104").setValue("2");
		ws.getRange2("A105").setValue("text");
		ws.getRange2("A106").setValue("#N/A");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.5"); // Column1
		ws.getRange2("B601").setValue("0.1"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.234");
		ws2.getRange2("A2").setValue("0.01");
		ws2.getRange2("A3").setValue("2.5");
		ws2.getRange2("A4").setValue("1");
		ws2.getRange2("A5").setValue("text");
		ws2.getRange2("A6").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1.5"); // TestName
		ws.getRange2("A202").setValue("0.1"); // TestName1
		ws.getRange2("A206").setValue("text"); // TestNameArea
		ws.getRange2("A207").setValue("#N/A"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1.5") // TestName3D
		ws2.getRange2("A12").setValue("1") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Rounds 2.5 up to nearest multiple of 1
		oParser = new parserFormula('CEILING(2.5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2). Rounds 2.5 up to nearest multiple of 1');
		// Case #2: Number(2). Rounds -2.5 up to nearest multiple of -2
		oParser = new parserFormula('CEILING(-2.5,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(-2.5,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number(2). Rounds -2.5 up to nearest multiple of -2');
		// Case #3: Number(2). Rounds -2.5 up to nearest multiple of 2
		oParser = new parserFormula('CEILING(-2.5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(-2.5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Number(2). Rounds -2.5 up to nearest multiple of 2');
		// Case #4: Number(2). Rounds 1.5 up to the nearest multiple of 0.1
		oParser = new parserFormula('CEILING(1.5,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1.5,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1.5, 'Test: Positive case: Number(2). Rounds 1.5 up to the nearest multiple of 0.1');
		// Case #5: Number(2). Rounds 0.234 up to the nearest multiple of 0.01
		oParser = new parserFormula('CEILING(0.234,0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(0.234,0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.24, 'Test: Positive case: Number(2). Rounds 0.234 up to the nearest multiple of 0.01');
		// Case #6: Number(2). Basic usage with integer significance. Rounds up to nearest integer multiple of 1.
		oParser = new parserFormula('CEILING(2.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2). Basic usage with integer significance. Rounds up to nearest integer multiple of 1.');
		// Case #7: Number(2). Significance > 1. Rounds up to nearest multiple of 2 (result is 4).
		oParser = new parserFormula('CEILING(2.5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Number(2). Significance > 1. Rounds up to nearest multiple of 2 (result is 4).');
		// Case #8: Number(2). Negative number with negative significance. Both arguments must have same sign.
		oParser = new parserFormula('CEILING(-2.5, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(-2.5, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number(2). Negative number with negative significance. Both arguments must have same sign.');
		// Case #9: Number(2). Decimal significance < 1. Rounds up to nearest multiple of 0.1.
		oParser = new parserFormula('CEILING(4.5, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(4.5, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 4.5, 'Test: Positive case: Number(2). Decimal significance < 1. Rounds up to nearest multiple of 0.1.');
		// Case #10: Number(2). Negative number with negative decimal significance < 1.
		oParser = new parserFormula('CEILING(-4.5, -0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(-4.5, -0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, -4.5, 'Test: Positive case: Number(2). Negative number with negative decimal significance < 1.');
		// Case #11: Number(2). Zero with positive significance returns 0.
		oParser = new parserFormula('CEILING(0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero with positive significance returns 0.');
		// Case #12: Number(2). Zero with negative significance returns 0.
		oParser = new parserFormula('CEILING(0, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(0, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero with negative significance returns 0.');
		// Case #13: Number(2). Zero with zero significance returns 0 (special case).
		oParser = new parserFormula('CEILING(0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero with zero significance returns 0 (special case).');
		// Case #14: Number, Empty. Omitted significance defaults to 1 (result is 3).
		oParser = new parserFormula('CEILING(2.5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Empty. Omitted significance defaults to 1 (result is 3).');
		// Case #15: String(2). String numbers converted to numeric values.
		oParser = new parserFormula('CEILING("2.5", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING("2.5", "1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String(2). String numbers converted to numeric values.');
		// Case #16: Formula(2). Using math formulas as arguments (both < 1).
		oParser = new parserFormula('CEILING(SIN(PI()/4), COS(PI()/4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(SIN(PI()/4), COS(PI()/4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.707106781, 'Test: Positive case: Formula(2). Using math formulas as arguments (both < 1).');
		// Case #17: Formula. CEILING nested inside another formula (result is 13).
		oParser = new parserFormula('SUM(CEILING(2.5, 1), 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CEILING(2.5, 1), 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Positive case: Formula. CEILING nested inside another formula (result is 13).');
		// Case #18: Reference link(2). Both arguments are cell references.
		oParser = new parserFormula('CEILING(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Reference link(2). Both arguments are cell references.');
		// Case #19: Area(2). Both arguments are single-cell areas.
		oParser = new parserFormula('CEILING(A102:A102, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(A102:A102, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Area(2). Both arguments are single-cell areas.');
		// Case #20: Array(2). Both arguments are single-element arrays.
		oParser = new parserFormula('CEILING({2.5}, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING({2.5}, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 3, 'Test: Positive case: Array(2). Both arguments are single-element arrays.');
		// Case #21: Name(2). Both arguments are named ranges.
		oParser = new parserFormula('CEILING(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1.5, 'Test: Positive case: Name(2). Both arguments are named ranges.');
		// Case #22: Name3D(2). Both arguments are 3D named ranges.
		oParser = new parserFormula('CEILING(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Name3D(2). Both arguments are 3D named ranges.');
		// Case #23: Ref3D(2). Both arguments are 3D references.
		oParser = new parserFormula('CEILING(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.24, 'Test: Positive case: Ref3D(2). Both arguments are 3D references.');
		// Case #24: Area3D(2). Both arguments are 3D single-cell areas.
		oParser = new parserFormula('CEILING(Sheet2!A1:A1, Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(Sheet2!A1:A1, Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.24, 'Test: Positive case: Area3D(2). Both arguments are 3D single-cell areas.');
		// Case #25: Table. Both arguments are table references.
		oParser = new parserFormula('CEILING(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1.5, 'Test: Positive case: Table. Both arguments are table references.');
		// Case #26: Array, Number. Multi-element array returns array of results.
		oParser = new parserFormula('CEILING({1,2}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING({1,2}, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, 'Test: Positive case: Array, Number. Multi-element array returns array of results.');
		// Case #27: Number, Array. Multi-element array for significance returns array of results.
		oParser = new parserFormula('CEILING(1, {1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1, {1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, 'Test: Positive case: Number, Array. Multi-element array for significance returns array of results.');
		// Case #28: Date, Number. Date serial number with integer significance.
		oParser = new parserFormula('CEILING(DATE(2023,5,15), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(DATE(2023,5,15), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45061, 'Test: Positive case: Date, Number. Date serial number with integer significance.');
		// Case #29: Time, Number. Time serial number with fractional significance.
		oParser = new parserFormula('CEILING(TIME(12,30,0), 0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(TIME(12,30,0), 0.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.75, 'Test: Positive case: Time, Number. Time serial number with fractional significance.');
		// Case #30: Number(2). Larger number with small significance (precision test).
		oParser = new parserFormula('CEILING(123.45, 0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(123.45, 0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 123.45, 'Test: Positive case: Number(2). Larger number with small significance (precision test).');
		// Case #31: Number(2). Significance that doesn\'t divide evenly (result is 0.666).
		oParser = new parserFormula('CEILING(0.5, 0.333)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(0.5, 0.333) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.666, 'Test: Positive case: Number(2). Significance that doesn\'t divide evenly (result is 0.666).');
		// Case #32: Number(2). Number very close to next integer (result is 5).
		oParser = new parserFormula('CEILING(4.999, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(4.999, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number(2). Number very close to next integer (result is 5).');
		// Case #33: Number(2). Large number with small significance (result is 1000000).
		oParser = new parserFormula('CEILING(1000000, 0.001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1000000, 0.001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000000, 'Test: Positive case: Number(2). Large number with small significance (result is 1000000).');
		// Case #34: Number(2). Large negative number with small negative significance.
		oParser = new parserFormula('CEILING(-1000000, -0.001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(-1000000, -0.001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1000000, 'Test: Positive case: Number(2). Large negative number with small negative significance.');
		// Case #35: Number(2). Very small significance value (result is 2.100001).
		oParser = new parserFormula('CEILING(2.1, 0.000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.1, 0.000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 2.1, 'Test: Positive case: Number(2). Very small significance value (result is 2.100001).');
		// Case #36: Number(2). Negative number with positive significance.
		oParser = new parserFormula('CEILING(-2.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(-2.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Number(2). Negative number with positive significance.');
		// Case #37: Number(2). Non-zero number with zero significance.
		oParser = new parserFormula('CEILING(2.5, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Non-zero number with zero significance.');
		// Case #38: Number, Boolean. Boolean FALSE=0 for significance.
		oParser = new parserFormula('CEILING(2.5, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Boolean. Boolean FALSE=0 for significance.');
		// Case #39: Empty, Number. Empty first argument.
		oParser = new parserFormula('CEILING(, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number. Empty first argument.');
		// Case #40: Number, Empty. Second argument is empty.
		oParser = new parserFormula('CEILING(1, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Empty. Second argument is empty.');

		// Negative cases:

		// Case #1: Number(2). #NUM! error: Positive number with negative significance.
		oParser = new parserFormula('CEILING(2.5, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). #NUM! error: Positive number with negative significance.');
		// Case #2: Number(2). #NUM! error: Opposing signs with large numbers.
		oParser = new parserFormula('CEILING(1E+100, -1E+100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1E+100, -1E+100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). #NUM! error: Opposing signs with large numbers.');
		// Case #3: Formula, Number. #NUM! error: Formula resulting in error propagates.
		oParser = new parserFormula('CEILING(SQRT(-1), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(SQRT(-1), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. #NUM! error: Formula resulting in error propagates.');
		// Case #4: Number, Formula. #NUM! error: Error in significance formula propagates.
		oParser = new parserFormula('CEILING(2.5, SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5, SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. #NUM! error: Error in significance formula propagates.');
		// Case #5: String(2). #VALUE! error: Non-numeric string in first argument.
		oParser = new parserFormula('CEILING("abc", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING("abc", "1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). #VALUE! error: Non-numeric string in first argument.');
		// Case #6: String(2). #VALUE! error: Non-numeric string in second argument.
		oParser = new parserFormula('CEILING("2.5", "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING("2.5", "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). #VALUE! error: Non-numeric string in second argument.');
		// Case #7: Number, String. #VALUE! error: Text significance that cannot be converted.
		oParser = new parserFormula('CEILING(2.5, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. #VALUE! error: Text significance that cannot be converted.');
		// Case #8: Area, Number. #VALUE! error: Multi-cell range in first argument with text and error.
		oParser = new parserFormula('CEILING(A105:A106, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(A105:A106, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. #VALUE! error: Multi-cell range in first argument with text and error.');
		// Case #9: Number, Area. #VALUE! error: Multi-cell range in second argument with text and error.
		oParser = new parserFormula('CEILING(1, A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1, A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. #VALUE! error: Multi-cell range in second argument with text and error.');
		// Case #10: Area3D, Number. #VALUE! error: 3D multi-cell range in first argument with text and error
		oParser = new parserFormula('CEILING(Sheet2!A5:A6, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(Sheet2!A5:A6, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number. #VALUE! error: 3D multi-cell range in first argument with text and error');
		// Case #11: Number, Area3D. #VALUE! error: 3D multi-cell range in second argument with text and error
		oParser = new parserFormula('CEILING(1, Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1, Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D. #VALUE! error: 3D multi-cell range in second argument with text and error');
		// Case #12: Name, Number. #VALUE! error: Named range with multiple cells in first argument with text and error.
		oParser = new parserFormula('CEILING(TestNameArea, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(TestNameArea, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number. #VALUE! error: Named range with multiple cells in first argument with text and error.');
		// Case #13: Number, Name. #VALUE! error: Named range with multiple cells in second argument.
		oParser = new parserFormula('CEILING(1, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1, TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name. #VALUE! error: Named range with multiple cells in second argument.');
		// Case #14: Error, Number. #N/A error: Error value in first argument propagates.
		oParser = new parserFormula('CEILING(NA(), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(NA(), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. #N/A error: Error value in first argument propagates.');
		// Case #15: Number, Error. #N/A error: Error in second argument propagates.
		oParser = new parserFormula('CEILING(2.5, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(2.5, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. #N/A error: Error in second argument propagates.');
		// Case #16: String, Number. #VALUE! error: String representing invalid formula.
		oParser = new parserFormula('CEILING("0/1", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING("0/1", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. #VALUE! error: String representing invalid formula.');
		// Case #17: Number(2). Potential overflow with number close to maximum limit.
		oParser = new parserFormula('CEILING(9.99999E+307, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(9.99999E+307, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Potential overflow with number close to maximum limit.');

		// Bounded cases:

		// Case #1: Number(2). Minimum case where number equals significance (integer).
		oParser = new parserFormula('CEILING(1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Minimum case where number equals significance (integer).');
		// Case #2: Number(2). Minimum positive number with equal significance.
		oParser = new parserFormula('CEILING(0.000000001, 0.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(0.000000001, 0.000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-9, 'Test: Bounded case: Number(2). Minimum positive number with equal significance.');
		// Case #3: Number(2). Maximum negative number with equal significance.
		oParser = new parserFormula('CEILING(-0.000000001, -0.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(-0.000000001, -0.000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-9, 'Test: Bounded case: Number(2). Maximum negative number with equal significance.');
		// Case #4: Number(2). Maximum positive number Excel can handle.
		oParser = new parserFormula('CEILING(1.79769E+307, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1.79769E+307, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.79769e+307, 'Test: Bounded case: Number(2). Maximum positive number Excel can handle.');
		// Case #5: Number(2). Minimum negative number Excel can handle.
		oParser = new parserFormula('CEILING(-1.79769E+307, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(-1.79769E+307, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.79769e+307, 'Test: Bounded case: Number(2). Minimum negative number Excel can handle.');
		// Case #6: Number(2). Very large number with small significance.
		oParser = new parserFormula('CEILING(9.99999999999999E+306, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(9.99999999999999E+306, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.999999999999991e+306, 'Test: Bounded case: Number(2). Very large number with small significance.');
		// Case #7: Number(2). Very small positive number with equal significance.
		oParser = new parserFormula('CEILING(1E-307, 1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(1E-307, 1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number(2). Very small positive number with equal significance.');
		// Case #8: Number(2). Very small negative number with equal significance.
		oParser = new parserFormula('CEILING(-1E-307, -1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING(-1E-307, -1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-307, 'Test: Bounded case: Number(2). Very small negative number with equal significance.');


		testArrayFormula2(assert, "CEILING", 2, 2);
	});

	QUnit.test("Test: \"CEILING.MATH\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("");
		ws.getRange2("A101").setValue("-5.5");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("-1");
		ws.getRange2("A104").setValue("text");
		ws.getRange2("A105").setValue("#N/A");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("-5.5"); // Column1
		ws.getRange2("B601").setValue("2"); // Column2
		ws.getRange2("C601").setValue("-1"); // Column3
		ws.getRange2("D601").setValue("test"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("-5.5");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("-1");
		ws2.getRange2("A4").setValue("text");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("-5.5"); // TestName
		ws.getRange2("A202").setValue("2"); // TestName1
		ws.getRange2("A203").setValue("-1"); // TestName2
		ws.getRange2("A206").setValue("text"); // TestNameArea
		ws.getRange2("A207").setValue("#N/A"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("-5.5") // TestName3D
		ws2.getRange2("A12").setValue("2") // TestName3D1
		ws2.getRange2("A13").setValue("-1") // TestName3D2

		// Positive cases:

		// Case #1: Number(2). Rounds 24.3 up to the nearest integer that is a multiple of 5.
		oParser = new parserFormula('CEILING.MATH(24.3, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(24.3, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number(2). Rounds 24.3 up to the nearest integer that is a multiple of 5.');
		// Case #2: Number. Rounds 6.7 up to the nearest integer.
		oParser = new parserFormula('CEILING.MATH(6.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(6.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Number. Rounds 6.7 up to the nearest integer.');
		// Case #3: Number(2). Rounds -8.1 up (toward 0) to the nearest integer that is a multiple of 2.
		oParser = new parserFormula('CEILING.MATH(-8.1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(-8.1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -8, 'Test: Positive case: Number(2). Rounds -8.1 up (toward 0) to the nearest integer that is a multiple of 2.');
		// Case #4: Number(3). Rounds -5.5 down (away from 0) to the nearest integer that is a multiple of 2 with a mode of -1 which reverses rounding direction.
		oParser = new parserFormula('CEILING.MATH(-5.5, 2, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(-5.5, 2, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6, 'Test: Positive case: Number(3). Rounds -5.5 down (away from 0) to the nearest integer that is a multiple of 2 with a mode of -1 which reverses rounding direction.');
		// Case #5: Number. Rounds a positive float number up to the nearest integer. Significance and mode are default.
		oParser = new parserFormula('CEILING.MATH(7.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(7.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Number. Rounds a positive float number up to the nearest integer. Significance and mode are default.');
		// Case #6: Number(2). Rounds a positive number up to the nearest multiple of significance (2).
		oParser = new parserFormula('CEILING.MATH(7.7, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(7.7, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Number(2). Rounds a positive number up to the nearest multiple of significance (2).');
		// Case #7: Number, String. Significance is a numeric string "1", which is converted to a number.
		oParser = new parserFormula('CEILING.MATH(2.4, "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(2.4, "1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number, String. Significance is a numeric string "1", which is converted to a number.');
		// Case #8: String(3). Both number and significance are numeric strings that are converted to numbers.
		oParser = new parserFormula('CEILING.MATH("8.1", "3", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH("8.1", "3", "1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: String(3). Both number and significance are numeric strings that are converted to numbers.');
		// Case #9: Number. Rounds a negative number. By default, it rounds towards zero (-5).
		oParser = new parserFormula('CEILING.MATH(-5.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(-5.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -5, 'Test: Positive case: Number. Rounds a negative number. By default, it rounds towards zero (-5).');
		// Case #10: Number(2). Rounds a negative number away from zero (-6) when significance is negative.
		oParser = new parserFormula('CEILING.MATH(-5.7, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(-5.7, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -5, 'Test: Positive case: Number(2). Rounds a negative number away from zero (-6) when significance is negative.');
		// Case #11: Number(3). Rounds a negative number away from zero (-6) using mode argument (non-zero value).
		oParser = new parserFormula('CEILING.MATH(-5.7, 1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(-5.7, 1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6, 'Test: Positive case: Number(3). Rounds a negative number away from zero (-6) using mode argument (non-zero value).');
		// Case #12: Number(3). Mode argument does not affect the rounding of positive numbers.
		oParser = new parserFormula('CEILING.MATH(5.7, 1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(5.7, 1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(3). Mode argument does not affect the rounding of positive numbers.');
		// Case #13: Number(2). If significance is 0, the function returns 0.
		oParser = new parserFormula('CEILING.MATH(10, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(10, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). If significance is 0, the function returns 0.');
		// Case #14: Formula. The number argument is a nested formula.
		oParser = new parserFormula('CEILING.MATH(SUM(2.1, 3.2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(SUM(2.1, 3.2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. The number argument is a nested formula.');
		// Case #15: Number, Formula. The significance argument is a nested formula.
		oParser = new parserFormula('CEILING.MATH(10,ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(10,ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number, Formula. The significance argument is a nested formula.');
		// Case #16: Reference link. Reference to an empty cell, which is treated as 0.
		oParser = new parserFormula('CEILING.MATH(A100, A100, A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(A100, A100, A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to an empty cell, which is treated as 0.');
		// Case #17: Reference link. Reference to a cell with a positive number.
		oParser = new parserFormula('CEILING.MATH(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -5, 'Test: Positive case: Reference link. Reference to a cell with a positive number.');
		// Case #18: Reference link(3). Both arguments are references to cells.
		oParser = new parserFormula('CEILING.MATH(A101, A102, A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(A101, A102, A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6, 'Test: Positive case: Reference link(3). Both arguments are references to cells.');
		// Case #19: Area(3). Reference to a single-cell area.
		oParser = new parserFormula('CEILING.MATH(A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6, 'Test: Positive case: Area(3). Reference to a single-cell area.');
		// Case #20: Formula. CEILING.MATH is used as part of a larger formula.
		oParser = new parserFormula('CEILING.MATH(0.99)*10', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(0.99)*10 is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. CEILING.MATH is used as part of a larger formula.');
		// Case #21: Name(3). Argument is a named range (TestName -> 7.3).
		oParser = new parserFormula('CEILING.MATH(TestName, TestName1, TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(TestName, TestName1, TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6, 'Test: Positive case: Name(3). Argument is a named range (TestName -> 7.3).');
		// Case #22: Ref3D(3). Reference to a cell on another sheet.
		oParser = new parserFormula('CEILING.MATH(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6, 'Test: Positive case: Ref3D(3). Reference to a cell on another sheet.');
		// Case #23: Area3D(3). Reference to a multi-cell area on another sheet. Uses implicit intersection.
		oParser = new parserFormula('CEILING.MATH(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6, 'Test: Positive case: Area3D(3). Reference to a multi-cell area on another sheet. Uses implicit intersection.');
		// Case #24: Name3D(3). Argument is a named range on another sheet (TestName3D -> -1.5).
		oParser = new parserFormula('CEILING.MATH(TestName3D,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(TestName3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6, 'Test: Positive case: Name3D(3). Argument is a named range on another sheet (TestName3D -> -1.5).');
		// Case #25: Table(3). Reference to a value within a table column.
		oParser = new parserFormula('CEILING.MATH(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6, 'Test: Positive case: Table(3). Reference to a value within a table column.');
		// Case #26: Number. Number is an exact multiple of significance, no rounding needed.
		oParser = new parserFormula('CEILING.MATH(6,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(6,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number. Number is an exact multiple of significance, no rounding needed.');
		// Case #27: Array(3). Array for all arguments.
		oParser = new parserFormula('CEILING.MATH({5.7};{1};{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH({5.7};{1};{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 6, 'Test: Positive case: Array(3). Array for all arguments.');
		// Case #28: Boolean. Boolean values converted to numbers
		oParser = new parserFormula('CEILING.MATH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean. Boolean values converted to numbers');
		// Case #29: Formula. Using a Date type will convert it to its serial number, but this can be an unintended use case leading to logical errors. Considered negative as it\'s not the primary function design.
		oParser = new parserFormula('CEILING.MATH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Formula. Using a Date type will convert it to its serial number, but this can be an unintended use case leading to logical errors. Considered negative as it\'s not the primary function design.');
		// Case #30: Number(2). Number is positive and significance is negative.
		oParser = new parserFormula('CEILING.MATH(5, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(5, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number(2). Number is positive and significance is negative.');
		// Case #31: Number(2). Positive number and negative significance.
		oParser = new parserFormula('CEILING.MATH(5.7, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(5.7, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(2). Positive number and negative significance.');
		// Case #32: Area. Multi-cell area reference.
		oParser = new parserFormula('CEILING.MATH(A101:A102)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(A101:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -5, 'Test: Positive case: Area. Multi-cell area reference.');
        //? assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 2, 'Test: Positive case: Area. Multi-cell area reference.');

		// Negative cases:

		// Case #1: String. Number argument is a non-numeric string.
		oParser = new parserFormula('CEILING.MATH("text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH("text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Number argument is a non-numeric string.');
		// Case #2: Number, String. Significance argument is a non-numeric string.
		oParser = new parserFormula('CEILING.MATH(10, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(10, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Significance argument is a non-numeric string.');
		// Case #3: Number(2), String. Mode argument is a non-numeric string.
		oParser = new parserFormula('CEILING.MATH(10, 1, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(10, 1, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String. Mode argument is a non-numeric string.');
		// Case #4: Error. Propagates #N/A error from input.
		oParser = new parserFormula('CEILING.MATH(#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error from input.');
		// Case #5: Formula. Propagates #DIV/0! error from a nested formula.
		oParser = new parserFormula('CEILING.MATH(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Propagates #DIV/0! error from a nested formula.');
		// Case #6: Reference link. Reference to a cell containing text.
		oParser = new parserFormula('CEILING.MATH(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to a cell containing text.');
		// Case #7: Name. Named range refers to a multi-cell area, causing a #VALUE! error in older Excel versions or spill in new ones.
		oParser = new parserFormula('CEILING.MATH(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range refers to a multi-cell area, causing a #VALUE! error in older Excel versions or spill in new ones.');
		// Case #8: Area. Multi-cell area reference with text and error.
		oParser = new parserFormula('CEILING.MATH(A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area.Multi-cell area reference with text and error.');
		// Case #9: Ref3D. Reference to a cell containing text on another sheet.
		oParser = new parserFormula('CEILING.MATH(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. Reference to a cell containing text on another sheet.');
		// Case #10: Error. Propagates #VALUE! error.
		oParser = new parserFormula('CEILING.MATH(#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error. Propagates #VALUE! error.');
		// Case #11: Formula, Number. Propagates #N/A error from NA() function.
		oParser = new parserFormula('CEILING.MATH(NA(), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(NA(), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula, Number. Propagates #N/A error from NA() function.');
		// Case #12: Reference link. Reference to a cell containing an error.
		oParser = new parserFormula('CEILING.MATH(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link. Reference to a cell containing an error.');
		// Case #13: Table. Reference to an entire table object returns an error.
		oParser = new parserFormula('CEILING.MATH(Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Reference to an entire table object returns an error.');

		// Bounded cases:

		// Case #1: Number. Maximum positive value for a number in Excel. Returns the number itself as it\'s already an integer multiple.
		oParser = new parserFormula('CEILING.MATH(1.79E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(1.79E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.79e+307, 'Test: Bounded case: Number. Maximum positive value for a number in Excel. Returns the number itself as it\'s already an integer multiple.');
		// Case #2: Number. Minimum negative value for a number in Excel.
		oParser = new parserFormula('CEILING.MATH(-1.79E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(-1.79E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.79e+307, 'Test: Bounded case: Number. Minimum negative value for a number in Excel.');
		// Case #3: Number. Smallest positive value greater than zero. Rounds up to 1.
		oParser = new parserFormula('CEILING.MATH(2.225E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(2.225E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Smallest positive value greater than zero. Rounds up to 1.');
		// Case #4: Number. Largest negative value (closest to zero). Rounds up (towards zero) to 0.
		oParser = new parserFormula('CEILING.MATH(-2.225E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(-2.225E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Largest negative value (closest to zero). Rounds up (towards zero) to 0.');
		// Case #5: Number(2). Number is exactly on the boundary of significance.
		oParser = new parserFormula('CEILING.MATH(4, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(4, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Bounded case: Number(2). Number is exactly on the boundary of significance.');
		// Case #6: Number(2). Number is just over the boundary of significance, forcing rounding up.
		oParser = new parserFormula('CEILING.MATH(4.00000000000001, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.MATH(4.00000000000001, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Bounded case: Number(2). Number is just over the boundary of significance, forcing rounding up.');

        // Need to fix: diff results from MS
        // Case #7: Number, String. Significance is a numeric string "1", which is converted to a number.
        // Case #8: String(3). Both number and significance are numeric strings that are converted to numbers.
        // Case #32: Area. Multi-cell area reference.
        // Case #6: Number(2). Number is just over the boundary of significance, forcing rounding up.

		testArrayFormula2(assert, "CEILING.MATH", 1, 3);
	});

	QUnit.test("Test: \"CEILING.PRECISE\"", function (assert) {

        ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("0.1");
		ws.getRange2("A103").setValue("0.5");
		ws.getRange2("A104").setValue("text");
		ws.getRange2("A105").setValue("#N/A");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("4.3"); // Column1
		ws.getRange2("B601").setValue("2"); // Column2
		ws.getRange2("C601").setValue("text"); // Column3
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("2");
		ws2.getRange2("A2").setValue("3");
		ws2.getRange2("A3").setValue("text");
		ws2.getRange2("A4").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("2"); // TestName
		ws.getRange2("A202").setValue("3"); // TestName1
		ws.getRange2("A206").setValue("text"); // TestNameArea
		ws.getRange2("A207").setValue("#N/A"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("3") // TestName3D
		ws2.getRange2("A12").setValue("4") // TestName3D1

		// Positive cases:

		// Case #1: Number. Rounds 4.3 up to the nearest multiple of 1.
		oParser = new parserFormula('CEILING.PRECISE(4.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number. Rounds 4.3 up to the nearest multiple of 1.');
		// Case #2: Number. Rounds -4.3 up to the nearest multiple of 1. Rounds toward 0 because the number is negative.
		oParser = new parserFormula('CEILING.PRECISE(-4.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(-4.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number. Rounds -4.3 up to the nearest multiple of 1. Rounds toward 0 because the number is negative.');
		// Case #3: Number(2). Rounds 4.3 up to the nearest multiple of 2.
		oParser = new parserFormula('CEILING.PRECISE(4.3, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(2). Rounds 4.3 up to the nearest multiple of 2.');
		// Case #4: Number(2). Rounds 4.3 up to the nearest multiple of -2.
		oParser = new parserFormula('CEILING.PRECISE(4.3,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(2). Rounds 4.3 up to the nearest multiple of -2.');
		// Case #5: Number(2). Rounds -4.3 up to the nearest multiple of 2. Rounds toward 0 because the number is negative.
		oParser = new parserFormula('CEILING.PRECISE(-4.3,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(-4.3,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number(2). Rounds -4.3 up to the nearest multiple of 2. Rounds toward 0 because the number is negative.');
		// Case #6: Number(2). Rounds -4.3 up to the nearest multiple of -2.
		oParser = new parserFormula('CEILING.PRECISE(-4.3,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(-4.3,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number(2). Rounds -4.3 up to the nearest multiple of -2.');
		// Case #7: Number. Basic valid input: positive number. 1 of 2 arguments used.
		oParser = new parserFormula('CEILING.PRECISE(4.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number. Basic valid input: positive number. 1 of 2 arguments used.');
		// Case #8: Number(2). Positive number with positive significance. Returns 6 (next multiple of 2 greater than or equal to 4.3).
		oParser = new parserFormula('CEILING.PRECISE(4.3, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(2). Positive number with positive significance. Returns 6 (next multiple of 2 greater than or equal to 4.3).');
		// Case #9: Number(2). Negative number with positive significance. Returns -4 (next multiple of 2 greater than or equal to -4.3).
		oParser = new parserFormula('CEILING.PRECISE(-4.3, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(-4.3, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number(2). Negative number with positive significance. Returns -4 (next multiple of 2 greater than or equal to -4.3).');
		// Case #10: Number(2). Positive number with negative significance. Sign of significance is ignored. Returns 6.
		oParser = new parserFormula('CEILING.PRECISE(4.3, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(2). Positive number with negative significance. Sign of significance is ignored. Returns 6.');
		// Case #11: Number(2). Negative number with negative significance. Sign of significance is ignored. Returns -4.
		oParser = new parserFormula('CEILING.PRECISE(-4.3, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(-4.3, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number(2). Negative number with negative significance. Sign of significance is ignored. Returns -4.');
		// Case #12: String(2). String values convertible to numbers. Returns 6.
		oParser = new parserFormula('CEILING.PRECISE("4.3", "2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE("4.3", "2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: String(2). String values convertible to numbers. Returns 6.');
		// Case #13: String(2). Negative string values convertible to numbers. Returns -4.
		oParser = new parserFormula('CEILING.PRECISE("-4.3", "-2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE("-4.3", "-2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: String(2). Negative string values convertible to numbers. Returns -4.');
		// Case #14: Formula(2). Nested formulas for both arguments. SQRT(16)=4, ABS(-2)=2. Returns 4.
		oParser = new parserFormula('CEILING.PRECISE(SQRT(16), ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(SQRT(16), ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula(2). Nested formulas for both arguments. SQRT(16)=4, ABS(-2)=2. Returns 4.');
		// Case #15: Formula. Trigonometric function SIN(PI()/4)≈0.7071. With default significance=1, returns 1.
		oParser = new parserFormula('CEILING.PRECISE(SIN(PI()/4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(SIN(PI()/4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Trigonometric function SIN(PI()/4)≈0.7071. With default significance=1, returns 1.');
		// Case #16: Reference link(2). References to cells with valid numbers. Cell F2=5, F3=10. Returns 10.
		oParser = new parserFormula('CEILING.PRECISE(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link(2). References to cells with valid numbers. Cell F2=5, F3=10. Returns 10.');
		// Case #17: Area(2). Single-cell ranges with valid numbers. F4=0.1, F5=0.5. Returns 0.5.
		oParser = new parserFormula('CEILING.PRECISE(A102:A102, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(A102:A102, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Area(2). Single-cell ranges with valid numbers. F4=0.1, F5=0.5. Returns 0.5.');
		// Case #18: Array(2). Arrays with single elements. Returns 6.
		oParser = new parserFormula('CEILING.PRECISE({4.3}, {2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE({4.3}, {2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 6, 'Test: Positive case: Array(2). Arrays with single elements. Returns 6.');
		// Case #19: Name(2). Named ranges with valid numbers. TestNameCEIL=2, TestName1CEIL=3. Returns 3.
		oParser = new parserFormula('CEILING.PRECISE(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Name(2). Named ranges with valid numbers. TestNameCEIL=2, TestName1CEIL=3. Returns 3.');
		// Case #20: Name3D(2). 3D named ranges with valid numbers. TestName3DCEIL=3, TestName3D1CEIL=4. Returns 4.
		oParser = new parserFormula('CEILING.PRECISE(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Name3D(2). 3D named ranges with valid numbers. TestName3DCEIL=3, TestName3D1CEIL=4. Returns 4.');
		// Case #21: Ref3D(2). 3D references to cells with valid numbers. B68=2, B69=3. Returns 3.
		oParser = new parserFormula('CEILING.PRECISE(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Ref3D(2). 3D references to cells with valid numbers. B68=2, B69=3. Returns 3.');
		// Case #22: Area3D(2). 3D single-cell ranges with valid numbers. B70=3, B71=4. Returns 4.
		oParser = new parserFormula('CEILING.PRECISE(Sheet2!A1:A1, Sheet2!A2:A2)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(Sheet2!A1:A1, Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Positive case: Area3D(2). 3D single-cell ranges with valid numbers. B70=3, B71=4. Returns 4.');
		// Case #23: Table(2). Table references with valid numbers. Column1=5, Column2=10. Returns 10.
		oParser = new parserFormula('CEILING.PRECISE(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Table(2). Table references with valid numbers. Column1=5, Column2=10. Returns 10.');
		// Case #24: Formula. CEILING.PRECISE used inside another formula. Returns 4 (3+1).
		oParser = new parserFormula('SUM(CEILING.PRECISE(2.3), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CEILING.PRECISE(2.3), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. CEILING.PRECISE used inside another formula. Returns 4 (3+1).');
		// Case #25: Number, Empty. Number with significance omitted (defaults to 1). Returns 5.
		oParser = new parserFormula('CEILING.PRECISE(4.3,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Empty. Number with significance omitted (defaults to 1). Returns 5.');
		// Case #26: String, Empty. String convertible to number with significance omitted. Returns 5.
		oParser = new parserFormula('CEILING.PRECISE("4.3",)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE("4.3",) is parsed.');
		//?? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String, Empty. String convertible to number with significance omitted. Returns 5.');
		// Case #27: Formula, Empty. Formula result with significance omitted. SQRT(10)≈3.16, returns 4.
		oParser = new parserFormula('CEILING.PRECISE(SQRT(10),)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(SQRT(10),) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula, Empty. Formula result with significance omitted. SQRT(10)≈3.16, returns 4.');
		// Case #28: Reference link, Empty. Reference to cell with significance omitted. F2=5, returns 5.
		oParser = new parserFormula('CEILING.PRECISE(A100,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(A100,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Reference link, Empty. Reference to cell with significance omitted. F2=5, returns 5.');
		// Case #29: Number(2). Rounding to nearest 0.1. Returns 4.5.
		oParser = new parserFormula('CEILING.PRECISE(4.5, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.5, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 4.5, 'Test: Positive case: Number(2). Rounding to nearest 0.1. Returns 4.5.');
		// Case #30: Number(2). Rounding to nearest 0.01. Returns 4.42.
		oParser = new parserFormula('CEILING.PRECISE(4.42, 0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.42, 0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 4.42, 'Test: Positive case: Number(2). Rounding to nearest 0.01. Returns 4.42.');
		// Case #31: Number(2). Rounding to nearest 0.25. Returns 4.5.
		oParser = new parserFormula('CEILING.PRECISE(4.3, 0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, 0.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 4.5, 'Test: Positive case: Number(2). Rounding to nearest 0.25. Returns 4.5.');
		// Case #32: Number(2). Negative number rounding to nearest 0.25. Returns -4.25.
		oParser = new parserFormula('CEILING.PRECISE(-4.3, 0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(-4.3, 0.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, -4.25, 'Test: Positive case: Number(2). Negative number rounding to nearest 0.25. Returns -4.25.');
		// Case #33: Date, Number. Date serial number rounded to nearest week. Returns next Sunday date.
		oParser = new parserFormula('CEILING.PRECISE(DATE(2023,1,1), 7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(DATE(2023,1,1), 7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 44933, 'Test: Positive case: Date, Number. Date serial number rounded to nearest week. Returns next Sunday date.');
		// Case #34: Time, Empty. Time serial number with default significance. TIME(12,30,0)=0.5208, returns 1.
		oParser = new parserFormula('CEILING.PRECISE(TIME(12,30,0),)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(TIME(12,30,0),) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time, Empty. Time serial number with default significance. TIME(12,30,0)=0.5208, returns 1.');
		// Case #35: Number(2). Zero with positive significance. Returns 0.
		oParser = new parserFormula('CEILING.PRECISE(0, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(0, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero with positive significance. Returns 0.');
		// Case #36: Array, Number. Array with multiple elements and single significance. Returns {6, 6}.
		oParser = new parserFormula('CEILING.PRECISE({4.3, 5.8}, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE({4.3, 5.8}, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 6, 'Test: Positive case: Array, Number. Array with multiple elements and single significance. Returns {6, 6}.');
		// Case #37: Number, Boolean. Boolean TRUE converted to 1 for significance. Returns 4.
		oParser = new parserFormula('CEILING.PRECISE(3.4, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(3.4, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Number, Boolean. Boolean TRUE converted to 1 for significance. Returns 4.');
		// Case #38: Number, Boolean. Boolean FALSE converted to 0 for significance. Returns #DIV/0! error.
		oParser = new parserFormula('CEILING.PRECISE(3.4, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(3.4, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Boolean. Boolean FALSE converted to 0 for significance. Returns #DIV/0! error.');
		// Case #39: Empty, Number. Empty cell for number argument treated as 0. Returns 0.
		oParser = new parserFormula('CEILING.PRECISE(, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number. Empty cell for number argument treated as 0. Returns 0.');
		// Case #40: Number, String. String convertible to number for significance. Returns 1.3.
		oParser = new parserFormula('CEILING.PRECISE(1.23, "0.1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(1.23, "0.1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1.3, 'Test: Positive case: Number, String. String convertible to number for significance. Returns 1.3.');
		// Case #41: Date, Date. Date values converted to serial numbers. Returns next date multiple.
		oParser = new parserFormula('CEILING.PRECISE(DATE(2023,1,15), DATE(2023,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(DATE(2023,1,15), DATE(2023,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 89854, 'Test: Positive case: Date, Date. Date values converted to serial numbers. Returns next date multiple.');
		// Case #42: Time, Time. Time values converted to serial numbers. Returns next time multiple.
		oParser = new parserFormula('CEILING.PRECISE(TIME(8,30,0), TIME(4,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(TIME(8,30,0), TIME(4,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Time, Time. Time values converted to serial numbers. Returns next time multiple.');
		// Case #43: Number(2). Small significance value. Returns 1.0100.
		oParser = new parserFormula('CEILING.PRECISE(1.01, 0.0001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(1.01, 0.0001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 1.01, 'Test: Positive case: Number(2). Small significance value. Returns 1.0100.');
		// Case #44: Number(2). Large number with large significance. Returns 10000.
		oParser = new parserFormula('CEILING.PRECISE(10000, 1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(10000, 1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10000, 'Test: Positive case: Number(2). Large number with large significance. Returns 10000.');
		// Case #45: Number(2). Very small number and significance. Returns 0.0000001.
		oParser = new parserFormula('CEILING.PRECISE(0.0000001, 0.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(0.0000001, 0.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-7, 'Test: Positive case: Number(2). Very small number and significance. Returns 0.0000001.');
		// Case #46: Formula(2). Nested formulas INT(4.9)=4, ROUND(1.9,0)=2. Returns 4.
		oParser = new parserFormula('CEILING.PRECISE(INT(4.9), ROUND(1.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(INT(4.9), ROUND(1.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula(2). Nested formulas INT(4.9)=4, ROUND(1.9,0)=2. Returns 4.');
		// Case #47: Number(2). Zero significance
		oParser = new parserFormula('CEILING.PRECISE(4.3, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero significance');

		// Negative cases:

		// Case #1: Name. Unknown name
		oParser = new parserFormula('CEILING.PRECISE(test)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(test) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name. Unknown name');
		// Case #2: String. First argument as text
		oParser = new parserFormula('CEILING.PRECISE("test")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE("test") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. First argument as text');
		// Case #3: String, Number. Non-numeric string returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE("abc", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE("abc", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string returns #VALUE!');
		// Case #4: Number, String. Non-numeric string for significance returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(4.3, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for significance returns #VALUE!');
		// Case #5: Error, Number. Error value for number argument propagates the error.
		oParser = new parserFormula('CEILING.PRECISE(NA(), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(NA(), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error value for number argument propagates the error.');
		// Case #6: Number, Error. Error value for significance argument propagates the error.
		oParser = new parserFormula('CEILING.PRECISE(4.3, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error value for significance argument propagates the error.');
		// Case #7: Area, Number. Multi-cell range for number argument with text and error returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(A104:A105, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(A104:A105, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell range for number argument with text and error returns #VALUE!');
		// Case #8: Number, Area. Multi-cell range for significance argument returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(4.3, A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Multi-cell range for significance argument returns #VALUE!');
		// Case #9: Reference link, Number. Reference to non-numeric cell returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(A104, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(A104, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to non-numeric cell returns #VALUE!');
		// Case #10: Number, Reference link. Reference to non-numeric cell for significance returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(4.3, A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Reference to non-numeric cell for significance returns #VALUE!');
		// Case #11: Array, Number. Array with non-numeric element returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE({"abc"}, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE({"abc"}, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#VALUE!', 'Test: Negative case: Array, Number. Array with non-numeric element returns #VALUE!');
		// Case #12: Number, Array. Array with non-numeric element for significance returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(4.3, {"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, {"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#VALUE!', 'Test: Negative case: Number, Array. Array with non-numeric element for significance returns #VALUE!');
		// Case #13: Name, Number. Named range with text returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(TestNameArea, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(TestNameArea, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number. Named range with text returns #VALUE!');
		// Case #14: Number, Name. Named range with text for significance returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(4.3, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name. Named range with text for significance returns #VALUE!');
		// Case #15: Table, Number. Table column with text returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(Table1[Column3], 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(Table1[Column3], 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table, Number. Table column with text returns #VALUE!');
		// Case #16: Number, Table. Table column with text for significance returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(4.3, Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Table. Table column with text for significance returns #VALUE!');
		// Case #17: Area3D, Number. 3D multi-cell range returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(Sheet2!A3:A4, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(Sheet2!A3:A4, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number. 3D multi-cell range returns #VALUE!');
		// Case #18: Number, Area3D. 3D multi-cell range for significance returns #VALUE!
		oParser = new parserFormula('CEILING.PRECISE(4.3, Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D. 3D multi-cell range for significance returns #VALUE!');
		// Case #19: Formula, Number. Formula resulting in error propagates the error.
		oParser = new parserFormula('CEILING.PRECISE(SQRT(-1), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(SQRT(-1), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in error propagates the error.');
		// Case #20: Number, Formula. Formula resulting in error for significance propagates the error.
		oParser = new parserFormula('CEILING.PRECISE(4.3, SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Formula resulting in error for significance propagates the error.');

		// Bounded cases:

		// Case #1: Number, Empty. Smallest positive number Excel can handle. Returns 1.
		oParser = new parserFormula('CEILING.PRECISE(1E-307,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(1E-307,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Empty. Smallest positive number Excel can handle. Returns 1.');
		// Case #2: Number, Empty. Smallest negative number Excel can handle. Returns 0.
		oParser = new parserFormula('CEILING.PRECISE(-1E-307,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(-1E-307,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Empty. Smallest negative number Excel can handle. Returns 0.');
		// Case #3: Number, Empty. Largest positive number Excel can handle. Returns 1E+308.
		oParser = new parserFormula('CEILING.PRECISE(9.99999999999999E+307,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(9.99999999999999E+307,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number, Empty. Largest positive number Excel can handle. Returns 1E+308.');
		// Case #4: Number, Empty. Largest negative number Excel can handle.
		oParser = new parserFormula('CEILING.PRECISE(-9.99999999999999E+307,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(-9.99999999999999E+307,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1e+308, 'Test: Bounded case: Number, Empty. Largest negative number Excel can handle.');
		// Case #5: Number(2). Smallest positive significance. Returns slightly larger than 4.3.
		oParser = new parserFormula('CEILING.PRECISE(4.3, 1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, 1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.3, 'Test: Bounded case: Number(2). Smallest positive significance. Returns slightly larger than 4.3.');
		// Case #6: Number(2). Largest positive significance.
		oParser = new parserFormula('CEILING.PRECISE(4.3, 9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(4.3, 9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number(2). Largest positive significance.');
		// Case #7: Number(2). Very small number and significance.
		oParser = new parserFormula('CEILING.PRECISE(0.0000000001, 0.0000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(0.0000000001, 0.0000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-10, 'Test: Bounded case: Number(2). Very small number and significance.');
		// Case #8: Number(2). Very large number and significance.
		oParser = new parserFormula('CEILING.PRECISE(9.99999999999999E+307, 9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CEILING.PRECISE(9.99999999999999E+307, 9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number(2). Very large number and significance.');

        // Need to fix: result difference from ms
        // Case #25: Number, Empty. Number with significance omitted (defaults to 1). Returns 5.
        // Case #26: String, Empty. String convertible to number with significance omitted. Returns 5.
        // Case #27: Formula, Empty. Formula result with significance omitted. SQRT(10)≈3.16, returns 4.
        // Case #28: Reference link, Empty. Reference to cell with significance omitted. F2=5, returns 5.
        // Case #34: Time, Empty. Time serial number with default significance. TIME(12,30,0)=0.5208, returns 1.
        // Case #1: Number, Empty. Smallest positive number Excel can handle. Returns 1.
        // Case #3: Number, Empty. Largest positive number Excel can handle. Returns 1E+308.
        // Case #4: Number, Empty. Largest negative number Excel can handle.

		testArrayFormula2(assert, "CEILING.PRECISE", 1, 2);
	});

	QUnit.test("Test: \"COMBIN\"", function (assert) {

        ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("8");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("test");
		ws.getRange2("A103").setValue("#NULL!");
		ws.getRange2("A104").setValue("");

		ws.getRange2("R10").setValue("1");
		ws.getRange2("R11").setValue("2");
		ws.getRange2("R12").setValue("3");
		ws.getRange2("S10").setValue("20");
		ws.getRange2("S11").setValue("10");
		ws.getRange2("S12").setValue("5");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("22"); // Column1
		ws.getRange2("B601").setValue("2"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("6");
		ws2.getRange2("A2").setValue("5");
		ws2.getRange2("A3").setValue("22");
		ws2.getRange2("A4").setValue("6");
		ws2.getRange2("A5").setValue("2");
		ws2.getRange2("A6").setValue("5");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("10"); // TestName
		ws.getRange2("A202").setValue("4"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("6") // TestName3D
		ws2.getRange2("A12").setValue("5") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Possible two-person teams that can be formed from 8 candidates.
		oParser = new parserFormula('COMBIN(8,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(8,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 28, 'Test: Positive case: Number(2). Possible two-person teams that can be formed from 8 candidates.');
		// Case #2: Number(2). Possible four-person teams that can be formed from 10 candidates.
		oParser = new parserFormula('COMBIN(10,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(10,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 210, 'Test: Positive case: Number(2). Possible four-person teams that can be formed from 10 candidates.');
		// Case #3: Number(2). Possible five-person teams that can be formed from 6 candidates.
		oParser = new parserFormula('COMBIN(6,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(6,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(2). Possible five-person teams that can be formed from 6 candidates.');
		// Case #4: Number(2). Number and number_chosen are zero value
		oParser = new parserFormula('COMBIN(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Number and number_chosen are zero value');
		// Case #5: Empty, Number. Number is empty converted to 0
		oParser = new parserFormula('COMBIN(,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty, Number. Number is empty converted to 0');
		// Case #6: Empty(2). Number and number_chosen are empty converted to 0
		oParser = new parserFormula('COMBIN(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty(2). Number and number_chosen are empty converted to 0');
		// Case #7: Number(2). Possible zero-person teams that can be formed from 1 candidates.
		oParser = new parserFormula('COMBIN(1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Possible zero-person teams that can be formed from 1 candidates.');
		// Case #8: Number(2). Possible 2424-person teams that can be formed from 2424 candidates.
		oParser = new parserFormula('COMBIN(2424,2424)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(2424,2424) is parsed.');
		// Case #9: Number(2). Possible 2423-person teams that can be formed from 2424 candidates.
		// Different result with MS
		oParser = new parserFormula('COMBIN(2424,2423)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(2424,2423) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Number(2). Possible 2423-person teams that can be formed from 2424 candidates.');// must be 2424
		// cString
		// Case #10: String, Number. Number as number in string
		oParser = new parserFormula('COMBIN("22",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN("22",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 231, 'Test: Positive case: String, Number. Number as number in string');
		// Case #11: String(2). Number and number_chosen are number in string format
		oParser = new parserFormula('COMBIN("22","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN("22","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 231, 'Test: Positive case: String(2). Number and number_chosen are number in string format');
		// cBool
		// Case #12: Number, Boolean. Number_chosen is boolean -> number (FALSE -> 0)
		oParser = new parserFormula('COMBIN(22,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(22,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Boolean. Number_chosen is boolean -> number (FALSE -> 0)');
		// Case #13: Number, Boolean. Number_chosen is boolean -> number (TRUE-> 1)
		oParser = new parserFormula('COMBIN(22,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(22,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 22, 'Test: Positive case: Number, Boolean. Number_chosen is boolean -> number (TRUE-> 1)');
		// Case #14: Boolean(2). Number and number_chosen are boolean -> number (TRUE -> 1, FALSE -> 0)
		oParser = new parserFormula('COMBIN(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean(2). Number and number_chosen are boolean -> number (TRUE -> 1, FALSE -> 0)');
		// Case #15: Boolean(2). Number and number_chosen are boolean -> number (TRUE -> 1, TRUE -> 1)
		oParser = new parserFormula('COMBIN(TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(TRUE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean(2). Number and number_chosen are boolean -> number (TRUE -> 1, TRUE -> 1)');
		// Case #16: Boolean, Number. Number is boolean -> number (TRUE -> 1)
		oParser = new parserFormula('COMBIN(TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(TRUE,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean, Number. Number is boolean -> number (TRUE -> 1)');
		// cArray
		// Case #17: Number, Array. Number_choosen is array with 3 elements.[]
		oParser = new parserFormula("COMBIN(20,{1,2,3})", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(20,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 20, 'Test: Positive case: Number, Array. Number_choosen is array with 3 elements.[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 190, 'Test: Positive case: Number, Array. Number_choosen is array with 3 elements.[0,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,2).getValue(), 1140, 'Test: Positive case: Number, Array. Number_choosen is array with 3 elements.[0,2]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), "", 'Test: Positive case: Number, Array. Number_choosen is array with 3 elements.[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), "", 'Test: Positive case: Number, Array. Number_choosen is array with 3 elements.[1,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,2).getValue(), "", 'Test: Positive case: Number, Array. Number_choosen is array with 3 elements.[1,2]');
		// Case #18: Array(2). Number and number_choosen are array with 2 and 3 elements.
		oParser = new parserFormula("COMBIN({12;9},{5,2,13})", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN({12;9},{5,2,13}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 792, 'Test: Positive case: Array(2). Number and number_choosen are array with 2 and 3 elements.[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 66, 'Test: Positive case: Array(2). Number and number_choosen are array with 2 and 3 elements.[0,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,2).getValue(), "#NUM!", 'Test: Positive case: Array(2). Number and number_choosen are array with 2 and 3 elements.[0,2]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 126, 'Test: Positive case: Array(2). Number and number_choosen are array with 2 and 3 elements.[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 36, 'Test: Positive case: Array(2). Number and number_choosen are array with 2 and 3 elements.[1,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,2).getValue(), "#NUM!", 'Test: Positive case: Array(2). Number and number_choosen are array with 2 and 3 elements.[1,2]');
		// Case #19: Array, Number. Number is array with 4 elements
		oParser = new parserFormula("COMBIN({12,9;10,19},10)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN({12,9;10,19},10) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 66, 'Test: Positive case: Array, Number. Number is array with 4 elements.[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), "#NUM!", 'Test: Positive case: Array, Number. Number is array with 4 elements.[0,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,2).getValue(), "", 'Test: Positive case: Array, Number. Number is array with 4 elements.[0,2]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Test: Positive case: Array, Number. Number is array with 4 elements.[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 92378, 'Test: Positive case: Array, Number. Number is array with 4 elements.[1,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,2).getValue(), "", 'Test: Positive case: Array, Number. Number is array with 4 elements.[1,2]');
		// cellsRange
		// Case #20: Area(2). Number and number_chosen are area
		oParser = new parserFormula("COMBIN(R10:S12,R10:R12)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(R10:S12,R10:R12) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Area(2). Number and number_chosen are area.[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 20, 'Test: Positive case: Area(2). Number and number_chosen are area.[0,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,2).getValue(), "", 'Test: Positive case: Area(2). Number and number_chosen are area.[0,2]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Test: Positive case: Area(2). Number and number_chosen are area.[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 45, 'Test: Positive case: Area(2). Number and number_chosen are area.[1,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,2).getValue(), "", 'Test: Positive case: Area(2). Number and number_chosen are area.[1,2]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 1, 'Test: Positive case: Area(2). Number and number_chosen are area.[2,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,1).getValue(), 10, 'Test: Positive case: Area(2). Number and number_chosen are area.[2,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,2).getValue(), "", 'Test: Positive case: Area(2). Number and number_chosen are area.[2,2]');
		// Case #21: Number, Area. Number_chosen is area with 3 elements
		oParser = new parserFormula("COMBIN(11,R10:R12)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(11,R10:R12) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 11, 'Test: Positive case: Number, Area. Number_chosen is area with 3 elements.[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), "", 'Test: Positive case: Number, Area. Number_chosen is area with 3 elements.[0,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 55, 'Test: Positive case: Number, Area. Number_chosen is area with 3 elements.[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), "", 'Test: Positive case: Number, Area. Number_chosen is area with 3 elements.[1,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 165, 'Test: Positive case: Number, Area. Number_chosen is area with 3 elements.[2,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,1).getValue(), "", 'Test: Positive case: Number, Area. Number_chosen is area with 3 elements.[2,1]');
		// Case #22: Area, Number. Number is area with 6 elements
		oParser = new parserFormula("COMBIN(R10:S12,2)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(R10:S12,2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), "#NUM!", 'Test: Positive case: Area, Number. Number is area with 6 elements.[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 190, 'Test: Positive case: Area, Number. Number is area with 6 elements.[0,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Test: Positive case: Area, Number. Number is area with 6 elements.[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 45, 'Test: Positive case: Area, Number. Number is area with 6 elements.[1,1]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 3, 'Test: Positive case: Area, Number. Number is area with 6 elements.[2,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,1).getValue(), 10, 'Test: Positive case: Area, Number. Number is area with 6 elements.[2,1]');
		// Case #23: Number(2). Possible two-person (float number must be trunced) teams that can be formed from 8 (float number must be trunced candidates.
		// Different result with MS
		oParser = new parserFormula('COMBIN(8.5, 2.6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(8.5, 2.6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 28, 'Test: Positive case: Number(2). Possible two-person (float number must be trunced) teams that can be formed from 8 (float number must be trunced candidates.');
		// Case #24: Formula(2). Number and number_chosen are using ROUND formula.
		oParser = new parserFormula('COMBIN(ROUND(8.4,0),ROUND(1.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(ROUND(8.4,0),ROUND(1.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 28, 'Test: Positive case: Formula(2). Number and number_chosen are using ROUND formula.');
		// Case #25: Formula. COMBIN is nested formula
		oParser = new parserFormula('SUM(COMBIN(10,4),10,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COMBIN(10,4),10,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 227, 'Test: Positive case: Formula. COMBIN is nested formula');
		// Case #26: Formula(2). Number and number_chosen are dates.  Date -> Number
		// Different result with MS
		oParser = new parserFormula('COMBIN(DATE(2000,5,2),DATE(2000,3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(DATE(2000,5,2),DATE(2000,3,2)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4.7848e+194, 'Test: Positive case: Formula(2). Number and number_chosen are dates.  Date -> Number');
		// Case #27: Formula(2). Number and number_chosen have time formula. Time -> Number
		// Different result with MS
		oParser = new parserFormula('COMBIN(4+TIME(13,0,0), 2+TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(4+TIME(13,0,0), 2+TIME(15,0,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula(2). Number and number_chosen have time formula. Time -> Number');
		// Case #28: Reference link(2). Number and number_chosen are ref links to 8 and 2 numbers
		oParser = new parserFormula('COMBIN(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 28, 'Test: Positive case: Reference link(2). Number and number_chosen are ref links to 8 and 2 numbers');
		// Case #29: Name(2). Number and number_chosen are DefName to 10 and 4 numbers
		oParser = new parserFormula('COMBIN(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 210, 'Test: Positive case: Name(2). Number and number_chosen are DefName to 10 and 4 numbers');
		// Case #30: Name3D(2). Number and number_chosen are DefName from another sheet to 6 and 5 numbers
		oParser = new parserFormula('COMBIN(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Name3D(2). Number and number_chosen are DefName from another sheet to 6 and 5 numbers');
		// Case #31: Ref3D(2). Number and number_chosen are Ref links from another sheet to 6 and 5 numbers
		oParser = new parserFormula('COMBIN(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Ref3D(2). Number and number_chosen are Ref links from another sheet to 6 and 5 numbers');
		// Case #32: Area3D(2). Number and number_chosen are Area from another sheet to 22 and 2, 6 and 5 numbers
		// Different result with MS
		oParser = new parserFormula('COMBIN(Sheet2!A3:A4,Sheet2!A5:A6)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(Sheet2!A3:A4,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 231, 'Test: Positive case: Area3D(2). Number and number_chosen are Area from another sheet to 22 and 2, 6 and 5 numbers');
		// Case #33: Table(2). Number and number_chosen are Table with 22 and 2 numbers
		oParser = new parserFormula('COMBIN(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 231, 'Test: Positive case: Table(2). Number and number_chosen are Table with 22 and 2 numbers');
		// Case #34: Reference link(2). Number and number_chosen are  ref links to empty cell
		oParser = new parserFormula('COMBIN(A104,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(A104,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link(2). Number and number_chosen are  ref links to empty cell');

		// Negative cases:

		// Case #1: Number(2). Number < 0 return #NUM! error
		oParser = new parserFormula('COMBIN(-6,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(-6,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number < 0 return #NUM! error');
		// Case #2: Number(2). Number < number_chosen return #NUM! error
		oParser = new parserFormula('COMBIN(3,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(3,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number < number_chosen return #NUM! error');
		// Case #3: Number(2). Number_chosen  < 0 return #NUM! error
		oParser = new parserFormula('COMBIN(6,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(6,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number_chosen  < 0 return #NUM! error');
		// Case #4: Number(2). Number (zero value) < number_chosen return #NUM! error
		oParser = new parserFormula('COMBIN(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number (zero value) < number_chosen return #NUM! error');
		// Case #5: String, Number. Number as text string return #VALUE! error
		oParser = new parserFormula('COMBIN("22s",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN("22s",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Number as text string return #VALUE! error');
		// Case #6: String(2). Number_chosen as text string return #VALUE! error
		oParser = new parserFormula('COMBIN("22","2s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN("22","2s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Number_chosen as text string return #VALUE! error');
		// Case #7: String, Error. Number is text string, number_chosen is error. Return #VALUE! error because of first arg.
		oParser = new parserFormula('COMBIN("22s",#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN("22s",#NUM!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Error. Number is text string, number_chosen is error. Return #VALUE! error because of first arg.');
		// Case #8: Boolean(2). Number and number_choosen are boolean -> number, but number <  number_chosen return #NUM! error
		oParser = new parserFormula('COMBIN(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean(2). Number and number_choosen are boolean -> number, but number <  number_chosen return #NUM! error');
		// Case #9: Boolean, Number. Number is boolean -> number, but number <  number_chosen return #NUM! error
		oParser = new parserFormula('COMBIN(TRUE,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(TRUE,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number. Number is boolean -> number, but number <  number_chosen return #NUM! error');
		// Case #10: Error, Number. Number is error return #N/A
		oParser = new parserFormula('COMBIN(#N/A, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(#N/A, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Number is error return #N/A');
		// Case #11: Number, Error. Number_chosen is error return #N/A
		oParser = new parserFormula('COMBIN(22, #N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(22, #N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Number_chosen is error return #N/A');
		// Case #12: Reference link, Number. Number is ref link to cell with text return #VALUE!
		oParser = new parserFormula('COMBIN(A102, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(A102, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Number is ref link to cell with text return #VALUE!');
		// Case #13: Number, Reference link. Number_chosen is ref link to cell with text return #VALUE!
		oParser = new parserFormula('COMBIN(3,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(3,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Number_chosen is ref link to cell with text return #VALUE!');
		// Case #14: Reference link, Number. Number is ref link to cell with error return #NULL!
		oParser = new parserFormula('COMBIN(A103, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(A103, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number. Number is ref link to cell with error return #NULL!');
		// Case #15: Number, Reference link. Number_chosen is ref link to cell with error return #NULL!
		oParser = new parserFormula('COMBIN(3,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(3,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number, Reference link. Number_chosen is ref link to cell with error return #NULL!');

		// Bounded cases:

		// Case #1: Number(2). Number is maximum accepted number
		// Different result with MS
		oParser = new parserFormula('COMBIN(2147483646,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(2147483646,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2147483646, 'Test: Bounded case: Number(2). Number is maximum accepted number');
		// Case #2: Number(2). Number and number_chosen are maximum accepted number
		oParser = new parserFormula('COMBIN(2147483646,2147483646)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(2147483646,2147483646) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Number and number_chosen are maximum accepted number');
		// Case #3: Area(2). Number and number_chosen are whole cols and rows
		oParser = new parserFormula('COMBIN(A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBIN(A:A,100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Area(2). Number and number_chosen are whole cols and rows');

        // Need to fix: diff results with ms

	});

	QUnit.test("Test: \"COMBINA\"", function (assert) {

        ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("8");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("test");
		ws.getRange2("A103").setValue("#NULL!");
		ws.getRange2("A104").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("22"); // Column1
		ws.getRange2("B601").setValue("2"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("6");
		ws2.getRange2("A2").setValue("5");
		ws2.getRange2("A3").setValue("22");
		ws2.getRange2("A4").setValue("6");
		ws2.getRange2("A5").setValue("2");
		ws2.getRange2("A6").setValue("5");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("10"); // TestName
		ws.getRange2("A202").setValue("4"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("6") // TestName3D
		ws2.getRange2("A12").setValue("5") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Returns the number of combinations (with repetitions) for 4 and 3.
		oParser = new parserFormula('COMBINA(4,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(4,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Number(2). Returns the number of combinations (with repetitions) for 4 and 3.');
		// Case #2: Number(2). Returns the number of combinations (with repetitions) for 4 and 3.
		oParser = new parserFormula('COMBINA(10,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(10,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 220, 'Test: Positive case: Number(2). Returns the number of combinations (with repetitions) for 4 and 3.');
		// Case #3: Number(2). Possible two-person teams that can be formed from 8 candidates.
		oParser = new parserFormula('COMBINA(8,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(8,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36, 'Test: Positive case: Number(2). Possible two-person teams that can be formed from 8 candidates.');
		// Case #4: Number(2). Possible four-person teams that can be formed from 10 candidates.
		oParser = new parserFormula('COMBINA(10,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(10,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 715, 'Test: Positive case: Number(2). Possible four-person teams that can be formed from 10 candidates.');
		// Case #5: Number(2). Possible five-person teams that can be formed from 6 candidates.
		oParser = new parserFormula('COMBINA(6,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(6,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 252, 'Test: Positive case: Number(2). Possible five-person teams that can be formed from 6 candidates.');
		// Case #6: Number(2). Number and number_chosen are zero value
		// Different result with MS
		oParser = new parserFormula('COMBINA(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Number and number_chosen are zero value');
		// Case #7: Empty, Number. Number is empty converted to 0
		// Different result with MS
		oParser = new parserFormula('COMBINA(,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty, Number. Number is empty converted to 0');
		// Case #8: Empty(2). Number and number_chosen are empty converted to 0
		// Different result with MS
		oParser = new parserFormula('COMBINA(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty(2). Number and number_chosen are empty converted to 0');
		// Case #9: Number(2). Possible zero-person teams that can be formed from 1 candidates.
		oParser = new parserFormula('COMBINA(1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Possible zero-person teams that can be formed from 1 candidates.');
		// Case #10: Number(2). Possible 242-person teams that can be formed from 242 candidates.
		// Different result with MS
		oParser = new parserFormula('COMBINA(242,242)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(242,242) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 9.0528e+143, 'Test: Positive case: Number(2). Possible 242-person teams that can be formed from 242 candidates.');
		// Case #11: Number(2). Possible 242-person teams that can be formed from 241 candidates.
		// Different result with MS
		oParser = new parserFormula('COMBINA(242,241)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(242,241) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4.5358e+143, 'Test: Positive case: Number(2). Possible 242-person teams that can be formed from 241 candidates.');
		// Case #12: String, Number. Number as number in string
		oParser = new parserFormula('COMBINA("22",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA("22",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 253, 'Test: Positive case: String, Number. Number as number in string');
		// Case #13: String(2). Number and number_chosen are number in string format
		oParser = new parserFormula('COMBINA("22","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA("22","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 253, 'Test: Positive case: String(2). Number and number_chosen are number in string format');
		// Case #14: Number, Boolean. Number_chosen is boolean -> number (FALSE -> 0)
		oParser = new parserFormula('COMBINA(22,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(22,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Boolean. Number_chosen is boolean -> number (FALSE -> 0)');
		// Case #15: Number, Boolean. Number_chosen is boolean -> number (TRUE-> 1)
		oParser = new parserFormula('COMBINA(22,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(22,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 22, 'Test: Positive case: Number, Boolean. Number_chosen is boolean -> number (TRUE-> 1)');
		// Case #16: Boolean(2). Number and number_chosen are boolean -> number (TRUE -> 1, FALSE -> 0)
		oParser = new parserFormula('COMBINA(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean(2). Number and number_chosen are boolean -> number (TRUE -> 1, FALSE -> 0)');
		// Case #17: Boolean(2). Number and number_chosen are boolean -> number (TRUE -> 1, TRUE -> 1)
		oParser = new parserFormula('COMBINA(TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(TRUE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean(2). Number and number_chosen are boolean -> number (TRUE -> 1, TRUE -> 1)');
		// Case #18: Boolean, Number. Number is boolean -> number (TRUE -> 1)
		oParser = new parserFormula('COMBINA(TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(TRUE,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean, Number. Number is boolean -> number (TRUE -> 1)');
		// Case #19: Number(2). Possible two-person (float number must be trunced) teams that can be formed from 8 (float number must be trunced) candidates.
		oParser = new parserFormula('COMBINA(8.5, 2.6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(8.5, 2.6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36, 'Test: Positive case: Number(2). Possible two-person (float number must be trunced) teams that can be formed from 8 (float number must be trunced) candidates.');
		// Case #20: Formula(2). Number and number_chosen are using ROUND formula.
		oParser = new parserFormula('COMBINA(ROUND(8.4,0),ROUND(1.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(ROUND(8.4,0),ROUND(1.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36, 'Test: Positive case: Formula(2). Number and number_chosen are using ROUND formula.');
		// Case #21: Formula. COMBIN is nested formula
		oParser = new parserFormula('SUM(COMBIN(10,4),10,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COMBIN(10,4),10,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 227, 'Test: Positive case: Formula. COMBIN is nested formula');
		// Case #22: Formula(2). Number and number_chosen are dates. Date -> Number
		// Different result with MS
		oParser = new parserFormula('COMBINA(DATE(1900,5,2),DATE(1900,3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(DATE(1900,5,2),DATE(1900,3,2)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 7.17059e+49, 'Test: Positive case: Formula(2). Number and number_chosen are dates. Date -> Number');
		// Case #23: Formula(2). Number and number_chosen have time formula. Time -> Number
		oParser = new parserFormula('COMBINA(4+TIME(13,0,0), 2+TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(4+TIME(13,0,0), 2+TIME(15,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula(2). Number and number_chosen have time formula. Time -> Number');
		// Case #24: Reference link(2). Number and number_chosen are ref links to 8 and 2 numbers
		oParser = new parserFormula('COMBINA(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36, 'Test: Positive case: Reference link(2). Number and number_chosen are ref links to 8 and 2 numbers');
		// Case #25: Name(2). Number and number_chosen are DefName to 10 and 4 numbers
		oParser = new parserFormula('COMBINA(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 715, 'Test: Positive case: Name(2). Number and number_chosen are DefName to 10 and 4 numbers');
		// Case #26: Name3D(2). Number and number_chosen are DefName from another sheet to 6 and 5 numbers
		oParser = new parserFormula('COMBINA(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 252, 'Test: Positive case: Name3D(2). Number and number_chosen are DefName from another sheet to 6 and 5 numbers');
		// Case #27: Ref3D(2). Number and number_chosen are Ref links from another sheet to 6 and 5 numbers
		oParser = new parserFormula('COMBINA(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 252, 'Test: Positive case: Ref3D(2). Number and number_chosen are Ref links from another sheet to 6 and 5 numbers');
		// Case #28: Area3D(2). Number and number_chosen are Area from another sheet to 22 and 2, 6 and 5 numbers
		oParser = new parserFormula('COMBINA(Sheet2!A3:A4,Sheet2!A5:A6)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(Sheet2!A3:A4,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed() - 0, 253, 'Test: Positive case: Area3D(2). Number and number_chosen are Area from another sheet to 22 and 2, 6 and 5 numbers');
		// Case #29: Table(2). Number and number_chosen are Table with 22 and 2 numbers
		oParser = new parserFormula('COMBINA(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 253, 'Test: Positive case: Table(2). Number and number_chosen are Table with 22 and 2 numbers');
		// Case #30: Reference link(2). Number and number_chosen are ref links to empty cell
		// Different result with MS
		oParser = new parserFormula('COMBINA(A104,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(A104,A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link(2). Number and number_chosen are ref links to empty cell');

		// Negative cases:

		// Case #1: Number(2). Number < number_chosen return #NUM! error.
		// Different result with MS, but MS has mistake
		oParser = new parserFormula('COMBINA(3,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(3,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number < number_chosen return #NUM! error.');
		// Case #2: Number(2). Number_chosen < 0 return #NUM! error.
		oParser = new parserFormula('COMBINA(10,-3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(10,-3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number_chosen < 0 return #NUM! error.');
		// Case #3: Number(2). Number < 0 return #NUM! error
		oParser = new parserFormula('COMBINA(-6,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(-6,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number < 0 return #NUM! error');
		// Case #4: Number(2). Number < number_chosen return #NUM! error
		// Different result with MS, but MS has mistake
		oParser = new parserFormula('COMBINA(3,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(3,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number < number_chosen return #NUM! error');
		// Case #5: Number(2). Number_chosen < 0 return #NUM! error
		oParser = new parserFormula('COMBINA(6,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(6,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number_chosen < 0 return #NUM! error');
		// Case #6: Number(2). Number (zero value) < number_chosen return #NUM! error
		oParser = new parserFormula('COMBINA(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number (zero value) < number_chosen return #NUM! error');
		// Case #7: String, Number. Number as text string return #VALUE! error
		oParser = new parserFormula('COMBINA("22s",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA("22s",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Number as text string return #VALUE! error');
		// Case #8: String(2). Number_chosen as text string return #VALUE! error
		oParser = new parserFormula('COMBINA("22","2s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA("22","2s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Number_chosen as text string return #VALUE! error');
		// Case #9: String, Error. Number is text string, number_chosen is error. Return #VALUE! error because of first arg.
		oParser = new parserFormula('COMBINA("22s",#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA("22s",#NUM!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Error. Number is text string, number_chosen is error. Return #VALUE! error because of first arg.');
		// Case #10: Boolean(2). Number and number_choosen are boolean -> number, but number < number_chosen return #NUM! error
		oParser = new parserFormula('COMBINA(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean(2). Number and number_choosen are boolean -> number, but number < number_chosen return #NUM! error');
		// Case #11: Boolean, Number. Number is boolean -> number, but number < number_chosen return #NUM! error
		// Different result with MS, but MS has mistake
		oParser = new parserFormula('COMBINA(TRUE,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(TRUE,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number. Number is boolean -> number, but number < number_chosen return #NUM! error');
		// Case #12: Error, Number. Number is error return #N/A
		oParser = new parserFormula('COMBINA(#N/A, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(#N/A, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Number is error return #N/A');
		// Case #13: Number, Error. Number_chosen is error return #N/A
		oParser = new parserFormula('COMBINA(22, #N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(22, #N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Number_chosen is error return #N/A');
		// Case #14: Reference link, Number. Number is ref link to cell with text return #VALUE!
		oParser = new parserFormula('COMBINA(A102, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(A102, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Number is ref link to cell with text return #VALUE!');
		// Case #15: Number, Reference link. Number_chosen is ref link to cell with text return #VALUE!
		oParser = new parserFormula('COMBINA(3,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(3,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Number_chosen is ref link to cell with text return #VALUE!');
		// Case #16: Reference link, Number. Number is ref link to cell with error return #NULL!
		oParser = new parserFormula('COMBINA(A103, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(A103, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number. Number is ref link to cell with error return #NULL!');
		// Case #17: Number, Reference link. Number_chosen is ref link to cell with error return #NULL!
		oParser = new parserFormula('COMBINA(3,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(3,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number, Reference link. Number_chosen is ref link to cell with error return #NULL!');

		// Bounded cases:

		// Case #1: Number(2). Number is maximum accepted number
		// Different result with MS
		oParser = new parserFormula('COMBINA(2147483646,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(2147483646,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2147483646, 'Test: Bounded case: Number(2). Number is maximum accepted number');
		// Case #2: Area(2). Number and number_chosen are whole cols and rows
		oParser = new parserFormula('COMBINA(A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMBINA(A:A,100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Area(2). Number and number_chosen are whole cols and rows');

        // Need to fix: results diff from ms

		testArrayFormula2(assert, "COMBINA", 2, 2);
	});

	QUnit.test("Test: \"COS\"", function (assert) {

        ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1.047");
		ws.getRange2("B100").setValue("=RADIANS(60)");
		ws.getRange2("A102").setValue("abc");
		ws.getRange2("A103").setValue("text");
		ws.getRange2("A104").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.047"); // Column1
		ws.getRange2("B601").setValue("text"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1.047");
		ws2.getRange2("B1").setValue("=RADIANS(60)");
		ws2.getRange2("A3").setValue("text");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1.047"); // TestName
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1.047") // TestName3D

		// Positive cases:

		// Case #1: Formula. Cosine of  Pi/2
		oParser = new parserFormula('COS(PI()/2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(PI()/2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.123233995736766e-17, 'Test: Positive case: Formula. Cosine of  Pi/2');
		// Case #2: Number. Basic valid input: integer 0. 1 argument used.
		oParser = new parserFormula('COS(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Basic valid input: integer 0. 1 argument used.');
		// Case #3: Number. Basic valid input: integer. 1 argument used.
		oParser = new parserFormula('COS(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.540302306, 'Test: Positive case: Number. Basic valid input: integer. 1 argument used.');
		// Case #4: Number. PI constant. 1 argument used.
		oParser = new parserFormula('COS(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Number. PI constant. 1 argument used.');
		// Case #5: Number. Negative float input. 1 argument used.
		oParser = new parserFormula('COS(-2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(-2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.801143616, 'Test: Positive case: Number. Negative float input. 1 argument used.');
		// Case #6: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('COS("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #7: String. String of PI value. 1 argument used.
		oParser = new parserFormula('COS("3.14159265358979")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS("3.14159265358979") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: String. String of PI value. 1 argument used.');
		// Case #8: Formula. Conversion from degrees to radians. 1 argument used.
		oParser = new parserFormula('COS(RADIANS(60))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(RADIANS(60)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Formula. Conversion from degrees to radians. 1 argument used.');
		// Case #9: Reference link. Ref to cell with valid number. 1 argument used.
		oParser = new parserFormula('COS(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.500171075, 'Test: Positive case: Reference link. Ref to cell with valid number. 1 argument used.');
		// Case #10: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('COS(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(B100:B100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #11: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('COS({0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS({0}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #12: Array. Multi-element array. 1 argument used.
		oParser = new parserFormula('COS({0, 3.14159265358979})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS({0, 3.14159265358979}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, 'Test: Positive case: Array. Multi-element array. 1 argument used.');
		// Case #13: Name. Named range. 1 argument used.
		oParser = new parserFormula('COS(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.500171075, 'Test: Positive case: Name. Named range. 1 argument used.');
		// Case #14: Name3D. 3D named range. 1 argument used.
		oParser = new parserFormula('COS(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.500171075, 'Test: Positive case: Name3D. 3D named range. 1 argument used.');
		// Case #15: Ref3D. 3D reference to cell. 1 argument used.
		oParser = new parserFormula('COS(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.500171075, 'Test: Positive case: Ref3D. 3D reference to cell. 1 argument used.');
		// Case #16: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('COS(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.500171075, 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #17: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('COS(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.500171075, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #18: Formula. Date as serial number. 1 argument used.
		oParser = new parserFormula('COS(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.330497783, 'Test: Positive case: Formula. Date as serial number. 1 argument used.');
		// Case #19: Formula. Time value (0.5). 1 argument used.
		oParser = new parserFormula('COS(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.877582562, 'Test: Positive case: Formula. Time value (0.5). 1 argument used.');
		// Case #20: Boolean. Boolean TRUE (1). 1 argument used.
		oParser = new parserFormula('COS(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.540302306, 'Test: Positive case: Boolean. Boolean TRUE (1). 1 argument used.');
		// Case #21: Formula. COS inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(COS(0),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COS(0),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. COS inside SUM formula. 1 argument used.');
		// Case #22: Formula. Nested IF returning valid value. 1 argument used.
		oParser = new parserFormula('COS(IF(TRUE, PI(), 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(IF(TRUE, PI(), 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Formula. Nested IF returning valid value. 1 argument used.');
		// Case #23: String. Date string converted to number. 1 argument used.
		oParser = new parserFormula('COS("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS("12/12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.790743634, 'Test: Positive case: String. Date string converted to number. 1 argument used.');
		// Case #24: Formula. Conversion from radians to degrees. 1 argument used.
		oParser = new parserFormula('COS(DEGREES(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(DEGREES(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.733654558, 'Test: Positive case: Formula. Conversion from radians to degrees. 1 argument used.');
		// Case #25: Area. Two-cell range. 1 argument used.
		oParser = new parserFormula('COS(A100:B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(A100:B100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.500171075, 'Test: Positive case: Area. Two-cell range. 1 argument used.');
		// Case #26: Area3D. 3D two-cell range. 1 argument used.
		oParser = new parserFormula('COS(Sheet2!A1:B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(Sheet2!A1:B1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.500171075, 'Test: Positive case: Area3D. 3D two-cell range. 1 argument used.');
		// Case #27: Empty. Reference to empty cell
		oParser = new parserFormula('COS(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty. Reference to empty cell');
		// Case #28: Boolean. Boolean FALSE (0) - valid case, but included for completeness.
		oParser = new parserFormula('COS(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean. Boolean FALSE (0) - valid case, but included for completeness.');

		// Negative cases:

		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('COS("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('COS("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #3: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('COS(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #4: Error. Propagates #REF! error. 1 argument used.
		oParser = new parserFormula('COS(#REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(#REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Error. Propagates #REF! error. 1 argument used.');
		// Case #5: Area. Multi-cell range returns #VALUE! error.
		oParser = new parserFormula('COS(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE! error.');
		// Case #6: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('COS(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #7: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('COS(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #8: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('COS(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #9: Formula. Formula resulting in #DIV/0! error.
		oParser = new parserFormula('COS(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! error.');
		// Case #10: Array. Array with text returns #VALUE!.
		oParser = new parserFormula('COS({"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS({"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#VALUE!', 'Test: Negative case: Array. Array with text returns #VALUE!.');
		// Case #11: String. String of very large number returns #NUM!.
		oParser = new parserFormula('COS("1E+309")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS("1E+309") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String of very large number returns #NUM!.');
		// Case #12: Number. Very large number may cause precision issues.
		oParser = new parserFormula('COS(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Very large number may cause precision issues.');
		// Case #13: Date. Invalid date string returns #VALUE!.
		oParser = new parserFormula('COS("13/13/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS("13/13/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Date. Invalid date string returns #VALUE!.');
		// Case #14: Formula. Nested error propagation.
		oParser = new parserFormula('COS(COS("a"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(COS("a")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Nested error propagation.');
		// Case #15: Area3D. 3D multi-cell range with text.
		oParser = new parserFormula('COS(Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range with text.');

		// Bounded cases:

		// Case #1: Number. Very small number close to zero. 1 argument used.
		oParser = new parserFormula('COS(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Very small number close to zero. 1 argument used.');
		// Case #2: Number. Very large number. 1 argument used.
		oParser = new parserFormula('COS(100000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(100000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.363385089', 'Test: Bounded case: Number. Very large number. 1 argument used.');
		// Case #3: Number. Very large negative number. 1 argument used.
		oParser = new parserFormula('COS(-100000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(-100000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.363385089', 'Test: Bounded case: Number. Very large negative number. 1 argument used.');
		// Case #4: Number. Multiple of PI for periodicity check. 1 argument used.
		oParser = new parserFormula('COS(2*PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(2*PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Multiple of PI for periodicity check. 1 argument used.');
		// Case #5: Area. Whole column range test. 1 argument used.
		oParser = new parserFormula('COS(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COS(A:A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Area. Whole column range test. 1 argument used.');

        // Need to fix: boundary case number
        // Case #12: Number. Very large number may cause precision issues.
	});

	QUnit.test("Test: \"COSH\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("-1");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("B101").setValue("2");
		ws.getRange2("A103").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("-1"); // Column1
		ws.getRange2("B601").setValue("text"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("-1");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("B2").setValue("2");
		ws2.getRange2("A4").setValue("text");
		ws2.getRange2("A5").setValue("test");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("-1"); // TestName
		ws.getRange2("A202").setValue("text"); // TestName1
		ws.getRange2("A208").setValue("1.5"); // TestNameArea2
		ws.getRange2("B208").setValue("2"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("-1") // TestName3D
		ws2.getRange2("A12").setValue("text") // TestName3D1

		// Positive cases:

		// Case #1: Number. Hyperbolic cosine of 0
		oParser = new parserFormula('COSH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Hyperbolic cosine of 0');
		// Case #2: Number. Hyperbolic cosine of 1
		oParser = new parserFormula('COSH(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Number. Hyperbolic cosine of 1');
		// Case #3: Number. Negative integer input.
		oParser = new parserFormula('COSH(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Number. Negative integer input.');
		// Case #4: Number. Float input.
		oParser = new parserFormula('COSH(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.352409615', 'Test: Positive case: Number. Float input.');
		// Case #5: Number. Negative float input.
		oParser = new parserFormula('COSH(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.352409615', 'Test: Positive case: Number. Negative float input.');
		// Case #6: String. String convertible to number.
		oParser = new parserFormula('COSH("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '3.762195691', 'Test: Positive case: String. String convertible to number.');
		// Case #7: Formula. Nested formula.
		oParser = new parserFormula('COSH(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '3.762195691', 'Test: Positive case: Formula. Nested formula.');
		// Case #8: Reference link. Reference to cell with valid number.
		oParser = new parserFormula('COSH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Reference link. Reference to cell with valid number.');
		// Case #9: Area. Single-cell range.
		oParser = new parserFormula('COSH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.352409615', 'Test: Positive case: Area. Single-cell range.');
		// Case #10: Array. Array with single element.
		oParser = new parserFormula('COSH({2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH({2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 3.762195691083631, 'Test: Positive case: Array. Array with single element.');
		// Case #11: Name. Named range.
		oParser = new parserFormula('COSH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Name. Named range.');
		// Case #12: Name3D. 3D named range.
		oParser = new parserFormula('COSH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Name3D. 3D named range.');
		// Case #13: Ref3D. 3D reference to cell.
		oParser = new parserFormula('COSH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Ref3D. 3D reference to cell.');
		// Case #14: Area3D. 3D single-cell range.
		oParser = new parserFormula('COSH(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Area3D. 3D single-cell range.');
		// Case #15: Table. Table structured reference.
		oParser = new parserFormula('COSH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Table. Table structured reference.');
		// Case #16: Formula. Date as serial number.
		oParser = new parserFormula('COSH(DATE(1900,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(DATE(1900,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Formula. Date as serial number.');
		// Case #17: Formula. Time as serial number.
		oParser = new parserFormula('COSH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.127625965', 'Test: Positive case: Formula. Time as serial number.');
		// Case #18: Boolean. Boolean TRUE (1).
		oParser = new parserFormula('COSH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.543080635', 'Test: Positive case: Boolean. Boolean TRUE (1).');
		// Case #19: Boolean. Boolean FALSE (0).
		oParser = new parserFormula('COSH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean. Boolean FALSE (0).');
		// Case #20: Formula. COSH inside SUM formula.
		oParser = new parserFormula('SUM(COSH(2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COSH(2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.762195691', 'Test: Positive case: Formula. COSH inside SUM formula.');
		// Case #21: String. String of zero.
		oParser = new parserFormula('COSH("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String of zero.');
		// Case #22: Array. Multi-element array.
		oParser = new parserFormula('COSH({1, 2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH({1, 2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1.5430806348152437, 'Test: Positive case: Array. Multi-element array.');
		// Case #23: Formula. Nested IF returning valid value.
		oParser = new parserFormula('COSH(IF(TRUE, 2, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(IF(TRUE, 2, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '3.762195691', 'Test: Positive case: Formula. Nested IF returning valid value.');
		// Case #24: String. String of float.
		oParser = new parserFormula('COSH("1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH("1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.352409615', 'Test: Positive case: String. String of float.');
		// Case #25: Formula. Pi constant.
		oParser = new parserFormula('COSH(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '11.59195328', 'Test: Positive case: Formula. Pi constant.');
		// Case #26: Area. Multi-cell range returns array of results.
		oParser = new parserFormula('COSH(A101:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(A101:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.352409615', 'Test: Positive case: Area. Multi-cell range returns array of results.');
		// Case #27: Area3D. 3D multi-cell range returns array.
		oParser = new parserFormula('COSH(Sheet2!A2:B2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(Sheet2!A2:B2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.352409615', 'Test: Positive case: Area3D. 3D multi-cell range returns array.');
		// Case #28: Name. Named range with multiple cells.
		oParser = new parserFormula('COSH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.352409615', 'Test: Positive case: Name. Named range with multiple cells.');
		// Case #29: Empty. Reference link is empty.
		oParser = new parserFormula('COSH(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty. Reference link is empty.');

		// Negative cases:

		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('COSH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('COSH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: String. Empty string returns #VALUE!.
		oParser = new parserFormula('COSH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #4: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('COSH(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #5: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('COSH(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #6: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('COSH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #7: Formula. Division by zero returns #DIV/0!.
		oParser = new parserFormula('COSH(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero returns #DIV/0!.');
		// Case #8: Number. Extremely large number returns #NUM!.
		oParser = new parserFormula('COSH(1E+154)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(1E+154) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Extremely large number returns #NUM!.');
		// Case #9: Number. Extremely large negative number returns #NUM!.
		oParser = new parserFormula('COSH(-1E+154)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(-1E+154) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Extremely large negative number returns #NUM!.');
		// Case #10: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('COSH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #11: Formula. Error propagation in formula.
		oParser = new parserFormula('COSH(1/0+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(1/0+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Error propagation in formula.');
		// Case #12: String. String of error value returns #VALUE!.
		oParser = new parserFormula('COSH("#N/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH("#N/A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String of error value returns #VALUE!.');
		// Case #13: Formula. Nested formula returns #VALUE!.
		oParser = new parserFormula('COSH(VALUE("abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(VALUE("abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Nested formula returns #VALUE!.');
		// Case #14: Formula. Nested formula with negative log returns #NUM!.
		oParser = new parserFormula('COSH(LOG(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(LOG(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula with negative log returns #NUM!.');
		// Case #15: Name3D. 3D named range with invalid data.
		oParser = new parserFormula('COSH(TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with invalid data.');
		// Case #16: Area3D. 3D range with text values.
		oParser = new parserFormula('COSH(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D range with text values.');
		// Case #17: Formula. MATCH not found returns #N/A error.
		oParser = new parserFormula('COSH(MATCH("xyz",A1:A10,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(MATCH("xyz",A1:A10,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. MATCH not found returns #N/A error.');

		// Bounded cases:

		// Case #1: Number. Minimum result value (1).
		oParser = new parserFormula('COSH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum result value (1).');
		// Case #2: Number. Near maximum value before overflow.
		oParser = new parserFormula('COSH(709)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(709) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.109203730777331e+307, 'Test: Bounded case: Number. Near maximum value before overflow.');
		// Case #3: Number. Near maximum negative value before overflow.
		oParser = new parserFormula('COSH(-709)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(-709) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.109203730777331e+307, 'Test: Bounded case: Number. Near maximum negative value before overflow.');
		// Case #4: Number. Just below overflow threshold.
		oParser = new parserFormula('COSH(708.999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(708.999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.109203730773127e+307, 'Test: Bounded case: Number. Just below overflow threshold.');
		// Case #5: Number. Just below negative overflow threshold.
		oParser = new parserFormula('COSH(-708.999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(-708.999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.109203730773127e+307, 'Test: Bounded case: Number. Just below negative overflow threshold.');
		// Case #6: Area. Entire column reference.
		oParser = new parserFormula('COSH(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(A:A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Area. Entire column reference.');
		// Case #7: Area. Entire row reference.
		oParser = new parserFormula('COSH(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COSH(100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5430806348152437, 'Test: Bounded case: Area. Entire row reference.');

	});

	QUnit.test("Test: \"COT\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("-1");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("B101").setValue("2");
		ws.getRange2("A103").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("-1"); // Column1
		ws.getRange2("B601").setValue("text"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("-1");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("B2").setValue("2");
		ws2.getRange2("A4").setValue("text");
		ws2.getRange2("A5").setValue("test");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("-1"); // TestName
		ws.getRange2("A202").setValue("text"); // TestName1
		ws.getRange2("A208").setValue("1.5"); // TestNameArea2
		ws.getRange2("B208").setValue("2"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("-1") // TestName3D
		ws2.getRange2("A12").setValue("text") // TestName3D1

		// Positive cases:

		// Case #1: Number. Returns the cotangent of 30
		oParser = new parserFormula('COT(30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.156119952', 'Test: Positive case: Number. Returns the cotangent of 30');
		// Case #2: Number. Basic valid input: positive number.
		oParser = new parserFormula('COT(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.830487722', 'Test: Positive case: Number. Basic valid input: positive number.');
		// Case #3: Number. Basic valid input: positive integer.
		oParser = new parserFormula('COT(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.642092616', 'Test: Positive case: Number. Basic valid input: positive integer.');
		// Case #4: Number. Negative integer input.
		oParser = new parserFormula('COT(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.642092616', 'Test: Positive case: Number. Negative integer input.');
		// Case #5: Number. Float input.
		oParser = new parserFormula('COT(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.070914844', 'Test: Positive case: Number. Float input.');
		// Case #6: Number. Negative float input.
		oParser = new parserFormula('COT(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.070914844', 'Test: Positive case: Number. Negative float input.');
		// Case #7: String. String convertible to number.
		oParser = new parserFormula('COT("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.457657554', 'Test: Positive case: String. String convertible to number.');
		// Case #8: Formula. Nested formula.
		oParser = new parserFormula('COT(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.457657554', 'Test: Positive case: Formula. Nested formula.');
		// Case #9: Reference link. Reference to cell with valid number.
		oParser = new parserFormula('COT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.642092616', 'Test: Positive case: Reference link. Reference to cell with valid number.');
		// Case #10: Area. Single-cell range.
		oParser = new parserFormula('COT(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.070914844', 'Test: Positive case: Area. Single-cell range.');
		// Case #11: Array. Array with single element.
		oParser = new parserFormula('COT({2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT({2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), -0.45765755436028577, 'Test: Positive case: Array. Array with single element.');
		// Case #12: Name. Named range.
		oParser = new parserFormula('COT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.642092616', 'Test: Positive case: Name. Named range.');
		// Case #13: Name3D. 3D named range.
		oParser = new parserFormula('COT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.642092616', 'Test: Positive case: Name3D. 3D named range.');
		// Case #14: Ref3D. 3D reference to cell.
		oParser = new parserFormula('COT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.642092616', 'Test: Positive case: Ref3D. 3D reference to cell.');
		// Case #15: Area3D. 3D single-cell range.
		oParser = new parserFormula('COT(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.642092616', 'Test: Positive case: Area3D. 3D single-cell range.');
		// Case #16: Table. Table structured reference.
		oParser = new parserFormula('COT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.642092616', 'Test: Positive case: Table. Table structured reference.');
		// Case #17: Formula. Date as serial number.
		oParser = new parserFormula('COT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.350175263', 'Test: Positive case: Formula. Date as serial number.');
		// Case #18: Formula. Time as serial number.
		oParser = new parserFormula('COT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.830487722', 'Test: Positive case: Formula. Time as serial number.');
		// Case #19: Boolean. Boolean TRUE (1).
		oParser = new parserFormula('COT(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.642092616', 'Test: Positive case: Boolean. Boolean TRUE (1).');
		// Case #20: Number. Value between 0 and 1.
		oParser = new parserFormula('COT(0.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(0.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.187241832', 'Test: Positive case: Number. Value between 0 and 1.');
		// Case #21: Formula. COT inside SUM formula.
		oParser = new parserFormula('SUM(COT(2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COT(2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.542342446', 'Test: Positive case: Formula. COT inside SUM formula.');
		// Case #22: String. String of non-zero value.
		oParser = new parserFormula('COT("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.830487722', 'Test: Positive case: String. String of non-zero value.');
		// Case #23: Array. Multi-element array.
		oParser = new parserFormula('COT({1, 2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT({1, 2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 0.6420926159343306, 'Test: Positive case: Array. Multi-element array.');
		// Case #24: Formula. Nested IF returning valid value.
		oParser = new parserFormula('COT(IF(TRUE, 2, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(IF(TRUE, 2, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.457657554', 'Test: Positive case: Formula. Nested IF returning valid value.');
		// Case #25: String. String of float.
		oParser = new parserFormula('COT("1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT("1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.070914844', 'Test: Positive case: String. String of float.');
		// Case #26: Formula. Pi/4 value.
		oParser = new parserFormula('COT(PI()/4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(PI()/4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Formula. Pi/4 value.');
		// Case #27: Area. Multi-cell range returns array of results.
		oParser = new parserFormula('COT(A101:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(A101:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.070914844', 'Test: Positive case: Area. Multi-cell range returns array of results.');
		// Case #28: Area3D. 3D multi-cell range returns array.
		oParser = new parserFormula('COT(Sheet2!A2:B2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(Sheet2!A2:B2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.070914844', 'Test: Positive case: Area3D. 3D multi-cell range returns array.');
		// Case #29: Name. Named range with multiple cells.
		oParser = new parserFormula('COT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.070914844', 'Test: Positive case: Name. Named range with multiple cells.');

		// Negative cases:

		// Case #1: Number. Returns the cotangent of 0
		oParser = new parserFormula('COT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Returns the cotangent of 0');
		// Case #2: Number. Returns the cotangent of 1000000000
		oParser = new parserFormula('COT(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Returns the cotangent of 1000000000');
		// Case #3: Number. Returns the cotangent of -1000000000
		oParser = new parserFormula('COT(-1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(-1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Returns the cotangent of -1000000000');
		// Case #4: Name. Unknown name
		oParser = new parserFormula('COT(test)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(test) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name. Unknown name');
		// Case #5: String. Text string. Return #VALUE!
		oParser = new parserFormula('COT("test")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT("test") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Text string. Return #VALUE!');
		// Case #6: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('COT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #7: Error. Propagates #N/A error.
		oParser = new parserFormula('COT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #8: String. Empty string returns #VALUE!.
		oParser = new parserFormula('COT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #9: Empty. Reference link is empty.
		oParser = new parserFormula('COT(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Reference link is empty.');
		// Case #10: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('COT(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #11: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('COT(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #12: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('COT(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #13: Number. Zero returns #DIV/0!.
		oParser = new parserFormula('COT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Zero returns #DIV/0!.');
		// Case #14: Number. Number ≥ 2^27 returns #NUM!.
		oParser = new parserFormula('COT(134217728)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(134217728) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number ≥ 2^27 returns #NUM!.');
		// Case #15: Number. Number ≤ -2^27 returns #NUM!.
		oParser = new parserFormula('COT(-134217728)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(-134217728) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number ≤ -2^27 returns #NUM!.');
		// Case #16: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('COT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #17: Formula. Error propagation in formula.
		oParser = new parserFormula('COT(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Error propagation in formula.');
		// Case #18: String. String of error value returns #VALUE!.
		oParser = new parserFormula('COT("#N/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT("#N/A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String of error value returns #VALUE!.');
		// Case #19: Formula. Nested formula returns #VALUE!.
		oParser = new parserFormula('COT(VALUE("abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(VALUE("abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Nested formula returns #VALUE!.');
		// Case #20: Formula. Nested formula with negative log returns #NUM!.
		oParser = new parserFormula('COT(LOG(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(LOG(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula with negative log returns #NUM!.');
		// Case #21: Name3D. 3D named range with invalid data.
		oParser = new parserFormula('COT(TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with invalid data.');
		// Case #22: Area3D. 3D range with text values.
		oParser = new parserFormula('COT(Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D range with text values.');
		// Case #23: Formula. MATCH not found returns #N/A error.
		oParser = new parserFormula('COT(MATCH("xyz",A1:A10,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(MATCH("xyz",A1:A10,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. MATCH not found returns #N/A error.');
		// Case #24: Boolean. Arguments is boolean (FALSE) Return #DIV/0!
		oParser = new parserFormula('COT(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Arguments is boolean (FALSE) Return #DIV/0!');

		// Bounded cases:

		// Case #1: Number. Near singularity (approaching π/2).
		oParser = new parserFormula('COT(PI()/2-0.001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(PI()/2-0.001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0010000003333334177, 'Test: Bounded case: Number. Near singularity (approaching π/2).');
		// Case #2: Number. Near singularity (approaching 3π/2).
		oParser = new parserFormula('COT(3*PI()/2-0.001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(3*PI()/2-0.001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0010000003333339844, 'Test: Bounded case: Number. Near singularity (approaching 3π/2).');
		// Case #3: Number. Just below maximum allowed value (2^27-1).
		oParser = new parserFormula('COT(134217727)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(134217727) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3068937771063105, 'Test: Bounded case: Number. Just below maximum allowed value (2^27-1).');
		// Case #4: Number. Just above minimum allowed value (-(2^27-1)).
		oParser = new parserFormula('COT(-134217727)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(-134217727) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.3068937771063105, 'Test: Bounded case: Number. Just above minimum allowed value (-(2^27-1)).');
		// Case #5: Number. Very small positive value (near singularity).
		oParser = new parserFormula('COT(0.000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(0.000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1000000', 'Test: Bounded case: Number. Very small positive value (near singularity).');
		// Case #6: Area. Entire column reference.
		oParser = new parserFormula('COT(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(A:A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Area. Entire column reference.');
		// Case #7: Area. Entire row reference.
		oParser = new parserFormula('COT(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COT(100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.6420926159343306, 'Test: Bounded case: Area. Entire row reference.');

		testArrayFormula(assert, "COT");
	});

	QUnit.test("Test: \"COTH\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("-1");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("B101").setValue("2");
		ws.getRange2("A103").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("-1"); // Column1
		ws.getRange2("B601").setValue("text"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("-1");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("B2").setValue("2");
		ws2.getRange2("A4").setValue("text");
		ws2.getRange2("A5").setValue("test");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("-1"); // TestName
		ws.getRange2("A202").setValue("text"); // TestName1
		ws.getRange2("A208").setValue("1.5"); // TestNameArea2
		ws.getRange2("B208").setValue("2"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("-1") // TestName3D
		ws2.getRange2("A12").setValue("text") // TestName3D1

		// Positive cases:

		// Case #1: Number. Returns the hyperbolic cotangent of 2
		oParser = new parserFormula('COTH(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.037314721', 'Test: Positive case: Number. Returns the hyperbolic cotangent of 2');
		// Case #2: Number. Returns the hyperbolic cotangent of 1000000000
		oParser = new parserFormula('COTH(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Returns the hyperbolic cotangent of 1000000000');
		// Case #3: Number. Returns the hyperbolic cotangent of -1000000000
		oParser = new parserFormula('COTH(-1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(-1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Number. Returns the hyperbolic cotangent of -1000000000');
		// Case #4: Number. Basic valid input: small positive value.
		oParser = new parserFormula('COTH(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.163953414', 'Test: Positive case: Number. Basic valid input: small positive value.');
		// Case #5: Number. Basic valid input: positive integer.
		oParser = new parserFormula('COTH(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.313035285', 'Test: Positive case: Number. Basic valid input: positive integer.');
		// Case #6: Number. Negative integer input.
		oParser = new parserFormula('COTH(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.313035285', 'Test: Positive case: Number. Negative integer input.');
		// Case #7: Number. Float input.
		oParser = new parserFormula('COTH(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.104791393', 'Test: Positive case: Number. Float input.');
		// Case #8: Number. Negative float input.
		oParser = new parserFormula('COTH(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.104791393', 'Test: Positive case: Number. Negative float input.');
		// Case #9: String. String convertible to number.
		oParser = new parserFormula('COTH("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.037314721', 'Test: Positive case: String. String convertible to number.');
		// Case #10: Formula. Nested formula.
		oParser = new parserFormula('COTH(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.037314721', 'Test: Positive case: Formula. Nested formula.');
		// Case #11: Reference link. Reference to cell with valid number.
		oParser = new parserFormula('COTH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.313035285', 'Test: Positive case: Reference link. Reference to cell with valid number.');
		// Case #12: Area. Single-cell range.
		oParser = new parserFormula('COTH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.104791393', 'Test: Positive case: Area. Single-cell range.');
		// Case #13: Array. Array with single element.
		oParser = new parserFormula('COTH({2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH({2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1.0373147207275482, 'Test: Positive case: Array. Array with single element.');
		// Case #14: Name. Named range.
		oParser = new parserFormula('COTH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.313035285', 'Test: Positive case: Name. Named range.');
		// Case #15: Name3D. 3D named range.
		oParser = new parserFormula('COTH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.313035285', 'Test: Positive case: Name3D. 3D named range.');
		// Case #16: Ref3D. 3D reference to cell.
		oParser = new parserFormula('COTH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.313035285', 'Test: Positive case: Ref3D. 3D reference to cell.');
		// Case #17: Area3D. 3D single-cell range.
		oParser = new parserFormula('COTH(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.313035285', 'Test: Positive case: Area3D. 3D single-cell range.');
		// Case #18: Table. Table structured reference.
		oParser = new parserFormula('COTH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.313035285', 'Test: Positive case: Table. Table structured reference.');
		// Case #19: Formula. Date as serial number.
		oParser = new parserFormula('COTH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Date as serial number.');
		// Case #20: Formula. Time as serial number.
		oParser = new parserFormula('COTH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.163953414', 'Test: Positive case: Formula. Time as serial number.');
		// Case #21: Boolean. Boolean TRUE (1).
		oParser = new parserFormula('COTH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.313035285', 'Test: Positive case: Boolean. Boolean TRUE (1).');
		// Case #22: Formula. COTH inside SUM formula.
		oParser = new parserFormula('SUM(COTH(2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COTH(2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.037314721', 'Test: Positive case: Formula. COTH inside SUM formula.');
		// Case #23: String. String of non-zero number.
		oParser = new parserFormula('COTH("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.163953414', 'Test: Positive case: String. String of non-zero number.');
		// Case #24: Array. Multi-element array.
		oParser = new parserFormula('COTH({1, 2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH({1, 2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1.3130352854993315, 'Test: Positive case: Array. Multi-element array.');
		// Case #25: Formula. Nested IF returning valid value.
		oParser = new parserFormula('COTH(IF(TRUE, 2, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(IF(TRUE, 2, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.037314721', 'Test: Positive case: Formula. Nested IF returning valid value.');
		// Case #26: String. String of float.
		oParser = new parserFormula('COTH("1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH("1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.104791393', 'Test: Positive case: String. String of float.');
		// Case #27: Formula. Pi constant.
		oParser = new parserFormula('COTH(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.003741873', 'Test: Positive case: Formula. Pi constant.');
		// Case #28: Area. Multi-cell range returns array of results.
		oParser = new parserFormula('COTH(A101:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(A101:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.104791393', 'Test: Positive case: Area. Multi-cell range returns array of results.');
		// Case #29: Area3D. 3D multi-cell range returns array.
		oParser = new parserFormula('COTH(Sheet2!A2:B2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(Sheet2!A2:B2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.104791393', 'Test: Positive case: Area3D. 3D multi-cell range returns array.');
		// Case #30: Name. Named range with multiple cells.
		oParser = new parserFormula('COTH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.104791393', 'Test: Positive case: Name. Named range with multiple cells.');

		// Negative cases:

		// Case #1: Number. Returns the hyperbolic cotangent of 0
		oParser = new parserFormula('COTH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Returns the hyperbolic cotangent of 0');
		// Case #2: Name. Incorrect name
		oParser = new parserFormula('COTH(test)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(test) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name. Incorrect name');
		// Case #3: String. Text string return #VALUE!
		oParser = new parserFormula('COTH("test")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH("test") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Text string return #VALUE!');
		// Case #4: Boolean. Boolean FALSE (0).
		oParser = new parserFormula('COTH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean FALSE (0).');
		// Case #5: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('COTH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #6: Error. Propagates #N/A error.
		oParser = new parserFormula('COTH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #7: String. Empty string returns #VALUE!.
		oParser = new parserFormula('COTH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #8: Empty. Reference link is empty.
		oParser = new parserFormula('COTH(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Reference link is empty.');
		// Case #9: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('COTH(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #10: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('COTH(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #11: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('COTH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #12: Formula. Zero input returns #DIV/0!.
		oParser = new parserFormula('COTH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Zero input returns #DIV/0!.');
		// Case #13: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('COTH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #14: Formula. Error propagation in formula.
		oParser = new parserFormula('COTH(1/0+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(1/0+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Error propagation in formula.');
		// Case #15: String. String of error value returns #VALUE!.
		oParser = new parserFormula('COTH("#N/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH("#N/A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String of error value returns #VALUE!.');
		// Case #16: Formula. Nested formula returns #VALUE!.
		oParser = new parserFormula('COTH(VALUE("abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(VALUE("abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Nested formula returns #VALUE!.');
		// Case #17: Formula. Nested formula with negative log returns #NUM!.
		oParser = new parserFormula('COTH(LOG(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(LOG(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula with negative log returns #NUM!.');
		// Case #18: Name3D. 3D named range with invalid data.
		oParser = new parserFormula('COTH(TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with invalid data.');
		// Case #19: Area3D. 3D range with text values.
		oParser = new parserFormula('COTH(Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D range with text values.');
		// Case #20: Formula. MATCH not found returns #N/A error.
		oParser = new parserFormula('COTH(MATCH("xyz",A1:A10,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(MATCH("xyz",A1:A10,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. MATCH not found returns #N/A error.');

		// Bounded cases:

		// Case #1: Number. Value close to zero (large result).
		oParser = new parserFormula('COTH(0.000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(0.000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000000.0000003333, 'Test: Bounded case: Number. Value close to zero (large result).');
		// Case #2: Number. Near maximum value before overflow.
		oParser = new parserFormula('COTH(709)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(709) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Near maximum value before overflow.');
		// Case #3: Number. Near maximum negative value before overflow.
		oParser = new parserFormula('COTH(-709)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(-709) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Number. Near maximum negative value before overflow.');
		// Case #4: Number. Just below overflow threshold.
		oParser = new parserFormula('COTH(708.999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(708.999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Just below overflow threshold.');
		// Case #5: Number. Just below negative overflow threshold.
		oParser = new parserFormula('COTH(-708.999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(-708.999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Number. Just below negative overflow threshold.');
		// Case #6: Area. Entire column reference.
		oParser = new parserFormula('COTH(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(A:A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Area. Entire column reference.');
		// Case #7: Area. Entire row reference.
		oParser = new parserFormula('COTH(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.3130352854993315, 'Test: Bounded case: Area. Entire row reference.');
		// Case #8: Number. Extremely large number.
		oParser = new parserFormula('COTH(1E+154)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(1E+154) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Extremely large number.');
		// Case #9: Number. Extremely large negative number.
		oParser = new parserFormula('COTH(-1E+154)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COTH(-1E+154) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Number. Extremely large negative number.');

		testArrayFormula(assert, "COTH");
	});

	QUnit.test("Test: \"CSC\"", function (assert) {

        ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("15");
		ws.getRange2("B100").setValue("15");
		ws.getRange2("A102").setValue("");
		ws.getRange2("A103").setValue("#N/A");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("15"); // Column1
		ws.getRange2("B601").setValue("text"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("15");
		ws2.getRange2("A2").setValue("15");
		ws2.getRange2("A3").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("15"); // TestName
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("15") // TestName3D

		// Positive cases:

		// Case #1: Number. Return 1.538
		oParser = new parserFormula('CSC(15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Number. Return 1.538');
		// Case #2: Number. Basic valid input: integer.
		oParser = new parserFormula('CSC(15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Number. Basic valid input: integer.');
		// Case #3: Number. Float input.
		oParser = new parserFormula('CSC(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.002511304', 'Test: Positive case: Number. Float input.');
		// Case #4: Number. Negative number.
		oParser = new parserFormula('CSC(-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.537780562', 'Test: Positive case: Number. Negative number.');
		// Case #5: String. String convertible to number.
		oParser = new parserFormula('CSC("15")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC("15") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: String. String convertible to number.');
		// Case #6: Formula. Nested formula returning 15.
		oParser = new parserFormula('CSC(SQRT(225))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(SQRT(225)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Formula. Nested formula returning 15.');
		// Case #7: Reference link. Ref to cell with valid number.
		oParser = new parserFormula('CSC(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Reference link. Ref to cell with valid number.');
		// Case #8: Area. Single-cell range.
		oParser = new parserFormula('CSC(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Area. Single-cell range.');
		// Case #9: Array. Array with single element.
		oParser = new parserFormula('CSC({15})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC({15}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1.5377805615408537, 'Test: Positive case: Array. Array with single element.');
		// Case #10: Name. Named range.
		oParser = new parserFormula('CSC(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Name. Named range.');
		// Case #11: Name3D. 3D named range.
		oParser = new parserFormula('CSC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Name3D. 3D named range.');
		// Case #12: Ref3D. 3D reference to cell.
		oParser = new parserFormula('CSC(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Ref3D. 3D reference to cell.');
		// Case #13: Area3D. 3D single-cell range.
		oParser = new parserFormula('CSC(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Area3D. 3D single-cell range.');
		// Case #14: Table. Table structured reference.
		oParser = new parserFormula('CSC(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Table. Table structured reference.');
		// Case #15: Date. Date as serial number.
		oParser = new parserFormula('CSC(DATE(2025,1,15))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(DATE(2025,1,15)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-2.190834635', 'Test: Positive case: Date. Date as serial number.');
		// Case #16: Time. Time as decimal.
		oParser = new parserFormula('CSC(TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(TIME(15,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '1.70911752', 'Test: Positive case: Time. Time as decimal.');
		// Case #17: Formula. CSC inside SUM formula.
		oParser = new parserFormula('SUM(CSC(15),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CSC(15),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '2.537780562', 'Test: Positive case: Formula. CSC inside SUM formula.');
		// Case #18: Boolean. Boolean TRUE converted to 1.
		oParser = new parserFormula('CSC(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.188395106', 'Test: Positive case: Boolean. Boolean TRUE converted to 1.');
		// Case #19: String. Date string converted to serial number.
		oParser = new parserFormula('CSC("01/15/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC("01/15/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-2.190834635', 'Test: Positive case: String. Date string converted to serial number.');
		// Case #20: Array. Multi-element array.
		oParser = new parserFormula('CSC({15, 20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC({15, 20}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1.5377805615408537, 'Test: Positive case: Array. Multi-element array.');
		// Case #21: Formula. Nested IF returning valid value.
		oParser = new parserFormula('CSC(IF(TRUE, 15, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(IF(TRUE, 15, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Formula. Nested IF returning valid value.');
		// Case #22: Number. Small positive number.
		oParser = new parserFormula('CSC(0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '10.01668613', 'Test: Positive case: Number. Small positive number.');
		// Case #23: Formula. Value near PI/2 but not exact.
		oParser = new parserFormula('CSC(PI()/2+0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(PI()/2+0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.005020918', 'Test: Positive case: Formula. Value near PI/2 but not exact.');
		// Case #24: Area. Multi-cell range with valid values.
		oParser = new parserFormula('CSC(A100:B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(A100:B100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Area. Multi-cell range with valid values.');
		// Case #25: Area3D. 3D multi-cell range with valid values.
		oParser = new parserFormula('CSC(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.537780562', 'Test: Positive case: Area3D. 3D multi-cell range with valid values.');
		// Case #26: Number. PI
		oParser = new parserFormula('CSC(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(PI()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 8162280000000000, 'Test: Positive case: Number. PI');
		// Case #27: Number. 2*PI
		oParser = new parserFormula('CSC(2*PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(2*PI()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -4081140000000000, 'Test: Positive case: Number. 2*PI');
		// Case #28: Number. 3*PI
		oParser = new parserFormula('CSC(3*PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(3*PI()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2720760000000000, 'Test: Positive case: Number. 3*PI');

		// Negative cases:

		// Case #1: Number. Return #DIV/0!
		oParser = new parserFormula('CSC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Return #DIV/0!');
		// Case #2: Number. Return #NUM!
		oParser = new parserFormula('CSC(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Return #NUM!');
		// Case #3: Number. Return #NUM!
		oParser = new parserFormula('CSC(-1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(-1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Return #NUM!');
		// Case #4: Name. Incorrect DefName. Return #NAME?
		oParser = new parserFormula('CSC(test)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(test) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name. Incorrect DefName. Return #NAME?');
		// Case #5: String. Text instead of number. Return #VALUE!
		oParser = new parserFormula('CSC("test")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC("test") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Text instead of number. Return #VALUE!');
		// Case #6: Number. Zero returns #DIV/0! error.
		oParser = new parserFormula('CSC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Zero returns #DIV/0! error.');
		// Case #7: String. Non-numeric string returns #VALUE! error.
		oParser = new parserFormula('CSC("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE! error.');
		// Case #8: Error. Propagates #N/A error.
		oParser = new parserFormula('CSC(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #9: Empty. Empty cell returns #VALUE! error.
		oParser = new parserFormula('CSC(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Empty cell returns #VALUE! error.');
		// Case #10: String. Empty string returns #VALUE! error.
		oParser = new parserFormula('CSC("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE! error.');
		// Case #11: Boolean. Boolean FALSE (0) returns #DIV/0! error.
		oParser = new parserFormula('CSC(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #DIV/0! error.');
		// Case #12: Number. Number equals 2^27 returns #NUM! error.
		oParser = new parserFormula('CSC(2^27)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(2^27) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number equals 2^27 returns #NUM! error.');
		// Case #13: Number. Number equals -2^27 returns #NUM! error.
		oParser = new parserFormula('CSC(-2^27)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(-2^27) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number equals -2^27 returns #NUM! error.');
		// Case #14: Table. Table column with text returns #VALUE! error.
		oParser = new parserFormula('CSC(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE! error.');
		// Case #15: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('CSC(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #16: Array. Array with zero returns #DIV/0! error.
		oParser = new parserFormula('CSC({0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC({0}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with zero returns #DIV/0! error.');
		// Case #17: Number. Number > 2^27-1 returns #NUM! error.
		oParser = new parserFormula('CSC(134217728)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(134217728) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number > 2^27-1 returns #NUM! error.');
		// Case #18: Number. Number < -2^27+1 returns #NUM! error.
		oParser = new parserFormula('CSC(-134217728)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(-134217728) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number < -2^27+1 returns #NUM! error.');
		// Case #19: String. String "0" returns #DIV/0! error.
		oParser = new parserFormula('CSC("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. String "0" returns #DIV/0! error.');
		// Case #20: Reference link. Ref to error cell propagates error.
		oParser = new parserFormula('CSC(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link. Ref to error cell propagates error.');
		// Case #21: Formula. Division by zero returns #DIV/0! error.
		oParser = new parserFormula('CSC(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero returns #DIV/0! error.');
		// Case #22: Ref3D. 3D ref to zero returns #DIV/0! error.
		oParser = new parserFormula('CSC(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D. 3D ref to zero returns #DIV/0! error.');

		// Bounded cases:

		// Case #1: Number. Max valid value (2^27-1).
		oParser = new parserFormula('CSC(134217727)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(134217727) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.0460324040996902, 'Test: Bounded case: Number. Max valid value (2^27-1).');
		// Case #2: Number. Min valid value (-2^27+1).
		oParser = new parserFormula('CSC(-134217727)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(-134217727) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0460324040996902, 'Test: Bounded case: Number. Min valid value (-2^27+1).');
		// Case #3: Number. Very small positive number near zero.
		oParser = new parserFormula('CSC(0.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(0.000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1000000000', 'Test: Bounded case: Number. Very small positive number near zero.');
		// Case #4: Number. Very small negative number near zero.
		oParser = new parserFormula('CSC(-0.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(-0.000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '-1000000000', 'Test: Bounded case: Number. Very small negative number near zero.');
		// Case #5: Area. Entire column reference.
		oParser = new parserFormula('CSC(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(A:A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Area. Entire column reference.');
		// Case #6: Area. Entire row reference.
		oParser = new parserFormula('CSC(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSC(100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5377805615408537, 'Test: Bounded case: Area. Entire row reference.');

        // Need to fix: big number precision
        // Case #26: Number. PI
        // Case #27: Number. 2*PI
        // Case #28: Number. 3*PI

		testArrayFormula(assert, "CSC");
	});

	QUnit.test("Test: \"CSCH\"", function (assert) {

        ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("15");
		ws.getRange2("B100").setValue("15");
		ws.getRange2("A102").setValue("");
		ws.getRange2("A103").setValue("#N/A");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("15"); // Column1
		ws.getRange2("B601").setValue("text"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("15");
		ws2.getRange2("A2").setValue("15");
		ws2.getRange2("A3").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("15"); // TestName
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("15") // TestName3D
		/*oParser = new parserFormula('CSCH(1.5)', "A1", ws);
		assert.ok(oParser.parse(), 'CSCH(1.5)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 0.4696, 'CSCH(1.5)');*/

		// Positive cases:

		// Case #1: Number. Return 0.4696
		oParser = new parserFormula('CSCH(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.469642441', 'Test: Positive case: Number. Return 0.4696');
		// Case #2: Number. Return 0
		oParser = new parserFormula('CSCH(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Return 0');
		// Case #3: Number. Return 0
		oParser = new parserFormula('CSCH(-1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(-1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Return 0');
		// Case #1: Number. Basic valid input: integer.
		oParser = new parserFormula('CSCH(15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Number. Basic valid input: integer.');
		// Case #2: Number. Float input.
		oParser = new parserFormula('CSCH(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.469642441', 'Test: Positive case: Number. Float input.');
		// Case #3: Number. Negative number.
		oParser = new parserFormula('CSCH(-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6.118046410037094e-7, 'Test: Positive case: Number. Negative number.');
		// Case #4: String. String convertible to number.
		oParser = new parserFormula('CSCH("15")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH("15") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: String. String convertible to number.');
		// Case #5: Formula. Nested formula returning 15.
		oParser = new parserFormula('CSCH(SQRT(225))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(SQRT(225)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Formula. Nested formula returning 15.');
		// Case #6: Reference link. Ref to cell with valid number.
		oParser = new parserFormula('CSCH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Reference link. Ref to cell with valid number.');
		// Case #7: Area. Single-cell range.
		oParser = new parserFormula('CSCH(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Area. Single-cell range.');
		// Case #8: Array. Array with single element.
		oParser = new parserFormula('CSCH({15})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH({15}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 6.118046410037094e-7, 'Test: Positive case: Array. Array with single element.');
		// Case #9: Name. Named range.
		oParser = new parserFormula('CSCH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Name. Named range.');
		// Case #10: Name3D. 3D named range.
		oParser = new parserFormula('CSCH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Name3D. 3D named range.');
		// Case #11: Ref3D. 3D reference to cell.
		oParser = new parserFormula('CSCH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Ref3D. 3D reference to cell.');
		// Case #12: Area3D. 3D single-cell range.
		oParser = new parserFormula('CSCH(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Area3D. 3D single-cell range.');
		// Case #13: Table. Table structured reference.
		oParser = new parserFormula('CSCH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Table. Table structured reference.');
		// Case #14: Date. Date as serial number.
		oParser = new parserFormula('CSCH(DATE(2025,1,15))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(DATE(2025,1,15)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date. Date as serial number.');
		// Case #15: Time. Time as decimal.
		oParser = new parserFormula('CSCH(TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(TIME(15,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.500392508', 'Test: Positive case: Time. Time as decimal.');
		// Case #16: Formula. CSCH inside SUM formula.
		oParser = new parserFormula('SUM(CSCH(15),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CSCH(15),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.000000612', 'Test: Positive case: Formula. CSCH inside SUM formula.');
		// Case #17: Boolean. Boolean TRUE converted to 1.
		oParser = new parserFormula('CSCH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.850918128', 'Test: Positive case: Boolean. Boolean TRUE converted to 1.');
		// Case #18: String. Date string converted to serial number.
		oParser = new parserFormula('CSCH("01/15/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH("01/15/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Date string converted to serial number.');
		// Case #19: Array. Multi-element array.
		oParser = new parserFormula('CSCH({15, 20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH({15, 20}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 6.118046410037094e-7, 'Test: Positive case: Array. Multi-element array.');
		// Case #20: Formula. Nested IF returning valid value.
		oParser = new parserFormula('CSCH(IF(TRUE, 15, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(IF(TRUE, 15, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Formula. Nested IF returning valid value.');
		// Case #21: Number. Small positive number.
		oParser = new parserFormula('CSCH(0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '9.983352757', 'Test: Positive case: Number. Small positive number.');
		// Case #22: Number. PI value as valid input.
		oParser = new parserFormula('CSCH(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.086589538', 'Test: Positive case: Number. PI value as valid input.');
		// Case #23: Area. Multi-cell range with valid values.
		oParser = new parserFormula('CSCH(A100:B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(A100:B100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Area. Multi-cell range with valid values.');
		// Case #24: Area3D. 3D multi-cell range with valid values.
		oParser = new parserFormula('CSCH(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Positive case: Area3D. 3D multi-cell range with valid values.');
		// Case #25: Number. 2*PI as valid input.
		oParser = new parserFormula('CSCH(2*PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(2*PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.003734898', 'Test: Positive case: Number. 2*PI as valid input.');
		// Case #26: Formula. Nested LN formula.
		oParser = new parserFormula('CSCH(LN(15))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(LN(15)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.133928571', 'Test: Positive case: Formula. Nested LN formula.');

		// Negative cases:

		// Case #1: Number. Return #DIV/0!
		oParser = new parserFormula('CSCH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Return #DIV/0!');
		// Case #2: Name. Return #NAME?
		oParser = new parserFormula('CSCH(test)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(test) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name. Return #NAME?');
		// Case #3: String. Return #VALUE!
		oParser = new parserFormula('CSCH("test")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH("test") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Return #VALUE!');
		// Case #1: Number. Zero returns #DIV/0! error.
		oParser = new parserFormula('CSCH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Zero returns #DIV/0! error.');
		// Case #2: String. Non-numeric string returns #VALUE! error.
		oParser = new parserFormula('CSCH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE! error.');
		// Case #3: Error. Propagates #N/A error.
		oParser = new parserFormula('CSCH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #4: Empty. Empty cell returns #VALUE! error.
		oParser = new parserFormula('CSCH(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Empty cell returns #VALUE! error.');
		// Case #5: String. Empty string returns #VALUE! error.
		oParser = new parserFormula('CSCH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE! error.');
		// Case #6: Boolean. Boolean FALSE (0) returns #DIV/0! error.
		oParser = new parserFormula('CSCH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #DIV/0! error.');
		// Case #7: Number. Number equals 2^27 returns 0.
		oParser = new parserFormula('CSCH(2^27)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(2^27) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Number equals 2^27 returns 0.');
		// Case #8: Number. Number equals -2^27 returns 0.
		oParser = new parserFormula('CSCH(-2^27)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(-2^27) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Number equals -2^27 returns 0.');
		// Case #9: Table. Table column with text returns #VALUE! error.
		oParser = new parserFormula('CSCH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE! error.');
		// Case #10: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('CSCH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #11: Array. Array with zero returns #DIV/0! error.
		oParser = new parserFormula('CSCH({0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH({0}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with zero returns #DIV/0! error.');
		// Case #12: Number. Number > 2^27-1 returns 0.
		oParser = new parserFormula('CSCH(134217728)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(134217728) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Number > 2^27-1 returns 0.');
		// Case #13: Number. Number < -2^27+1 returns 0.
		oParser = new parserFormula('CSCH(-134217728)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(-134217728) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Number < -2^27+1 returns 0.');
		// Case #14: String. String "0" returns #DIV/0! error.
		oParser = new parserFormula('CSCH("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. String "0" returns #DIV/0! error.');
		// Case #15: Reference link. Ref to error cell propagates error.
		oParser = new parserFormula('CSCH(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link. Ref to error cell propagates error.');
		// Case #16: Formula. Division by zero returns #DIV/0! error.
		oParser = new parserFormula('CSCH(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero returns #DIV/0! error.');
		// Case #17: Ref3D. 3D ref to zero returns #DIV/0! error.
		oParser = new parserFormula('CSCH(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D. 3D ref to zero returns #DIV/0! error.');
		// Case #18: Error. Error from nested formula propagates.
		oParser = new parserFormula('CSCH(DIV(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(DIV(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Error. Error from nested formula propagates.');
		// Case #19: Number. Extremely large number returns 0 error.
		oParser = new parserFormula('CSCH(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Extremely large number returns 0 error.');
		// Case #20: Formula. Formula resulting in zero returns #DIV/0! error.
		oParser = new parserFormula('CSCH(0*PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(0*PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in zero returns #DIV/0! error.');

		// Bounded cases:

		// Case #1: Number. Max valid value (2^27-1).
		oParser = new parserFormula('CSCH(134217727)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(134217727) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Max valid value (2^27-1).');
		// Case #2: Number. Min valid value (-2^27+1).
		oParser = new parserFormula('CSCH(-134217727)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(-134217727) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Min valid value (-2^27+1).');
		// Case #3: Number. Very small positive number near zero.
		oParser = new parserFormula('CSCH(0.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(0.000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1000000000, 'Test: Bounded case: Number. Very small positive number near zero.');
		// Case #4: Number. Very small negative number near zero.
		oParser = new parserFormula('CSCH(-0.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(-0.000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1000000000, 'Test: Bounded case: Number. Very small negative number near zero.');
		// Case #5: Area. Entire column reference.
		oParser = new parserFormula('CSCH(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(A:A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Area. Entire column reference.');
		// Case #6: Area. Entire row reference.
		oParser = new parserFormula('CSCH(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CSCH(100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.118046410037094e-7, 'Test: Bounded case: Area. Entire row reference.');

        // Need to fix: numbers precision in boundary cases
        // Case #3: Number. Very small positive number near zero.
        // Case #4: Number. Very small negative number near zero.

		testArrayFormula(assert, "CSCH");
	});

	QUnit.test("Test: \"DECIMAL\"", function (assert) {

        ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("FF");
		ws.getRange2("A101").setValue("16");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A104").setValue("text");
		ws.getRange2("A105").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("FF"); // Column1
		ws.getRange2("B601").setValue("16"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("FF");
		ws2.getRange2("A2").setValue("16");
		ws2.getRange2("A3").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("FF"); // TestName
		ws.getRange2("A202").setValue("16"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("FF") // TestName3D
		ws2.getRange2("A12").setValue("16") // TestName3D1

		// Positive cases:

		// Case #1: String, Number. Return 255.
		oParser = new parserFormula('DECIMAL("FF",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("FF",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: String, Number. Return 255.');
		// Case #2: Number(2). Return 7.
		oParser = new parserFormula('DECIMAL(111,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(111,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Number(2). Return 7.');
		// Case #3: String, Number. Return 45745.
		oParser = new parserFormula('DECIMAL("zap",36)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("zap",36) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45745, 'Test: Positive case: String, Number. Return 45745.');
		// Case #4: String, Number. Return 255.
		oParser = new parserFormula('DECIMAL("00FF",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("00FF",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: String, Number. Return 255.');
		// Case #5: String, Number. Return 5.
		oParser = new parserFormula('DECIMAL("101b",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("101b",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String, Number. Return 5.');
		// Case #6: String(2). Convert binary string "111" to decimal. Both arguments are strings.
		oParser = new parserFormula('DECIMAL("111","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("111","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: String(2). Convert binary string "111" to decimal. Both arguments are strings.');
		// Case #7: Number(2). Convert binary number 111 to decimal. Both arguments are numbers.
		oParser = new parserFormula('DECIMAL(111,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(111,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Number(2). Convert binary number 111 to decimal. Both arguments are numbers.');
		// Case #8: String, Number. Convert hexadecimal string "FF" to decimal (255). Text as string, Radix as number.
		oParser = new parserFormula('DECIMAL("FF",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("FF",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: String, Number. Convert hexadecimal string "FF" to decimal (255). Text as string, Radix as number.');
		// Case #9: String, Number. Convert octal string "10" to decimal (8).
		oParser = new parserFormula('DECIMAL("10",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: String, Number. Convert octal string "10" to decimal (8).');
		// Case #10: String, Number. Convert base 36 string "Z" to decimal (35). Maximum radix.
		oParser = new parserFormula('DECIMAL("Z",36)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("Z",36) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 35, 'Test: Positive case: String, Number. Convert base 36 string "Z" to decimal (35). Maximum radix.');
		// Case #11: String, Number. Convert multi-digit hexadecimal string to decimal (6699).
		oParser = new parserFormula('DECIMAL("1A2B",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("1A2B",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6699, 'Test: Positive case: String, Number. Convert multi-digit hexadecimal string to decimal (6699).');
		// Case #12: String, Number. Convert base 3 string "121" to decimal (16).
		oParser = new parserFormula('DECIMAL("121",3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("121",3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: String, Number. Convert base 3 string "121" to decimal (16).');
		// Case #13: String, Number. Convert base 5 string "234" to decimal (69).
		oParser = new parserFormula('DECIMAL("234",5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("234",5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 69, 'Test: Positive case: String, Number. Convert base 5 string "234" to decimal (69).');
		// Case #14: String, Number. Lowercase hexadecimal string converted to decimal. Case insensitive.
		oParser = new parserFormula('DECIMAL("ff",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("ff",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: String, Number. Lowercase hexadecimal string converted to decimal. Case insensitive.');
		// Case #15: String, Number. Mixed case hexadecimal string converted to decimal.
		oParser = new parserFormula('DECIMAL("Ff",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("Ff",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: String, Number. Mixed case hexadecimal string converted to decimal.');
		// Case #16: String, Number. Convert zero string to decimal (0).
		oParser = new parserFormula('DECIMAL("0",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("0",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String, Number. Convert zero string to decimal (0).');
		// Case #17: String, Empty. Empty string as Text returns 0.
		oParser = new parserFormula('DECIMAL("",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String, Empty. Empty string as Text returns 0.');
		// Case #18: Number, Number. Radix as float number truncated to 2.
		oParser = new parserFormula('DECIMAL(10,2.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(10,2.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, Number. Radix as float number truncated to 2.');
		// Case #19: Formula, Number. Text argument from formula concatenation.
		oParser = new parserFormula('DECIMAL(CONCATENATE("1","0"),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(CONCATENATE("1","0"),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula, Number. Text argument from formula concatenation.');
		// Case #20: String, Formula. Radix from ROUND formula returning 3.
		oParser = new parserFormula('DECIMAL("10",ROUND(2.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",ROUND(2.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String, Formula. Radix from ROUND formula returning 3.');
		// Case #21: Formula, Formula. Both arguments from nested IF formulas.
		oParser = new parserFormula('DECIMAL(IF(TRUE,"10","20"),IF(TRUE,2,10))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(IF(TRUE,"10","20"),IF(TRUE,2,10)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula, Formula. Both arguments from nested IF formulas.');
		// Case #22: Reference link(2). Text and Radix from reference links.
		oParser = new parserFormula('DECIMAL(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Reference link(2). Text and Radix from reference links.');
		// Case #23: Area(2). Single-cell areas for both arguments.
		oParser = new parserFormula('DECIMAL(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Area(2). Single-cell areas for both arguments.');
		// Case #24: Array(2). Single-element arrays for both arguments.
		oParser = new parserFormula('DECIMAL({"10"},{"2"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL({"10"},{"2"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 2, 'Test: Positive case: Array(2). Single-element arrays for both arguments.');
		// Case #25: Name(2). Named ranges for both arguments.
		oParser = new parserFormula('DECIMAL(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Name(2). Named ranges for both arguments.');
		// Case #26: Name3D(2). 3D named ranges for both arguments.
		oParser = new parserFormula('DECIMAL(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Name3D(2). 3D named ranges for both arguments.');
		// Case #27: Ref3D(2). 3D references for both arguments.
		oParser = new parserFormula('DECIMAL(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Ref3D(2). 3D references for both arguments.');
		// Case #28: Area3D(2). 3D single-cell areas for both arguments.
		oParser = new parserFormula('DECIMAL(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Area3D(2). 3D single-cell areas for both arguments.');
		// Case #29: Area3D, Number. Multi-cell area for Text argument. Returns array result.
		oParser = new parserFormula('DECIMAL(Sheet2!A1:A2,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(Sheet2!A1:A2,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Area3D, Number. Multi-cell area for Text argument. Returns array result.');
		// Case #30: String, Area3D. Multi-cell area for Radix argument. Returns array result.
		oParser = new parserFormula('DECIMAL("10",Sheet2!A2:A3)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 16, 'Test: Positive case: String, Area3D. Multi-cell area for Radix argument. Returns array result.');
		// Case #31: Table(2). Table structured references for both arguments.
		oParser = new parserFormula('DECIMAL(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Table(2). Table structured references for both arguments.');
		// Case #32: Formula. DECIMAL used inside SUM formula. Returns 7 (2+5).
		oParser = new parserFormula('SUM(DECIMAL("10",2),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DECIMAL("10",2),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Formula. DECIMAL used inside SUM formula. Returns 7 (2+5).');
		// Case #33: String, Formula. Radix from DATE formula (serial number >= 2).
		oParser = new parserFormula('DECIMAL("10",DATE(1900,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",DATE(1900,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String, Formula. Radix from DATE formula (serial number >= 2).');
		// Case #34: String, Formula. Radix from TIME formula adjusted to >=2.
		oParser = new parserFormula('DECIMAL("10",TIME(12,0,0)+2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",TIME(12,0,0)+2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String, Formula. Radix from TIME formula adjusted to >=2.');
		// Case #35: String, Number. Multiple alphabetic characters in hexadecimal (2748).
		oParser = new parserFormula('DECIMAL("ABC",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("ABC",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2748, 'Test: Positive case: String, Number. Multiple alphabetic characters in hexadecimal (2748).');
		// Case #36: String, Number. Long octal string converted to decimal (342391).
		oParser = new parserFormula('DECIMAL("1234567",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("1234567",8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 342391, 'Test: Positive case: String, Number. Long octal string converted to decimal (342391).');
		// Case #37: Number, Number. Zero as numeric argument.
		oParser = new parserFormula('DECIMAL(0,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(0,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Number. Zero as numeric argument.');
		// Case #38: Formula, Number. Text from text manipulation formula (LEFT).
		oParser = new parserFormula('DECIMAL(LEFT("1010",2),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(LEFT("1010",2),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula, Number. Text from text manipulation formula (LEFT).');
		// Case #39: String, Number. Multiple maximum digits in base 36 (1679615).
		oParser = new parserFormula('DECIMAL("ZZZZ",36)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("ZZZZ",36) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1679615, 'Test: Positive case: String, Number. Multiple maximum digits in base 36 (1679615).');
		// Case #40: String, Number. Standard decimal conversion.
		oParser = new parserFormula('DECIMAL("10",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String, Number. Standard decimal conversion.');
		// Case #41: Reference link, Number. Reference link to cell with hex string.
		oParser = new parserFormula('DECIMAL(A103,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(A103,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link, Number. Reference link to cell with hex string.');
		// Case #42: Area, Number. Multi-cell area for Text argument. Returns array result.
		oParser = new parserFormula('DECIMAL(A100:A101,16)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(A100:A101,16) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 255, 'Test: Positive case: Area, Number. Multi-cell area for Text argument. Returns array result.');
		// Case #43: String, Area. Multi-cell area for Radix argument. Returns array result.
		oParser = new parserFormula('DECIMAL("10",A101:A102)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",A101:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 16, 'Test: Positive case: String, Area. Multi-cell area for Radix argument. Returns array result.');

		// Negative cases:

		// Case #1: String, Number. Radix below minimum (1 < 2) returns #NUM! error.
		oParser = new parserFormula('DECIMAL("10",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Radix below minimum (1 < 2) returns #NUM! error.');
		// Case #2: String, Number. Radix equals 0 returns #NUM! error.
		oParser = new parserFormula('DECIMAL("10",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Radix equals 0 returns #NUM! error.');
		// Case #3: String, Number. Radix above maximum (37 > 36) returns #NUM! error.
		oParser = new parserFormula('DECIMAL("10",37)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",37) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Radix above maximum (37 > 36) returns #NUM! error.');
		// Case #4: String, Number. Negative Radix returns #NUM! error.
		oParser = new parserFormula('DECIMAL("10",-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Negative Radix returns #NUM! error.');
		// Case #5: String, Number. Invalid character "2" for base 2 returns #NUM! error.
		oParser = new parserFormula('DECIMAL("2",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("2",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Invalid character "2" for base 2 returns #NUM! error.');
		// Case #6: String, Number. Character "A" invalid for base 9 returns #NUM! error.
		oParser = new parserFormula('DECIMAL("A",9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("A",9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Character "A" invalid for base 9 returns #NUM! error.');
		// Case #7: String, Number. Character "G" invalid for base 16 returns #NUM! error.
		oParser = new parserFormula('DECIMAL("G",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("G",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Character "G" invalid for base 16 returns #NUM! error.');
		// Case #8: String, Empty. Empty Radix argument returns #VALUE! or #NUM! error.
		oParser = new parserFormula('DECIMAL("10",)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Empty. Empty Radix argument returns #VALUE! or #NUM! error.');
		// Case #9: Empty(2). Both arguments empty returns #NUM! error.
		oParser = new parserFormula('DECIMAL(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty(2). Both arguments empty returns #NUM! error.');
		// Case #10: Error, Number. Error value in Text argument propagates #N/A.
		oParser = new parserFormula('DECIMAL(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error value in Text argument propagates #N/A.');
		// Case #11: String, Error. Error value in Radix argument propagates #N/A.
		oParser = new parserFormula('DECIMAL("10",NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String, Error. Error value in Radix argument propagates #N/A.');
		// Case #12: String, Number. Negative number string returns #NUM! error.
		oParser = new parserFormula('DECIMAL("-10",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("-10",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Negative number string returns #NUM! error.');
		// Case #13: Reference link, Number. Reference link to cell with text returns #VALUE! error.
		oParser = new parserFormula('DECIMAL(A104,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(A104,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Number. Reference link to cell with text returns #VALUE! error.');
		// Case #14: Reference link, Number. Reference link to cell with error returns error.
		oParser = new parserFormula('DECIMAL(A105,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(A105,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number. Reference link to cell with error returns error.');
		// Case #15: String, Reference link. Radix as reference link to cell with text returns #VALUE! error.
		oParser = new parserFormula('DECIMAL("10",A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Reference link. Radix as reference link to cell with text returns #VALUE! error.');
		// Case #16: String, Reference link. Radix as reference link to cell with error returns error.
		oParser = new parserFormula('DECIMAL("10",A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: String, Reference link. Radix as reference link to cell with error returns error.');
		// Case #17: Boolean, Number. Boolean TRUE converted to number 1, then to string "1" for conversion.
		oParser = new parserFormula('DECIMAL(TRUE,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(TRUE,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number. Boolean TRUE converted to number 1, then to string "1" for conversion.');
		// Case #18: String, Boolean. Boolean FALSE (0) as Radix returns #NUM! error.
		oParser = new parserFormula('DECIMAL("10",FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Boolean. Boolean FALSE (0) as Radix returns #NUM! error.');
		// Case #19: String, Number. Number exceeding 2^53 may result in loss of precision.
		oParser = new parserFormula('DECIMAL("10000000000000000",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10000000000000000",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10000000000000000, 'Test: Negative case: String, Number. Number exceeding 2^53 may result in loss of precision.');
		// Case #20: String, Number. Special characters in Text returns #NUM! or #VALUE! error.
		oParser = new parserFormula('DECIMAL("@#$",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("@#$",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Special characters in Text returns #NUM! or #VALUE! error.');
		// Case #21: Number, Number. Decimal point in Text returns #NUM! error.
		oParser = new parserFormula('DECIMAL(10.5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(10.5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Decimal point in Text returns #NUM! error.');
		// Case #22: String, Number. Float Radix truncated to 1, which is < 2, returns #NUM! error.
		oParser = new parserFormula('DECIMAL("10",1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Float Radix truncated to 1, which is < 2, returns #NUM! error.');
		// Case #23: String, String. Non-numeric string as Radix returns #VALUE! error.
		oParser = new parserFormula('DECIMAL("10","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. Non-numeric string as Radix returns #VALUE! error.');
		// Case #24: Array, Number. Array with invalid character for radix 10 returns #NUM! error.
		oParser = new parserFormula('DECIMAL({"G"},10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL({"G"},10) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#NUM!', 'Test: Negative case: Array, Number. Array with invalid character for radix 10 returns #NUM! error.');
		// Case #25: Formula, Number. Formula returning #NUM! error propagates error.
		oParser = new parserFormula('DECIMAL(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula returning #NUM! error propagates error.');
		// Case #26: String, Number. Text with leading/trailing spaces may return error or trim automatically.
		oParser = new parserFormula('DECIMAL(" 10 ",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(" 10 ",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Text with leading/trailing spaces may return error or trim automatically.');
		// Case #27: String, Number. Character "8" invalid for base 8 (octal) returns #NUM! error.
		oParser = new parserFormula('DECIMAL("8",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("8",8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Character "8" invalid for base 8 (octal) returns #NUM! error.');
		// Case #28: Number, Number. Negative number as Text returns #NUM! error.
		oParser = new parserFormula('DECIMAL(-5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(-5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative number as Text returns #NUM! error.');

		// Bounded cases:

		// Case #1: String, Number. Minimum valid radix (2) with valid Text. Returns 1.
		oParser = new parserFormula('DECIMAL("1",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("1",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: String, Number. Minimum valid radix (2) with valid Text. Returns 1.');
		// Case #2: String, Number. Maximum valid radix (36) with maximum single character. Returns 35.
		oParser = new parserFormula('DECIMAL("Z",36)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("Z",36) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 35, 'Test: Bounded case: String, Number. Maximum valid radix (36) with maximum single character. Returns 35.');
		// Case #3: String, Number. Minimum valid Text value (0). Returns 0.
		oParser = new parserFormula('DECIMAL("0",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("0",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: String, Number. Minimum valid Text value (0). Returns 0.');
		// Case #4: String, Number. Maximum binary string close to 2^53.
		oParser = new parserFormula('DECIMAL("11111111111111111111111111111111111111111111111111",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("11111111111111111111111111111111111111111111111111",2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1125900000000000, 'Test: Bounded case: String, Number. Maximum binary string close to 2^53.');
		// Case #5: String, Number. Maximum hexadecimal value close to 2^53 (9007199254740990).
		oParser = new parserFormula('DECIMAL("1FFFFFFFFFFFE",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("1FFFFFFFFFFFE",16) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 562950000000000, 'Test: Bounded case: String, Number. Maximum hexadecimal value close to 2^53 (9007199254740990).');
		// Case #6: String, Number. Large base 36 value within 2^53 limit.
		oParser = new parserFormula('DECIMAL("FFFFFFFFFFFFFF",36)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("FFFFFFFFFFFFFF",36) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.631832377627778e+21, 'Test: Bounded case: String, Number. Large base 36 value within 2^53 limit.');
		// Case #7: Area, Number. Whole column as Text argument.
		oParser = new parserFormula('DECIMAL(A:A,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL(A:A,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Area, Number. Whole column as Text argument.');
		// Case #8: String, Area. Whole row as Radix argument.
		oParser = new parserFormula('DECIMAL("10",100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DECIMAL("10",100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: String, Area. Whole row as Radix argument.');

        // Need to fix: big num precision
        // Case #4: String, Number. Maximum binary string close to 2^53.
        // Case #5: String, Number. Maximum hexadecimal value close to 2^53 (9007199254740990).

		testArrayFormula2(assert, "DECIMAL", 2, 2);
	});

	QUnit.test("Test: \"DEGREES\"", function (assert) {

        ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("-1");
		ws.getRange2("A102").setValue("");
		ws.getRange2("A103").setValue("text");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Column1
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("-1");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1"); // TestName
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1") // TestName3D

		// Positive cases:

		// Case #1: Formula. Return 180
		oParser = new parserFormula('DEGREES(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Positive case: Formula. Return 180');
		// Case #2: Number. Basic valid input: positive integer. 1 argument used.
		oParser = new parserFormula('DEGREES(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Number. Basic valid input: positive integer. 1 argument used.');
		// Case #3: Number. Negative number input. 1 argument used.
		oParser = new parserFormula('DEGREES(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '-57.29577951', 'Test: Positive case: Number. Negative number input. 1 argument used.');
		// Case #4: Number. PI value in radians. 1 argument used.
		oParser = new parserFormula('DEGREES(3.14159265358979)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(3.14159265358979) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '180', 'Test: Positive case: Number. PI value in radians. 1 argument used.');
		// Case #5: Number. Zero returns zero degrees. 1 argument used.
		oParser = new parserFormula('DEGREES(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero returns zero degrees. 1 argument used.');
		// Case #6: Formula. PI function returning radians. 1 argument used.
		oParser = new parserFormula('DEGREES(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Positive case: Formula. PI function returning radians. 1 argument used.');
		// Case #7: Formula. Two PI (full circle). 1 argument used.
		oParser = new parserFormula('DEGREES(2*PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(2*PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Formula. Two PI (full circle). 1 argument used.');
		// Case #8: Formula. Negative PI value. 1 argument used.
		oParser = new parserFormula('DEGREES(-PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(-PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -180, 'Test: Positive case: Formula. Negative PI value. 1 argument used.');
		// Case #9: Number. PI/2 value (90 degrees). 1 argument used.
		oParser = new parserFormula('DEGREES(1.5707963267949)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(1.5707963267949) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '90', 'Test: Positive case: Number. PI/2 value (90 degrees). 1 argument used.');
		// Case #10: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('DEGREES("1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES("1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '85.94366927', 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #11: Formula. Nested formula. 1 argument used.
		oParser = new parserFormula('DEGREES(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '114.591559', 'Test: Positive case: Formula. Nested formula. 1 argument used.');
		// Case #12: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('DEGREES(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #13: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('DEGREES(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #14: Area. Multi-cell range with valid numbers. 1 argument used.
		oParser = new parserFormula('DEGREES(A100:A101)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(8), '57.29577951', 'Test: Positive case: Area. Multi-cell range with valid numbers. 1 argument used.');
		// Case #15: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('DEGREES({1.5708})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES({1.5708}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 90.0002104591497, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #16: Array. Multi-element array. 1 argument used.
		oParser = new parserFormula('DEGREES({0;1.5708;3.14159})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES({0;1.5708;3.14159}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 0, 'Test: Positive case: Array. Multi-element array. 1 argument used.');
		// Case #17: Name. Named range. 1 argument used.
		oParser = new parserFormula('DEGREES(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Name. Named range. 1 argument used.');
		// Case #18: Name3D. 3D named range. 1 argument used.
		oParser = new parserFormula('DEGREES(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Name3D. 3D named range. 1 argument used.');
		// Case #19: Ref3D. 3D reference to cell. 1 argument used.
		oParser = new parserFormula('DEGREES(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Ref3D. 3D reference to cell. 1 argument used.');
		// Case #20: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('DEGREES(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #21: Area3D. 3D multi-cell range. 1 argument used.
		oParser = new parserFormula('DEGREES(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Area3D. 3D multi-cell range. 1 argument used.');
		// Case #22: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('DEGREES(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #23: Date. Date as serial number. 1 argument used.
		oParser = new parserFormula('DEGREES(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '2616010.701', 'Test: Positive case: Date. Date as serial number. 1 argument used.');
		// Case #24: Time. Time formula adjusted. 1 argument used.
		oParser = new parserFormula('DEGREES(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '85.94366927', 'Test: Positive case: Time. Time formula adjusted. 1 argument used.');
		// Case #25: Formula. DEGREES inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(DEGREES(1),DEGREES(2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DEGREES(1),DEGREES(2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '171.8873385', 'Test: Positive case: Formula. DEGREES inside SUM formula. 1 argument used.');
		// Case #26: String. String representation of PI. 1 argument used.
		oParser = new parserFormula('DEGREES("3.14159")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES("3.14159") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '179.999848', 'Test: Positive case: String. String representation of PI. 1 argument used.');
		// Case #27: Number. Two PI value (360 degrees). 1 argument used.
		oParser = new parserFormula('DEGREES(6.28318530717959)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(6.28318530717959) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '360', 'Test: Positive case: Number. Two PI value (360 degrees). 1 argument used.');
		// Case #28: Formula. Nested IF returning valid value. 1 argument used.
		oParser = new parserFormula('DEGREES(IF(TRUE,1.5708,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(IF(TRUE,1.5708,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '90.00021046', 'Test: Positive case: Formula. Nested IF returning valid value. 1 argument used.');
		// Case #29: Number. Large positive number. 1 argument used.
		oParser = new parserFormula('DEGREES(1E+10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(1E+10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 572958000000, 'Test: Positive case: Number. Large positive number. 1 argument used.');
		// Case #30: Number. Large negative number. 1 argument used.
		oParser = new parserFormula('DEGREES(-1E+10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(-1E+10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -572958000000, 'Test: Positive case: Number. Large negative number. 1 argument used.');
		// Case #31: Formula. DEGREES of sine result. 1 argument used.
		oParser = new parserFormula('DEGREES(SIN(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(SIN(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '48.21273601', 'Test: Positive case: Formula. DEGREES of sine result. 1 argument used.');
		// Case #32: String. Date string converted to serial. 1 argument used.
		oParser = new parserFormula('DEGREES("12/31/2024")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES("12/31/2024") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '2615953.405', 'Test: Positive case: String. Date string converted to serial. 1 argument used.');
		// Case #33: Boolean. Boolean TRUE converted to 1. 1 argument used.
		oParser = new parserFormula('DEGREES(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '57.29577951', 'Test: Positive case: Boolean. Boolean TRUE converted to 1. 1 argument used.');
		// Case #34: Formula. Nested RADIANS formula. 1 argument used.
		oParser = new parserFormula('DEGREES(RADIANS(180))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(RADIANS(180)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Positive case: Formula. Nested RADIANS formula. 1 argument used.');
		// Case #35: Empty. Reference to empty cell. 1 argument used.
		oParser = new parserFormula('DEGREES(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty. Reference to empty cell. 1 argument used.');
		// Case #36: Boolean. Boolean FALSE returns 0 or error. 1 argument used.
		oParser = new parserFormula('DEGREES(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean. Boolean FALSE returns 0 or error. 1 argument used.');

		// Negative cases:

		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('DEGREES("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: String. Mixed string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('DEGREES("text123")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES("text123") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Mixed string returns #VALUE!. 1 argument used.');
		// Case #3: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('DEGREES(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #4: Error. Propagates #DIV/0! error. 1 argument used.
		oParser = new parserFormula('DEGREES(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Propagates #DIV/0! error. 1 argument used.');
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('DEGREES("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #6: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('DEGREES(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #7: Array. Array with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('DEGREES({"text"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES({"text"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), '#VALUE!', 'Test: Negative case: Array. Array with text returns #VALUE!. 1 argument used.');
		// Case #8: String. Currency string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('DEGREES("$100")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES("$100") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Currency string returns #VALUE!. 1 argument used.');
		// Case #9: String. String looks like error. 1 argument used.
		oParser = new parserFormula('DEGREES("#REF!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES("#REF!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String looks like error. 1 argument used.');
		// Case #10: Error. Propagates #REF! error. 1 argument used.
		oParser = new parserFormula('DEGREES(#REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(#REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Error. Propagates #REF! error. 1 argument used.');
		// Case #11: Error. Propagates #NAME? error. 1 argument used.
		oParser = new parserFormula('DEGREES(#NAME?)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(#NAME?) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Error. Propagates #NAME? error. 1 argument used.');
		// Case #12: Array. Array with mixed types. 1 argument used.
		oParser = new parserFormula('DEGREES({1;"text"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES({1;"text"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 57.29577951308232, 'Test: Negative case: Array. Array with mixed types. 1 argument used.');
		// Case #13: Formula. IF returning text. 1 argument used.
		oParser = new parserFormula('DEGREES(IF(FALSE,1,"error"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(IF(FALSE,1,"error")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. IF returning text. 1 argument used.');
		// Case #14: String. String with space returns #VALUE!. 1 argument used.
		oParser = new parserFormula('DEGREES(" ")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(" ") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String with space returns #VALUE!. 1 argument used.');
		// Case #15: String. String with overflow value. 1 argument used.
		oParser = new parserFormula('DEGREES("1E+400")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES("1E+400") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String with overflow value. 1 argument used.');
		// Case #16: Formula. Formula with invalid calculation. 1 argument used.
		oParser = new parserFormula('DEGREES(LOG(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(LOG(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula with invalid calculation. 1 argument used.');
		// Case #17: Reference link. Reference to cell with text. 1 argument used.
		oParser = new parserFormula('DEGREES(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to cell with text. 1 argument used.');

		// Bounded cases:

		// Case #1: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('DEGREES(9.99999999999999E+305)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(9.99999999999999E+305) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #2: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('DEGREES(-9.99999999999999E+305)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(-9.99999999999999E+305) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #3: Area. Entire column reference returns array. 1 argument used.
		oParser = new parserFormula('DEGREES(M:M)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(M:M) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Area. Entire column reference returns array. 1 argument used.');
		// Case #4: Area. Entire row reference returns array. 1 argument used.
		oParser = new parserFormula('DEGREES(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEGREES(100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 57.29577951308232, 'Test: Bounded case: Area. Entire row reference returns array. 1 argument used.');

        // Need to fix: diff results from MS
        // Case #29: Number. Large positive number. 1 argument used.
        // Case #30: Number. Large negative number. 1 argument used.
        // Case #8: String. Currency string returns #VALUE!. 1 argument used.
        // Case #17: Reference link. Reference to cell with text. 1 argument used.

		testArrayFormula(assert, "DEGREES");
	});

	QUnit.test("Test: \"ECMA.CEILING\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2.5");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A102").setValue("-2.5");
		ws.getRange2("A103").setValue("-2");
		ws.getRange2("A104").setValue("2");
		ws.getRange2("A105").setValue("text");
		ws.getRange2("A106").setValue("#N/A");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.5"); // Column1
		ws.getRange2("B601").setValue("0.1"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.234");
		ws2.getRange2("A2").setValue("0.01");
		ws2.getRange2("A3").setValue("2.5");
		ws2.getRange2("A4").setValue("1");
		ws2.getRange2("A5").setValue("text");
		ws2.getRange2("A6").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1.5"); // TestName
		ws.getRange2("A202").setValue("0.1"); // TestName1
		ws.getRange2("A206").setValue("text"); // TestNameArea
		ws.getRange2("A207").setValue("#N/A"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1.5") // TestName3D
		ws2.getRange2("A12").setValue("2") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Rounds 2.5 up to nearest multiple of 1
		oParser = new parserFormula('ECMA.CEILING(2.5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2). Rounds 2.5 up to nearest multiple of 1');
		// Case #2: Number(2). Rounds -2.5 up to nearest multiple of -2
		oParser = new parserFormula('ECMA.CEILING(-2.5,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(-2.5,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number(2). Rounds -2.5 up to nearest multiple of -2');
		// Case #3: Number(2). Rounds -2.5 up to nearest multiple of 2
		oParser = new parserFormula('ECMA.CEILING(-2.5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(-2.5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Number(2). Rounds -2.5 up to nearest multiple of 2');
		// Case #4: Number(2). Rounds 1.5 up to the nearest multiple of 0.1
		oParser = new parserFormula('ECMA.CEILING(1.5,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1.5,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.5', 'Test: Positive case: Number(2). Rounds 1.5 up to the nearest multiple of 0.1');
		// Case #5: Number(2). Rounds 0.234 up to the nearest multiple of 0.01
		oParser = new parserFormula('ECMA.CEILING(0.234,0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(0.234,0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.24', 'Test: Positive case: Number(2). Rounds 0.234 up to the nearest multiple of 0.01');
		// Case #6: Number(2). Basic usage with integer significance. Rounds up to nearest integer multiple of 1.
		oParser = new parserFormula('ECMA.CEILING(2.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2). Basic usage with integer significance. Rounds up to nearest integer multiple of 1.');
		// Case #7: Number(2). Significance > 1. Rounds up to nearest multiple of 2 (result is 4).
		oParser = new parserFormula('ECMA.CEILING(2.5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Number(2). Significance > 1. Rounds up to nearest multiple of 2 (result is 4).');
		// Case #8: Number(2). Negative number with negative significance. Both arguments must have same sign.
		oParser = new parserFormula('ECMA.CEILING(-2.5, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(-2.5, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number(2). Negative number with negative significance. Both arguments must have same sign.');
		// Case #9: Number(2). Decimal significance < 1. Rounds up to nearest multiple of 0.1.
		oParser = new parserFormula('ECMA.CEILING(4.5, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(4.5, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '4.5', 'Test: Positive case: Number(2). Decimal significance < 1. Rounds up to nearest multiple of 0.1.');
		// Case #10: Number(2). Negative number with negative decimal significance < 1.
		oParser = new parserFormula('ECMA.CEILING(-4.5, -0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(-4.5, -0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '-4.5', 'Test: Positive case: Number(2). Negative number with negative decimal significance < 1.');
		// Case #11: Number(2). Zero with positive significance returns 0.
		oParser = new parserFormula('ECMA.CEILING(0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero with positive significance returns 0.');
		// Case #12: Number(2). Zero with negative significance returns 0.
		oParser = new parserFormula('ECMA.CEILING(0, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(0, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero with negative significance returns 0.');
		// Case #13: Number(2). Zero with zero significance returns 0 (special case).
		oParser = new parserFormula('ECMA.CEILING(0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero with zero significance returns 0 (special case).');
		// Case #14: Number, Empty. Omitted significance defaults to 1 (result is 3).
		oParser = new parserFormula('ECMA.CEILING(2.5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Empty. Omitted significance defaults to 1 (result is 3).');
		// Case #15: String(2). String numbers converted to numeric values.
		oParser = new parserFormula('ECMA.CEILING("2.5", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING("2.5", "1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String(2). String numbers converted to numeric values.');
		// Case #16: Formula(2). Using math formulas as arguments (both < 1).
		oParser = new parserFormula('ECMA.CEILING(SIN(PI()/4), COS(PI()/4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(SIN(PI()/4), COS(PI()/4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.707106781', 'Test: Positive case: Formula(2). Using math formulas as arguments (both < 1).');
		// Case #17: Formula. ECMA.CEILING nested inside another formula (result is 13).
		oParser = new parserFormula('SUM(ECMA.CEILING(2.5, 1), 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(ECMA.CEILING(2.5, 1), 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Positive case: Formula. ECMA.CEILING nested inside another formula (result is 13).');
		// Case #18: Reference link(2). Both arguments are cell references.
		oParser = new parserFormula('ECMA.CEILING(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Reference link(2). Both arguments are cell references.');
		// Case #19: Area(2). Both arguments are single-cell areas.
		oParser = new parserFormula('ECMA.CEILING(A102:A102, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(A102:A102, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Area(2). Both arguments are single-cell areas.');
		// Case #20: Array(2). Both arguments are single-element arrays.
		oParser = new parserFormula('ECMA.CEILING({2.5}, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING({2.5}, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 3, 'Test: Positive case: Array(2). Both arguments are single-element arrays.');
		// Case #21: Name(2). Both arguments are named ranges.
		oParser = new parserFormula('ECMA.CEILING(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.5', 'Test: Positive case: Name(2). Both arguments are named ranges.');
		// Case #22: Name3D(2). Both arguments are 3D named ranges.
		oParser = new parserFormula('ECMA.CEILING(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Name3D(2). Both arguments are 3D named ranges.');
		// Case #23: Ref3D(2). Both arguments are 3D references.
		oParser = new parserFormula('ECMA.CEILING(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.24', 'Test: Positive case: Ref3D(2). Both arguments are 3D references.');
		// Case #24: Area3D(2). Both arguments are 3D single-cell areas.
		oParser = new parserFormula('ECMA.CEILING(Sheet2!A1:A1, Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(Sheet2!A1:A1, Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.24', 'Test: Positive case: Area3D(2). Both arguments are 3D single-cell areas.');
		// Case #25: Table. Both arguments are table references.
		oParser = new parserFormula('ECMA.CEILING(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.5', 'Test: Positive case: Table. Both arguments are table references.');
		// Case #26: Array, Number. Multi-element array returns array of results.
		oParser = new parserFormula('ECMA.CEILING({1,2}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING({1,2}, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, 'Test: Positive case: Array, Number. Multi-element array returns array of results.');
		// Case #27: Number, Array. Multi-element array for significance returns array of results.
		oParser = new parserFormula('ECMA.CEILING(1, {1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1, {1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, 'Test: Positive case: Number, Array. Multi-element array for significance returns array of results.');
		// Case #28: Date, Number. Date serial number with integer significance.
		oParser = new parserFormula('ECMA.CEILING(DATE(2023,5,15), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(DATE(2023,5,15), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45061, 'Test: Positive case: Date, Number. Date serial number with integer significance.');
		// Case #29: Time, Number. Time serial number with fractional significance.
		oParser = new parserFormula('ECMA.CEILING(TIME(12,30,0), 0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(TIME(12,30,0), 0.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.75', 'Test: Positive case: Time, Number. Time serial number with fractional significance.');
		// Case #30: Number(2). Larger number with small significance (precision test).
		oParser = new parserFormula('ECMA.CEILING(123.45, 0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(123.45, 0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '123.45', 'Test: Positive case: Number(2). Larger number with small significance (precision test).');
		// Case #31: Number(2). Significance that doesn\'t divide evenly (result is 0.666).
		oParser = new parserFormula('ECMA.CEILING(0.5, 0.333)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(0.5, 0.333) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '0.666', 'Test: Positive case: Number(2). Significance that doesn\'t divide evenly (result is 0.666).');
		// Case #32: Number(2). Number very close to next integer (result is 5).
		oParser = new parserFormula('ECMA.CEILING(4.999, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(4.999, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number(2). Number very close to next integer (result is 5).');
		// Case #33: Number(2). Large number with small significance (result is 1000000).
		oParser = new parserFormula('ECMA.CEILING(1000000, 0.001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1000000, 0.001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000000, 'Test: Positive case: Number(2). Large number with small significance (result is 1000000).');
		// Case #34: Number(2). Large negative number with small negative significance.
		oParser = new parserFormula('ECMA.CEILING(-1000000, -0.001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(-1000000, -0.001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1000000, 'Test: Positive case: Number(2). Large negative number with small negative significance.');
		// Case #35: Number(2). Very small significance value (result is 2.100001).
		oParser = new parserFormula('ECMA.CEILING(2.1, 0.000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.1, 0.000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '2.1', 'Test: Positive case: Number(2). Very small significance value (result is 2.100001).');
		// Case #36: Number(2). Negative number with positive significance.
		oParser = new parserFormula('ECMA.CEILING(-2.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(-2.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Number(2). Negative number with positive significance.');
		// Case #37: Number(2). Non-zero number with zero significance.
		oParser = new parserFormula('ECMA.CEILING(2.5, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Non-zero number with zero significance.');
		// Case #38: Number, Boolean. Boolean FALSE=0 for significance.
		oParser = new parserFormula('ECMA.CEILING(2.5, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Boolean. Boolean FALSE=0 for significance.');
		// Case #39: Empty, Number. Empty first argument.
		oParser = new parserFormula('ECMA.CEILING(, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number. Empty first argument.');
		// Case #40: Number, Empty. Second argument is empty.
		oParser = new parserFormula('ECMA.CEILING(1, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Empty. Second argument is empty.');

		// Negative cases:

		// Case #1: Number(2). #NUM! error: Positive number with negative significance.
		oParser = new parserFormula('ECMA.CEILING(2.5, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). #NUM! error: Positive number with negative significance.');
		// Case #2: Number(2). #NUM! error: Opposing signs with large numbers.
		oParser = new parserFormula('ECMA.CEILING(1E+100, -1E+100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1E+100, -1E+100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). #NUM! error: Opposing signs with large numbers.');
		// Case #3: Formula, Number. #NUM! error: Formula resulting in error propagates.
		oParser = new parserFormula('ECMA.CEILING(SQRT(-1), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(SQRT(-1), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. #NUM! error: Formula resulting in error propagates.');
		// Case #4: Number, Formula. #NUM! error: Error in significance formula propagates.
		oParser = new parserFormula('ECMA.CEILING(2.5, SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5, SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. #NUM! error: Error in significance formula propagates.');
		// Case #5: String(2). #VALUE! error: Non-numeric string in first argument.
		oParser = new parserFormula('ECMA.CEILING("abc", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING("abc", "1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). #VALUE! error: Non-numeric string in first argument.');
		// Case #6: String(2). #VALUE! error: Non-numeric string in second argument.
		oParser = new parserFormula('ECMA.CEILING("2.5", "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING("2.5", "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). #VALUE! error: Non-numeric string in second argument.');
		// Case #7: Number, String. #VALUE! error: Text significance that cannot be converted.
		oParser = new parserFormula('ECMA.CEILING(2.5, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. #VALUE! error: Text significance that cannot be converted.');
		// Case #8: Area, Number. #VALUE! error: Multi-cell range in first argument with text and error.
		oParser = new parserFormula('ECMA.CEILING(A105:A106, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(A105:A106, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. #VALUE! error: Multi-cell range in first argument with text and error.');
		// Case #9: Number, Area. #VALUE! error: Multi-cell range in second argument with text and error.
		oParser = new parserFormula('ECMA.CEILING(1, A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1, A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. #VALUE! error: Multi-cell range in second argument with text and error.');
		// Case #10: Area3D, Number. #VALUE! error: 3D multi-cell range in first argument with text and error
		oParser = new parserFormula('ECMA.CEILING(Sheet2!A5:A6, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(Sheet2!A5:A6, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number. #VALUE! error: 3D multi-cell range in first argument with text and error');
		// Case #11: Number, Area3D. #VALUE! error: 3D multi-cell range in second argument with text and error
		oParser = new parserFormula('ECMA.CEILING(1, Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1, Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D. #VALUE! error: 3D multi-cell range in second argument with text and error');
		// Case #12: Name, Number. #VALUE! error: Named range with multiple cells in first argument with text and error.
		oParser = new parserFormula('ECMA.CEILING(TestNameArea, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(TestNameArea, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number. #VALUE! error: Named range with multiple cells in first argument with text and error.');
		// Case #13: Number, Name. #VALUE! error: Named range with multiple cells in second argument.
		oParser = new parserFormula('ECMA.CEILING(1, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1, TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name. #VALUE! error: Named range with multiple cells in second argument.');
		// Case #14: Error, Number. #N/A error: Error value in first argument propagates.
		oParser = new parserFormula('ECMA.CEILING(NA(), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(NA(), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. #N/A error: Error value in first argument propagates.');
		// Case #15: Number, Error. #N/A error: Error in second argument propagates.
		oParser = new parserFormula('ECMA.CEILING(2.5, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(2.5, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. #N/A error: Error in second argument propagates.');
		// Case #16: String, Number. #VALUE! error: String representing invalid formula.
		oParser = new parserFormula('ECMA.CEILING("0/1", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING("0/1", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. #VALUE! error: String representing invalid formula.');
		// Case #17: Number(2). Potential overflow with number close to maximum limit.
		oParser = new parserFormula('ECMA.CEILING(9.99999E+307, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(9.99999E+307, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Potential overflow with number close to maximum limit.');

		// Bounded cases:

		// Case #1: Number(2). Minimum case where number equals significance (integer).
		oParser = new parserFormula('ECMA.CEILING(1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Minimum case where number equals significance (integer).');
		// Case #2: Number(2). Minimum positive number with equal significance.
		oParser = new parserFormula('ECMA.CEILING(0.000000001, 0.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(0.000000001, 0.000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-9, 'Test: Bounded case: Number(2). Minimum positive number with equal significance.');
		// Case #3: Number(2). Maximum negative number with equal significance.
		oParser = new parserFormula('ECMA.CEILING(-0.000000001, -0.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(-0.000000001, -0.000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-9, 'Test: Bounded case: Number(2). Maximum negative number with equal significance.');
		// Case #4: Number(2). Maximum positive number Excel can handle.
		oParser = new parserFormula('ECMA.CEILING(1.79769E+307, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1.79769E+307, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.79769e+307, 'Test: Bounded case: Number(2). Maximum positive number Excel can handle.');
		// Case #5: Number(2). Minimum negative number Excel can handle.
		oParser = new parserFormula('ECMA.CEILING(-1.79769E+307, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(-1.79769E+307, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.79769e+307, 'Test: Bounded case: Number(2). Minimum negative number Excel can handle.');
		// Case #6: Number(2). Very large number with small significance.
		oParser = new parserFormula('ECMA.CEILING(9.99999999999999E+306, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(9.99999999999999E+306, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.999999999999991e+306, 'Test: Bounded case: Number(2). Very large number with small significance.');
		// Case #7: Number(2). Very small positive number with equal significance.
		oParser = new parserFormula('ECMA.CEILING(1E-307, 1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(1E-307, 1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number(2). Very small positive number with equal significance.');
		// Case #8: Number(2). Very small negative number with equal significance.
		oParser = new parserFormula('ECMA.CEILING(-1E-307, -1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ECMA.CEILING(-1E-307, -1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-307, 'Test: Bounded case: Number(2). Very small negative number with equal significance.');
	});

	QUnit.test("Test: \"EVEN\"", function (assert) {

		oParser = new parserFormula("EVEN(1.5)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula("EVEN(3)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		oParser = new parserFormula("EVEN(2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula("EVEN(-1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -2);

		ws.getRange2("A100:D210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: positive integer. 1 argument used.
		oParser = new parserFormula('EVEN(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Basic valid input: positive integer. 1 argument used.');
		// Case #1: Number. Basic valid input: negative integer. 1 argument used.
		oParser = new parserFormula('EVEN(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Number. Basic valid input: negative integer. 1 argument used.');
		// Case #2: Number. Float input: positive decimal. 1 argument used.
		oParser = new parserFormula('EVEN(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Float input: positive decimal. 1 argument used.');
		// Case #3: Number. Float input: negative decimal. 1 argument used.
		oParser = new parserFormula('EVEN(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Number. Float input: negative decimal. 1 argument used.');
		// Case #4: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('EVEN("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #5: String. String convertible to negative number. 1 argument used.
		oParser = new parserFormula('EVEN("-2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN("-2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: String. String convertible to negative number. 1 argument used.');
		// Case #6: Formula. Nested formula returning integer. 1 argument used.
		oParser = new parserFormula('EVEN(SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Nested formula returning integer. 1 argument used.');
		// Case #7: Formula. Nested formula returning float. 1 argument used.
		oParser = new parserFormula('EVEN(ABS(-1.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(ABS(-1.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Nested formula returning float. 1 argument used.');
		// Case #8: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('EVEN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #9: Area. Single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('EVEN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area. Single-cell range with valid number. 1 argument used.');
		// Case #10: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('EVEN({3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN({3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 4, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #11: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('EVEN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #12: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('EVEN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #13: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('EVEN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #14: Area3D. 3D single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('EVEN(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D single-cell range with valid number. 1 argument used.');
		// Case #15: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('EVEN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #16: Date. Date as serial number. 1 argument used.
		oParser = new parserFormula('EVEN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date. Date as serial number. 1 argument used.');
		// Case #17: Time. Time adjusted to valid number. 1 argument used.
		oParser = new parserFormula('EVEN(TIME(12,0,0)*100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(TIME(12,0,0)*100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Time. Time adjusted to valid number. 1 argument used.');
		// Case #18: Formula. EVEN inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(EVEN(2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(EVEN(2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. EVEN inside SUM formula. 1 argument used.');
		// Case #19: Array. Multi-element array, processes first element. 1 argument used.
		oParser = new parserFormula('EVEN({1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN({1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Array. Multi-element array, processes first element. 1 argument used.');
		// Case #20: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('EVEN(IF(TRUE,2,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(IF(TRUE,2,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');

		// Negative cases:
		// Case #0: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #1: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('EVEN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #2: Empty. Reference to empty cell returns 0 (Excel behavior). 1 argument used.
		oParser = new parserFormula('EVEN(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Empty. Reference to empty cell returns 0 (Excel behavior). 1 argument used.');
		// Case #3: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #4: Boolean. Boolean TRUE (1) returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('EVEN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result but unexpected type. 1 argument used.');
		// Case #5: Boolean. Boolean FALSE (0) returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('EVEN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean FALSE (0) returns valid result but unexpected type. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #7: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('EVEN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #12: String. Date string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN("1/1/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN("1/1/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Negative case: String. Date string returns #VALUE!. 1 argument used.');
		// Case #13: Array. Array with boolean returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('EVEN({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN({TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Negative case: Array. Array with boolean returns valid result but unexpected type. 1 argument used.');
		// Case #14: Time. Time value (0.5) returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('EVEN(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Time. Time value (0.5) returns valid result but unexpected type. 1 argument used.');
		// Case #15: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('EVEN(SUM(1,1.1,1.11))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(SUM(1,1.1,1.11)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #16: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #17: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #18: String. String representing out-of-range number returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN("1.5E+308")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN("1.5E+308") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String representing out-of-range number returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('EVEN(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #20: Name. Named range with error returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EVEN(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Name. Named range with error returns #VALUE!. 1 argument used.');

		// Bounded cases:
		// Case #0: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('EVEN(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #1: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('EVEN(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -9.99999999999999e+307, 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #2: Number. Smallest positive Excel number. 1 argument used.
		oParser = new parserFormula('EVEN(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Number. Smallest positive Excel number. 1 argument used.');
		// Case #3: Number. Smallest negative Excel number. 1 argument used.
		oParser = new parserFormula('EVEN(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EVEN(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Bounded case: Number. Smallest negative Excel number. 1 argument used.');

		// Need to fix:
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.

		testArrayFormula(assert, "EVEN");

	});

	QUnit.test("Test: \"EXP\"", function (assert) {

		oParser = new parserFormula("EXP(1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 2.71828183);

		oParser = new parserFormula("EXP(2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 7.3890561);

		ws.getRange2("A100:D210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: positive integer. 1 argument used.
		oParser = new parserFormula('EXP(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.38905609893065, 'Test: Positive case: Number. Basic valid input: positive integer. 1 argument used.');
		// Case #1: Number. Basic valid input: negative integer. 1 argument used.
		oParser = new parserFormula('EXP(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1353352832366127, 'Test: Positive case: Number. Basic valid input: negative integer. 1 argument used.');
		// Case #2: Number. Float input: positive decimal. 1 argument used.
		oParser = new parserFormula('EXP(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.4816890703380645, 'Test: Positive case: Number. Float input: positive decimal. 1 argument used.');
		// Case #3: Number. Float input: negative decimal. 1 argument used.
		oParser = new parserFormula('EXP(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22313016014842982, 'Test: Positive case: Number. Float input: negative decimal. 1 argument used.');
		// Case #4: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('EXP("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.38905609893065, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #5: String. String convertible to negative number. 1 argument used.
		oParser = new parserFormula('EXP("-2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP("-2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1353352832366127, 'Test: Positive case: String. String convertible to negative number. 1 argument used.');
		// Case #6: Formula. Nested formula returning integer. 1 argument used.
		oParser = new parserFormula('EXP(SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20.085536923187668, 'Test: Positive case: Formula. Nested formula returning integer. 1 argument used.');
		// Case #7: Formula. Nested formula returning float. 1 argument used.
		oParser = new parserFormula('EXP(ABS(-1.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(ABS(-1.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.4816890703380645, 'Test: Positive case: Formula. Nested formula returning float. 1 argument used.');
		// Case #8: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('EXP(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6487212707001282, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #9: Area. Single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('EXP(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.4816890703380645, 'Test: Positive case: Area. Single-cell range with valid number. 1 argument used.');
		// Case #10: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('EXP({3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP({3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 20.08553692, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #11: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('EXP(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6065306597126334, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #12: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('EXP(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6065306597126334, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #13: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('EXP(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6487212707001282, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #14: Area3D. 3D single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('EXP(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6487212707001282, 'Test: Positive case: Area3D. 3D single-cell range with valid number. 1 argument used.');
		// Case #15: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('EXP(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.718281828459045, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #16: Date. Date as serial number. 1 argument used.
		oParser = new parserFormula('EXP(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Date. Date as serial number. 1 argument used.');
		// Case #17: Time. Time adjusted to valid number. 1 argument used.
		oParser = new parserFormula('EXP(TIME(12,0,0)*100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(TIME(12,0,0)*100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.184705528587072e+21, 'Test: Positive case: Time. Time adjusted to valid number. 1 argument used.');
		// Case #18: Formula. ODD inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(EXP(2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(EXP(2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.38905609893065, 'Test: Positive case: Formula. ODD inside SUM formula. 1 argument used.');
		// Case #19: Array. Multi-element array, processes first element. 1 argument used.
		oParser = new parserFormula('EXP({1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP({1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.718281828, 'Test: Positive case: Array. Multi-element array, processes first element. 1 argument used.');
		// Case #20: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('EXP(IF(TRUE,2,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(IF(TRUE,2,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.38905609893065, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');

		// Negative cases:
		// Case #0: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #1: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('EXP(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #2: Empty. Reference to empty cell returns 0 (Excel behavior). 1 argument used.
		oParser = new parserFormula('EXP(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6487212707001282, 'Test: Negative case: Empty. Reference to empty cell returns 0 (Excel behavior). 1 argument used.');
		// Case #3: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #4: Boolean. Boolean TRUE (1) returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('EXP(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.718281828459045, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result but unexpected type. 1 argument used.');
		// Case #5: Boolean. Boolean FALSE (0) returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('EXP(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean FALSE (0) returns valid result but unexpected type. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #7: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.4816890703380645, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.225540928492468, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.225540928492468, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #10: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #11: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('EXP(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #12: String. Date string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP("1/1/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP("1/1/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Date string returns #VALUE!. 1 argument used.');
		// Case #13: Array. Array with boolean returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('EXP({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP({TRUE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.718281828, 'Test: Negative case: Array. Array with boolean returns valid result but unexpected type. 1 argument used.');
		// Case #14: Time. Time value (0.5) returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('EXP(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6487212707001282, 'Test: Negative case: Time. Time value (0.5) returns valid result but unexpected type. 1 argument used.');
		// Case #15: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('EXP(SUM(1,1.1,1.0001))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(SUM(1,1.1,1.0001)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 22.200171187563242, 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #16: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.718281828459045, 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #17: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #18: String. String representing out-of-range number returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP("1.5E+308")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP("1.5E+308") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String representing out-of-range number returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('EXP(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #20: Name. Named range with error returns #VALUE!. 1 argument used.
		oParser = new parserFormula('EXP(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6487212707001282, 'Test: Negative case: Name. Named range with error returns #VALUE!. 1 argument used.');

		// Bounded cases:
		// Case #0: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('EXP(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #1: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('EXP(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #2: Number. Smallest positive Excel number. 1 argument used.
		oParser = new parserFormula('EXP(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Smallest positive Excel number. 1 argument used.');
		// Case #3: Number. Smallest negative Excel number. 1 argument used.
		oParser = new parserFormula('EXP(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXP(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Smallest negative Excel number. 1 argument used.');

		// Need to fix:
		// Case #10: Array. Array with single element. 1 argument used.
		// Case #19: Array. Multi-element array, processes first element. 1 argument used.
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #13: Array. Array with boolean returns valid result but unexpected type. 1 argument used.

		testArrayFormula(assert, "EXP");

	});

	QUnit.test("Test: \"FACT\"", function (assert) {
		oParser = new parserFormula("FACT(5)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 120);

		oParser = new parserFormula("FACT(1.9)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("FACT(0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("FACT(-1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("FACT(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("5"); // Num (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: positive integer. 1 argument used.
		oParser = new parserFormula('FACT(5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: Number. Basic valid input: positive integer. 1 argument used.');
		// Case #2: String. String convertible to valid number. 1 argument used.
		oParser = new parserFormula('FACT("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: String. String convertible to valid number. 1 argument used.');
		// Case #3: Formula. Nested formula returning valid integer. 1 argument used.
		oParser = new parserFormula('FACT(ROUND(5.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(ROUND(5.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 720, 'Test: Positive case: Formula. Nested formula returning valid integer. 1 argument used.');
		// Case #4: Number. Non-integer truncated to integer. 1 argument used.
		oParser = new parserFormula('FACT(5.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(5.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: Number. Non-integer truncated to integer. 1 argument used.');
		// Case #5: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('FACT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #6: Area. Single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('FACT(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Single-cell range with valid number. 1 argument used.');
		// Case #7: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('FACT({5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT({5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 120, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #8: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('FACT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #9: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('FACT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('FACT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #11: Area3D. 3D single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('FACT(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell range with valid number. 1 argument used.');
		// Case #12: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('FACT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #13: Date. Date as serial number (large integer). 1 argument used.
		oParser = new parserFormula('FACT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Date. Date as serial number (large integer). 1 argument used.');
		// Case #14: Time. Time adjusted to valid number. 1 argument used.
		oParser = new parserFormula('FACT(TIME(12,0,0)+5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(TIME(12,0,0)+5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: Time. Time adjusted to valid number. 1 argument used.');
		// Case #15: Formula. Nested SUM formula returning valid number. 1 argument used.
		oParser = new parserFormula('FACT(SUM(2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(SUM(2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: Formula. Nested SUM formula returning valid number. 1 argument used.');
		// Case #16: Number. Larger valid integer. 1 argument used.
		oParser = new parserFormula('FACT(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3628800, 'Test: Positive case: Number. Larger valid integer. 1 argument used.');
		// Case #17: String. String convertible to number, truncated to integer. 1 argument used.
		oParser = new parserFormula('FACT("10.9")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT("10.9") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3628800, 'Test: Positive case: String. String convertible to number, truncated to integer. 1 argument used.');
		// Case #18: Array. Array with multiple valid elements. 1 argument used.
		oParser = new parserFormula('FACT({5,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT({5,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 120, 'Test: Positive case: Array. Array with multiple valid elements. 1 argument used.');
		// Case #19: Formula. Nested IF formula returning valid number. 1 argument used.
		oParser = new parserFormula('FACT(IF(TRUE,5,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(IF(TRUE,5,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: Formula. Nested IF formula returning valid number. 1 argument used.');
		// Case #20: Formula. Nested FLOOR formula returning valid integer. 1 argument used.
		oParser = new parserFormula('FACT(FLOOR(5.9,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(FLOOR(5.9,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: Formula. Nested FLOOR formula returning valid integer. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Negative number returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACT(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number returns #NUM!. 1 argument used.');
		// Case #2: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #3: Error. Error input propagates #N/A. 1 argument used.
		oParser = new parserFormula('FACT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error input propagates #N/A. 1 argument used.');
		// Case #4: Empty. Empty input returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty input returns #VALUE!. 1 argument used.');
		// Case #5: Boolean. Boolean TRUE (1) returns valid factorial but tested for completeness. 1 argument used.
		oParser = new parserFormula('FACT(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid factorial but tested for completeness. 1 argument used.');
		// Case #6: Reference link. Reference to cell with zero (valid but tested for edge case). 1 argument used.
		oParser = new parserFormula('FACT(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3628800, 'Test: Negative case: Reference link. Reference to cell with zero (valid but tested for edge case). 1 argument used.');
		// Case #7: Area. Multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACT(A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(A101:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3628800, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 1 argument used.');
		// Case #8: Name. Named range with area returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with area returns #VALUE!. 1 argument used.');
		// Case #9: Name3D. 3D named range with area returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACT(TestName3DArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(TestName3DArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name3D. 3D named range with area returns #VALUE!. 1 argument used.');
		// Case #10: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACT(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #11: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACT(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(Sheet2!A2:A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.');
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACT(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3628800, 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula returning #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('FACT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula returning #NUM! propagates error. 1 argument used.');
		// Case #14: Number. Number too large returns #NUM! due to overflow. 1 argument used.
		oParser = new parserFormula('FACT(171)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(171) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number too large returns #NUM! due to overflow. 1 argument used.');
		// Case #15: String. String convertible to negative number returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACT("-1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT("-1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to negative number returns #NUM!. 1 argument used.');
		// Case #16: Array. Array with boolean returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACT({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Array. Array with boolean returns #NUM!. 1 argument used.');
		// Case #17: Number. Negative decimal returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACT(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative decimal returns #NUM!. 1 argument used.');
		// Case #18: Time. Time value (0.5, truncated to 0) returns valid factorial but tested for edge case. 1 argument used.
		oParser = new parserFormula('FACT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Time. Time value (0.5, truncated to 0) returns valid factorial but tested for edge case. 1 argument used.');
		// Case #19: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #20: Formula. Formula returning #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('FACT(DIVIDE(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(DIVIDE(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Formula. Formula returning #DIV/0! propagates error. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid number (returns 1). 1 argument used.
		oParser = new parserFormula('FACT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid number (returns 1). 1 argument used.');
		// Case #2: Number. Maximum valid number before overflow. 1 argument used.
		oParser = new parserFormula('FACT(170)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(170) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.257415615308004e+306, 'Test: Bounded case: Number. Maximum valid number before overflow. 1 argument used.');
		// Case #3: Number. Small decimal truncated to 0 (returns 1). 1 argument used.
		oParser = new parserFormula('FACT(0.0001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACT(0.0001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Small decimal truncated to 0 (returns 1). 1 argument used.');

		// Need to fix: area handle
		// Case #7: Area. Multi-cell range returns #NUM!. 1 argument used.
		// Case #11: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.

		testArrayFormula(assert, "FACT");
	});

	QUnit.test("Test: \"FACTDOUBLE\"", function (assert) {

		oParser = new parserFormula("FACTDOUBLE(8)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2 * 4 * 6 * 8);

		oParser = new parserFormula("FACTDOUBLE(9)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 9 * 7 * 5 * 3);

		oParser = new parserFormula("FACTDOUBLE(6.5)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 6 * 4 * 2);

		oParser = new parserFormula("FACTDOUBLE(-6)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("FACTDOUBLE(600)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("5"); // Num (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-1.5"); // TestName
		ws.getRange2("A202").setValue("1.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-1.5"); // TestName3D
		ws.getRange2("A208").setValue("1.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-1.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("1.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-1.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: positive integer. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Number. Basic valid input: positive integer. 1 argument used.');
		// Case #2: String. String convertible to valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: String. String convertible to valid number. 1 argument used.');
		// Case #3: Formula. Nested formula returning valid integer. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(ROUND(5.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(ROUND(5.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 48, 'Test: Positive case: Formula. Nested formula returning valid integer. 1 argument used.');
		// Case #4: Number. Non-integer truncated to integer. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(5.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(5.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Number. Non-integer truncated to integer. 1 argument used.');
		// Case #5: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #6: Area. Single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(A101:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3840, 'Test: Positive case: Area. Single-cell range with valid number. 1 argument used.');
		// Case #7: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE({5})', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE({5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 15, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #8: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #9: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #11: Area3D. 3D single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell range with valid number. 1 argument used.');
		// Case #12: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #13: Date. Date as serial number (large integer). 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Date. Date as serial number (large integer). 1 argument used.');
		// Case #14: Time. Time adjusted to valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(TIME(12,0,0)+5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(TIME(12,0,0)+5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Time. Time adjusted to valid number. 1 argument used.');
		// Case #15: Formula. Nested SUM formula returning valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(SUM(2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(SUM(2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Formula. Nested SUM formula returning valid number. 1 argument used.');
		// Case #16: Number. Larger valid integer. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3840, 'Test: Positive case: Number. Larger valid integer. 1 argument used.');
		// Case #17: String. String convertible to number, truncated to integer. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE("10.9")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE("10.9") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3840, 'Test: Positive case: String. String convertible to number, truncated to integer. 1 argument used.');
		// Case #18: Array. Array with multiple valid elements. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE({5,10})', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE({5,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 15, 'Test: Positive case: Array. Array with multiple valid elements. 1 argument used.');
		// Case #19: Formula. Nested IF formula returning valid number. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(IF(TRUE,5,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(IF(TRUE,5,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Formula. Nested IF formula returning valid number. 1 argument used.');
		// Case #20: Formula. Nested FLOOR formula returning valid integer. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(FLOOR(5.9,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(FLOOR(5.9,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Formula. Nested FLOOR formula returning valid integer. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Negative number returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Negative number returns #NUM!. 1 argument used.');
		// Case #2: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #3: Error. Error input propagates #N/A. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error input propagates #N/A. 1 argument used.');
		// Case #4: Empty. Empty input returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty input returns #VALUE!. 1 argument used.');
		// Case #5: Boolean. Boolean TRUE (1) returns valid factorial but tested for completeness. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid factorial but tested for completeness. 1 argument used.');
		// Case #6: Reference link. Reference to cell with zero (valid but tested for edge case). 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Reference link. Reference to cell with zero (valid but tested for edge case). 1 argument used.');
		// Case #7: Area. Multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(A101:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #NUM!. 1 argument used.');
		// Case #8: Name. Named range with area returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with area returns #VALUE!. 1 argument used.');
		// Case #9: Name3D. 3D named range with area returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name3D. 3D named range with area returns #VALUE!. 1 argument used.');
		// Case #10: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #11: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.');
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3840, 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula returning #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula returning #NUM! propagates error. 1 argument used.');
		// Case #14: Number. Number too large returns #NUM! due to overflow. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(171)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(171) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.138742621225583e+155, 'Test: Negative case: Number. Number too large returns #NUM! due to overflow. 1 argument used.');
		// Case #15: String. String convertible to negative number returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE("-1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE("-1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: String. String convertible to negative number returns #NUM!. 1 argument used.');
		// Case #16: Array. Array with boolean returns #NUM!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #NUM!. 1 argument used.');
		// Case #17: Number. Negative decimal returns #NUM!. 1 argument used. - critical
		oParser = new parserFormula('FACTDOUBLE(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(-0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Negative decimal returns #NUM!. 1 argument used.');
		// Case #18: Time. Time value (0.5, truncated to 0) returns valid factorial but tested for edge case. 1 argument used. - crit
		oParser = new parserFormula('FACTDOUBLE(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(TIME(12,0,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Time. Time value (0.5, truncated to 0) returns valid factorial but tested for edge case. 1 argument used.');
		// Case #19: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #20: Formula. Formula returning #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(SUM(1,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(SUM(1,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 48, 'Test: Negative case: Formula. Formula returning #DIV/0! propagates error. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid number (returns 1). 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid number (returns 1). 1 argument used.');
		// Case #2: Number. Maximum valid number before overflow. 1 argument used.
		oParser = new parserFormula('FACTDOUBLE(170)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(170) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.0898143681335199e+154, 'Test: Bounded case: Number. Maximum valid number before overflow. 1 argument used.');
		// Case #3: Number. Small decimal truncated to 0 (returns 1). 1 argument used. - critical
		oParser = new parserFormula('FACTDOUBLE(0.0001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FACTDOUBLE(0.0001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Small decimal truncated to 0 (returns 1). 1 argument used.');

		// TODO in cases with numbers less than one, the editor freezes in an endless loop
		// Need to fix: area handle, MS result diff, negative numbers handle, critical while loop
		// Case #5: Reference link. Reference to cell with valid number. 1 argument used.
		// Case #9: Name3D. 3D named range with valid number. 1 argument used.
		// Case #1: Number. Negative number returns #NUM!. 1 argument used.
		// Case #5: Boolean. Boolean TRUE (1) returns valid factorial but tested for completeness. 1 argument used.
		// Case #15: String. String convertible to negative number returns #NUM!. 1 argument used.
		// Case #16: Array. Array with boolean returns #NUM!. 1 argument used.
		// Case #17: Number. Negative decimal returns #NUM!. 1 argument used. - critical
		// Case #18: Time. Time value (0.5, truncated to 0) returns valid factorial but tested for edge case. 1 argument used. - crit
		// Case #1: Number. Minimum valid number (returns 1). 1 argument used.
		// Case #2: Number. Maximum valid number before overflow. 1 argument used.
		// Case #3: Number. Small decimal truncated to 0 (returns 1). 1 argument used. - critical


		testArrayFormula(assert, "FACTDOUBLE", true);
	});

	QUnit.test("Test: \"FLOOR\"", function (assert) {
		oParser = new parserFormula('FLOOR(3.7,2)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR(3.7,2)');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'FLOOR(3.7,2)');

		oParser = new parserFormula('FLOOR(-2.5,-2)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR(-2.5,-2)');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'FLOOR(-2.5,-2)');

		oParser = new parserFormula('FLOOR(2.5,-2)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR(2.5,-2)');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'FLOOR(2.5,-2)');

		oParser = new parserFormula('FLOOR(1.58,0.1)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR(1.58,0.1)');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'FLOOR(1.58,0.1)');

		oParser = new parserFormula('FLOOR(0.234,0.01)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR(0.234,0.01)');
		assert.strictEqual(oParser.calculate().getValue(), 0.23, 'FLOOR(0.234,0.01)');

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: positive number, positive significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Number. Basic valid input: positive number, positive significance. 2 of 2 arguments used.');
		// Case #2: Number. Negative number with negative significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(-123.456,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(-123.456,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -123, 'Test: Positive case: Number. Negative number with negative significance. 2 of 2 arguments used.');
		// Case #3: Number. Positive number with decimal significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.4, 'Test: Positive case: Number. Positive number with decimal significance. 2 of 2 arguments used.');
		// Case #4: String. Strings convertible to valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR("123.456","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR("123.456","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: String. Strings convertible to valid numbers. 2 of 2 arguments used.');
		// Case #5: Formula. Nested formula for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(SQRT(10000),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(SQRT(10000),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Formula. Nested formula for number. 2 of 2 arguments used.');
		// Case #6: Formula. Nested IF formula for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(IF(TRUE,123.456,-123.456),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(IF(TRUE,123.456,-123.456),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Formula. Nested IF formula for number. 2 of 2 arguments used.');
		// Case #7: Reference link. Reference link to valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(A100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(A100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference link to valid number. 2 of 2 arguments used.');
		// Case #8: Reference link. Reference links for number and significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference links for number and significance. 2 of 2 arguments used.');
		// Case #9: Area. Single-cell range for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(A100:A100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(A100:A100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell range for number. 2 of 2 arguments used.');
		// Case #10: Array. Array with single valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR({123.456},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR({123.456},1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 123, 'Test: Positive case: Array. Array with single valid number. 2 of 2 arguments used.');
		// Case #11: Name. Named range with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(TestName,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(TestName,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Name. Named range with valid number. 2 of 2 arguments used.');
		// Case #12: Name3D. 3D named range with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(TestName3D,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(TestName3D,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Name3D. 3D named range with valid number. 2 of 2 arguments used.');
		// Case #13: Ref3D. 3D reference to valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(Sheet2!A1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(Sheet2!A1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to valid number. 2 of 2 arguments used.');
		// Case #14: Area3D. 3D single-cell range for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(Sheet2!A1:A1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(Sheet2!A1:A1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range for number. 2 of 2 arguments used.');
		// Case #15: Table. Table structured reference with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(Table1[Column1],0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(Table1[Column1],0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid number. 2 of 2 arguments used.');
		// Case #16: Date. Date as serial number with valid significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(DATE(2025,1,1),1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(DATE(2025,1,1),1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45000, 'Test: Positive case: Date. Date as serial number with valid significance. 2 of 2 arguments used.');
		// Case #17: Time. Time adjusted to valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(TIME(12,0,0)*1000,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(TIME(12,0,0)*1000,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 500, 'Test: Positive case: Time. Time adjusted to valid number. 2 of 2 arguments used.');
		// Case #18: Formula. FLOOR inside SUM formula. 2 of 2 arguments used.
		oParser = new parserFormula('SUM(FLOOR(123.456,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FLOOR(123.456,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 133, 'Test: Positive case: Formula. FLOOR inside SUM formula. 2 of 2 arguments used.');
		// Case #19: Number. Negative number with negative decimal significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(-123.456,-0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(-123.456,-0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -123.4, 'Test: Positive case: Number. Negative number with negative decimal significance. 2 of 2 arguments used.');
		// Case #20: Reference link. Reference links for number and decimal significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(A100,G1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(A100,G1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. Reference links for number and decimal significance. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: String. Nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR("abc",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR("abc",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #2: Number,String. Nonnumeric significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. Nonnumeric significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #3: Error. Propagates #N/A error. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 of 2 arguments used.');
		// Case #4: Empty. Empty reference link returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(A102,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(A102,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 2 of 2 arguments used.');
		// Case #5: String. Empty string returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR("",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR("",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 2 of 2 arguments used.');
		// Case #6: Boolean. Boolean number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(TRUE,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean number returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Area. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(A100:A101,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #8: Array. Multi-element array for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR({123.456,456.789},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR({123.456,456.789},1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 123, 'Test: Negative case: Array. Multi-element array for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: Ref3D. 3D reference to nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(Sheet2!A2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(Sheet2!A2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D. 3D reference to nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #10: Name. Named range with nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(TestNameArea2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(TestNameArea2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Name3D. 3D named range with nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(TestNameArea3D2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(TestNameArea3D2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #12: Table. Table column with nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(Table1[Column2],1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(Table1[Column2],1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(SQRT(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(SQRT(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 of 2 arguments used.');
		// Case #14: Number. Positive number with negative significance returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Positive number with negative significance returns #NUM!. 2 of 2 arguments used.');
		// Case #15: Number,Boolean. Boolean significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Negative case: Number,Boolean. Boolean significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Area. Multi-cell range for significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area. Multi-cell range for significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Array. Multi-element array for significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,{1,0.1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,{1,0.1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 123, 'Test: Negative case: Array. Multi-element array for significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Ref3D. 3D reference to nonnumeric significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Negative case: Ref3D. 3D reference to nonnumeric significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #19: Name. Named range with nonnumeric significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.2, 'Test: Negative case: Name. Named range with nonnumeric significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #20: Name3D. 3D named range with nonnumeric significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.2, 'Test: Negative case: Name3D. 3D named range with nonnumeric significance returns #VALUE!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive number and significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum positive number and significance. 2 of 2 arguments used.');
		// Case #2: Number. Minimum negative number and significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(-1E-307,-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(-1E-307,-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-307, 'Test: Bounded case: Number. Minimum negative number and significance. 2 of 2 arguments used.');
		// Case #3: Number. Maximum 15 significant digits for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123456789012345,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123456789012345,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 123457000000000, 'Test: Bounded case: Number. Maximum 15 significant digits for number. 2 of 2 arguments used.');
		// Case #4: Number. Maximum 15 significant digits for negative number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(-123456789012345,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(-123456789012345,-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -123457000000000, 'Test: Bounded case: Number. Maximum 15 significant digits for negative number. 2 of 2 arguments used.');
		// Case #5: Number. Large significance with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR(123.456,1E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR(123.456,1E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Large significance with valid number. 2 of 2 arguments used.');

		// Need to fix: area handle, boundary case diff
		// Case #20: Reference link. Reference links for number and decimal significance. 2 of 2 arguments used.
		// Case #16: Area. Multi-cell range for significance returns #VALUE!. 2 of 2 arguments used.
		// Case #3: Number. Maximum 15 significant digits for number. 2 of 2 arguments used.
		// Case #4: Number. Maximum 15 significant digits for negative number. 2 of 2 arguments used.


		testArrayFormula2(assert, "FLOOR", 2, 2);
	});

	QUnit.test("Test: \"FLOOR.PRECISE\"", function (assert) {
		oParser = new parserFormula('FLOOR.PRECISE(-3.2, -1)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.PRECISE(-3.2, -1)');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'FLOOR.PRECISE(-3.2, -1)');

		oParser = new parserFormula('FLOOR.PRECISE(3.2, 1)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.PRECISE(3.2, 1)');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'FLOOR.PRECISE(3.2, 1)');

		oParser = new parserFormula('FLOOR.PRECISE(-3.2, 1)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.PRECISE(-3.2, 1)');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'FLOOR.PRECISE(-3.2, 1)');

		oParser = new parserFormula('FLOOR.PRECISE(3.2, -1)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.PRECISE(3.2, -1)');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'FLOOR.PRECISE(3.2, -1)');

		oParser = new parserFormula('FLOOR.PRECISE(3.2)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.PRECISE(3.2)');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'FLOOR.PRECISE(3.2)');

		oParser = new parserFormula('FLOOR.PRECISE(test)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.PRECISE(test)');
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", 'FLOOR.PRECISE(test)');

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: positive number, positive significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Number. Basic valid input: positive number, positive significance. 2 of 2 arguments used.');
		// Case #2: Number. Negative number with negative significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(-123.456,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(-123.456,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -124, 'Test: Positive case: Number. Negative number with negative significance. 2 of 2 arguments used.');
		// Case #3: Number. Positive number with decimal significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.4, 'Test: Positive case: Number. Positive number with decimal significance. 2 of 2 arguments used.');
		// Case #4: String. Strings convertible to valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE("123.456","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE("123.456","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: String. Strings convertible to valid numbers. 2 of 2 arguments used.');
		// Case #5: Formula. Nested formula for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(SQRT(10000),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(SQRT(10000),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Formula. Nested formula for number. 2 of 2 arguments used.');
		// Case #6: Formula. Nested IF formula for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(IF(TRUE,123.456,-123.456),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(IF(TRUE,123.456,-123.456),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Formula. Nested IF formula for number. 2 of 2 arguments used.');
		// Case #7: Reference link. Reference link to valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(A100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(A100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference link to valid number. 2 of 2 arguments used.');
		// Case #8: Reference link. Reference links for number and significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference links for number and significance. 2 of 2 arguments used.');
		// Case #9: Area. Single-cell range for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(A100:A100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(A100:A100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell range for number. 2 of 2 arguments used.');
		// Case #10: Array. Array with single valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE({123.456},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE({123.456},1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 123, 'Test: Positive case: Array. Array with single valid number. 2 of 2 arguments used.');
		// Case #11: Name. Named range with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(TestName,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(TestName,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name. Named range with valid number. 2 of 2 arguments used.');
		// Case #12: Name3D. 3D named range with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(TestName3D,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(TestName3D,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name3D. 3D named range with valid number. 2 of 2 arguments used.');
		// Case #13: Ref3D. 3D reference to valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(Sheet2!A1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(Sheet2!A1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to valid number. 2 of 2 arguments used.');
		// Case #14: Area3D. 3D single-cell range for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(Sheet2!A1:A1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(Sheet2!A1:A1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range for number. 2 of 2 arguments used.');
		// Case #15: Table. Table structured reference with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(Table1[Column1],0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(Table1[Column1],0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid number. 2 of 2 arguments used.');
		// Case #16: Date. Date as serial number with valid significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(DATE(2025,1,1),1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(DATE(2025,1,1),1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45000, 'Test: Positive case: Date. Date as serial number with valid significance. 2 of 2 arguments used.');
		// Case #17: Time. Time adjusted to valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(TIME(12,0,0)*1000,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(TIME(12,0,0)*1000,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 500, 'Test: Positive case: Time. Time adjusted to valid number. 2 of 2 arguments used.');
		// Case #18: Formula. FLOOR inside SUM formula. 2 of 2 arguments used.
		oParser = new parserFormula('SUM(FLOOR.PRECISE(123.456,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FLOOR.PRECISE(123.456,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 133, 'Test: Positive case: Formula. FLOOR inside SUM formula. 2 of 2 arguments used.');
		// Case #19: Number. Negative number with negative decimal significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(-123.456,-0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(-123.456,-0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -123.5, 'Test: Positive case: Number. Negative number with negative decimal significance. 2 of 2 arguments used.');
		// Case #20: Reference link. Reference links for number and decimal significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(A100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(A100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference links for number and decimal significance. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: String. Nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE("abc",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE("abc",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #2: Number,String. Nonnumeric significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. Nonnumeric significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #3: Error. Propagates #N/A error. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 of 2 arguments used.');
		// Case #4: Empty. Empty reference link returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(A102,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(A102,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 2 of 2 arguments used.');
		// Case #5: String. Empty string returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE("",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE("",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 2 of 2 arguments used.');
		// Case #6: Boolean. Boolean number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(TRUE,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean number returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Area. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(A100:A101,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #8: Array. Multi-element array for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE({123.456,456.789},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE({123.456,456.789},1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 123, 'Test: Negative case: Array. Multi-element array for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: Ref3D. 3D reference to nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(Sheet2!A2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(Sheet2!A2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D. 3D reference to nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #10: Name. Named range with nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(TestNameArea2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(TestNameArea2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Name3D. 3D named range with nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(TestNameArea3D2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(TestNameArea3D2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #12: Table. Table column with nonnumeric number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(Table1[Column2],1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(Table1[Column2],1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with nonnumeric number returns #VALUE!. 2 of 2 arguments used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(SQRT(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(SQRT(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 of 2 arguments used.');
		// Case #14: Number. Positive number with negative significance returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Negative case: Number. Positive number with negative significance returns #NUM!. 2 of 2 arguments used.');
		// Case #15: Number,Boolean. Boolean significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Negative case: Number,Boolean. Boolean significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Area. Multi-cell range for significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 123.4, 'Test: Negative case: Area. Multi-cell range for significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Array. Multi-element array for significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,{1,0.1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,{1,0.1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 123, 'Test: Negative case: Array. Multi-element array for significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Ref3D. 3D reference to nonnumeric significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Negative case: Ref3D. 3D reference to nonnumeric significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #19: Name. Named range with nonnumeric significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.2, 'Test: Negative case: Name. Named range with nonnumeric significance returns #VALUE!. 2 of 2 arguments used.');
		// Case #20: Name3D. 3D named range with nonnumeric significance returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.2, 'Test: Negative case: Name3D. 3D named range with nonnumeric significance returns #VALUE!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive number and significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum positive number and significance. 2 of 2 arguments used.');
		// Case #2: Number. Minimum negative number and significance. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(-1E-307,-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(-1E-307,-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-307, 'Test: Bounded case: Number. Minimum negative number and significance. 2 of 2 arguments used.');
		// Case #3: Number. Maximum 15 significant digits for number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123456789012345,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123456789012345,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 123457000000000, 'Test: Bounded case: Number. Maximum 15 significant digits for number. 2 of 2 arguments used.');
		// Case #4: Number. Maximum 15 significant digits for negative number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(-123456789012345,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(-123456789012345,-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -123457000000000, 'Test: Bounded case: Number. Maximum 15 significant digits for negative number. 2 of 2 arguments used.');
		// Case #5: Number. Large significance with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('FLOOR.PRECISE(123.456,1E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.PRECISE(123.456,1E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Large significance with valid number. 2 of 2 arguments used.');

		// Need to fix: area handle, boundary cases diff
		// Case #7: Area. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.
		// Case #16: Area. Multi-cell range for significance returns #VALUE!. 2 of 2 arguments used.
		// Case #3: Number. Maximum 15 significant digits for number. 2 of 2 arguments used.
		// Case #4: Number. Maximum 15 significant digits for negative number. 2 of 2 arguments used.


		testArrayFormula2(assert, "FLOOR.PRECISE", 1, 2);
	});

	QUnit.test("Test: \"FLOOR.MATH\"", function (assert) {
		oParser = new parserFormula('FLOOR.MATH(24.3, 5)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.MATH(24.3, 5)');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'FLOOR.MATH(24.3, 5)');

		oParser = new parserFormula('FLOOR.MATH(6.7)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.MATH(6.7)');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'FLOOR.MATH(6.7)');

		oParser = new parserFormula('FLOOR.MATH(-8.1, 5)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.MATH(-8.1, 5)');
		assert.strictEqual(oParser.calculate().getValue(), -10, 'FLOOR.MATH(-8.1, 5)');

		oParser = new parserFormula('FLOOR.MATH(-5.5, 2, -1)', "A1", ws);
		assert.ok(oParser.parse(), 'FLOOR.MATH(-5.5, 2, -1)');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'FLOOR.MATH(-5.5, 2, -1)');

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Positive number, default significance (1), rounds down to 123. 1 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Number. Positive number, default significance (1), rounds down to 123. 1 of 3 arguments used.');
		// Case #2: Number. Negative number, default significance (1), rounds to -124. 1 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(-123.456)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(-123.456) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -124, 'Test: Positive case: Number. Negative number, default significance (1), rounds to -124. 1 of 3 arguments used.');
		// Case #3: Number. Positive number with decimal significance. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.4, 'Test: Positive case: Number. Positive number with decimal significance. 2 of 3 arguments used.');
		// Case #4: Number. Negative number with negative significance, mode -1 rounds toward 0. 3 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(-123.456,-0.1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(-123.456,-0.1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -123.4, 'Test: Positive case: Number. Negative number with negative significance, mode -1 rounds toward 0. 3 of 3 arguments used.');
		// Case #5: String. Strings convertible to valid numbers. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH("123.456","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH("123.456","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: String. Strings convertible to valid numbers. 2 of 3 arguments used.');
		// Case #6: Formula. Nested formula for number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(SQRT(10000),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(SQRT(10000),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Formula. Nested formula for number. 2 of 3 arguments used.');
		// Case #7: Formula. Nested IF formula for number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(IF(TRUE,123.456,-123.456),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(IF(TRUE,123.456,-123.456),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Formula. Nested IF formula for number. 2 of 3 arguments used.');
		// Case #8: Reference link. Reference link to valid number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(A100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(A100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference link to valid number. 2 of 3 arguments used.');
		// Case #9: Reference link. Reference links for number, significance, and mode. 3 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(A100,A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(A100,A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference links for number, significance, and mode. 3 of 3 arguments used.');
		// Case #10: Area. Single-cell range for number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(A100:A100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(A100:A100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell range for number. 2 of 3 arguments used.');
		// Case #11: Array. Array with single valid number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH({123.456},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH({123.456},1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 123, 'Test: Positive case: Array. Array with single valid number. 2 of 3 arguments used.');
		// Case #12: Name. Named range with valid number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(TestName,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(TestName,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name. Named range with valid number. 2 of 3 arguments used.');
		// Case #13: Name3D. 3D named range with valid number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(TestName3D,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(TestName3D,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name3D. 3D named range with valid number. 2 of 3 arguments used.');
		// Case #14: Ref3D. 3D reference to valid number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(Sheet2!A1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(Sheet2!A1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to valid number. 2 of 3 arguments used.');
		// Case #15: Area3D. 3D single-cell range for number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(Sheet2!A1:A1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(Sheet2!A1:A1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range for number. 2 of 3 arguments used.');
		// Case #16: Table. Table structured reference with valid number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(Table1[Column1],0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(Table1[Column1],0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid number. 2 of 3 arguments used.');
		// Case #17: Date. Date as serial number with valid significance. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(DATE(2025,1,1),1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(DATE(2025,1,1),1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45000, 'Test: Positive case: Date. Date as serial number with valid significance. 2 of 3 arguments used.');
		// Case #18: Time. Time adjusted to valid number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(TIME(12,0,0)*1000,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(TIME(12,0,0)*1000,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 500, 'Test: Positive case: Time. Time adjusted to valid number. 2 of 3 arguments used.');
		// Case #19: Formula. FLOOR.MATH inside SUM formula. 2 of 3 arguments used.
		oParser = new parserFormula('SUM(FLOOR.MATH(123.456,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FLOOR.MATH(123.456,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 133, 'Test: Positive case: Formula. FLOOR.MATH inside SUM formula. 2 of 3 arguments used.');
		// Case #20: Number. Negative number with negative significance, default mode. 3 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(-123.456,-0.1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(-123.456,-0.1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -123.5, 'Test: Positive case: Number. Negative number with negative significance, default mode. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: String. Nonnumeric number returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH("abc",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH("abc",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Nonnumeric number returns #VALUE!. 2 of 3 arguments used.');
		// Case #2: Number,String. Nonnumeric significance returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. Nonnumeric significance returns #VALUE!. 2 of 3 arguments used.');
		// Case #3: Number,String. Nonnumeric mode returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,1,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. Nonnumeric mode returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: Error. Propagates #N/A error. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 of 3 arguments used.');
		// Case #5: Empty. Empty reference link returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(A102,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(A102,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 2 of 3 arguments used.');
		// Case #6: String. Empty string returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH("",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH("",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 2 of 3 arguments used.');
		// Case #7: Boolean. Boolean number returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(TRUE,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean number returns #VALUE!. 2 of 3 arguments used.');
		// Case #8: Area. Multi-cell range for number returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(A100:A101,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range for number returns #VALUE!. 2 of 3 arguments used.');
		// Case #9: Array. Multi-element array for number returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH({123.456,456.789},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH({123.456,456.789},1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 123, 'Test: Negative case: Array. Multi-element array for number returns #VALUE!. 2 of 3 arguments used.');
		// Case #10: Ref3D. 3D reference to nonnumeric number returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(Sheet2!A2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(Sheet2!A2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D. 3D reference to nonnumeric number returns #VALUE!. 2 of 3 arguments used.');
		// Case #11: Name. Named range with nonnumeric number returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(TestNameArea2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(TestNameArea2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with nonnumeric number returns #VALUE!. 2 of 3 arguments used.');
		// Case #12: Name3D. 3D named range with nonnumeric number returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(TestNameArea3D2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(TestNameArea3D2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with nonnumeric number returns #VALUE!. 2 of 3 arguments used.');
		// Case #13: Table. Table column with nonnumeric number returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(Table1[Column2],1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(Table1[Column2],1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with nonnumeric number returns #VALUE!. 2 of 3 arguments used.');
		// Case #14: Formula. Formula resulting in #NUM! error. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(SQRT(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(SQRT(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 of 3 arguments used.');
		// Case #15: Number. Zero significance returns #NUM!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Zero significance returns #NUM!. 2 of 3 arguments used.');
		// Case #16: Area. Multi-cell range for significance returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 123.4, 'Test: Negative case: Area. Multi-cell range for significance returns #VALUE!. 2 of 3 arguments used.');
		// Case #17: Array. Multi-element array for significance returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,{1,0.1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,{1,0.1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 123, 'Test: Negative case: Array. Multi-element array for significance returns #VALUE!. 2 of 3 arguments used.');
		// Case #18: Ref3D. 3D reference to nonnumeric significance returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Negative case: Ref3D. 3D reference to nonnumeric significance returns #VALUE!. 2 of 3 arguments used.');
		// Case #19: Name. Named range with nonnumeric significance returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.2, 'Test: Negative case: Name. Named range with nonnumeric significance returns #VALUE!. 2 of 3 arguments used.');
		// Case #20: Name3D. 3D named range with nonnumeric significance returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.2, 'Test: Negative case: Name3D. 3D named range with nonnumeric significance returns #VALUE!. 2 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive number and significance. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum positive number and significance. 2 of 3 arguments used.');
		// Case #2: Number. Minimum negative number and significance, mode -1. 3 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(-1E-307,-1E-307,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(-1E-307,-1E-307,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-307, 'Test: Bounded case: Number. Minimum negative number and significance, mode -1. 3 of 3 arguments used.');
		// Case #3: Number. Maximum 15 significant digits for number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123456789012345,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123456789012345,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 123457000000000, 'Test: Bounded case: Number. Maximum 15 significant digits for number. 2 of 3 arguments used.');
		// Case #4: Number. Maximum 15 significant digits for negative number, mode -1. 3 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(-123456789012345,-1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(-123456789012345,-1,-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -123457000000000, 'Test: Bounded case: Number. Maximum 15 significant digits for negative number, mode -1. 3 of 3 arguments used.');
		// Case #5: Number. Large significance with valid number. 2 of 3 arguments used.
		oParser = new parserFormula('FLOOR.MATH(123.456,1E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FLOOR.MATH(123.456,1E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Large significance with valid number. 2 of 3 arguments used.');

		// Need to fix: area handle, boundary cases diff
		// Case #5: String. Strings convertible to valid numbers. 2 of 3 arguments used.
		// Case #8: Area. Multi-cell range for number returns #VALUE!. 2 of 3 arguments used.
		// Case #16: Area. Multi-cell range for significance returns #VALUE!. 2 of 3 arguments used.
		// Case #3: Number. Maximum 15 significant digits for number. 2 of 3 arguments used.
		// Case #4: Number. Maximum 15 significant digits for negative number, mode -1. 3 of 3 arguments used.


		testArrayFormula2(assert, "FLOOR.MATH", 1, 3);
	});

	QUnit.test("Test: \"GCD\"", function (assert) {
		oParser = new parserFormula("GCD(10,100,50)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 10);
		oParser = new parserFormula("GCD(24.6,36.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 12);
		oParser = new parserFormula("GCD(-1,39,52)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: two positive integers. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(12,18)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(12,18) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number. Basic valid input: two positive integers. 2 of 255 arguments used.');
		// Case #1: Number. Single positive integer. 1 of 255 arguments used.
		oParser = new parserFormula('GCD(6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number. Single positive integer. 1 of 255 arguments used.');
		// Case #2: Number. One divides any number evenly, returns 1. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(1,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(1,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. One divides any number evenly, returns 1. 2 of 255 arguments used.');
		// Case #3: Number. Prime numbers, returns 1. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(7,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(7,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Prime numbers, returns 1. 2 of 255 arguments used.');
		// Case #4: Number. Non-integer truncated to integer (2.5 ? 2). 2 of 255 arguments used.
		oParser = new parserFormula('GCD(2.5,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(2.5,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Non-integer truncated to integer (2.5 ? 2). 2 of 255 arguments used.');
		// Case #5: String. Strings convertible to positive integers. 2 of 255 arguments used.
		oParser = new parserFormula('GCD("12","18")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD("12","18") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: String. Strings convertible to positive integers. 2 of 255 arguments used.');
		// Case #6: Formula. Nested formulas returning valid integers. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(SQRT(36),ABS(18))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(SQRT(36),ABS(18)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. Nested formulas returning valid integers. 2 of 255 arguments used.');
		// Case #7: Reference link. References to cells with valid numbers (6, 12). 2 of 255 arguments used.
		oParser = new parserFormula('GCD(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. References to cells with valid numbers (6, 12). 2 of 255 arguments used.');
		// Case #8: Area. Single-cell ranges with valid numbers (6, 12). 2 of 255 arguments used.
		oParser = new parserFormula('GCD(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell ranges with valid numbers (6, 12). 2 of 255 arguments used.');
		// Case #9: Array. Arrays with single valid integers. 2 of 255 arguments used.
		oParser = new parserFormula('GCD({6},{12})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD({6},{12}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Array. Arrays with single valid integers. 2 of 255 arguments used.');
		// Case #10: Name. Named ranges with valid numbers (6, 1). 2 of 255 arguments used.
		oParser = new parserFormula('GCD(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers (6, 1). 2 of 255 arguments used.');
		// Case #11: Name3D. 3D named ranges with valid numbers (18, 1). 2 of 255 arguments used.
		oParser = new parserFormula('GCD(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers (18, 1). 2 of 255 arguments used.');
		// Case #12: Ref3D. 3D references to cells with valid numbers (12, 18). 2 of 255 arguments used.
		oParser = new parserFormula('GCD(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D references to cells with valid numbers (12, 18). 2 of 255 arguments used.');
		// Case #13: Area3D. 3D single-cell ranges with valid numbers (12, 18). 2 of 255 arguments used.
		oParser = new parserFormula('GCD(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers (12, 18). 2 of 255 arguments used.');
		// Case #14: Table. Table structured references with valid numbers (6, 1). 2 of 255 arguments used.
		oParser = new parserFormula('GCD(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured references with valid numbers (6, 1). 2 of 255 arguments used.');
		// Case #15: Date. Date as serial number truncated to integer. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(DATE(2025,1,1),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(DATE(2025,1,1),12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Date. Date as serial number truncated to integer. 2 of 255 arguments used.');
		// Case #16: Time. Time adjusted to valid integer (0.5*1000 = 500). 2 of 255 arguments used.
		oParser = new parserFormula('GCD(TIME(12,0,0)*1000,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(TIME(12,0,0)*1000,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Time. Time adjusted to valid integer (0.5*1000 = 500). 2 of 255 arguments used.');
		// Case #17: Formula. GCD inside SUM formula, valid inputs. 2 of 255 arguments used.
		oParser = new parserFormula('SUM(GCD(12,18),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GCD(12,18),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Formula. GCD inside SUM formula, valid inputs. 2 of 255 arguments used.');
		// Case #18: Number. Multiple positive integers (four arguments). 4 of 255 arguments used.
		oParser = new parserFormula('GCD(12,18,24,36)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(12,18,24,36) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number. Multiple positive integers (four arguments). 4 of 255 arguments used.');
		// Case #19: Formula. Nested IF formulas returning valid integers. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(IF(TRUE,12,6),IF(TRUE,18,6))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(IF(TRUE,12,6),IF(TRUE,18,6)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. Nested IF formulas returning valid integers. 2 of 255 arguments used.');
		// Case #20: Number. Distinct primes, returns 1. 3 of 255 arguments used.
		oParser = new parserFormula('GCD(2,3,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(2,3,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Distinct primes, returns 1. 3 of 255 arguments used.');
		// Case #21: String. Strings convertible to valid integers, three arguments. 3 of 255 arguments used.
		oParser = new parserFormula('GCD("6","12","18")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD("6","12","18") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: String. Strings convertible to valid integers, three arguments. 3 of 255 arguments used.');
		// Case #22: Reference link. References to cells with valid numbers (6, 12, 1, 2, 6). 5 of 255 arguments used.
		oParser = new parserFormula('GCD(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. References to cells with valid numbers (6, 12, 1, 2, 6). 5 of 255 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative number returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(-6,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(-6,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number returns #NUM!. 2 of 255 arguments used.');
		// Case #2: Number. Number ? 2^53 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(2^53,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(2^53,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Negative case: Number. Number ? 2^53 returns #NUM!. 2 of 255 arguments used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD("abc",12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD("abc",12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 2 of 255 arguments used.');
		// Case #4: String. Non-numeric string for second argument returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(12,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(12,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for second argument returns #VALUE!. 2 of 255 arguments used.');
		// Case #5: Error. Propagates #N/A error. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(NA(),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(NA(),12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 of 255 arguments used.');
		// Case #6: Empty. Empty reference returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(A105,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(A105,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Empty. Empty reference returns #VALUE!. 2 of 255 arguments used.');
		// Case #7: Area. Multi-cell range returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(A100:A101,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(A100:A101,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 2 of 255 arguments used.');
		// Case #8: Area. Multi-cell range for second argument returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(12,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(12,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Area. Multi-cell range for second argument returns #NUM!. 2 of 255 arguments used.');
		// Case #9: Ref3D. 3D reference to text (abc) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(Sheet2!A3,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(Sheet2!A3,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text (abc) returns #VALUE!. 2 of 255 arguments used.');
		// Case #10: Name. Named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(TestNameArea2,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(TestNameArea2,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Name. Named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.');
		// Case #11: Table. Table column with text (error) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(Table1[Column2],12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(Table1[Column2],12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text (error) returns #VALUE!. 2 of 255 arguments used.');
		// Case #12: Formula. Formula resulting in #NUM! error. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(SQRT(-1),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(SQRT(-1),12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 of 255 arguments used.');
		// Case #13: Array. Array with boolean returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD({FALSE},12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD({FALSE},12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #NUM!. 2 of 255 arguments used.');
		// Case #14: Area3D. 3D multi-cell range returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(Sheet2!A4:A5,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(Sheet2!A4:A5,12) is parsed.');
		//!! assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 2 of 255 arguments used.');
		// Case #15: Name3D. 3D named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(TestNameArea3D2,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(TestNameArea3D2,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Name3D. 3D named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.');
		// Case #16: Number. Negative number in first argument returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(-12,18)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(-12,18) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number in first argument returns #NUM!. 2 of 255 arguments used.');
		// Case #17: Number. Number = 2^53 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(9007199254740992,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(9007199254740992,12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Negative case: Number. Number = 2^53 returns #NUM!. 2 of 255 arguments used.');
		// Case #18: String. String convertible to 0 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD("0",12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD("0",12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: String. String convertible to 0 returns #NUM!. 2 of 255 arguments used.');
		// Case #19: Boolean. Boolean TRUE (1) is valid, but testing for clarity. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(TRUE,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(TRUE,12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean TRUE (1) is valid, but testing for clarity. 2 of 255 arguments used.');
		// Case #20: Number. Number > 2^53 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(2^53+1,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(2^53+1,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Negative case: Number. Number > 2^53 returns #NUM!. 2 of 255 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive integer. 1 of 255 arguments used.
		oParser = new parserFormula('GCD(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum positive integer. 1 of 255 arguments used.');
		// Case #2: Number. Maximum integer < 2^53. 1 of 255 arguments used.
		oParser = new parserFormula('GCD(9007199254740991)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(9007199254740991) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 9007200000000000, 'Test: Bounded case: Number. Maximum integer < 2^53. 1 of 255 arguments used.');
		// Case #3: Number. Maximum integer < 2^53 with another number. 2 of 255 arguments used.
		oParser = new parserFormula('GCD(2,9007199254740991)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GCD(2,9007199254740991) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Number. Maximum integer < 2^53 with another number. 2 of 255 arguments used.');

		// TODO Case #14: Area3D. 3D multi-cell range returns #NUM!. 2 of 255 arguments used. - critical problem in while loop
		// Need to fix: ms result diff in some cases
		// Case #13: Array. Array with boolean returns #NUM!. 2 of 255 arguments used.
		// Case #17: Number. Number = 2^53 returns #NUM!. 2 of 255 arguments used. - calc diff
		// Case #19: Boolean. Boolean TRUE (1) is valid, but testing for clarity. 2 of 255 arguments used. - calc diff
		// Case #2: Number. Maximum integer < 2^53. 1 of 255 arguments used.
		// Case #3: Number. Maximum integer < 2^53 with another number. 2 of 255 arguments used.


		testArrayFormula2(assert, "GCD", 1, 8, null, true);
	});

	QUnit.test("Test: \"INT\"", function (assert) {

		ws.getRange2("A202").setValue("19.5");

		oParser = new parserFormula("INT(8.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 8);

		oParser = new parserFormula("INT(-8.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -9);

		oParser = new parserFormula("A202-INT(A202)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.5);

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Positive decimal number rounded down to integer. 1 argument used.
		oParser = new parserFormula('INT(5.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(5.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number. Positive decimal number rounded down to integer. 1 argument used.');
		// Case #2: Number. Negative decimal number rounded down to integer. 1 argument used.
		oParser = new parserFormula('INT(-3.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(-3.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Number. Negative decimal number rounded down to integer. 1 argument used.');
		// Case #3: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('INT("5.7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT("5.7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #4: Formula. Nested formula returning valid number. 1 argument used.
		oParser = new parserFormula('INT(SQRT(25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(SQRT(25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Nested formula returning valid number. 1 argument used.');
		// Case #5: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('INT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #6: Area. Single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('INT(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell range with valid number. 1 argument used.');
		// Case #7: Array. Array with single valid number. 1 argument used.
		oParser = new parserFormula('INT({5.7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT({5.7}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Array with single valid number. 1 argument used.');
		// Case #8: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('INT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #9: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('INT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('INT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #11: Area3D. 3D single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('INT(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell range with valid number. 1 argument used.');
		// Case #12: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('INT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #13: Date. Date as serial number. 1 argument used.
		oParser = new parserFormula('INT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date. Date as serial number. 1 argument used.');
		// Case #14: Time. Time as decimal number. 1 argument used.
		oParser = new parserFormula('INT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time. Time as decimal number. 1 argument used.');
		// Case #15: Formula. INT inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(INT(5.7), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(INT(5.7), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. INT inside SUM formula. 1 argument used.');
		// Case #16: Number. Zero input. 1 argument used.
		oParser = new parserFormula('INT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero input. 1 argument used.');
		// Case #17: String. String of small decimal number. 1 argument used.
		oParser = new parserFormula('INT("0.000000000000001")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT("0.000000000000001") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String of small decimal number. 1 argument used.');
		// Case #18: Array. Multi-element array with valid numbers. 1 argument used.
		oParser = new parserFormula('INT({5.7, -3.2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT({5.7, -3.2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Multi-element array with valid numbers. 1 argument used.');
		// Case #19: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('INT(IF(TRUE, 5.7, -3.2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(IF(TRUE, 5.7, -3.2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');
		// Case #20: Reference link. Reference to cell with small decimal number. 1 argument used.
		oParser = new parserFormula('INT(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cell with small decimal number. 1 argument used.');
		// Case #21: Formula. Nested ABS formula returning valid number. 1 argument used.
		oParser = new parserFormula('INT(ABS(-5.7))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(ABS(-5.7)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Nested ABS formula returning valid number. 1 argument used.');
		// Case #22: Number. Large positive number. 1 argument used.
		oParser = new parserFormula('INT(1234567890.987)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(1234567890.987) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1234567890, 'Test: Positive case: Number. Large positive number. 1 argument used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: Boolean. Boolean input returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean input returns #VALUE!. 1 argument used.');
		// Case #3: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('INT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #4: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #5: Reference link. Reference to cell with non-numeric text. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to cell with non-numeric text. Returns #VALUE!. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(A104:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #7: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #8: Name. Named range with non-numeric text. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with non-numeric text. Returns #VALUE!. 1 argument used.');
		// Case #9: Name3D. 3D named range with non-numeric text. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with non-numeric text. Returns #VALUE!. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with non-numeric text. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with non-numeric text. Returns #VALUE!. 1 argument used.');
		// Case #11: Area3D. 3D multi-cell range. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range. Returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with non-numeric text. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with non-numeric text. Returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. Returns #VALUE!. 1 argument used.');
		// Case #14: String. String of boolean value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT("TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT("TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String of boolean value returns #VALUE!. 1 argument used.');
		// Case #15: Array. Array with boolean value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT({TRUE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Array with boolean value returns #VALUE!. 1 argument used.');
		// Case #16: Formula. Nested formula returning non-numeric string. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(CONCAT("A", 1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(CONCAT("A", 1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Nested formula returning non-numeric string. Returns #VALUE!. 1 argument used.');
		// Case #17: Reference link. Reference to cell with boolean value. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to cell with boolean value. Returns #VALUE!. 1 argument used.');
		// Case #18: Name. Named range with invalid number format. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with invalid number format. Returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Nested TEXT formula returning non-numeric string. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT(TEXT(5.7, "text"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(TEXT(5.7, "text")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Nested TEXT formula returning non-numeric string. Returns #VALUE!. 1 argument used.');
		// Case #20: Array. Array with mixed valid and invalid elements. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT({"5.7", "abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT({"5.7", "abc"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Array. Array with mixed valid and invalid elements. Returns #VALUE!. 1 argument used.');
		// Case #21: String. String causing division by zero. Returns #VALUE!. 1 argument used.
		oParser = new parserFormula('INT("1/0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT("1/0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36526, 'Test: Negative case: String. String causing division by zero. Returns #VALUE!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('INT(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(9.99999999999999E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #2: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('INT(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(-9.99999999999999E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1e+308, 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #3: Number. Smallest positive decimal number. 1 argument used.
		oParser = new parserFormula('INT(0.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(0.000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive decimal number. 1 argument used.');
		// Case #4: Number. Smallest negative decimal number. 1 argument used.
		oParser = new parserFormula('INT(-0.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INT(-0.000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Number. Smallest negative decimal number. 1 argument used.');

		// Need to fix: array and area handle, boundary cases results difference from ms
		// Case #7: Array. Array with single valid number. 1 argument used. - array handle
		// Case #18: Array. Multi-element array with valid numbers. 1 argument used. - array handle
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used. - area handle
		// Case #15: Array. Array with boolean value returns #VALUE!. 1 argument used. - array handle
		// Case #20: Array. Array with mixed valid and invalid elements. Returns #VALUE!. 1 argument used. - array handle
		// Case #1: Number. Maximum valid Excel number. 1 argument used.
		// Case #2: Number. Minimum valid Excel number. 1 argument used.

		testArrayFormula(assert, "INT");
	});

	QUnit.test("Test: \"ISO.CEILING\"", function (assert) {
		oParser = new parserFormula('ISO.CEILING(4.3)', "A1", ws);
		assert.ok(oParser.parse(), 'ISO.CEILING(4.3)');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'ISO.CEILING(4.3)');

		oParser = new parserFormula('ISO.CEILING(-4.3)', "A1", ws);
		assert.ok(oParser.parse(), 'ISO.CEILING(-4.3)');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'ISO.CEILING(-4.3)');

		oParser = new parserFormula('ISO.CEILING(4.3, 2)', "A1", ws);
		assert.ok(oParser.parse(), 'ISO.CEILING(4.3, 2)');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'ISO.CEILING(4.3, 2)');

		oParser = new parserFormula('ISO.CEILING(4.3,-2)', "A1", ws);
		assert.ok(oParser.parse(), 'ISO.CEILING(4.3,-2)');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'ISO.CEILING(4.3,-2)');

		oParser = new parserFormula('ISO.CEILING(-4.3,2)', "A1", ws);
		assert.ok(oParser.parse(), 'ISO.CEILING(-4.3,2)');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'ISO.CEILING(-4.3,2)');

		oParser = new parserFormula('ISO.CEILING(-4.3,-2)', "A1", ws);
		assert.ok(oParser.parse(), 'ISO.CEILING(-4.3,-2)');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'ISO.CEILING(-4.3,-2)');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A104").setValue("Text4");
		// For area
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("3");
		ws.getRange2("A105").setValue("Text5");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123"); // Num (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: positive number, default significance. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number. Basic valid input: positive number, default significance. 1 argument used.');
		// Case #2: Number. Positive number with positive significance. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(2.5,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(2.5,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Number. Positive number with positive significance. 2 arguments used.');
		// Case #3: String. String convertible to numbers. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING("2.5","0.1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING("2.5","0.1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: String. String convertible to numbers. 2 arguments used.');
		// Case #4: Formula. Nested formula for number. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(SQRT(6.25),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(SQRT(6.25),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Formula. Nested formula for number. 2 arguments used.');
		// Case #5: Reference link. Reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cells with valid numbers. 2 arguments used.');
		// Case #6: Area. Single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell ranges with valid numbers. 2 arguments used.');
		// Case #7: Array. Arrays with single valid numbers. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING({2.5},{0.1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING({2.5},{0.1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2.5, 'Test: Positive case: Array. Arrays with single valid numbers. 2 arguments used.');
		// Case #8: Name. Named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name. Named ranges with valid numbers. 2 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named ranges with valid numbers. 2 arguments used.');
		// Case #10: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers. 2 arguments used.');
		// Case #12: Table. Table structured references with valid numbers. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(Table1[Column1],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(Table1[Column1],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Table. Table structured references with valid numbers. 2 arguments used.');
		// Case #13: Formula. Nested IF formula for number. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(IF(TRUE,2.5,-2.5),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(IF(TRUE,2.5,-2.5),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Formula. Nested IF formula for number. 2 arguments used.');
		// Case #14: Number. Negative number with positive significance. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(-2.7,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(-2.7,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.5, 'Test: Positive case: Number. Negative number with positive significance. 2 arguments used.');
		// Case #15: Formula. ISO.CEILING as parent formula in SUM. 2 arguments used.
		oParser = new parserFormula('SUM(ISO.CEILING(2.5,0.1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(ISO.CEILING(2.5,0.1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Positive case: Formula. ISO.CEILING as parent formula in SUM. 2 arguments used.');
		// Case #16: String. Numeric string converted to negative number, default significance. 1 argument used.
		oParser = new parserFormula('ISO.CEILING("-2.7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING("-2.7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: String. Numeric string converted to negative number, default significance. 1 argument used.');
		// Case #17: Array. Arrays with one valid number, others ignored. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING({2.5,TRUE,"text"},{0.1,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING({2.5,TRUE,"text"},{0.1,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2.5, 'Test: Positive case: Array. Arrays with one valid number, others ignored. 2 arguments used.');
		// Case #18: Formula. Nested ROUND formula for number. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(ROUND(2.55,1),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(ROUND(2.55,1),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.6, 'Test: Positive case: Formula. Nested ROUND formula for number. 2 arguments used.');
		// Case #19: Reference link. Reference to cell with valid number, default significance. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Reference link. Reference to cell with valid number, default significance. 1 argument used.');
		// Case #20: Area. Single-cell range with small significance. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(A103:A103,0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(A103:A103,0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area. Single-cell range with small significance. 2 arguments used.');
		// Case #21: Number. Positive number with negative significance (absolute value used). 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(2.5,-0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(2.5,-0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Number. Positive number with negative significance (absolute value used). 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: String. Non-numeric significance returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(2.5,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(2.5,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric significance returns #VALUE!. 2 arguments used.');
		// Case #3: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #4: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #5: Empty. Empty cell reference returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty cell reference returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean value returns #VALUE!. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Ref3D. 3D ref to text cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text cell returns #VALUE!. 1 argument used.');
		// Case #9: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #10: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #11: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #12: Array. Multi-element array returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING({2.5,3.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING({2.5,3.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Negative case: Array. Multi-element array returns #VALUE!. 1 argument used.');
		// Case #13: Area. Multi-cell significance range returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(A100:A100,A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(A100:A100,A101:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell significance range returns #VALUE!. 2 arguments used.');
		// Case #14: Formula. Nested IF with #N/A propagates error. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(IF(FALSE,2.5,NA()))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(IF(FALSE,2.5,NA())) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Nested IF with #N/A propagates error. 1 argument used.');
		// Case #15: Date. Date serial number is valid number (returns week number). 1 argument used.
		oParser = new parserFormula('ISO.CEILING(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Negative case: Date. Date serial number is valid number (returns week number). 1 argument used.');
		// Case #16: Time. Time value (fractional) is valid number. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Time. Time value (fractional) is valid number. 1 argument used.');
		// Case #17: Array. Array with no valid numbers returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ISO.CEILING({TRUE,"text"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING({TRUE,"text"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Array. Array with no valid numbers returns #VALUE!. 1 argument used.');
		// Case #18: Ref3D. 3D ref with text significance returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(Sheet2!A1,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(Sheet2!A1,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref with text significance returns #VALUE!. 2 arguments used.');
		// Case #19: Name. Named range with text significance returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(TestName,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(TestName,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with text significance returns #VALUE!. 2 arguments used.');
		// Case #20: Table. Table column with text significance returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text significance returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive number supported by Excel, default significance. 1 argument used.
		oParser = new parserFormula('ISO.CEILING(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum positive number supported by Excel, default significance. 1 argument used.');
		// Case #2: Number. Maximum number with minimum significance. 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(9.99999999999999E+307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(9.99999999999999E+307,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum number with minimum significance. 2 arguments used.');
		// Case #3: Number. Maximum negative number with zero significance (returns 0). 2 arguments used.
		oParser = new parserFormula('ISO.CEILING(-9.99999999999999E+307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISO.CEILING(-9.99999999999999E+307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum negative number with zero significance (returns 0). 2 arguments used.');

		// Need to fix: area handle, boundary case diff
		// Case #4: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #13: Area. Multi-cell significance range returns #VALUE!. 2 arguments used.
		// Case #2: Number. Maximum number with minimum significance. 2 arguments used.


		testArrayFormula2(assert, "ISO.CEILING", 1, 2);
	});

	QUnit.test("Test: \"LCM\"", function (assert) {
		ws.getRange2("A1:Z300").cleanAll();

		oParser = new parserFormula("LCM(5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 5);

		oParser = new parserFormula("LCM(24.6,36.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 72);

		oParser = new parserFormula("LCM(-1,39,52)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("LCM(0,39,52)", "A1", ws);
		assert.ok(oParser.parse());
		//? assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("LCM(24,36,15)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 360);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Number(2). Basic case with two positive integers. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(12,18)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(12,18) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36, 'Test: Positive case 1: Number(2). Basic case with two positive integers. 2 of 2 arguments used.');
		// Case #2: Number(3). Three positive integers. 3 of 3 arguments used.
		oParser = new parserFormula('LCM(5,10,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(5,10,15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case 2: Number(3). Three positive integers. 3 of 3 arguments used.');
		// Case #3: Number, Empty. Second argument is empty. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(8,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(8,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case 3: Number, Empty. Second argument is empty. 2 of 2 arguments used.');
		// Case #4: Number, Formula. Second argument is a formula. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(20, SQRT(100))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(20, SQRT(100)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case 4: Number, Formula. Second argument is a formula. 2 of 2 arguments used.');
		// Case #5: String(2). Arguments as numeric strings. 2 of 2 arguments used.
		oParser = new parserFormula('LCM("12","18")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM("12","18") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36, 'Test: Positive case 5: String(2). Arguments as numeric strings. 2 of 2 arguments used.');
		// Case #6: Reference link(2). Arguments as reference links. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(A100,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case 6: Reference link(2). Arguments as reference links. 2 of 2 arguments used.');
		// Case #7: Area(2). Arguments as single-cell areas. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case 7: Area(2). Arguments as single-cell areas. 2 of 2 arguments used.');
		// Case #8: Array(2). Arguments as single-element arrays. 2 of 2 arguments used.
		oParser = new parserFormula('LCM({12},{18})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM({12},{18}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36, 'Test: Positive case 8: Array(2). Arguments as single-element arrays. 2 of 2 arguments used.');
		// Case #9: Array(2). Arguments as multi-element arrays. 2 of 2 arguments used.
		oParser = new parserFormula('LCM({12,6},{18,9})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM({12,6},{18,9}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36, 'Test: Positive case 9: Array(2). Arguments as multi-element arrays. 2 of 2 arguments used.');
		// Case #10: Name(2). Arguments as named ranges. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case 10: Name(2). Arguments as named ranges. 2 of 2 arguments used.');
		// Case #11: Name3D(2). Arguments as 3D-named ranges. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(TestName3D1,TestName3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case 11: Name3D(2). Arguments as 3D-named ranges. 2 of 2 arguments used.');
		// Case #12: Ref3D(2). Arguments as 3D references. 2 of 2 arguments used.
		oParser = new parserFormula("LCM(Sheet2!A1,Sheet2!A2)", 'A2', ws);
		assert.ok(oParser.parse(), "Test: LCM(Sheet2!A1,Sheet2!A2) is parsed.");
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case 12: Ref3D(2). Arguments as 3D references. 2 of 2 arguments used.');
		// Case #13: Area3D(2). Arguments as 3D-area references. 2 of 2 arguments used.
		oParser = new parserFormula("LCM(Sheet2!A1:A1,Sheet2!A2:A2)", 'A2', ws);
		assert.ok(oParser.parse(), "Test: LCM(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.");
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case 13: Area3D(2). Arguments as 3D-area references. 2 of 2 arguments used.');
		// Case #14: Table. Arguments as table columns. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case 14: Table. Arguments as table columns. 2 of 2 arguments used.');
		// Case #15: Number(2). One argument is zero. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(0,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(0,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case 15: Number(2). One argument is zero. 2 of 2 arguments used.');
		// Case #16: Number(2). Arguments are ones. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case 16: Number(2). Arguments are ones. 2 of 2 arguments used.');
		// Case #17: Number(2). Large numbers. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(1E+100,1E+100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(1E+100,1E+100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case 17: Number(2). Large numbers. 2 of 2 arguments used.');
		// Case #18: Number(2). Very small numbers. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(1E-100,1E-100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(1E-100,1E-100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case 18: Number(2). Very small numbers. 2 of 2 arguments used.');
		// Case #19: Formula(2). Arguments as formulas. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(2*3,3*4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(2*3,3*4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case 19: Formula(2). Arguments as formulas. 2 of 2 arguments used.');
		// Case #20: Number(4). Four arguments. 4 of 4 arguments used.
		oParser = new parserFormula('LCM(2,4,8,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(2,4,8,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case 20: Number(4). Four arguments. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: String, Boolean. Second argument is boolean. 2 of 2 arguments used.
		oParser = new parserFormula('LCM("12",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM("12",TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case 1: String, Boolean. Second argument is boolean. 2 of 2 arguments used.');
		// Case #2: Boolean, Number. First argument is boolean. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(FALSE,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(FALSE,12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case 2: Boolean, Number. First argument is boolean. 2 of 2 arguments used.');
		// Case #3: String(2). Non-numeric strings. 2 of 2 arguments used.
		oParser = new parserFormula('LCM("A","B")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM("A","B") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case 3: String(2). Non-numeric strings. 2 of 2 arguments used.');
		// Case #4: Empty, String. First argument empty, second non-numeric. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(,"ABC")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(,"ABC") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case 4: Empty, String. First argument empty, second non-numeric. 2 of 2 arguments used.');
		// Case #5: Number, Error. Second argument is an error. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(12,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(12,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case 5: Number, Error. Second argument is an error. 2 of 2 arguments used.');
		// Case #6: Error, Number. First argument is an error. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(#VALUE!,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(#VALUE!,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case 6: Error, Number. First argument is an error. 2 of 2 arguments used.');
		// Case #7: Number(2). Negative number. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(-12,18)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(-12,18) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case 7: Number(2). Negative number. 2 of 2 arguments used.');
		// Case #8: Number(2). Negative number. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(12,-18)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(12,-18) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case 8: Number(2). Negative number. 2 of 2 arguments used.');
		// Case #9: Number(2). Non-integer number. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(1.5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(1.5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case 9: Number(2). Non-integer number. 2 of 2 arguments used.');
		// Case #10: Number(2). Non-integer number. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(2,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(2,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case 10: Number(2). Non-integer number. 2 of 2 arguments used.');
		// Case #11: Date, Number. Date as argument. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(DATE(2025,1,1),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(DATE(2025,1,1),12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 273948, 'Test: Negative case 11: Date, Number. Date as argument. 2 of 2 arguments used.');
		// Case #12: Time, Number. Time as argument. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(TIME(12,0,0),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(TIME(12,0,0),12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case 12: Time, Number. Time as argument. 2 of 2 arguments used.');
		// Case #13: Array, Boolean. Array with boolean. 2 of 2 arguments used.
		oParser = new parserFormula('LCM({TRUE},12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM({TRUE},12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case 13: Array, Boolean. Array with boolean. 2 of 2 arguments used.');
		// Case #14: Area, Boolean. Area with boolean. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(A110:A111,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(A110:A111,12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case 14: Area, Boolean. Area with boolean. 2 of 2 arguments used.');
		// Case #15: Name, Boolean. Named range with boolean. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(TestNameBool,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(TestNameBool,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case 15: Name, Boolean. Named range with boolean. 2 of 2 arguments used.');
		// Case #16: Name3D, Boolean. 3D-named range with boolean. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(TestName3DBool,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(TestName3DBool,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case 16: Name3D, Boolean. 3D-named range with boolean. 2 of 2 arguments used.');
		// Case #17: Ref3D, Boolean. 3D reference with boolean. 2 of 2 arguments used.
		oParser = new parserFormula("LCM(Sheet2!A1,12)", 'A2', ws);
		assert.ok(oParser.parse(), "Test: LCM(Sheet2!A1,12) is parsed.");
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case 17: Ref3D, Boolean. 3D reference with boolean. 2 of 2 arguments used.');
		// Case #18: Area3D, Boolean. 3D-area with boolean. 2 of 2 arguments used.
		oParser = new parserFormula("LCM(Sheet2!A1:B1,12)", 'A2', ws);
		assert.ok(oParser.parse(), "Test: LCM(Sheet2!A1:B1,12) is parsed.");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Negative case 18: Area3D, Boolean. 3D-area with boolean. 2 of 2 arguments used.');
		// Case #19: Number(2). Numbers exceeding Excel\'s limit. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case 19: Number(2). Numbers exceeding Excel\'s limit. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number(2). Maximum allowed number. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(1,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(1,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case 1: Number(2). Maximum allowed number. 2 of 2 arguments used.');
		// Case #2: Number(2). Minimum allowed number. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(1E-307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case 2: Number(2). Minimum allowed number. 2 of 2 arguments used.');
		// Case #3: Number(2). Both arguments zero. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case 3: Number(2). Both arguments zero. 2 of 2 arguments used.');
		// Case #4: Number(2). Large but valid integers. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(2^20,2^20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(2^20,2^20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1048576, 'Test: Bounded case 4: Number(2). Large but valid integers. 2 of 2 arguments used.');
		// Case #5: Number(2). Extremely small numbers. 2 of 2 arguments used.
		oParser = new parserFormula('LCM(1E-100,1E-100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LCM(1E-100,1E-100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case 5: Number(2). Extremely small numbers. 2 of 2 arguments used.');

		// TODO Note: Fix are ready, it will remove the bugs after merge
		// Need to fix: error check, empty check, zero and negative val check, array and cellsRange internal checks
		// Different result with MS
		// Case #3: Number, Empty. Case #6: Reference link(2). Case #7: Area(2) Case #11: Name3D(2). Case #12: Ref3D(2). Case #15: Number(2). Case #17: Number(2).
		// Case #1: String, Boolean. Case #2: Boolean, Number. Case #4: Empty, String. Case #13: Array, Boolean. Case #14: Area, Boolean. Case #19: Number(2).
		// Case #1: Number(2). Case #2: Number(2). Case #3: Number(2).  Case #5: Number(2).


		testArrayFormula2(assert, "LCM", 1, 8, null, true);

	});

	QUnit.test("Test: \"LN\"", function (assert) {

		oParser = new parserFormula("LN(86)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 4.4543473);

		oParser = new parserFormula("LN(2.7182818)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1);

		oParser = new parserFormula("LN(EXP(3))", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);


		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: positive integer. 1 argument used.
		oParser = new parserFormula('LN(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "2.302585093", 'Test: Positive case: Number. Basic valid input: positive integer. 1 argument used.');
		// Case #1: Number. Input is Euler\'s number (e). 1 argument used.
		oParser = new parserFormula('LN(2.718281828459045)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(2.718281828459045) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Input is Euler\'s number (e). 1 argument used.');
		// Case #2: Number. Positive fractional number. 1 argument used.
		oParser = new parserFormula('LN(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.693147181", 'Test: Positive case: Number. Positive fractional number. 1 argument used.');
		// Case #3: String. String convertible to positive number. 1 argument used.
		oParser = new parserFormula('LN("10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN("10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "2.302585093", 'Test: Positive case: String. String convertible to positive number. 1 argument used.');
		// Case #4: String. String convertible to fractional number. 1 argument used.
		oParser = new parserFormula('LN("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.693147181", 'Test: Positive case: String. String convertible to fractional number. 1 argument used.');
		// Case #5: Reference link. Ref to cell with valid number. 1 argument used.
		oParser = new parserFormula('LN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.693147181", 'Test: Positive case: Reference link. Ref to cell with valid number. 1 argument used.');
		// Case #6: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('LN(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.693147181", 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #7: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('LN({10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN({10}) is parsed.');
		//? assert.strictEqual(oParser.calculate(), 2.302585093, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #8: Array. Array with multiple elements. 1 argument used.
		oParser = new parserFormula('LN({10, 5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN({10, 5}) is parsed.');
		// assert.strictEqual(oParser.calculate().getValue(), '2.302585093', 'Test: Positive case: Array. Array with multiple elements. 1 argument used.');
		// Case #9: Name. Named range. 1 argument used.
		oParser = new parserFormula('LN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range. 1 argument used.');
		// Case #10: Name3D. 3D named range. 1 argument used.
		oParser = new parserFormula('LN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range. 1 argument used.');
		// Case #11: Ref3D. 3D reference to cell. 1 argument used.
		oParser = new parserFormula('LN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.693147181", 'Test: Positive case: Ref3D. 3D reference to cell. 1 argument used.');
		// Case #12: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('LN(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.693147181", 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #13: Area3D. 3D multi-cell range. 1 argument used.
		oParser = new parserFormula('LN(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(Sheet2!A1:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D multi-cell range. 1 argument used.');
		// Case #14: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('LN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #15: Date. Date as serial number. 1 argument used.
		oParser = new parserFormula('LN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), "10.72893412", 'Test: Positive case: Date. Date as serial number. 1 argument used.');
		// Case #16: Time. Time formula adjusted to >=0. 1 argument used.
		oParser = new parserFormula('LN(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.405465108", 'Test: Positive case: Time. Time formula adjusted to >=0. 1 argument used.');
		// Case #17: Formula. LN inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(LN(10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(LN(10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "3.302585093", 'Test: Positive case: Formula. LN inside SUM formula. 1 argument used.');
		// Case #18: Formula. Nested IF returning valid value. 1 argument used.
		oParser = new parserFormula('LN(IF(TRUE,10,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(IF(TRUE,10,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "2.302585093", 'Test: Positive case: Formula. Nested IF returning valid value. 1 argument used.');
		// Case #19: Number. Very small positive number. 1 argument used.
		oParser = new parserFormula('LN(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), "-706.8936235", 'Test: Positive case: Number. Very small positive number. 1 argument used.');
		// Case #20: Number. Value slightly above 1. 1 argument used.
		oParser = new parserFormula('LN(1.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(1.000000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positve case: Number. Value slightly above 1. 1 argument used.');
		// Case #21: Number. Large positive integer. 1 argument used.
		oParser = new parserFormula('LN(10000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(10000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), "23.02585093", 'Test: Positive case: Number. Large positive integer. 1 argument used.');
		// Case #22: Number. Very small positive decimal. 1 argument used.
		oParser = new parserFormula('LN(0.0000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(0.0000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), "-23.02585093", 'Test: Positive case: Number. Very small positive decimal. 1 argument used.');
		// Case #23: Formula. Mathematical constant as input. 1 argument used.
		oParser = new parserFormula('LN(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "1.144729886", 'Test: Positive case: Formula. Mathematical constant as input. 1 argument used.');
		// Case #24: Formula. Compound function test. 1 argument used.
		oParser = new parserFormula('LN(EXP(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(EXP(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Compound function test. 1 argument used.');
		// Case #25: Reference link. Reference to cell with decimal. 1 argument used.
		oParser = new parserFormula('LN(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Reference link. Reference to cell with decimal. 1 argument used.');
		// Case #26: Area. Two-cell range. 1 argument used.
		oParser = new parserFormula('LN(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.693147181, 'Test: Positive case: Area. Two-cell range. 1 argument used.');
		// Case #27: Array. Array with multiple values. 1 argument used.
		oParser = new parserFormula('LN({0.5, 1, 2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN({0.5, 1, 2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Array. Array with multiple values. 1 argument used.');
		// Case #28: Name. Alternative named range. 1 argument used.
		oParser = new parserFormula('LN(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.693147181", 'Test: Positive case: Name. Alternative named range. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('LN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero returns #NUM!. 1 argument used.');
		// Case #2: Number. Negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('LN(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative integer returns #NUM!. 1 argument used.');
		// Case #3: Number. Negative fractional number returns #NUM!. 1 argument used.
		oParser = new parserFormula('LN(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative fractional number returns #NUM!. 1 argument used.');
		// Case #4: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #5: String. String convertible to zero. 1 argument used.
		oParser = new parserFormula('LN("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to zero. 1 argument used.');
		// Case #6: String. String convertible to negative number. 1 argument used.
		oParser = new parserFormula('LN("-1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN("-1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to negative number. 1 argument used.');
		// Case #7: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('LN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #8: Area. Multi-cell range returns error.
		oParser = new parserFormula('LN(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#SPILL!', 'Test: Negative case: Area. Multi-cell range returns error.');
		// Case #9: Empty. Reference link is empty.
		oParser = new parserFormula('LN(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Empty. Reference link is empty.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('LN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Boolean. Boolean FALSE (0) returns #NUM!.
		oParser = new parserFormula('LN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!.');
		// Case #12: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('LN(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #13: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('LN(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #14: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('LN(Table1[Column2])', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: LN(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #15: Formula. Formula resulting in error.
		oParser = new parserFormula('LN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in error.');
		// Case #16: Array. Array with boolean returns #NUM!.
		oParser = new parserFormula('LN({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!.');
		// Case #17: Date. Date before Excel epoch returns #NUM!.
		oParser = new parserFormula('LN(DATE(1899,12,31))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(DATE(1899,12,31)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), "13.45017248", 'Test: Negative case: Date. Date before Excel epoch returns #NUM!.');
		// Case #18: Time. Time value (0) returns #NUM!.
		oParser = new parserFormula('LN(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time value (0) returns #NUM!.');
		// Case #19: Number. Large negative number returns #NUM!.
		oParser = new parserFormula('LN(-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large negative number returns #NUM!.');
		// Case #20: String. Negative date string returns #NUM!.
		oParser = new parserFormula('LN(-"01/01/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(-"01/01/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Negative date string returns #NUM!.');
		// Case #21: Number. Very small negative decimal. 1 argument used.
		oParser = new parserFormula('LN(-0.0000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(-0.0000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Very small negative decimal. 1 argument used.');
		// Case #22: String. Date string before Excel epoch. 1 argument used.
		oParser = new parserFormula('LN("12/31/1899")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN("12/31/1899") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Date string before Excel epoch. 1 argument used.');
		// Case #23: Error. Reference error propagation. 1 argument used.
		oParser = new parserFormula('LN(#REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(#REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Error. Reference error propagation. 1 argument used.');
		// Case #24: Boolean. Boolean TRUE (1) returns 0. 1 argument used.
		oParser = new parserFormula('LN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean TRUE (1) returns 0. 1 argument used.');
		// Case #25: Area. Range with empty cells. 1 argument used.
		oParser = new parserFormula('LN(A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Range with empty cells. 1 argument used.');
		// Case #26: Array. Array with text values. 1 argument used.
		oParser = new parserFormula('LN({"a","b"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN({"a","b"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with text values. 1 argument used.');
		// Case #27: Name. Named range with mixed values. 1 argument used.
		oParser = new parserFormula('LN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.223143551", 'Test: Negative case: Name. Named range with mixed values. 1 argument used.');
		// Case #28: Name3D. 3D named range with errors. 1 argument used.
		oParser = new parserFormula('LN(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with errors. 1 argument used.');
		// Case #29: Formula. Division by zero error. 1 argument used.
		oParser = new parserFormula('LN(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero error. 1 argument used.');
		// Case #30: Date. Invalid date string format. 1 argument used.
		oParser = new parserFormula('LN("31/12/1899")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN("31/12/1899") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Date. Invalid date string format. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Min valid positive value. 1 argument used.
		oParser = new parserFormula('LN(2.2250738585072014E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(2.2250738585072014E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Min valid positive value. 1 argument used.');
		// Case #2: Number. Max valid positive value. 1 argument used.
		oParser = new parserFormula('LN(1.7976931348623158E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(1.7976931348623158E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), "707.4801278", 'Test: Bounded case: Number. Max valid positive value. 1 argument used.');
		// Case #3: Number. LN(1) equals 0. 1 argument used.
		oParser = new parserFormula('LN(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. LN(1) equals 0. 1 argument used.');
		// Case #4: Number. Borderline minimum value. 1 argument used.
		oParser = new parserFormula('LN(2.2251E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(2.2251E-308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), "-708.3964068", 'Test: Bounded case: Number. Borderline minimum value. 1 argument used.');
		// Case #5: Number. Borderline maximum value. 1 argument used.
		oParser = new parserFormula('LN(1.7976E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(1.7976E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), "707.480076", 'Test: Bounded case: Number. Borderline maximum value. 1 argument used.');
		// Case #6: Number. Very small positive value. 1 argument used.
		oParser = new parserFormula('LN(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), "-706.8936235", 'Test: Bounded case: Number. Very small positive value. 1 argument used.');
		// Case #7: Number. Very large positive value. 1 argument used.
		oParser = new parserFormula('LN(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), "706.8936235", 'Test: Bounded case: Number. Very large positive value. 1 argument used.');
		// Case #8: Formula. Compound function boundary test. 1 argument used.
		oParser = new parserFormula('LN(EXP(10))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LN(EXP(10)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Bounded case: Formula. Compound function boundary test. 1 argument used.');


		// Need to fix: cross Area check, empty check
		// Different result with MS
		// Case #7: Array. Array with single element
		// Case #13: Area3D. 3D multi-cell range
		// Case #20: Number. Value slightly above 1
		// Case #26: Area. Two-cell range
		// Case #27: Array. Array with multiple values
		// Case #8: Area. Multi-cell range returns error
		// Case #13: Name. Named range with text returns #VALUE
		// Case #14: Table. Table column with text returns #VALUE!.
		// Case #16: Array. Array with boolean returns #NUM!.
		// Case #26: Array. Array with text values.
		// Case #1: Number. Min valid positive value


		testArrayFormula(assert, "LN");
	});

	QUnit.test("Test: \"LOG\"", function (assert) {
		oParser = new parserFormula("LOG(10)", "A1", ws);
		assert.ok(oParser.parse(), "LOG(10)");
		assert.strictEqual(oParser.calculate().getValue(), 1, "LOG(10)");

		oParser = new parserFormula("LOG(8,2)", "A1", ws);
		assert.ok(oParser.parse(), "LOG(8,2)");
		assert.strictEqual(oParser.calculate().getValue(), 3, "LOG(8,2)");

		oParser = new parserFormula("LOG(86, 2.7182818)", "A1", ws);
		assert.ok(oParser.parse(), "LOG(86, 2.7182818)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 4.4543473, "LOG(86, 2.7182818)");

		oParser = new parserFormula("LOG(8,1)", "A1", ws);
		assert.ok(oParser.parse(), "LOG(8,1)");
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", "LOG(8,1)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: integer >0. 1 argument used.
		oParser = new parserFormula('LOG(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Basic valid input: integer >0. 1 argument used.');
		// Case #2: Number. Float input. 1 argument used.
		oParser = new parserFormula('LOG(2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.397940009", 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #3: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('LOG("10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG("10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #4: Reference link. Ref to cell with valid number. 1 argument used.
		oParser = new parserFormula('LOG(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.301029996", 'Test: Positive case: Reference link. Ref to cell with valid number. 1 argument used.');
		// Case #5: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('LOG(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.301029996", 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #6: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('LOG({10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG({10}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #7: Name. Named range. 1 argument used.
		oParser = new parserFormula('LOG(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range. 1 argument used.');
		// Case #8: Name3D. 3D named range. 1 argument used.
		oParser = new parserFormula('LOG(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range. 1 argument used.');
		// Case #9: Ref3D. 3D reference to cell. 1 argument used.
		oParser = new parserFormula('LOG(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), "-0.3010", 'Test: Positive case: Ref3D. 3D reference to cell. 1 argument used.');
		// Case #10: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('LOG(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), "-0.3010", 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #11: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('LOG(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #12: Date. Date as serial number (>0). 1 argument used.
		oParser = new parserFormula('LOG(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "4.659516884", 'Test: Positive case: Date. Date as serial number (>0). 1 argument used.');
		// Case #13: Time. Time formula adjusted to >0. 1 argument used.
		oParser = new parserFormula('LOG(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.176091259", 'Test: Positive case: Time. Time formula adjusted to >0. 1 argument used.');
		// Case #14: Formula. LOG inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(LOG(10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(LOG(10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. LOG inside SUM formula. 1 argument used.');
		// Case #15: Number. Value slightly above 0. 1 argument used.
		oParser = new parserFormula('LOG(1.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(1.000000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Value slightly above 0. 1 argument used.');
		// Case #16: String. String of min valid value. 1 argument used.
		oParser = new parserFormula('LOG("1.000000000000001")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG("1.000000000000001") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String of min valid value. 1 argument used.');
		// Case #17: Array. Multi-element array. 1 argument used.
		oParser = new parserFormula('LOG({1, 10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG({1, 10}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array. Multi-element array. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 1, 'Test: Positive case: Array. Multi-element array. 1 argument used.');
		// Case #18: Formula. Nested IF returning valid value. 1 argument used.
		oParser = new parserFormula('LOG(IF(TRUE, 10, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(IF(TRUE, 10, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested IF returning valid value. 1 argument used.');
		// Case #19: String. Date string converted to number. 1 argument used.
		oParser = new parserFormula('LOG("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG("12/12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "4.662786154", 'Test: Positive case: String. Date string converted to number. 1 argument used.');
		// Case #20: Number. Large valid number. 1 argument used.
		oParser = new parserFormula('LOG(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 307, 'Test: Positive case: Number. Large valid number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('LOG(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero returns #NUM!. 1 argument used.');
		// Case #2: Number. Negative number returns #NUM!. 1 argument used.
		oParser = new parserFormula('LOG(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number returns #NUM!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LOG("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: String. String convertible to zero. 1 argument used.
		oParser = new parserFormula('LOG("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to zero. 1 argument used.');
		// Case #5: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('LOG(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #NUM! error.
		oParser = new parserFormula('LOG(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.301029996, 'Test: Negative case: Area. Multi-cell range returns #NUM! error.');
		// Case #7: Empty. Reference link is empty.
		oParser = new parserFormula('LOG(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference link is empty.');
		// Case #8: String. Empty string returns #VALUE!.
		oParser = new parserFormula('LOG("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #9: Boolean. Boolean FALSE (0) returns #NUM!.
		oParser = new parserFormula('LOG(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!.');
		// Case #10: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('LOG(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 	"#VALUE!", 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #11: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('LOG(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #12: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('LOG(Table1[Column2])', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: LOG(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=LOG(Table1[Column2])', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #13: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('LOG(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #14: Number. Large negative number returns #NUM!.
		oParser = new parserFormula('LOG(-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large negative number returns #NUM!.');
		// Case #15: Array. Array with boolean returns #NUM!.
		oParser = new parserFormula('LOG({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!.');
		// Case #16: Number. Value slightly below 0 returns #NUM!.
		oParser = new parserFormula('LOG(1-1e-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(1-1e-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4.339473599489794e-16, 'Test: Negative case: Number. Value slightly below 0 returns #NUM!.');
		// Case #17: Time. Time value (0) returns #NUM!.
		oParser = new parserFormula('LOG(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time value (0) returns #NUM!.');
		// Case #18: Date. Date before Excel epoch returns #NUM!.
		oParser = new parserFormula('LOG(DATE(1899,12,31))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(DATE(1899,12,31)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), "5.8413357", 'Test: Negative case: Date. Date before Excel epoch returns #NUM!.');
		// Case #19: Area3D. 3D multi-cell range returns #NUM!.
		oParser = new parserFormula('LOG(Sheet2!A1:B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(Sheet2!A1:B1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.30102999566398114, 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!.');
		// Case #20: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('LOG(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Min valid value (1). 1 argument used.
		oParser = new parserFormula('LOG(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Min valid value (1). 1 argument used.');
		// Case #2: Number. Smallest valid value above 0. 1 argument used.
		oParser = new parserFormula('LOG(1.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(1.000000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest valid value above 0. 1 argument used.');
		// Case #3: Number. Max valid Excel number. 1 argument used.
		oParser = new parserFormula('LOG(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 308, 'Test: Bounded case: Number. Max valid Excel number. 1 argument used.');
		// Case #4: Date. Earliest valid Excel date. 1 argument used.
		oParser = new parserFormula('LOG(DATE(1900,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(DATE(1900,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Date. Earliest valid Excel date. 1 argument used.');
		// Case #5: Time. Smallest valid time (>0). 1 argument used.
		oParser = new parserFormula('LOG(TIME(0,0,1)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(TIME(0,0,1)+1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.00000502653, 'Test: Bounded case: Time. Smallest valid time (>0). 1 argument used.');

		// TODO need to fix:
		// zero values should be returned instead very small numbers(maybe it's precision problem)

		testArrayFormula(assert, "LOG", 1, 2);
	});

	QUnit.test("Test: \"LOG10\"", function (assert) {

		oParser = new parserFormula("LOG10(86)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 1.9345);

		oParser = new parserFormula("LOG10(10)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("LOG10(100000)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 5);

		oParser = new parserFormula("LOG10(10^5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 5);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: integer >0. 1 argument used.
		oParser = new parserFormula('LOG10(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Basic valid input: integer >0. 1 argument used.');
		// Case #2: Number. Float input. 1 argument used.
		oParser = new parserFormula('LOG10(2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.397940009", 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #3: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('LOG10("10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10("10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #4: Reference link. Ref to cell with valid number. 1 argument used.
		oParser = new parserFormula('LOG10(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.301029996", 'Test: Positive case: Reference link. Ref to cell with valid number. 1 argument used.');
		// Case #5: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('LOG10(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "-0.301029996", 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #6: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('LOG10({10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10({10}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #7: Name. Named range. 1 argument used.
		oParser = new parserFormula('LOG10(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range. 1 argument used.');
		// Case #8: Name3D. 3D named range. 1 argument used.
		oParser = new parserFormula('LOG10(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range. 1 argument used.');
		// Case #9: Ref3D. 3D reference to cell. 1 argument used.
		oParser = new parserFormula('LOG10(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), "-0.3010", 'Test: Positive case: Ref3D. 3D reference to cell. 1 argument used.');
		// Case #10: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('LOG10(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), "-0.3010", 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #11: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('LOG10(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #12: Date. Date as serial number (>0). 1 argument used.
		oParser = new parserFormula('LOG10(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "4.659516884", 'Test: Positive case: Date. Date as serial number (>0). 1 argument used.');
		// Case #13: Time. Time formula adjusted to >0. 1 argument used.
		oParser = new parserFormula('LOG10(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.176091259", 'Test: Positive case: Time. Time formula adjusted to >0. 1 argument used.');
		// Case #14: Formula. LOG inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(LOG10(10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(LOG10(10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. LOG10 inside SUM formula. 1 argument used.');
		// Case #15: Number. Value slightly above 0. 1 argument used.
		oParser = new parserFormula('LOG10(1.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(1.000000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Value slightly above 0. 1 argument used.');
		// Case #16: String. String of min valid value. 1 argument used.
		oParser = new parserFormula('LOG10("1.000000000000001")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10("1.000000000000001") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String of min valid value. 1 argument used.');
		// Case #17: Array. Multi-element array. 1 argument used.
		oParser = new parserFormula('LOG10({1, 10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10({1, 10}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array. Multi-element array. 1 argument used.');
		// Case #18: Formula. Nested IF returning valid value. 1 argument used.
		oParser = new parserFormula('LOG10(IF(TRUE, 10, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(IF(TRUE, 10, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested IF returning valid value. 1 argument used.');
		// Case #19: String. Date string converted to number. 1 argument used.
		oParser = new parserFormula('LOG10("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10("12/12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "4.662786154", 'Test: Positive case: String. Date string converted to number. 1 argument used.');
		// Case #20: Number. Large valid number. 1 argument used.
		oParser = new parserFormula('LOG10(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 307, 'Test: Positive case: Number. Large valid number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('LOG10(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero returns #NUM!. 1 argument used.');
		// Case #2: Number. Negative number returns #NUM!. 1 argument used.
		oParser = new parserFormula('LOG10(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number returns #NUM!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LOG10("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: String. String convertible to zero. 1 argument used.
		oParser = new parserFormula('LOG10("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to zero. 1 argument used.');
		// Case #5: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('LOG10(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #NUM! error.
		oParser = new parserFormula('LOG10(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.301029996, 'Test: Negative case: Area. Multi-cell range returns #NUM! error.');
		// Case #7: Empty. Reference link is empty.
		oParser = new parserFormula('LOG10(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference link is empty.');
		// Case #8: String. Empty string returns #VALUE!.
		oParser = new parserFormula('LOG10("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #9: Boolean. Boolean FALSE (0) returns #NUM!.
		oParser = new parserFormula('LOG10(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!.');
		// Case #10: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('LOG10(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 	"#VALUE!", 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #11: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('LOG10(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #12: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('LOG10(Table1[Column2])', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: LOG10(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=LOG10(Table1[Column2])', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #13: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('LOG10(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #14: Number. Large negative number returns #NUM!.
		oParser = new parserFormula('LOG10(-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large negative number returns #NUM!.');
		// Case #15: Array. Array with boolean returns #NUM!.
		oParser = new parserFormula('LOG10({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!.');
		// Case #16: Number. Value slightly below 0 returns #NUM!.
		oParser = new parserFormula('LOG10(1-1e-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(1-1e-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4.339473599489794e-16, 'Test: Negative case: Number. Value slightly below 0 returns #NUM!.');
		// Case #17: Time. Time value (0) returns #NUM!.
		oParser = new parserFormula('LOG10(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time value (0) returns #NUM!.');
		// Case #18: Date. Date before Excel epoch returns #NUM!.
		oParser = new parserFormula('LOG10(DATE(1899,12,31))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(DATE(1899,12,31)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), "5.8413357", 'Test: Negative case: Date. Date before Excel epoch returns #NUM!.');
		// Case #19: Area3D. 3D multi-cell range returns #NUM!.
		oParser = new parserFormula('LOG10(Sheet2!A1:B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(Sheet2!A1:B1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.30102999566398114, 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!.');
		// Case #20: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('LOG10(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Min valid value (1). 1 argument used.
		oParser = new parserFormula('LOG10(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Min valid value (1). 1 argument used.');
		// Case #2: Number. Smallest valid value above 0. 1 argument used.
		oParser = new parserFormula('LOG10(1.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(1.000000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest valid value above 0. 1 argument used.');
		// Case #3: Number. Max valid Excel number. 1 argument used.
		oParser = new parserFormula('LOG10(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 308, 'Test: Bounded case: Number. Max valid Excel number. 1 argument used.');
		// Case #4: Date. Earliest valid Excel date. 1 argument used.
		oParser = new parserFormula('LOG10(DATE(1900,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(DATE(1900,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Date. Earliest valid Excel date. 1 argument used.');
		// Case #5: Time. Smallest valid time (>0). 1 argument used.
		oParser = new parserFormula('LOG10(TIME(0,0,1)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOG10(TIME(0,0,1)+1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.00000502653, 'Test: Bounded case: Time. Smallest valid time (>0). 1 argument used.');

		// TODO need to fix:
		// zero values should be returned instead very small numbers
		// empty function after array call

		testArrayFormula(assert, "LOG10");
	});

	QUnit.test("Test: \"MDETERM\"", function (assert) {

		ws.getRange2("A2").setValue("1");
		ws.getRange2("A3").setValue("1");
		ws.getRange2("A4").setValue("1");
		ws.getRange2("A5").setValue("7");

		ws.getRange2("B2").setValue("3");
		ws.getRange2("B3").setValue("3");
		ws.getRange2("B4").setValue("1");
		ws.getRange2("B5").setValue("3");

		ws.getRange2("C2").setValue("8");
		ws.getRange2("C3").setValue("6");
		ws.getRange2("C4").setValue("1");
		ws.getRange2("C5").setValue("10");

		ws.getRange2("D2").setValue("5");
		ws.getRange2("D3").setValue("1");
		ws.getRange2("D4").setValue("0");
		ws.getRange2("D5").setValue("2");


		oParser = new parserFormula("MDETERM(A2:D5)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 88);

		oParser = new parserFormula("MDETERM({3,6,1;1,1,0;3,10,2})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("MDETERM({3,6;1,1})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -3);

		oParser = new parserFormula("MDETERM({1,3,8,5;1,3,6,1})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("B101").setValue("4");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		ws2.getRange2("A3:B4").setValue("Text");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Single number
		oParser = new parserFormula('MDETERM(123)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(123) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Number. Single number');
		// Case #1: Array. Unit matrix 2x2. Determinant=1. All arguments used.
		oParser = new parserFormula('MDETERM({1,0;0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({1,0;0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Unit matrix 2x2. Determinant=1. All arguments used.');
		// Case #2: Array. Diagonal matrix 3x3. Determinant=8.
		oParser = new parserFormula('MDETERM({2,0,0;0,2,0;0,0,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({2,0,0;0,2,0;0,0,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Array. Diagonal matrix 3x3. Determinant=8.');
		// Case #3: Array. String numbers converted to numeric. Determinant=-2.
		oParser = new parserFormula('MDETERM({"1","2";"3","4"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({"1","2";"3","4"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Array. String numbers converted to numeric. Determinant=-2.');
		// Case #4: Formula. Nested SQRT in matrix. Determinant=8.
		oParser = new parserFormula('MDETERM({4,2;3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({4,2;3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case.');
		// Case #5: Reference link. Ref to 2x2 matrix. F1:F2: 1,2,3,4. Determinant=-2.
		oParser = new parserFormula('MDETERM(A100:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(A100:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Reference link. Ref to 2x2 matrix. F1:F2: 1,2,3,4. Determinant=-2.');
		// Case #7: Array. 3x3 array. Determinant=0.
		oParser = new parserFormula('MDETERM({1,2,3;4,5,6;7,8,9})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({1,2,3;4,5,6;7,8,9}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6.66134e-16, 'Test: Positive case: Array. 3x3 array. Determinant=0.');
		// Case #8: Name. Named range.
		oParser = new parserFormula('MDETERM(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name. Named range.');
		// Case #9: Name3D. 3D named range.
		oParser = new parserFormula('MDETERM(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named range.');
		// Case #10: Ref3D. 3D ref to 2x2 matrix. Determinant=-2.
		oParser = new parserFormula('MDETERM(Sheet2!A1:B2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(Sheet2!A1:B2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Ref3D. 3D ref to 2x2 matrix. Determinant=-2.');
		// Case #12: Table. Table structured refs.
		oParser = new parserFormula('MDETERM(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured refs.');
		// Case #15: Empty. Empty treated as 0. Determinant=1.
		oParser = new parserFormula('MDETERM({1,0;0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({1,0;0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty. Empty treated as 0. Determinant=1.');
		// Case #16: Number. Single-element matrix. Determinant=5.
		oParser = new parserFormula('MDETERM({5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number. Single-element matrix. Determinant=5.');
		// Case #17: Number. 4x4 unit matrix. Determinant=1.
		oParser = new parserFormula('MDETERM({1,0,0,0;0,1,0,0;0,0,1,0;0,0,0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({1,0,0,0;0,1,0,0;0,0,1,0;0,0,0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. 4x4 unit matrix. Determinant=1.');

		// Negative cases:
		// Case #1: Array. 3x2 matrix returns #VALUE!.
		oParser = new parserFormula('MDETERM({1,2;3,4;5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({1,2;3,4;5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. 3x2 matrix returns #VALUE!.');
		// Case #2: String. Non-numeric strings return #VALUE!.
		oParser = new parserFormula('MDETERM({"a","b";"c","d"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({"a","b";"c","d"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!.');
		// Case #3: Boolean. Booleans return #VALUE!.
		oParser = new parserFormula('MDETERM({TRUE,FALSE;FALSE,TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({TRUE,FALSE;FALSE,TRUE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Booleans return #VALUE!.');
		// Case #4: Error. Propagates #N/A error.
		oParser = new parserFormula('MDETERM(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #5: Empty. Empty refs return #VALUE!.
		oParser = new parserFormula('MDETERM(A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty refs return #VALUE!.');
		// Case #8: Area3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('MDETERM(Sheet2!A3:B4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(Sheet2!A3:B4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D ref to text returns #VALUE!.');
		// Case #9: Name. Named area.
		oParser = new parserFormula('MDETERM(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM(TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name. Named area.');

		// Bounded cases:
		// Case #1: Array. Smallest valid numbers. Determinant=1E-614.
		oParser = new parserFormula('MDETERM({1E-307,0;0,1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({1E-307,0;0,1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Smallest valid numbers. Determinant=1E-614.');
		// Case #2: Array. Largest valid numbers. Determinant=1E+614.
		oParser = new parserFormula('MDETERM({1E+307,0;0,1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({1E+307,0;0,1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array. Largest valid numbers. Determinant=1E+614.');
		// Case #3: Array. Precision boundary. Determinantâ??1.
		oParser = new parserFormula('MDETERM({1.000000000000001,0;0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDETERM({1.000000000000001,0;0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), "1", 'Test: Bounded case: Array. Precision boundary..');

		// Need to fix: error differences, single number processing, single num in array
		// Case #0: Number. Single number
		// Case #3: Array. String numbers converted to numeric
		// Case #7: Array. 3x3 array. Determinant=0.
		// Case #8: Name. Named range.
		// Case #9: Name3D. 3D named range.
		// Case #10: Ref3D. 3D ref to 2x2 matrix
		// Case #12: Table. Table structured refs.
		// Case #2: String. Non-numeric strings return #VALUE!.
		// Case #8: Area3D. 3D ref to text returns #VALUE
		// Case #9: Name. Named area.

		oParser = new parserFormula("MDETERM({1,2;10,11})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -9);

		let ws2Name = ws2.getName();

		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");

		oParser = new parserFormula("MDETERM("+ws2Name+"!A1:B2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -2);

	});

	QUnit.test("Test: \"MINVERSE\"", function (assert) {
		// 2x2 matrix
		ws.getRange2("A202").setValue("1");
		ws.getRange2("A203").setValue("3");
		ws.getRange2("B202").setValue("2");
		ws.getRange2("B203").setValue("4");
		// 3x3 matrix + 4x4 matrix + 5x5 matrix
		ws.getRange2("A204").setValue("2");
		ws.getRange2("A205").setValue("6");
		ws.getRange2("A206").setValue("5");
		ws.getRange2("A207").setValue("3");
		ws.getRange2("A208").setValue("125");
		ws.getRange2("B204").setValue("5");
		ws.getRange2("B205").setValue("3");
		ws.getRange2("B206").setValue("-2");
		ws.getRange2("B207").setValue("2");
		ws.getRange2("B208").setValue("-1.5");
		ws.getRange2("C204").setValue("7");
		ws.getRange2("C205").setValue("4");
		ws.getRange2("C206").setValue("-3");
		ws.getRange2("C207").setValue("4");
		ws.getRange2("C208").setValue("-1");
		ws.getRange2("D204").setValue("12");
		ws.getRange2("D205").setValue("-2");
		ws.getRange2("D206").setValue("7");
		ws.getRange2("D207").setValue("5");
		ws.getRange2("D208").setValue("2.5");
		ws.getRange2("E204").setValue("14.5");
		ws.getRange2("E205").setValue("-3");
		ws.getRange2("E206").setValue("35");
		ws.getRange2("E207").setValue("309");
		ws.getRange2("E208").setValue("-25");

		// false matrixes
		ws.getRange2("J17").setValue("");
		ws.getRange2("J18").setValue("10");
		ws.getRange2("J19").setValue("");
		ws.getRange2("J20").setValue("");
		ws.getRange2("J21").setValue("TRUE");
		ws.getRange2("J22").setValue("#N/A");
		ws.getRange2("J23").setValue("{2;3;4;5}");
		ws.getRange2("J24").setValue("20");
		ws.getRange2("J24").setNumFormat("@");

		ws.getRange2("J25").setValue("1");
		ws.getRange2("J26").setValue("2");
		ws.getRange2("H25").setValue("4");
		ws.getRange2("H26").setValue("8");

		oParser = new parserFormula("MINVERSE(A202:B203)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(A202:B203)");
		let array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue(), -2, "Result [0,0] MINVERSE(A202:B203)");
		assert.strictEqual(array.getElementRowCol(0,1).getValue(), 1, "Result [0,1] MINVERSE(A202:B203)");
		assert.strictEqual(array.getElementRowCol(1,0).getValue(), 1.5, "Result [1,0] MINVERSE(A202:B203)");
		assert.strictEqual(array.getElementRowCol(1,1).getValue(), -0.5, "Result [1,1] MINVERSE(A202:B203)");

		oParser = new parserFormula("MINVERSE(A204:C206)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(A204:C206)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue(), 1, "Result [0,0] MINVERSE(A204:C206)");
		assert.strictEqual(array.getElementRowCol(1,0).getValue(), -38, "Result [1,0] MINVERSE(A204:C206)");
		assert.strictEqual(array.getElementRowCol(2,0).getValue(), 27, "Result [2,0] MINVERSE(A204:C206)");
		assert.strictEqual(array.getElementRowCol(0,1).getValue(), -1, "Result [0,1] MINVERSE(A204:C206)");
		assert.strictEqual(array.getElementRowCol(1,1).getValue(), 41, "Result [1,1] MINVERSE(A204:C206)");
		assert.strictEqual(array.getElementRowCol(2,1).getValue(), -29, "Result [2,1] MINVERSE(A204:C206)");
		assert.strictEqual(array.getElementRowCol(0,2).getValue(), 1, "Result [0,2] MINVERSE(A204:C206)");
		assert.strictEqual(array.getElementRowCol(1,2).getValue(), -34, "Result [1,2] MINVERSE(A204:C206)");
		assert.strictEqual(array.getElementRowCol(2,2).getValue(), 24, "Result [2,2] MINVERSE(A204:C206)");

		oParser = new parserFormula("MINVERSE(A204:D207)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(A204:D207)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue().toFixed(5) - 0, -0.04108, "Result [0,0] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(1,0).getValue().toFixed(5) - 0, 0.47025, "Result [1,0] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(2,0).getValue().toFixed(5) - 0, -0.26629, "Result [2,0] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(3,0).getValue().toFixed(5) - 0, 0.04958, "Result [3,0] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(0,1).getValue().toFixed(5) - 0, 0.10057, "Result [0,1] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(1,1).getValue().toFixed(5) - 0, 0.33144, "Result [1,1] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(2,1).getValue().toFixed(5) - 0, -0.17564, "Result [2,1] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(3,1).getValue().toFixed(5) - 0, -0.05241, "Result [3,1] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(0,2).getValue().toFixed(5) - 0, 0.07790, "Result [0,2] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(1,2).getValue().toFixed(5) - 0, 0.07365, "Result [1,2] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(2,2).getValue().toFixed(5) - 0, -0.15014, "Result [2,2] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(3,2).getValue().toFixed(5) - 0, 0.04391, "Result [3,2] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(0,3).getValue().toFixed(5) - 0, 0.02975, "Result [0,3] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(1,3).getValue().toFixed(5) - 0, -1.09915, "Result [1,3] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(2,3).getValue().toFixed(5) - 0, 0.77904, "Result [2,3] MINVERSE(A204:D207)");
		assert.strictEqual(array.getElementRowCol(3,3).getValue().toFixed(5) - 0, -0.00142, "Result [3,3] MINVERSE(A204:D207)");

		oParser = new parserFormula("MINVERSE(A204:E208)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(A204:E208)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue().toFixed(5) - 0, -0.00516, "Result [0,0] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(1,0).getValue().toFixed(5) - 0, -0.60923, "Result [1,0] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(2,0).getValue().toFixed(5) - 0, 0.49022, "Result [2,0] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(3,0).getValue().toFixed(5) - 0, 0.05601, "Result [3,0] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(4,0).getValue().toFixed(5) - 0, -0.00326, "Result [4,0] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(0,1).getValue().toFixed(5) - 0, 0.02070, "Result [0,1] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(1,1).getValue().toFixed(5) - 0, 2.73184, "Result [1,1] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(2,1).getValue().toFixed(5) - 0, -1.85786, "Result [2,1] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(3,1).getValue().toFixed(5) - 0, -0.06672, "Result [3,1] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(4,1).getValue().toFixed(5) - 0, 0.00725, "Result [4,1] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(0,2).getValue().toFixed(5) - 0, 0.01274, "Result [0,2] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(1,2).getValue().toFixed(5) - 0, 2.03215, "Result [1,2] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(2,2).getValue().toFixed(5) - 0, -1.52268, "Result [2,2] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(3,2).getValue().toFixed(5) - 0, 0.03223, "Result [3,2] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(4,2).getValue().toFixed(5) - 0, 0.00591, "Result [4,2] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(0,3).getValue().toFixed(5) - 0, -0.00047, "Result [0,3] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(1,3).getValue().toFixed(5) - 0, -0.19109, "Result [1,3] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(2,3).getValue().toFixed(5) - 0, 0.14266, "Result [2,3] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(3,3).getValue().toFixed(5) - 0, -0.00683, "Result [3,3] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(4,3).getValue().toFixed(5) - 0, 0.00274, "Result [4,3] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(0,4).getValue().toFixed(5) - 0, 0.00659, "Result [0,4] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(1,4).getValue().toFixed(5) - 0, -0.19808, "Result [1,4] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(2,4).getValue().toFixed(5) - 0, 0.13882, "Result [2,4] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(3,4).getValue().toFixed(5) - 0, 0.00118, "Result [3,4] MINVERSE(A204:E208)");
		assert.strictEqual(array.getElementRowCol(4,4).getValue().toFixed(5) - 0, -0.0006, "Result [4,4] MINVERSE(A204:E208)");

		oParser = new parserFormula("MINVERSE({10,0;0,10})", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE({10,0;0,10})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.1, "Result [0,0] MINVERSE({10,0;0,10})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 0, "Result [0,1] MINVERSE({10,0;0,10})");	// died on this test
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, "Result [1,0] MINVERSE({10,0;0,10})");
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 0.1, "Result [1,1] MINVERSE({10,0;0,10})");

		oParser = new parserFormula("MINVERSE(TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MINVERSE(TRUE)");

		oParser = new parserFormula("MINVERSE(10)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(10)");
		assert.strictEqual(oParser.calculate().getValue(), 0.1, "Result MINVERSE(10)");

		oParser = new parserFormula("MINVERSE(10,10,10,10)", "A2", ws);
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", "Result MINVERSE(10,10,10,10)");

		oParser = new parserFormula("MINVERSE(str)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(str)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MINVERSE(str)");

		oParser = new parserFormula("MINVERSE({10})", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE({10})");
		assert.strictEqual(oParser.calculate().getValue(), 0.1, "Result MINVERSE({10})");

		oParser = new parserFormula("MINVERSE(J24)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(J24)");
		assert.strictEqual(oParser.calculate().getValue(), 0.05, "Result MINVERSE('20')");

		oParser = new parserFormula("MINVERSE(J17:J20)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(J17:J20)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MINVERSE(J17:J20)");

		oParser = new parserFormula("MINVERSE(J18:J18)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(J18:J18)");
		assert.strictEqual(oParser.calculate().getValue(), 0.1, "Result MINVERSE(J18:J18)");

		oParser = new parserFormula("MINVERSE(J25:H26)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(J25:H26)");
		array = oParser.calculate();
		assert.strictEqual(array.getValue(), "#VALUE!", "Result MINVERSE(J25:H26)");

		oParser = new parserFormula("MINVERSE(J17:J24)", "A2", ws);
		assert.ok(oParser.parse(), "MINVERSE(J25:H26)");
		array = oParser.calculate();
		assert.strictEqual(array.getValue(), "#VALUE!", "Result MINVERSE(J25:H26)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("-0.5");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Array. Basic valid input: 2x2 numeric array. 1 argument used.
		oParser = new parserFormula('MINVERSE({1,2;3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1,2;3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -2, 'Test: Positive case: Array. Basic valid input: 2x2 numeric array. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 1, 'Test: Positive case: Array. Basic valid input: 2x2 numeric array. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1.5, 'Test: Positive case: Array. Basic valid input: 2x2 numeric array. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), -0.5, 'Test: Positive case: Array. Basic valid input: 2x2 numeric array. 1 argument used.');
		// Case #2: Array. 3x3 identity matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE({1,0,0;0,1,0;0,0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1,0,0;0,1,0;0,0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. 3x3 identity matrix. 1 argument used.');
		// Case #3: Number. 1x1 matrix (single number). 1 argument used.
		oParser = new parserFormula('MINVERSE({5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2, 'Test: Positive case: Number. 1x1 matrix (single number). 1 argument used.');
		// Case #4: Formula. 2x2 matrix with nested formulas. 1 argument used.
		oParser = new parserFormula('MINVERSE({2,1;2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({2,1;2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.75, 'Test: Positive case: Formula. 2x2 matrix with nested formulas. 1 argument used.');
		// Case #5: Reference link. Reference to a 2x2 matrix in cells A100:A101. 1 argument used.
		oParser = new parserFormula('MINVERSE(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. Reference to a 2x2 matrix in cells A100:A101. 1 argument used.');
		// Case #6: Area. Single-cell range forming a 2x2 matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area. Single-cell range forming a 2x2 matrix. 1 argument used.');
		// Case #7: Name. Named range referring to a 2x2 matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Name. Named range referring to a 2x2 matrix. 1 argument used.');
		// Case #8: Name3D. 3D named range referring to a 2x2 matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Name3D. 3D named range referring to a 2x2 matrix. 1 argument used.');
		// Case #9: Ref3D. 3D reference to a 2x2 matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D reference to a 2x2 matrix. 1 argument used.');
		// Case #10: Area3D. 3D single-cell range forming a 2x2 matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell range forming a 2x2 matrix. 1 argument used.');
		// Case #12: Array. 2x2 matrix with float numbers. 1 argument used.
		oParser = new parserFormula('MINVERSE({1.5,2.5;3.5,4.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1.5,2.5;3.5,4.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -2.25, 'Test: Positive case: Array. 2x2 matrix with float numbers. 1 argument used.');
		// Case #14: Formula. MINVERSE inside SUM formula for 2x2 matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE(SUM({1,2;3,4},0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(SUM({1,2;3,4},0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1, 'Test: Positive case: Formula. MINVERSE inside SUM formula for 2x2 matrix. 1 argument used.');
		// Case #15: Array. 2x2 matrix with larger integers. 1 argument used.
		oParser = new parserFormula('MINVERSE({10,20;30,40})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({10,20;30,40}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -0.2, 'Test: Positive case: Array. 2x2 matrix with larger integers. 1 argument used.');
		// Case #16: Reference link. Reference to a 2x2 matrix with different values. 1 argument used.
		oParser = new parserFormula('MINVERSE(A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. Reference to a 2x2 matrix with different values. 1 argument used.');
		// Case #18: Name. Named range referring to a different 2x2 matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Name. Named range referring to a different 2x2 matrix. 1 argument used.');
		// Case #19: Ref3D. 3D reference to a different 2x2 matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE(Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D reference to a different 2x2 matrix. 1 argument used.');
		// Case #20: Array. 2x2 identity matrix. 1 argument used.
		oParser = new parserFormula('MINVERSE({1,0;0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1,0;0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. 2x2 identity matrix. 1 argument used.');

		// Negative cases:
		// Case #1: Array. Non-square matrix (2x3) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE({1,2,3;4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1,2,3;4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Non-square matrix (2x3) returns #VALUE!. 1 argument used.');
		// Case #2: Array. Matrix with non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE({1,"a";3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1,"a";3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Matrix with non-numeric string returns #VALUE!. 1 argument used.');
		// Case #3: Array. Matrix with boolean value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE({1,TRUE;3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1,TRUE;3,4}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Matrix with boolean value returns #VALUE!. 1 argument used.');
		/// Case #5: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE(A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #6: String. Non-numeric string input returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string input returns #VALUE!. 1 argument used.');
		// Case #7: Boolean. Boolean input returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean input returns #VALUE!. 1 argument used.');
		// Case #8: Area. Multi-cell range (non-square) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE(A109:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(A109:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range (non-square) returns #VALUE!. 1 argument used.');
		// Case #9: Ref3D. 3D reference to non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE(Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to non-numeric value returns #VALUE!. 1 argument used.');
		// Case #10: Name. Named range with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #13: Array. Singular matrix (determinant 0) returns #NUM!. 1 argument used.
		oParser = new parserFormula('MINVERSE({0,0;0,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({0,0;0,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Singular matrix (determinant 0) returns #NUM!. 1 argument used.');
		// Case #14: Array. Singular matrix (determinant 0) returns #NUM!. 1 argument used.
		oParser = new parserFormula('MINVERSE({1,2;2,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1,2;2,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Singular matrix (determinant 0) returns #NUM!. 1 argument used.');
		// Case #15: Reference link. Reference to singular matrix returns #NUM!. 1 argument used.
		oParser = new parserFormula('MINVERSE(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to singular matrix returns #NUM!. 1 argument used.');
		// Case #16: Area. Range forming singular matrix returns #NUM!. 1 argument used.
		oParser = new parserFormula('MINVERSE(A111:A112)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(A111:A112) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Range forming singular matrix returns #NUM!. 1 argument used.');
		// Case #17: Ref3D. 3D reference to singular matrix returns #NUM!. 1 argument used.
		oParser = new parserFormula('MINVERSE(Sheet2!A8:A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(Sheet2!A8:A9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to singular matrix returns #NUM!. 1 argument used.');
		// Case #18: Name. Named range referring to singular matrix returns #NUM!. 1 argument used.
		oParser = new parserFormula('MINVERSE(TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE(TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.095238095, 'Test: Negative case: Name. Named range referring to singular matrix returns #NUM!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #NUM! error in matrix returns #NUM!. 1 argument used.
		oParser = new parserFormula('MINVERSE({"str",1;2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({"str",1;2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Formula resulting in #NUM! error in matrix returns #NUM!. 1 argument used.');
		// Case #20: Array. Empty array returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MINVERSE({""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({""}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Empty array returns #VALUE!. 1 argument used.');

		// Bounded cases:
		// Case #1: Array. Matrix with smallest valid numbers. 1 argument used.
		oParser = new parserFormula('MINVERSE({1E-307,0;0,1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1E-307,0;0,1E-307}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Array. Matrix with smallest valid numbers. 1 argument used.');
		// Case #2: Array. Matrix with largest valid numbers. 1 argument used.
		oParser = new parserFormula('MINVERSE({9.99999999999999E+307,0;0,9.99999999999999E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({9.99999999999999E+307,0;0,9.99999999999999E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Bounded case: Array. Matrix with largest valid numbers. 1 argument used.');
		// Case #3: Array. Matrix with near-singular determinant (close to zero but invertible). 1 argument used.
		oParser = new parserFormula('MINVERSE({1,1E-307;1E-307,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINVERSE({1,1E-307;1E-307,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Array. Matrix with near-singular determinant (close to zero but invertible). 1 argument used.');

		// Need to fix: name range and cellsRange error handle, different ERROR types, different results
		// Case #7: Name. Named range referring to a 2x2 matrix
		// Case #8: Name3D. 3D named range referring to a 2x2 matrix. 1 argument used.
		// Case #18: Name. Named range referring to a different 2x2 matrix. 1 argument used.
		// Case #3: Array. Matrix with boolean value returns #VALUE!. 1 argument used.
		// Case #18: Name. Named range referring to singular matrix returns #NUM!. 1 argument used.
		// Case #20: Array. Empty array returns #VALUE!. 1 argument used.
		// Case #1: Array. Matrix with smallest valid numbers. 1 argument used.

	});

	QUnit.test("Test: \"MMULT\"", function (assert) {
		ws.getRange2("AAA102").setValue("4");
		ws.getRange2("AAA103").setValue("5");
		ws.getRange2("AAA104").setValue("6");
		ws.getRange2("AAA105").setValue("7");
		ws.getRange2("AAB102").setValue("1");
		ws.getRange2("AAB103").setValue("2");
		ws.getRange2("AAB104").setValue("3");
		ws.getRange2("AAB105").setValue("2");
		ws.getRange2("AAC102").setValue("4");
		ws.getRange2("AAC103").setValue("5");
		ws.getRange2("AAC104").setValue("6");
		ws.getRange2("AAC105").setValue("3");
		ws.getRange2("AAD102").setValue("7");
		ws.getRange2("AAD103").setValue("8");
		ws.getRange2("AAD104").setValue("9");
		ws.getRange2("AAD105").setValue("4");

		ws.getRange2("AAF102").setValue("1");
		ws.getRange2("AAF103").setValue("2");
		ws.getRange2("AAF104").setValue("3");
		ws.getRange2("AAF105").setValue("6");

		ws.getRange2("AAG102").setValue("2");
		ws.getRange2("AAG103").setValue("3");
		ws.getRange2("AAG104").setValue("4");
		ws.getRange2("AAG105").setValue("5");

		oParser = new parserFormula("MMULT(AAC102,AAF104)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 12);

		oParser = new parserFormula("MMULT(AAA102:AAD105,AAF104)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("MMULT(AAC102,AAF104)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 12);

		oParser = new parserFormula("MMULT(AAA102:AAD105,AAF102:AAG105)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 60);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 62);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 72);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue(), 76);

		oParser = new parserFormula("MMULT(AAA102:AAD105,AAF102:AAF105)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 60);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 72);

		oParser = new parserFormula("MMULT(AAA102:AAD105,AAF102:AAF105)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 60);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 72);

		oParser = new parserFormula("MMULT(AAA102:AAD105,AAF102:AAF104)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("MMULT(AAA102:AAD105,AAK110:AAN110)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("MMULT(AAA102:AAD105,AAA102:AAD105)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 94);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 116);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue(), 138);

		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 32);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue(), 40);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 1).getValue(), 48);

		oParser = new parserFormula("MMULT(AAF102:AAF105,AAG102:AAG105)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("MMULT(AAF102:AAF105,AAA102:AAD102)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 4);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 8);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue(), 12);

		oParser = new parserFormula("MMULT({1,2,3},{1;2;3})", "A1", ws);
		assert.ok(oParser.parse(), "MMULT({1,2,3},{1;2;3})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 14, "Result of MMULT({1,2,3},{1;2;3})");

		oParser = new parserFormula("MMULT({1,3,4},{2;3;4;5})", "A1", ws);
		assert.ok(oParser.parse(), "MMULT({1,3,4},{2;3;4;5})");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of MMULT({1,3,4},{2;3;4;5})");

		oParser = new parserFormula("MMULT({1,2,3,4},{1;2;3})", "A1", ws);
		assert.ok(oParser.parse(), "MMULT({1,2,3,4},{1;2;3})");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of MMULT({1,2,3,4},{1;2;3})");

		oParser = new parserFormula("MMULT({1;2;3},{1,2,3})", "A1", ws);
		assert.ok(oParser.parse(), "MMULT({1;2;3},{1,2,3})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 2);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 2).getValue(), 3);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 2);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue(), 4);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 2).getValue(), 6);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue(), 3);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 1).getValue(), 6);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 2).getValue(), 9);

		oParser = new parserFormula('MMULT({1;2;3},{1,"2",3})', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT({1;2;3},{1,2,3})');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of MMULT({1;2;3},{1,2,3})');

		ws.getRange2("K100").setValue("");

		oParser = new parserFormula("MMULT({1;2;3},{1;2;3})", "A1", ws);
		assert.ok(oParser.parse(), "MMULT({1;2;3},{1;2;3})");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of MMULT({1;2;3},{1;2;3})");

		oParser = new parserFormula("MMULT({1,2,3},{1,2,3})", "A1", ws);
		assert.ok(oParser.parse(), "MMULT({1,2,3},{1,2,3})");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of MMULT({1,2,3},{1,2,3})");

		oParser = new parserFormula("MMULT({1;2},2)", "A1", ws);
		assert.ok(oParser.parse(), "MMULT({1;2},2)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 2);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 4);

		oParser = new parserFormula("MMULT(2,3)", "A1", ws);
		assert.ok(oParser.parse(), "MMULT(2,3)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 6);

		oParser = new parserFormula('MMULT("2",3)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT("2",3)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of MMULT("2",3)');

		oParser = new parserFormula('MMULT(2,TRUE)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(2,TRUE)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of MMULT(2,TRUE)');

		oParser = new parserFormula('MMULT(TRUE,2)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(TRUE,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of MMULT(TRUE,2)');

		oParser = new parserFormula('MMULT(2,-1)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(2,-1)');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), -2, 'Result of MMULT(2,-1)');

		oParser = new parserFormula('MMULT(2,)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(2,)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of MMULT(2,)');

		oParser = new parserFormula('MMULT(,2)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of MMULT(,2)');

		oParser = new parserFormula('MMULT(2,K100)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(2,K100)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of MMULT(2,K100)');

		oParser = new parserFormula('MMULT(K100,2)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(K100,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of MMULT(K100,2)');

		oParser = new parserFormula('MMULT(2,0)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(2,0)');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 0, 'Result of MMULT(2,0)');

		oParser = new parserFormula('MMULT(0,2)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(0,2)');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 0, 'Result of MMULT(0,2)');

		oParser = new parserFormula('MMULT(0,0)', "A1", ws);
		assert.ok(oParser.parse(), 'MMULT(0,0)');
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 0, 'Result of MMULT(0,0)');

		ws.getRange2("A100").setValue("1");
		ws.getRange2("B100").setValue("2");
		ws.getRange2("C100").setValue("3");
		ws.getRange2("A101").setValue("4");
		ws.getRange2("B101").setValue("5");
		ws.getRange2("C101").setValue("6");
		ws.getRange2("A102").setValue("7");
		ws.getRange2("B102").setValue("8");
		ws.getRange2("C102").setValue("9");

		oParser = new parserFormula("MMULT(A100:B102,A100:C101)", "A1", ws);
		assert.ok(oParser.parse(), "MMULT(A100:B102,A100:C101)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 9);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 12);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 2).getValue(), 15);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 24);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue(), 33);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 2).getValue(), 42);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue(), 39);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 1).getValue(), 54);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 2).getValue(), 69);

		oParser = new parserFormula("MMULT(A100:C102,A100:A102)", "A1", ws);
		assert.ok(oParser.parse(), "MMULT(A100:C102,A100:A102)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 30);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 66);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue(), 102);

		oParser = new parserFormula("MMULT(A100:A102,A100:C102)", "A1", ws);
		assert.ok(oParser.parse(), "MMULT(A100:A102,A100:C102)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("B101").setValue("4");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		ws2.getRange2("A3:B4").setValue("Text");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: 2x2 * 2x1 numeric arrays. 2 arguments used.
		oParser = new parserFormula('MMULT({1,2;3,4},{5;6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1,2;3,4},{5;6}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 17, 'Test: Positive case: Number. Basic valid input: 2x2 * 2x1 numeric arrays. 2 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 39, 'Test: Positive case: Number. Basic valid input: 2x2 * 2x1 numeric arrays. 2 arguments used.');
		// Case #1: Number. Basic valid input: 1x2 * 2x1 numeric arrays. 2 arguments used.
		oParser = new parserFormula('MMULT({1,2},{3;4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1,2},{3;4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 11, 'Test: Positive case: Number. Basic valid input: 1x2 * 2x1 numeric arrays. 2 arguments used.');
		// Case #2: Formula. Nested formula in first array. 2 arguments used.
		oParser = new parserFormula('MMULT({0.1,2;3,4},{5;6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({0.1,2;3,4},{5;6}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 12.5, 'Test: Positive case: Formula. Nested formula in first array. 2 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 39, 'Test: Positive case: Formula. Nested formula in first array. 2 arguments used.');
		// Case #3: Formula. Nested IF formula in second array. 2 arguments used.
		oParser = new parserFormula('MMULT({1,2},{0;4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1,2},{0;4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 8, 'Test: Positive case: Formula. Nested IF formula in second array. 2 arguments used.');
		// Case #4: String. String convertible to numeric arrays. 2 arguments used.
		oParser = new parserFormula('MMULT("1,2;3,4","5;6")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT("1,2;3,4","5;6") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String. String convertible to numeric arrays. 2 arguments used.');
		// Case #5: Reference link. Reference to cells with valid numeric arrays. 2 arguments used.
		oParser = new parserFormula('MMULT(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Reference link. Reference to cells with valid numeric arrays. 2 arguments used.');
		// Case #6: Area. Single-cell ranges representing arrays. 2 arguments used.
		oParser = new parserFormula('MMULT(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area. Single-cell ranges representing arrays. 2 arguments used.');
		// Case #7: Array. 2x2 * 2x2 arrays producing 2x2 result. 2 arguments used.
		oParser = new parserFormula('MMULT({1,2;3,4},{5,6;7,8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1,2;3,4},{5,6;7,8}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 19, 'Test: Positive case: Array. 2x2 * 2x2 arrays producing 2x2 result. 2 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 22, 'Test: Positive case: Array. 2x2 * 2x2 arrays producing 2x2 result. 2 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 43, 'Test: Positive case: Array. 2x2 * 2x2 arrays producing 2x2 result. 2 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 50, 'Test: Positive case: Array. 2x2 * 2x2 arrays producing 2x2 result. 2 arguments used.');
		// Case #8: Name. Named ranges with valid numeric arrays. 2 arguments used.
		oParser = new parserFormula('MMULT(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -0.25, 'Test: Positive case: Name. Named ranges with valid numeric arrays. 2 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid numeric arrays. 2 arguments used.
		oParser = new parserFormula('MMULT(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.25, 'Test: Positive case: Name3D. 3D named ranges with valid numeric arrays. 2 arguments used.');
		// Case #10: Ref3D. 3D references to cells with numeric arrays. 2 arguments used.
		oParser = new parserFormula('MMULT(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Ref3D. 3D references to cells with numeric arrays. 2 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges with numeric arrays. 2 arguments used.
		oParser = new parserFormula('MMULT(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with numeric arrays. 2 arguments used.');
		// Case #12: Table. Table structured references with valid arrays. 2 arguments used.
		oParser = new parserFormula('MMULT(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Table. Table structured references with valid arrays. 2 arguments used.');
		// Case #13: Date. Dates converted to serial numbers. 2 arguments used.
		oParser = new parserFormula('MMULT({45659,2},{3;45658})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({45659,2},{3;45658}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 228293, 'Test: Positive case: Date. Dates converted to serial numbers. 2 arguments used.');
		// Case #14: Time. Time adjusted to valid numbers. 2 arguments used.
		oParser = new parserFormula('MMULT(TIME(0,0,0)+1,0+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(TIME(0,0,0)+1,0+1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Time. Time adjusted to valid numbers. 2 arguments used.');
		// Case #15: Formula. MMULT inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(MMULT({1,2;3,4},{5;6}))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MMULT({1,2;3,4},{5;6})) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 56, 'Test: Positive case: Formula. MMULT inside SUM formula. 2 arguments used.');
		// Case #16: Number. Float numbers in arrays. 2 arguments used.
		oParser = new parserFormula('MMULT({1.5,2.5},{3.5;4.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1.5,2.5},{3.5;4.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 16.5, 'Test: Positive case: Number. Float numbers in arrays. 2 arguments used.');
		// Case #17: String. Numeric strings converted to float arrays. 2 arguments used.
		oParser = new parserFormula('MMULT("1.5,2.5","3.5;4.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT("1.5,2.5","3.5;4.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String. Numeric strings converted to float arrays. 2 arguments used.');
		// Case #18: Array. 1x3 * 3x1 array producing scalar result. 2 arguments used.
		oParser = new parserFormula('MMULT({1,2,3},{4;5;6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1,2,3},{4;5;6}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 32, 'Test: Positive case: Array. 1x3 * 3x1 array producing scalar result. 2 arguments used.');
		// Case #19: Formula. Nested IF returning valid array. 2 arguments used.
		oParser = new parserFormula('MMULT(IF(TRUE,{1,2;3,4},{0,0;0,0}),{5;6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(IF(TRUE,{1,2;3,4},{0,0;0,0}),{5;6}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 17, 'Test: Positive case: Formula. Nested IF returning valid array. 2 arguments used.');
		// Case #20: Array. Zero-filled arrays. 2 arguments used.
		oParser = new parserFormula('MMULT({0,0;0,0},{0;0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({0,0;0,0},{0;0}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array. Zero-filled arrays. 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Invalid dimensions: 2x2 * 3x1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('MMULT({1,2;3,4},{5;6;7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1,2;3,4},{5;6;7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Invalid dimensions: 2x2 * 3x1 returns #NUM!. 2 arguments used.');
		// Case #2: Number. Invalid dimensions: 1x2 * 1x2 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('MMULT({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Invalid dimensions: 1x2 * 1x2 returns #NUM!. 2 arguments used.');
		// Case #3: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('MMULT("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT("abc","def") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #4: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('MMULT(NA(),{1;2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(NA(),{1;2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #5: Area. Multi-cell range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('MMULT(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range with text returns #VALUE!. 2 arguments used.');
		// Case #6: Empty. Empty cell references treated as 0 but valid dimensions. 2 arguments used.
		oParser = new parserFormula('MMULT(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty cell references treated as 0 but valid dimensions. 2 arguments used.');
		// Case #7: Boolean. Boolean arrays return #VALUE!. 2 arguments used.
		oParser = new parserFormula('MMULT({TRUE,FALSE},{TRUE;FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({TRUE,FALSE},{TRUE;FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean arrays return #VALUE!. 2 arguments used.');
		// Case #8: Ref3D. 3D reference to text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('MMULT(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 2 arguments used.');
		// Case #9: Name. Named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('MMULT(TestNameArea,TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(TestNameArea,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 2 arguments used.');
		// Case #11: Formula. Formula resulting in #NUM! error. 2 arguments used.
		oParser = new parserFormula('MMULT(SQRT(-1),{1;2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(SQRT(-1),{1;2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 arguments used.');
		// Case #12: Number. Valid dimensions but zero result. 2 arguments used.
		oParser = new parserFormula('MMULT({0,0},{0;0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({0,0},{0;0}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Number. Valid dimensions but zero result. 2 arguments used.');
		// Case #13: Array. Array with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('MMULT({1,"abc";3,4},{5;6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1,"abc";3,4},{5;6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with text returns #VALUE!. 2 arguments used.');
		// Case #14: Number. Invalid dimensions: 2x2 * 1x2 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('MMULT({1,2;3,4},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1,2;3,4},{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Invalid dimensions: 2x2 * 1x2 returns #NUM!. 2 arguments used.');
		// Case #15: String. String with non-numeric element returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('MMULT("1,2;3,abc","5;6")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT("1,2;3,abc","5;6") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String with non-numeric element returns #VALUE!. 2 arguments used.');
		// Case #16: Date. Invalid date (before Excels date system) returns #NUM!. 2 arguments used.
		oParser = new parserFormula('MMULT(DATE(1899,12,31),{3;4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(DATE(1899,12,31),{3;4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Date. Invalid date (before Excels date system) returns #NUM!. 2 arguments used.');
		// Case #17: Time. Time value (0.5) in array returns valid result but tests edge case. 2 arguments used.
		oParser = new parserFormula('MMULT({0.5,2},{3;4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({0.5,2},{3;4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 9.5, 'Test: Negative case: Time. Time value (0.5) in array returns valid result but tests edge case. 2 arguments used.');
		// Case #18: Formula. Formula resulting in #DIV/0! error. 2 arguments used.
		oParser = new parserFormula('MMULT(1/0,{3;4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(1/0,{3;4}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! error. 2 arguments used.');
		// Case #19: Area3D. 3D multi-cell range returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('MMULT(Sheet2!A1:B1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(Sheet2!A1:B1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 2 arguments used.');
		// Case #20: Name3D. 3D named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('MMULT(TestNameArea3D2,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT(TestNameArea3D2,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -0.4, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid numeric values in arrays. 2 arguments used.
		oParser = new parserFormula('MMULT({1E-307,2},{3;1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1E-307,2},{3;1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 4.999999999999999e-307, 'Test: Bounded case: Number. Minimum valid numeric values in arrays. 2 arguments used.');
		// Case #2: Number. Maximum valid numeric values in arrays. 2 arguments used.
		oParser = new parserFormula('MMULT({1E+307,2},{3;1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1E+307,2},{3;1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 5e+307, 'Test: Bounded case: Number. Maximum valid numeric values in arrays. 2 arguments used.');
		// Case #3: Number. Minimum valid values in 2x2 * 2x1 arrays. 2 arguments used.
		oParser = new parserFormula('MMULT({1E-307,1E-307;1E-307,1E-307},{1E-307;1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1E-307,1E-307;1E-307,1E-307},{1E-307;1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Bounded case: Number. Minimum valid values in 2x2 * 2x1 arrays. 2 arguments used.');
		// Case #4: Number. Maximum valid values in 2x2 * 2x1 arrays. 2 arguments used.
		oParser = new parserFormula('MMULT({1E+307,1E+307;1E+307,1E+307},{1E+307;1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MMULT({1E+307,1E+307;1E+307,1E+307},{1E+307;1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid values in 2x2 * 2x1 arrays. 2 arguments used.');

		// todo если возвращается одно единственное значение, должно ли оно оборачиваться в массив?
		// Need to fix: error handle, IF doesn't return an array, boolean handle
		// Case #19: Formula. Nested IF returning valid array. 2 arguments used.
		// Case #4: Error. Propagates #N/A error. 2 arguments used.
		// Case #7: Boolean. Boolean arrays return #VALUE!. 2 arguments used.
		// Case #11: Formula. Formula resulting in #NUM! error. 2 arguments used.
		// Case #14: Number. Invalid dimensions: 2x2 * 1x2 returns #NUM!. 2 arguments used.
		// Case #18: Formula. Formula resulting in #DIV/0! error. 2 arguments used.

	});

	QUnit.test("Test: \"MOD\"", function (assert) {
		oParser = new parserFormula("MOD(7,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("MOD(-10,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("MOD(-9,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("MOD(-8,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula("MOD(-7,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("MOD(-6,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		oParser = new parserFormula("MOD(-5,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("MOD(10,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("MOD(9,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		oParser = new parserFormula("MOD(8,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("MOD(15,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("MOD(15,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("B101").setValue("4");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("3");
		ws2.getRange2("A4").setValue("4");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		ws2.getRange2("A3:B4").setValue("Text");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(2). Basic valid input: integers. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Basic valid input: integers. 2 of 2 arguments used.');
		// Case #2: Number(2). Float input. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(15.5,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(15.5,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Positive case: Number(2). Float input. 2 of 2 arguments used.');
		// Case #3: String(2). Strings convertible to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MOD("10","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD("10","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String(2). Strings convertible to numbers. 2 of 2 arguments used.');
		// Case #4: Formula(2). Nested formulas resolving to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(SQRT(100),ABS(-3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(SQRT(100),ABS(-3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2). Nested formulas resolving to numbers. 2 of 2 arguments used.');
		// Case #5: Reference link(2). References to cells with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link(2). References to cells with valid numbers. 2 of 2 arguments used.');
		// Case #6: Area(2). Single-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area(2). Single-cell ranges. 2 of 2 arguments used.');
		// Case #7: Array(2). Arrays with single elements. 2 of 2 arguments used.
		oParser = new parserFormula('MOD({10},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD({10},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array(2). Arrays with single elements. 2 of 2 arguments used.');
		// Case #8: Name(2). Named ranges with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name(2). Named ranges with valid numbers. 2 of 2 arguments used.');
		// Case #9: Name3D(2). 3D named ranges with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D(2). 3D named ranges with valid numbers. 2 of 2 arguments used.');
		// Case #10: Ref3D(2). 3D references to cells with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D(2). 3D references to cells with valid numbers. 2 of 2 arguments used.');
		// Case #11: Area3D(2). 3D single-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area3D(2). 3D single-cell ranges. 2 of 2 arguments used.');
		// Case #13: Date(2). Date as serial number (45624). 2 of 2 arguments used.
		oParser = new parserFormula('MOD(DATE(2025,1,1),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(DATE(2025,1,1),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date(2). Date as serial number (45624). 2 of 2 arguments used.');
		// Case #14: Time(2). Time adjusted to number (500). 2 of 2 arguments used.
		oParser = new parserFormula('MOD(TIME(12,0,0)*1000,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(TIME(12,0,0)*1000,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Time(2). Time adjusted to number (500). 2 of 2 arguments used.');
		// Case #15: Formula(2). Nested IF formulas resolving to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(IF(TRUE,10,5),IF(FALSE,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(IF(TRUE,10,5),IF(FALSE,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2). Nested IF formulas resolving to numbers. 2 of 2 arguments used.');
		// Case #16: Number(2). Negative number. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(-10,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(-10,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(2). Negative number. 2 of 2 arguments used.');
		// Case #17: Number(2). Negative divisor. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,-3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,-3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Number(2). Negative divisor. 2 of 2 arguments used.');
		// Case #18: String(2). Float strings convertible to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MOD("15.5","4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD("15.5","4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Positive case: String(2). Float strings convertible to numbers. 2 of 2 arguments used.');
		// Case #19: Reference link, Number. Reference link for number, constant divisor. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(A100,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(A100,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link, Number. Reference link for number, constant divisor. 2 of 2 arguments used.');
		// Case #20: Number, Reference link. Constant number, reference link divisor. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Reference link. Constant number, reference link divisor. 2 of 2 arguments used.');
		// Case #21: Number, String. Number and string convertible to number. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,"3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,"3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, String. Number and string convertible to number. 2 of 2 arguments used.');
		// Case #22: Formula, Number. Formula for number, constant divisor. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(SQRT(100),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(SQRT(100),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula, Number. Formula for number, constant divisor. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number(2). Divisor is zero. Returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Divisor is zero. Returns #DIV/0!. 2 of 2 arguments used.');
		// Case #2: String(2). Non-numeric string for number. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD("abc","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD("abc","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric string for number. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #3: String(2). Non-numeric string for divisor. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD("10","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD("10","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric string for divisor. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #4: Error(2). Error value for number. Propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(NA(),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(NA(),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). Error value for number. Propagates #N/A. 2 of 2 arguments used.');
		// Case #5: Number, Error. Error value for divisor. Propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error value for divisor. Propagates #N/A. 2 of 2 arguments used.');
		// Case #6: Area(2). Multi-cell ranges. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2). Multi-cell ranges. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Empty, Number. Empty reference for number. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(A104,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(A104,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty, Number. Empty reference for number. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #8: Number, Empty. Empty reference for divisor. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Test: Negative case: Number, Empty. Empty reference for divisor. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: Boolean, Number. Boolean number (1). Returns remainder 1, but unexpected input type. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(TRUE,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(TRUE,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean, Number. Boolean number (1). Returns remainder 1, but unexpected input type. 2 of 2 arguments used.');
		// Case #10: Number, Boolean. Boolean divisor (0). Returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Boolean. Boolean divisor (0). Returns #DIV/0!. 2 of 2 arguments used.');
		// Case #11: Ref3D(2). 3D references to text cells. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D(2). 3D references to text cells. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #12: Name(2). Named range with area for number. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(TestNameArea,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(TestNameArea,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name(2). Named range with area for number. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #13: Name3D(2). 3D named range with area for number. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(TestNameArea3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(TestNameArea3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D(2). 3D named range with area for number. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #14: Array(2). Multi-element array for number. Returns array. 2 of 2 arguments used.
		oParser = new parserFormula('MOD({10,15},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD({10,15},{3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Array(2). Multi-element array for number. Returns array. 2 of 2 arguments used.');
		// Case #15: Number, Array. Multi-element array for divisor. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Number, Array. Multi-element array for divisor. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Formula(2). Formula resulting in #NUM! for number. Propagates #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(SQRT(-1),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(SQRT(-1),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). Formula resulting in #NUM! for number. Propagates #NUM!. 2 of 2 arguments used.');
		// Case #17: Number, Formula. Formula resulting in #NUM! for divisor. Propagates #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Formula resulting in #NUM! for divisor. Propagates #NUM!. 2 of 2 arguments used.');
		// Case #18: String(2). Empty string for number. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD("","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD("","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Empty string for number. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #19: Number, String. Empty string for divisor. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,"") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Empty string for divisor. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #20: String(2). Text string for number. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD("Str","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD("Str","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Text string for number. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #21: Number, String. Text string for divisor. Returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,"Str")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,"Str") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Text string for divisor. Returns #VALUE!. 2 of 2 arguments used.');
		// Case #22: Time(2). Time value (0.5) as number, valid but unexpected input. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(TIME(12,0,0),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(TIME(12,0,0),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Time(2). Time value (0.5) as number, valid but unexpected input. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number(2). Max valid Excel number for number. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(9.99999999999999E+307,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(9.99999999999999E+307,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2). Max valid Excel number for number. 2 of 2 arguments used.');
		// Case #2: Number(2). Min valid positive divisor. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2). Min valid positive divisor. 2 of 2 arguments used.');
		// Case #3: Number(2). Max negative Excel number for number. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(-9.99999999999999E+307,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(-9.99999999999999E+307,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2). Max negative Excel number for number. 2 of 2 arguments used.');
		// Case #4: Number(2). Min valid negative divisor. 2 of 2 arguments used.
		oParser = new parserFormula('MOD(10,-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MOD(10,-1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2). Min valid negative divisor. 2 of 2 arguments used.');

		// Need to fix: array return err, #NUM! error should be instead 0
		// Case #11: Area3D(2). 3D single-cell ranges
		// Case #14: Array(2). Multi-element array for number. Returns array. 2 of 2 arguments used.
		// Case #1: Number(2). Max valid Excel number for number
		// Case #2: Number(2). Min valid positive divisor
		// Case #3: Number(2). Max negative Excel number for number. 2 of 2 arguments used.
		// Case #4: Number(2). Min valid negative divisor. 2 of 2 arguments used.


		testArrayFormula2(assert, "MOD", 2, 2);
	});

	QUnit.test("Test: \"MROUND\"", function (assert) {
		var multiple;//должен равняться значению второго аргумента
		function mroundHelper(num) {
			var multiplier = Math.pow(10, Math.floor(Math.log(Math.abs(num)) / Math.log(10)) - AscCommonExcel.cExcelSignificantDigits + 1);
			var nolpiat = 0.5 * (num > 0 ? 1 : num < 0 ? -1 : 0) * multiplier;
			var y = (num + nolpiat) / multiplier;
			y = y / Math.abs(y) * Math.floor(Math.abs(y))
			var x = y * multiplier / multiple

			// var x = number / multiple;
			var nolpiat = 5 * (x / Math.abs(x)) * Math.pow(10, Math.floor(Math.log(Math.abs(x)) / Math.log(10)) - AscCommonExcel.cExcelSignificantDigits);
			x = x + nolpiat;
			x = x | x;

			return x * multiple;
		}


		oParser = new parserFormula("MROUND(10,3)", "A1", ws);
		assert.ok(oParser.parse());
		multiple = 3;
		assert.strictEqual(oParser.calculate().getValue(), mroundHelper(10 + 3 / 2));

		oParser = new parserFormula("MROUND(-10,-3)", "A1", ws);
		assert.ok(oParser.parse());
		multiple = -3;
		assert.strictEqual(oParser.calculate().getValue(), mroundHelper(-10 + -3 / 2));

		oParser = new parserFormula("MROUND(1.3,0.2)", "A1", ws);
		assert.ok(oParser.parse());
		multiple = 0.2;
		assert.strictEqual(oParser.calculate().getValue(), mroundHelper(1.3 + 0.2 / 2));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("B101").setValue("4");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A104").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("3");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		ws2.getRange2("A3:B4").setValue("Text");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: positive integers. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Number. Basic valid input: positive integers. 2 of 2 arguments used.');
		// Case #2: Number. Float inputs. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10.5, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10.5, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.5, 'Test: Positive case: Number. Float inputs. 2 of 2 arguments used.');
		// Case #3: String. Strings convertible to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND("10", "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND("10", "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: String. Strings convertible to numbers. 2 of 2 arguments used.');
		// Case #4: Formula. Nested formula for number. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(SQRT(100), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(SQRT(100), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Nested formula for number. 2 of 2 arguments used.');
		// Case #5: Reference link. Reference to cells with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Reference link. Reference to cells with valid numbers. 2 of 2 arguments used.');
		// Case #6: Area. Single-cell range. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(A102:A102, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(A102:A102, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell range. 2 of 2 arguments used.');
		// Case #7: Area. Two-cell range resolving to single value for number. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(A102:A102, A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(A102:A102, A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area. Two-cell range resolving to single value for number. 2 of 2 arguments used.');
		// Case #8: Array. Array with single elements. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND({10}, {3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND({10}, {3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 9, 'Test: Positive case: Array. Array with single elements. 2 of 2 arguments used.');
		// Case #9: Name. Named range with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid numbers. 2 of 2 arguments used.');
		// Case #10: Name3D. 3D named range with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(TestName3D, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(TestName3D, TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid numbers. 2 of 2 arguments used.');
		// Case #11: Ref3D. 3D reference to cells with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. 2 of 2 arguments used.');
		// Case #12: Area3D. 3D single-cell range. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(Sheet2!A3:A3, Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(Sheet2!A3:A3, Sheet2!A3:A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area3D. 3D single-cell range. 2 of 2 arguments used.');
		// Case #13: Area3D. 3D two-cell range resolving to single value for number. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(Sheet2!A5:A6, Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(Sheet2!A5:A6, Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D two-cell range resolving to single value for number. 2 of 2 arguments used.');
		// Case #15: Date. Date as serial number rounded to multiple of 5. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(DATE(2025,1,1), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(DATE(2025,1,1), 5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 45660, 'Test: Positive case: Date. Date as serial number rounded to multiple of 5. 2 of 2 arguments used.');
		// Case #16: Time. Time converted to number (fraction of day * 1000). 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(TIME(12,0,0)*1000, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(TIME(12,0,0)*1000, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 500, 'Test: Positive case: Time. Time converted to number (fraction of day * 1000). 2 of 2 arguments used.');
		// Case #17: Formula. MROUND inside SUM formula. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(SUM(8,2), 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(SUM(8,2), 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Formula. MROUND inside SUM formula. 2 of 2 arguments used.');
		// Case #18: Number. Negative numbers with same sign. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(-10, -3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(-10, -3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -9, 'Test: Positive case: Number. Negative numbers with same sign. 2 of 2 arguments used.');
		// Case #19: String. Date string converted to serial number. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND("01/01/2025", "5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND("01/01/2025", "5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45660, 'Test: Positive case: String. Date string converted to serial number. 2 of 2 arguments used.');
		// Case #20: Array. Array with multiple numbers, single multiple. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND({10, 20}, {5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND({10, 20}, {5}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 10, 'Test: Positive case: Array. Array with multiple numbers, single multiple. 2 of 2 arguments used.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 20, 'Test: Positive case: Array. Array with multiple numbers, single multiple. 2 of 2 arguments used.');
		// Case #21: Formula. Nested IF formula returning valid number. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(IF(TRUE, 15, 5), 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(IF(TRUE, 15, 5), 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Formula. Nested IF formula returning valid number. 2 of 2 arguments used.');
		// Case #22: Number. High-precision decimal numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(1000.123456, 0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(1000.123456, 0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000.12, 'Test: Positive case: Number. High-precision decimal numbers. 2 of 2 arguments used.');
		// Case #23: String. Time string converted to number (fraction of day). 2 of 2 arguments used.
		oParser = new parserFormula('MROUND("12:30", "0.1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND("12:30", "0.1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Time string converted to number (fraction of day). 2 of 2 arguments used.');
		// Case #24: Formula. Nested ROUND formula for number. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(ROUND(10.555, 2), 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(ROUND(10.555, 2), 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.5, 'Test: Positive case: Formula. Nested ROUND formula for number. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Multiple is zero, returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Multiple is zero, returns #NUM!. 2 of 2 arguments used.');
		// Case #2: Number. Different signs for number and multiple, returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, -3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, -3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Different signs for number and multiple, returns #NUM!. 2 of 2 arguments used.');
		// Case #3: Number. Different signs for number and multiple, returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(-10, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(-10, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Different signs for number and multiple, returns #NUM!. 2 of 2 arguments used.');
		// Case #4: String. Non-numeric string for number, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND("abc", 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND("abc", 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for number, returns #VALUE!. 2 of 2 arguments used.');
		// Case #5: String. Non-numeric string for multiple, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for multiple, returns #VALUE!. 2 of 2 arguments used.');
		// Case #6: Error. Propagates #N/A error. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(NA(), 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(NA(), 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 of 2 arguments used.');
		// Case #7: Error. Propagates #N/A error for multiple. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for multiple. 2 of 2 arguments used.');
		// Case #8: Area. Multi-cell range for number, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(A104:A105, A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(A104:A105, A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for number, returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: Area. Multi-cell range for multiple, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(A107, A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(A107, A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for multiple, returns #VALUE!. 2 of 2 arguments used.');
		// Case #10: Empty. Empty cell reference for number, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(A110, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(A110, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty cell reference for number, returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Empty. Empty cell reference for multiple, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty cell reference for multiple, returns #VALUE!. 2 of 2 arguments used.');
		// Case #12: Boolean. Boolean TRUE for number, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(TRUE, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(TRUE, 3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean TRUE for number, returns #VALUE!. 2 of 2 arguments used.');
		// Case #13: Boolean. Boolean FALSE for multiple, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE for multiple, returns #VALUE!. 2 of 2 arguments used.');
		// Case #14: Ref3D. 3D reference to text cell for number, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(Sheet2!A8, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(Sheet2!A8, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to text cell for number, returns #VALUE!. 2 of 2 arguments used.');
		// Case #15: Ref3D. 3D reference to text cell for multiple, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, Sheet2!A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, Sheet2!A9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to text cell for multiple, returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Name. Named range with text for number, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(TestNameArea, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(TestNameArea, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text for number, returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Name. Named range with text for multiple, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text for multiple, returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Name3D. 3D named range with text for number, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(TestNameArea3D2, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(TestNameArea3D2, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with text for number, returns #VALUE!. 2 of 2 arguments used.');
		// Case #19: Name3D. 3D named range with text for multiple, returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(10, TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(10, TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.4, 'Test: Negative case: Name3D. 3D named range with text for multiple, returns #VALUE!. 2 of 2 arguments used.');
		// Case #22: Formula. Formula resulting in #NUM!, propagates error. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(SQRT(-1), 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(SQRT(-1), 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM!, propagates error. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Smallest valid positive numbers. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(1E-307, 1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(1E-307, 1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Smallest valid positive numbers. 2 of 2 arguments used.');
		// Case #2: Number. Largest valid number with multiple of 1. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(9.99999999999999E+307, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(9.99999999999999E+307, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number. Largest valid number with multiple of 1. 2 of 2 arguments used.');
		// Case #3: Number. Smallest valid negative numbers with same sign. 2 of 2 arguments used.
		oParser = new parserFormula('MROUND(-1E-307, -1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MROUND(-1E-307, -1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-307, 'Test: Bounded case: Number. Smallest valid negative numbers with same sign. 2 of 2 arguments used.');

		// Need to fix: ms result diff, area errors, array errors?, small val diff
		// Case #10: Name3D. 3D named range with valid numbers
		// Case #12: Area3D. 3D single-cell range. 2 of 2 arguments used.
		// Case #15: Date. Date as serial number rounded to multiple of 5. 2 of 2 arguments used.
		// Case #20: Array. Array with multiple numbers, single multiple. 2 of 2 arguments used.
		// Case #12: Boolean. Boolean TRUE for number, returns #VALUE!. 2 of 2 arguments used.
		// Case #13: Boolean. Boolean FALSE for multiple, returns #VALUE!. 2 of 2 arguments used.
		// Case #2: Number. Largest valid number with multiple of 1. 2 of 2 arguments used.

		testArrayFormula2(assert, "MROUND", 2, 2, true, null);
	});

	QUnit.test("Test: \"MULTINOMIAL\"", function (assert) {
		oParser = new parserFormula("MULTINOMIAL(2,3,4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), Math.fact(2 + 3 + 4) / (Math.fact(2) * Math.fact(3) * Math.fact(4)));

		oParser = new parserFormula("MULTINOMIAL(2,3,\"r\")", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("MULTINOMIAL(150,50)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("B101").setValue("4");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		ws2.getRange2("A3:B4").setValue("Text");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Single integer argument. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Single integer argument. 1 argument used.');
		// Case #2: Number. Single float argument, truncated to integer. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Single float argument, truncated to integer. 1 argument used.');
		// Case #3: Number. Two integer arguments. 2 arguments used.
		oParser = new parserFormula('MULTINOMIAL(3,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(3,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number. Two integer arguments. 2 arguments used.');
		// Case #4: Number. Three integer arguments. 3 arguments used.
		oParser = new parserFormula('MULTINOMIAL(2,3,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(2,3,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1260, 'Test: Positive case: Number. Three integer arguments. 3 arguments used.');
		// Case #5: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL("2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #6: String. Two strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('MULTINOMIAL("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL("2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String. Two strings convertible to numbers. 2 arguments used.');
		// Case #7: Formula. Nested formula returning integer. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested formula returning integer. 1 argument used.');
		// Case #8: Formula. Two nested formulas returning integers. 2 arguments used.
		oParser = new parserFormula('MULTINOMIAL(ABS(-2),ROUND(3.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(ABS(-2),ROUND(3.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Formula. Two nested formulas returning integers. 2 arguments used.');
		// Case #9: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #10: Reference link. Two references to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('MULTINOMIAL(A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link. Two references to cells with valid numbers. 2 arguments used.');
		// Case #11: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #12: Area. Two single-cell ranges. 2 arguments used.
		oParser = new parserFormula('MULTINOMIAL(A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(A104:A104,A105:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Two single-cell ranges. 2 arguments used.');
		// Case #13: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL({2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL({2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #14: Array. Array with two elements. 2 arguments used.
		oParser = new parserFormula('MULTINOMIAL({2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL({2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Array. Array with two elements. 2 arguments used.');
		// Case #15: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #16: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #17: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #18: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #19: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #20: Formula. Nested IF formula returning valid number. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(IF(TRUE,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(IF(TRUE,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested IF formula returning valid number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Negative number returns #NUM!. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number returns #NUM!. 1 argument used.');
		// Case #2: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #3: Empty. Reference to empty cell returns #VALUE!.
		oParser = new parserFormula('MULTINOMIAL(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Boolean. Boolean FALSE (0) is valid, but testing for clarity. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE (0) is valid, but testing for clarity. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('MULTINOMIAL(A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(A107:A108) is parsed.');
		// ?assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #7: Array. Array with negative number returns #NUM!.
		oParser = new parserFormula('MULTINOMIAL({-1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL({-1}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with negative number returns #NUM!.');
		// Case #8: Ref3D. 3D reference to text returns #VALUE!.
		oParser = new parserFormula('MULTINOMIAL(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!.');
		// Case #9: Name. Named range with multi-cell range returns #VALUE!.
		oParser = new parserFormula('MULTINOMIAL(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with multi-cell range returns #VALUE!.');
		// Case #10: Name3D. 3D named range with multi-cell range returns #VALUE!.
		oParser = new parserFormula('MULTINOMIAL(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(TestNameArea3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name3D. 3D named range with multi-cell range returns #VALUE!.');
		// Case #12: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #13: Number. Two negative numbers return #NUM!. 2 arguments used.
		oParser = new parserFormula('MULTINOMIAL(-2,-3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(-2,-3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Two negative numbers return #NUM!. 2 arguments used.');
		// Case #14: String. String convertible to float, truncated to integer. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL("2.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL("2.5") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: String. String convertible to float, truncated to integer. 1 argument used.');
		// Case #15: Date. Date as large number returns valid result, testing for clarity. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(DATE(2025,1,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date as large number returns valid result, testing for clarity. 1 argument used.');
		// Case #16: Time. Time value (0.5) truncated to 0, valid but testing for clarity. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Time. Time value (0.5) truncated to 0, valid but testing for clarity. 1 argument used.');
		// Case #17: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('MULTINOMIAL(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with text returns #VALUE!.
		oParser = new parserFormula('MULTINOMIAL(A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!.');
		// Case #19: Number. Zero is valid, testing for clarity. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Zero is valid, testing for clarity. 1 argument used.');
		// Case #20: Number. Negative float truncated to negative integer, returns #NUM!. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative float truncated to negative integer, returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid value (0). 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid value (0). 1 argument used.');
		// Case #2: Number. Maximum valid Excel number, truncated to integer. 1 argument used.
		oParser = new parserFormula('MULTINOMIAL(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(9.99999999999999E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number, truncated to integer. 1 argument used.');
		// Case #3: Number. Three zero arguments, minimum valid. 3 arguments used.
		oParser = new parserFormula('MULTINOMIAL(0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MULTINOMIAL(0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Three zero arguments, minimum valid. 3 arguments used.');

		// Need to fix: error different types, string handle, table and name handle
		// Case #5: String. String convertible to number. 1 argument used.
		// Case #6: String. Two strings convertible to numbers. 2 arguments used.
		// Case #7: Array. Array with negative number returns #NUM!.
		// Case #12: Area. Two single-cell ranges. 2 arguments used.
		// Case #14: String. String convertible to float, truncated to integer. 1 argument used.
		// Case #15: Date. Date as large number returns valid result, testing for clarity. 1 argument used.
		// Case #2: Number. Maximum valid Excel number, truncated to integer. 1 argument used.
		// Case #6: Area. Multi-cell range returns #VALUE!.
		// Case #9: Name. Named range with multi-cell range returns #VALUE!.

		testArrayFormula2(assert, "MULTINOMIAL", 1, 8, null, true);
	});

	QUnit.test("Test: \"MUNIT\"", function (assert) {
		ws.getRange2("A101:B102").cleanAll();
		ws.getRange2("A101").setValue("5");
		ws.getRange2("B102").setValue("6");

		oParser = new parserFormula("MUNIT(1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1);

		oParser = new parserFormula("MUNIT(-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("MUNIT(1.123)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1);

		oParser = new parserFormula("MUNIT(2.123)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue(), 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 0);

		oParser = new parserFormula("MUNIT(A101)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue(), 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 0);

		oParser = new parserFormula("MUNIT(A101:B102)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), "#VALUE!");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), "#VALUE!");
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 1);

		oParser = new parserFormula("MUNIT({0,0;1,2;123,\"sdf\"})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), "#VALUE!");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue(), 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue(), 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 1).getValue(), "#VALUE!");

		oParser = new parserFormula("MUNIT({12,2})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 1);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: integer > 0. Returns 2x2 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Basic valid input: integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 0, 'Test: Positive case: Number. Basic valid input: integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Number. Basic valid input: integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 1, 'Test: Positive case: Number. Basic valid input: integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		// Case #2: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(3) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 0, 'Test: Positive case: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,2).getValue(), 0, 'Test: Positive case: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 1, 'Test: Positive case: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,2).getValue(), 0, 'Test: Positive case: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 0, 'Test: Positive case: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,1).getValue(), 0, 'Test: Positive case: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,2).getValue(), 1, 'Test: Positive case: Number. Valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		// Case #3: String. String convertible to integer > 0. Returns 4x4 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT("4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT("4") is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: String. String convertible to integer > 0. Returns 4x4 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,1).getValue(), 1, 'Test: Positive case: String. String convertible to integer > 0. Returns 4x4 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,2).getValue(), 1, 'Test: Positive case: String. String convertible to integer > 0. Returns 4x4 identity matrix. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(3,3).getValue(), 1, 'Test: Positive case: String. String convertible to integer > 0. Returns 4x4 identity matrix. 1 argument used.');
		// Case #4: Formula. Nested formula evaluating to integer > 0. Returns 3x3 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Formula. Nested formula evaluating to integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		// Case #5: Formula. Nested formula rounding to integer > 0. Returns 5x5 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(ROUND(4.7,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(ROUND(4.7,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Formula. Nested formula rounding to integer > 0. Returns 5x5 identity matrix. 1 argument used.');
		// Case #6: Formula. Nested IF formula returning integer > 0. Returns 2x2 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(IF(TRUE,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(IF(TRUE,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Formula. Nested IF formula returning integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		// Case #7: Reference link. Reference to cell with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. Reference to cell with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		// Case #8: Area. Single-cell range with valid integer > 0. Returns 3x3 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Area. Single-cell range with valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		// Case #9: Array. Array with single integer > 0. Returns 4x4 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT({4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT({4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Array with single integer > 0. Returns 4x4 identity matrix. 1 argument used.');
		// Case #10: Name. Named range with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Name. Named range with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		// Case #11: Name3D. 3D named range with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Name3D. 3D named range with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		// Case #12: Ref3D. 3D reference to cell with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D reference to cell with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		// Case #13: Area3D. 3D single-cell range with valid integer > 0. Returns 3x3 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell range with valid integer > 0. Returns 3x3 identity matrix. 1 argument used.');
		// Case #14: Table. Table structured reference with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid integer > 0. Returns 2x2 identity matrix. 1 argument used.');
		// Case #15: Date. Date as serial number (large integer). Returns large identity matrix (Excel limits apply). 1 argument used.
		oParser = new parserFormula('MUNIT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(DATE(2025,1,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number (large integer). Returns large identity matrix (Excel limits apply). 1 argument used.');
		// Case #16: Time. Time adjusted to integer >= 1. Returns 3x3 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(TIME(0,0,0)+3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(TIME(0,0,0)+3) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Time. Time adjusted to integer >= 1. Returns 3x3 identity matrix. 1 argument used.');
		// Case #17: Number. Larger valid integer. Returns 10x10 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(10) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Larger valid integer. Returns 10x10 identity matrix. 1 argument used.');
		// Case #18: String. String convertible to larger integer. Returns 100x100 identity matrix (Excel limits apply). 1 argument used.
		oParser = new parserFormula('MUNIT("100")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT("100") is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: String. String convertible to larger integer. Returns 100x100 identity matrix (Excel limits apply). 1 argument used.');
		// Case #19: Formula. Nested formula evaluating to integer > 0. Returns 5x5 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(ABS(-5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(ABS(-5)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Formula. Nested formula evaluating to integer > 0. Returns 5x5 identity matrix. 1 argument used.');
		// Case #20: Array. Array with multiple valid integers. Returns first elements matrix (10x10 identity matrix). 1 argument used.
		oParser = new parserFormula('MUNIT({10,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT({10,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Array with multiple valid integers. Returns first elements matrix (10x10 identity matrix). 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 1, 'Test: Positive case: Array. Array with multiple valid integers. Returns first elements matrix (10x10 identity matrix). 1 argument used.');
		// Case #21: Formula. Nested formula evaluating to integer > 0. Returns the SUM of the matrix 1000x1000.
		oParser = new parserFormula('SUM(MUNIT(1000))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MUNIT(1000)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Positive case: Formula. Nested formula evaluating to integer > 0. Returns the SUM of the matrix 1000x1000.');


		// Negative cases:
		// Case #1: Number. Zero returns #NUM! error (n must be positive). 1 argument used.
		oParser = new parserFormula('MUNIT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Zero returns #NUM! error (n must be positive). 1 argument used.');
		// Case #2: Number. Negative number returns #NUM! error (n must be positive). 1 argument used.
		oParser = new parserFormula('MUNIT(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Negative number returns #NUM! error (n must be positive). 1 argument used.');
		// Case #3: Number. Non-integer number returns #NUM! error (n must be integer). 1 argument used.
		oParser = new parserFormula('MUNIT(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Number. Non-integer number returns #NUM! error (n must be integer). 1 argument used.');
		// Case #4: String. Non-numeric string returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('MUNIT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE! error. 1 argument used.');
		// Case #5: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('MUNIT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #6: Empty. Reference to empty cell returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('MUNIT(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference to empty cell returns #VALUE! error. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('MUNIT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE! error. 1 argument used.');
		// Case #8: Boolean. Boolean FALSE (0) returns #NUM! error. 1 argument used.
		oParser = new parserFormula('MUNIT(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM! error. 1 argument used.');
		// Case #9: Boolean. Boolean TRUE (1) returns 1x1 identity matrix (valid but edge case, treated as negative for testing). 1 argument used.
		oParser = new parserFormula('MUNIT(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Boolean. Boolean TRUE (1) returns 1x1 identity matrix (valid but edge case, treated as negative for testing). 1 argument used.');
		// Case #10: Area. Multi-cell range can returns error depends on the value. 1 argument used.
		oParser = new parserFormula('MUNIT(A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range can returns error depends on the value. 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Test: Negative case: Area. Multi-cell range can returns error depends on the value. 1 argument used.');
		// Case #11: Array. Array with multiple elements returns #NUM! error (uses first element if valid). 1 argument used.
		oParser = new parserFormula('MUNIT({1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT({1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Array. Array with multiple elements returns #NUM! error (uses first element if valid). 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 1, 'Test: Negative case: Array. Array with multiple elements returns #NUM! error (uses first element if valid). 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,2).getValue(), 1, 'Test: Negative case: Array. Array with multiple elements returns #NUM! error (uses first element if valid). 1 argument used.');
		// Case #12: Ref3D. 3D reference to text returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('MUNIT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE! error. 1 argument used.');
		// Case #13: Name. Named range with text returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('MUNIT(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), "#VALUE!", 'Test: Negative case: Name. Named range with text returns #VALUE! error. 1 argument used.');
		// Case #14: Name3D. 3D named range with text returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('MUNIT(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), "#VALUE!", 'Test: Negative case: Name3D. 3D named range with text returns #VALUE! error. 1 argument used.');
		// Case #16: Formula. Formula resulting in #NUM! error propagates error. 1 argument used.
		oParser = new parserFormula('MUNIT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error propagates error. 1 argument used.');
		// Case #17: Time. Time value (0.5) returns #NUM! error (non-integer). 1 argument used.
		oParser = new parserFormula('MUNIT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Time. Time value (0.5) returns #NUM! error (non-integer). 1 argument used.');
		// Case #18: String. String convertible to negative number returns #NUM! error. 1 argument used.
		oParser = new parserFormula('MUNIT("-2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT("-2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String convertible to negative number returns #NUM! error. 1 argument used.');
		// Case #19: Number. Excessively large number exceeds Excel limits, returns #NUM! error. 1 argument used.
		oParser = new parserFormula('MUNIT(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Excessively large number exceeds Excel limits, returns #NUM! error. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid value (n=1). Returns 1x1 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Number. Minimum valid value (n=1). Returns 1x1 identity matrix. 1 argument used.');
		// Case #2: Number. Maximum valid value for Excel array size (approximate limit). Returns 255x255 identity matrix. 1 argument used.
		oParser = new parserFormula('MUNIT(255)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT(255) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Number. Maximum valid value for Excel array size (approximate limit). Returns 255x255 identity matrix. 1 argument used.');
		// Case #3: Array. Array with minimum and maximum valid integers. Returns 1x1 identity matrix (uses first element). 1 argument used.
		oParser = new parserFormula('MUNIT({1,255})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MUNIT({1,255}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Array. Array with minimum and maximum valid integers. Returns 1x1 identity matrix (uses first element). 1 argument used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 1, 'Test: Bounded case: Array. Array with minimum and maximum valid integers. Returns 1x1 identity matrix (uses first element). 1 argument used.');

		// Need to fix: app crash when we get big number in arg
		// Case #15: Date. Date as serial number (large integer)
		// Case #19: Number. Excessively large number exceeds Excel limits, returns #NUM! error. 1 argument used.Case #2: Number. Maximum valid value for Excel array size (approximate limit).

	});

	QUnit.test("Test: \"ODD\"", function (assert) {

		oParser = new parserFormula("ODD(1.5)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("ODD(3)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("ODD(2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("ODD(-1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1);

		oParser = new parserFormula("ODD(-2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -3);


		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: positive integer. 1 argument used.
		oParser = new parserFormula('ODD(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number. Basic valid input: positive integer. 1 argument used.');
		// Case #1: Number. Basic valid input: negative integer. 1 argument used.
		oParser = new parserFormula('ODD(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Positive case: Number. Basic valid input: negative integer. 1 argument used.');
		// Case #2: Number. Float input: positive decimal. 1 argument used.
		oParser = new parserFormula('ODD(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number. Float input: positive decimal. 1 argument used.');
		// Case #3: Number. Float input: negative decimal. 1 argument used.
		oParser = new parserFormula('ODD(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Positive case: Number. Float input: negative decimal. 1 argument used.');
		// Case #4: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('ODD("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #5: String. String convertible to negative number. 1 argument used.
		oParser = new parserFormula('ODD("-2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD("-2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Positive case: String. String convertible to negative number. 1 argument used.');
		// Case #6: Formula. Nested formula returning integer. 1 argument used.
		oParser = new parserFormula('ODD(SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. Nested formula returning integer. 1 argument used.');
		// Case #7: Formula. Nested formula returning float. 1 argument used.
		oParser = new parserFormula('ODD(ABS(-1.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(ABS(-1.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. Nested formula returning float. 1 argument used.');
		// Case #8: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('ODD(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #9: Area. Single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('ODD(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area. Single-cell range with valid number. 1 argument used.');
		// Case #10: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('ODD({3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD({3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #11: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('ODD(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #12: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('ODD(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #13: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('ODD(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #14: Area3D. 3D single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('ODD(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell range with valid number. 1 argument used.');
		// Case #15: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('ODD(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #16: Date. Date as serial number. 1 argument used.
		oParser = new parserFormula('ODD(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45659, 'Test: Positive case: Date. Date as serial number. 1 argument used.');
		// Case #17: Time. Time adjusted to valid number. 1 argument used.
		oParser = new parserFormula('ODD(TIME(12,0,0)*100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(TIME(12,0,0)*100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 51, 'Test: Positive case: Time. Time adjusted to valid number. 1 argument used.');
		// Case #18: Formula. ODD inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(ODD(2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(ODD(2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. ODD inside SUM formula. 1 argument used.');
		// Case #19: Array. Multi-element array, processes first element. 1 argument used.
		oParser = new parserFormula('ODD({1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD({1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Multi-element array, processes first element. 1 argument used.');
		// Case #20: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('ODD(IF(TRUE,2,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(IF(TRUE,2,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');

		// Negative cases:
		// Case #0: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #1: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('ODD(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #2: Empty. Reference to empty cell returns 0 (Excel behavior). 1 argument used.
		oParser = new parserFormula('ODD(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. Reference to empty cell returns 0 (Excel behavior). 1 argument used.');
		// Case #3: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #4: Boolean. Boolean TRUE (1) returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('ODD(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result but unexpected type. 1 argument used.');
		// Case #5: Boolean. Boolean FALSE (0) returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('ODD(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean FALSE (0) returns valid result but unexpected type. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #7: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(TestNameArea3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('ODD(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #12: String. Date string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD("1/1/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD("1/1/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45659, 'Test: Negative case: String. Date string returns #VALUE!. 1 argument used.');
		// Case #13: Array. Array with boolean returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('ODD({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD({TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Array. Array with boolean returns valid result but unexpected type. 1 argument used.');
		// Case #14: Time. Time value (0.5) returns valid result but unexpected type. 1 argument used.
		oParser = new parserFormula('ODD(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Time. Time value (0.5) returns valid result but unexpected type. 1 argument used.');
		// Case #15: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('ODD(DIVIDE(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(DIVIDE(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #16: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #17: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #18: String. String representing out-of-range number returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD("1.5E+308")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD("1.5E+308") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String representing out-of-range number returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('ODD(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #20: Name. Named range with error returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ODD(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with error returns #VALUE!. 1 argument used.');

		// Bounded cases:
		// Case #0: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('ODD(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #1: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('ODD(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -9.99999999999999e+307, 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #2: Number. Smallest positive Excel number. 1 argument used.
		oParser = new parserFormula('ODD(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Smallest positive Excel number. 1 argument used.');
		// Case #3: Number. Smallest negative Excel number. 1 argument used.
		oParser = new parserFormula('ODD(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODD(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Number. Smallest negative Excel number. 1 argument used.');

		// Need to fix: area handle
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		// Case #9: Name3D. 3D named range with text returns #VALUE!. 1 argument used.

		testArrayFormula(assert, "ODD");

	});

	QUnit.test("Test: \"POWER\"", function (assert) {
		let array;

		// ------------------------- same tests as in Pow operator tests ------------------------- //
		ws.getRange2("A100").setValue("2");
		ws.getRange2("A101").setValue("3");
		ws.getRange2("A102").setValue("4");
		ws.getRange2("B100").setValue("1");
		ws.getRange2("B101").setValue("2");
		ws.getRange2("B102").setValue("#DIV/0!");
		ws.getRange2("D100").setValue("2");
		ws.getRange2("D101").setValue("3");
		ws.getRange2("E100").setValue("3");
		ws.getRange2("E101").setValue("");

		oParser = new parserFormula("POWER(A100:B102,2)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(A100:B102,2)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 4, 'Result of A100:B102^2[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 9, 'Result of A100:B102^2[1,0]');
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 16, 'Result of A100:B102^2[2,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, 'Result of A100:B102^2[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, 'Result of A100:B102^2[1,1]');
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), "#DIV/0!", 'Result of A100:B102^2[2,1]');

		oParser = new parserFormula("POWER(A100:B102,A100)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(A100:B102,A100)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 4, 'Result of A100:B102^A100[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 9, 'Result of A100:B102^A100[1,0]');
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 16, 'Result of A100:B102^A100[2,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, 'Result of A100:B102^A100[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, 'Result of A100:B102^A100[1,1]');
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), "#DIV/0!", 'Result of A100:B102^A100[2,1]');

		oParser = new parserFormula("POWER(A100:B102,A100:A100)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(A100:B102,A100:A100)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 4, 'Result of A100:B102^A100:A100[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 9, 'Result of A100:B102^A100:A100[1,0]');
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 16, 'Result of A100:B102^A100:A100[2,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, 'Result of A100:B102^A100:A100[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, 'Result of A100:B102^A100:A100[1,1]');
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), "#DIV/0!", 'Result of A100:B102^A100:A100[2,1]');

		oParser = new parserFormula("POWER(2,A100:B102)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(2,A100:B102)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 4, 'Result of 2^A100:B102[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 8, 'Result of 2^A100:B102[1,0]');
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 16, 'Result of 2^A100:B102[2,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, 'Result of 2^A100:B102[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, 'Result of 2^A100:B102[1,1]');
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), "#DIV/0!", 'Result of 2^A100:B102[2,1]');

		oParser = new parserFormula("POWER(A100,A100:B102)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(A100,A100:B102)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 4, 'Result of A100^A100:B102[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 8, 'Result of A100^A100:B102[1,0]');
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 16, 'Result of A100^A100:B102[2,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, 'Result of A100^A100:B102[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, 'Result of A100^A100:B102[1,1]');
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), "#DIV/0!", 'Result of A100^A100:B102[2,1]');

		oParser = new parserFormula("POWER(A100:A100,A100:B102)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(A100:A100,A100:B102)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 4, 'Result of A100:A100^A100:B102[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 8, 'Result of A100:A100^A100:B102[1,0]');
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 16, 'Result of A100:A100^A100:B102[2,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, 'Result of A100:A100^A100:B102[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, 'Result of A100:A100^A100:B102[1,1]');
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), "#DIV/0!", 'Result of A100:A100^A100:B102[2,1]');
		
		oParser = new parserFormula("POWER(A100:B102,D100:E101)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(A100:B102,D100:E101)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 4, 'Result of A100:B102^D100:E101[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 27, 'Result of A100:B102^D100:E101[1,0]');
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), "#N/A", 'Result of A100:B102^D100:E101[2,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, 'Result of A100:B102^D100:E101[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 1, 'Result of A100:B102^D100:E101[1,1]');
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), "#DIV/0!", 'Result of A100:B102^D100:E101[2,1]');

		ws.getRange2("G100").setValue("a");
		ws.getRange2("G101").setValue("b");
		ws.getRange2("H100").setValue("c");
		ws.getRange2("H101").setValue("d");

		oParser = new parserFormula("POWER(G100:H101,2)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(G100:H101,2)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), "#VALUE!", 'Result of G100:H101^2[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#VALUE!", 'Result of G100:H101^2[1,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!", 'Result of G100:H101^2[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "#VALUE!", 'Result of G100:H101^2[1,1]');

		oParser = new parserFormula("POWER(2,G100:H101)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(2,G100:H101)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), "#VALUE!", 'Result of 2^G100:H101[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#VALUE!", 'Result of 2^G100:H101[1,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!", 'Result of 2^G100:H101[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "#VALUE!", 'Result of 2^G100:H101[1,1]');

		oParser = new parserFormula("POWER(G100:H101,G100:H101)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(G100:H101,G100:H101)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), "#VALUE!", 'Result of G100:H101^G100:H101[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#VALUE!", 'Result of G100:H101^G100:H101[1,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!", 'Result of G100:H101^G100:H101[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "#VALUE!", 'Result of G100:H101^G100:H101[1,1]');

		ws.getRange2("I100").setValue("#N/A");
		ws.getRange2("I101").setValue("#DIV/0!");
		ws.getRange2("J100").setValue("#NUM!");
		ws.getRange2("J101").setValue("0");

		oParser = new parserFormula("POWER(I100:J101,2)", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(I100:J101,2)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), "#N/A", 'Result of POWER(I100:J101,2)[0,0]');
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#DIV/0!", 'Result of POWER(I100:J101,2)[1,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#NUM!", 'Result of POWER(I100:J101,2)[0,1]');
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 0, 'Result of POWER(I100:J101,2)[1,1]');

		ws.getRange2("A100").setValue("75");
		ws.getRange2("B100").setValue("100");
		ws.getRange2("C100").setValue("200");
		ws.getRange2("D100").setValue("300");
		ws.getRange2("E100").setValue("350");
		ws.getRange2("F100").setValue("400");
		ws.getRange2("G100").setValue("500");

		oParser = new parserFormula("POWER(A100:G100,{1,2,1})", "A1", ws);
		assert.ok(oParser.parse(), 'POWER(A100:G100,{1,2,1})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 75, 'Result of POWER(A100:G100,{1,2,1})[0,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 10000, 'Result of POWER(A100:G100,{1,2,1})[0,1]');
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 200, 'Result of POWER(A100:G100,{1,2,1})[0,2]');
		assert.strictEqual(array.getElementRowCol(0, 3).getValue(), "#N/A", 'Result of POWER(A100:G100,{1,2,1})[0,3]');
		assert.strictEqual(array.getElementRowCol(0, 4).getValue(), "#N/A", 'Result of POWER(A100:G100,{1,2,1})[0,4]');
		assert.strictEqual(array.getElementRowCol(0, 5).getValue(), "#N/A", 'Result of POWER(A100:G100,{1,2,1})[0,5]');
		assert.strictEqual(array.getElementRowCol(0, 6).getValue(), "#N/A", 'Result of POWER(A100:G100,{1,2,1})[0,6]');

		// ------------------------- same tests as in Pow operator tests ------------------------- //


		oParser = new parserFormula("POWER(0,0)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(0,0)");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of POWER(0,0)");	// ms - #NUM!, js - 1, LO - 1, gs - 1

		oParser = new parserFormula("POWER(0,1)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of POWER(0,1)");

		oParser = new parserFormula("POWER(0,-1)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(0,-1)");
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", "Result of POWER(0,-1)");

		oParser = new parserFormula("POWER(0,1/3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(0,1/3)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of POWER(0,1/3)");

		oParser = new parserFormula("POWER(0,-1/3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(0,-1/3)");
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", "Result of POWER(0,-1/3)");

		oParser = new parserFormula("POWER(0,-3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(0,-3)");
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", "Result of POWER(0,-3)");

		oParser = new parserFormula("POWER(1,-3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(1,-3)");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of POWER(1,-3)");

		oParser = new parserFormula("POWER(1,-1/3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(1,-1/3)");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of POWER(1,-1/3)");

		oParser = new parserFormula("POWER(1,1/3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(1,1/3)");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of POWER(1,1/3)");

		oParser = new parserFormula("POWER(-1,1/2)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-1,1/2)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of POWER(-1,1/2)");

		oParser = new parserFormula("POWER(-1,1/3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-1,1/3)");
		assert.strictEqual(oParser.calculate().getValue(), -1, "Result of POWER(-1,1/3)");

		oParser = new parserFormula("POWER(-1,-1/3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-1,-1/3)");
		assert.strictEqual(oParser.calculate().getValue(), -1, "Result of POWER(-1,-1/3)");

		oParser = new parserFormula("POWER(-1,1/4)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-1,1/4)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of POWER(-1,1/4)");

		oParser = new parserFormula("POWER(-1,1/5)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-1,1/5)");
		assert.strictEqual(oParser.calculate().getValue(), -1, "Result of POWER(-1,1/5)");

		oParser = new parserFormula("POWER(-8,1/3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-8,1/3)");
		assert.strictEqual(oParser.calculate().getValue(), -2, "Result of POWER(-8,1/3)");

		oParser = new parserFormula("POWER(-8,-1/3)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-8,-1/3)");
		assert.strictEqual(oParser.calculate().getValue(), -0.5, "Result of POWER(-8,-1/3)");

		oParser = new parserFormula("POWER(-8,1/4)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-8,1/4)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of POWER(-8,1/4)");

		oParser = new parserFormula("POWER(-8,1/5)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-8,1/5)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), "-1.52", "Result of POWER(-8,1/5)");

		oParser = new parserFormula("POWER(-8,-1/5)", "A1", ws);
		assert.ok(oParser.parse(), "POWER(-8,-1/5)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), "-0.66", "Result of POWER(-8,-1/5)");

		oParser = new parserFormula('POWER("8",2)', "A1", ws);
		assert.ok(oParser.parse(), 'POWER("8",2)');
		assert.strictEqual(oParser.calculate().getValue(), 64, 'Result of POWER("8",2)');

		oParser = new parserFormula('POWER("8","2")', "A1", ws);
		assert.ok(oParser.parse(), 'POWER("8","2")');
		assert.strictEqual(oParser.calculate().getValue(), 64, 'Result of POWER("8","2")');

		oParser = new parserFormula('POWER("-8","2")', "A1", ws);
		assert.ok(oParser.parse(), 'POWER("-8","2")');
		assert.strictEqual(oParser.calculate().getValue(), 64, 'Result of POWER("-8","2")');

		oParser = new parserFormula('POWER("8s",2)', "A1", ws);
		assert.ok(oParser.parse(), 'POWER("8s",2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of POWER("8s",2)');

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integer numbers. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Number. Basic valid input: integer numbers. 2 of 2 arguments used.');
		// Case #1: Number. Float base, integer power. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(1.5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(1.5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Positive case: Number. Float base, integer power. 2 of 2 arguments used.');
		// Case #2: Number. Integer base, float power. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(4,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(4,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Integer base, float power. 2 of 2 arguments used.');
		// Case #3: String. Strings convertible to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('POWER("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER("2","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: String. Strings convertible to numbers. 2 of 2 arguments used.');
		// Case #4: Formula. Nested formula in base. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(SQRT(16),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(SQRT(16),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Formula. Nested formula in base. 2 of 2 arguments used.');
		// Case #5: Formula. Nested formula in power. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(2,ABS(-3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(2,ABS(-3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Formula. Nested formula in power. 2 of 2 arguments used.');
		// Case #6: Reference link. Reference links to valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3535533905932738, 'Test: Positive case: Reference link. Reference links to valid numbers. 2 of 2 arguments used.');
		// Case #7: Area. Single-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Single-cell ranges. 2 of 2 arguments used.');
		// Case #8: Array. Arrays with single elements. 2 of 2 arguments used.
		oParser = new parserFormula('POWER({2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER({2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 8, 'Test: Positive case: Array. Arrays with single elements. 2 of 2 arguments used.');
		// Case #9: Name. Named ranges with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers. 2 of 2 arguments used.');
		// Case #10: Name3D. 3D named ranges with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers. 2 of 2 arguments used.');
		// Case #11: Ref3D. 3D references to valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(Sheet2!A1,Sheet2!A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D references to valid numbers. 2 of 2 arguments used.');
		// Case #12: Area3D. 3D single-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges. 2 of 2 arguments used.');
		// Case #13: Table. Table structured references with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured references with valid numbers. 2 of 2 arguments used.');
		// Case #14: Date. Date as serial number. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(DATE(2025,1,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(DATE(2025,1,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2084652964, 'Test: Positive case: Date. Date as serial number. 2 of 2 arguments used.');
		// Case #15: Time. Time adjusted to valid number. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(TIME(12,0,0)+1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(TIME(12,0,0)+1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Positive case: Time. Time adjusted to valid number. 2 of 2 arguments used.');
		// Case #16: String. Float string base, integer string power. 2 of 2 arguments used.
		oParser = new parserFormula('POWER("1.5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER("1.5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Positive case: String. Float string base, integer string power. 2 of 2 arguments used.');
		// Case #17: Formula. Nested IF in base. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(IF(TRUE,2,1),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(IF(TRUE,2,1),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Formula. Nested IF in base. 2 of 2 arguments used.');
		// Case #18: Array. Multi-element array in base. 2 of 2 arguments used.
		oParser = new parserFormula('POWER({2,4},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER({2,4},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 4, 'Test: Positive case: Array. Multi-element array in base. 2 of 2 arguments used.');
		// Case #19: Number. Zero base, zero power (returns 1 in Excel). 2 of 2 arguments used.
		oParser = new parserFormula('POWER(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Zero base, zero power (returns 1 in Excel). 2 of 2 arguments used.');
		// Case #20: Number. Negative base, even integer power. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(-2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(-2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Number. Negative base, even integer power. 2 of 2 arguments used.');
		// Case #21: String. Date string converted to serial number. 2 of 2 arguments used.
		oParser = new parserFormula('POWER("01/01/2025",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER("01/01/2025",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: String. Date string converted to serial number. 2 of 2 arguments used.');

		// Negative cases:
		// Case #0: Number. Negative base with fractional power returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(-1,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(-1,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative base with fractional power returns #NUM!. 2 of 2 arguments used.');
		// Case #1: String. Non-numeric string returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER("abc",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER("abc",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 2 of 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 of 2 arguments used.');
		// Case #3: Empty. Reference to empty cell returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(A104,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(A104,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 2 of 2 arguments used.');
		// Case #4: Area. Multi-cell range returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(A105:A106,A107:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(A105:A106,A107:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 2 of 2 arguments used.');
		// Case #5: Boolean. Boolean TRUE (1) is valid, but testing for clarity. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(TRUE,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(TRUE,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean TRUE (1) is valid, but testing for clarity. 2 of 2 arguments used.');
		// Case #6: Ref3D. 3D reference to non-numeric value returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(Sheet2!A5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(Sheet2!A5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to non-numeric value returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Name. Named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(TestNameArea2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(TestNameArea2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(2), '0.64', 'Test: Negative case: Name. Named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 of 2 arguments used.');
		// Case #10: Number. Overflow returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(1E+307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(1E+307,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Overflow returns #NUM!. 2 of 2 arguments used.');
		// Case #11: String. Empty string returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER("",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER("",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 2 of 2 arguments used.');
		// Case #12: Array. Boolean array returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER({FALSE},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER({FALSE},2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Array. Boolean array returns #NUM!. 2 of 2 arguments used.');
		// Case #13: Time. Time value (0.5) is valid, but testing small number. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(TIME(12,0,0),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(TIME(12,0,0),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Time. Time value (0.5) is valid, but testing small number. 2 of 2 arguments used.');
		// Case #14: Number. Negative base, fractional power returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(-2,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(-2,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative base, fractional power returns #NUM!. 2 of 2 arguments used.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(Sheet2!A6:A7,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(Sheet2!A6:A7,2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Name3D. 3D named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(TestNameArea3D2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(TestNameArea3D2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(2), '0.64', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: String. Non-numeric string in power returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER("2","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER("2","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string in power returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Formula. Formula resulting in #N/A propagates error. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(2,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(2,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Formula resulting in #N/A propagates error. 2 of 2 arguments used.');
		// Case #19: Number. Zero base, negative power returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(0,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(0,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Zero base, negative power returns #DIV/0!. 2 of 2 arguments used.');
		// Case #20: Reference link. Reference to text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(A108,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(A108,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to text returns #VALUE!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #0: Number. Smallest positive base. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(1E-307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Smallest positive base. 2 of 2 arguments used.');
		// Case #1: Number. Largest positive base. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(1E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(1E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Number. Largest positive base. 2 of 2 arguments used.');
		// Case #2: Number. Largest positive power. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(2,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(2,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Largest positive power. 2 of 2 arguments used.');
		// Case #3: Number. Largest negative power. 2 of 2 arguments used.
		oParser = new parserFormula('POWER(2,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POWER(2,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Largest negative power. 2 of 2 arguments used.');


		// Need to fix: diff results from MS
		// Case #10: Name3D. 3D named ranges with valid numbers. 2 of 2 arguments used.
		// Case #11: Ref3D. 3D references to valid numbers. 2 of 2 arguments used.
		// Case #19: Number. Zero base, zero power (returns 1 in Excel). 2 of 2 arguments used.
		// Case #7: Name. Named range with text returns #VALUE!. 2 of 2 arguments used.

	});

	QUnit.test("Test: \"POWER(2,8)\"", function (assert) {
		oParser = new parserFormula("POWER(2,8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), Math.pow(2, 8));
	});

	QUnit.test("Test: \"POWER(0,-3)\"", function (assert) {
		oParser = new parserFormula("POWER(0,-3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		testArrayFormula2(assert, "POWER", 2, 2);
	});

	QUnit.test("Test: \"PRODUCT\"", function (assert) {

		ws.getRange2("A2").setValue("5");
		ws.getRange2("A3").setValue("15");
		ws.getRange2("A4").setValue("30");

		oParser = new parserFormula("PRODUCT(A2:A4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2250);

		oParser = new parserFormula("PRODUCT(A2:A4, 2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4500);


		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Single integer input. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number. Single integer input. 1 of 3 arguments used.');
		// Case #2: Number,Number. Two integer inputs. 2 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number,Number. Two integer inputs. 2 of 3 arguments used.');
		// Case #3: Number,Number,Number. Three inputs with float and integers. 3 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(1.5,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(1.5,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Number,Number,Number. Three inputs with float and integers. 3 of 3 arguments used.');
		// Case #4: String. String convertible to number. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT("4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT("4") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: String. String convertible to number. 1 of 3 arguments used.');
		// Case #5: String,Number. String and number inputs. 2 of 3 arguments used.
		oParser = new parserFormula('PRODUCT("2",3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT("2",3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: String,Number. String and number inputs. 2 of 3 arguments used.');
		// Case #6: Formula. Nested formula returning number. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(SQRT(16))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(SQRT(16)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Nested formula returning number. 1 of 3 arguments used.');
		// Case #7: Formula,Number. Nested formula and number. 2 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(ABS(-4),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(ABS(-4),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Formula,Number. Nested formula and number. 2 of 3 arguments used.');
		// Case #8: Reference link. Reference to cell with valid number. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 of 3 arguments used.');
		// Case #9: Reference link,Number. Reference and number. 2 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(A101,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Reference link,Number. Reference and number. 2 of 3 arguments used.');
		// Case #10: Area. Single-cell range. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Single-cell range. 1 of 3 arguments used.');
		// Case #11: Area,Number. Two-cell range and number. 2 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(A103:A104,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(A103:A104,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Area,Number. Two-cell range and number. 2 of 3 arguments used.');
		// Case #12: Array. Array with multiple elements. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT({2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT({2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Array. Array with multiple elements. 1 of 3 arguments used.');
		// Case #13: Array,Number. Array and number. 2 of 3 arguments used.
		oParser = new parserFormula('PRODUCT({1,2},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT({1,2},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Array,Number. Array and number. 2 of 3 arguments used.');
		// Case #14: Name. Named range with valid number. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name. Named range with valid number. 1 of 3 arguments used.');
		// Case #15: Name3D. 3D named range. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named range. 1 of 3 arguments used.');
		// Case #16: Ref3D. 3D reference to cell. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(Sheet2!A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell. 1 of 3 arguments used.');
		// Case #17: Area3D. 3D single-cell range. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D single-cell range. 1 of 3 arguments used.');
		// Case #18: Table. Table structured reference. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference. 1 of 3 arguments used.');
		// Case #19: Date. Date as serial number. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date. Date as serial number. 1 of 3 arguments used.');
		// Case #20: Time. Time as fraction of a day. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Time. Time as fraction of a day. 1 of 3 arguments used.');
		// Case #21: Formula. Nested IF formula returning number. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(IF(TRUE,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(IF(TRUE,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Nested IF formula returning number. 1 of 3 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 of 3 arguments used.');
		// Case #2: Error. Propagates #N/A error. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 of 3 arguments used.');
		// Case #3: Empty. Reference to empty cell returns 0. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. Reference to empty cell returns 0. 1 of 3 arguments used.');
		// Case #4: String. Empty string returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 of 3 arguments used.');
		// Case #5: Boolean. Boolean TRUE treated as 1. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean TRUE treated as 1. 1 of 3 arguments used.');
		// Case #6: Reference link. Reference to cell with text returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!. 1 of 3 arguments used.');
		// Case #7: Area. Multi-cell range with text returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(A107:A108) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range with text returns #VALUE!. 1 of 3 arguments used.');
		// Case #8: Array. Array with boolean treated as 0. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with boolean treated as 0. 1 of 3 arguments used.');
		// Case #9: Name. Named range with text returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 of 3 arguments used.');
		// Case #10: Name3D. 3D named range with text returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference to text cell returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(Sheet2!A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to text cell returns #VALUE!. 1 of 3 arguments used.');
		// Case #12: Area3D. 3D multi-cell range with text returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(Sheet2!A4:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D multi-cell range with text returns #VALUE!. 1 of 3 arguments used.');
		// Case #14: Formula. Formula resulting in #NUM! propagates error. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 of 3 arguments used.');
		// Case #15: Formula,Number. Formula resulting in #DIV/0! propagates error. 2 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(DIVIDE(1,0),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(DIVIDE(1,0),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Formula,Number. Formula resulting in #DIV/0! propagates error. 2 of 3 arguments used.');
		// Case #16: String,Number. Non-numeric string with number returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PRODUCT("0.5a",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT("0.5a",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Number. Non-numeric string with number returns #VALUE!. 2 of 3 arguments used.');
		// Case #17: Array. Array with non-numeric element returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT({1,"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT({1,"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Array with non-numeric element returns #VALUE!. 1 of 3 arguments used.');
		// Case #18: Name. Named range with multi-cell text returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.6400000000000001, 'Test: Negative case: Name. Named range with multi-cell text returns #VALUE!. 1 of 3 arguments used.');
		// Case #19: Name3D. 3D named range with multi-cell text returns #VALUE!. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.6400000000000001, 'Test: Negative case: Name3D. 3D named range with multi-cell text returns #VALUE!. 1 of 3 arguments used.');
		// Case #20: Time. Time value of 0 returns 0. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Time. Time value of 0 returns 0. 1 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Maximum Excel number. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(1.79769313486232E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(1.79769313486232E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.79769313486232e+307, 'Test: Bounded case: Number. Maximum Excel number. 1 of 3 arguments used.');
		// Case #2: Number. Minimum Excel number. 1 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(-1.79769313486232E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(-1.79769313486232E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.79769313486232e+307, 'Test: Bounded case: Number. Minimum Excel number. 1 of 3 arguments used.');
		// Case #3: Number,Number. Maximum Excel number with multiplier, causes overflow to #NUM!. 2 of 3 arguments used.
		oParser = new parserFormula('PRODUCT(1.79769313486232E+307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRODUCT(1.79769313486232E+307,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.59538626972464e+307, 'Test: Bounded case: Number,Number. Maximum Excel number with multiplier, causes overflow to #NUM!. 2 of 3 arguments used.');

		// Need to fix: strings handle, array handle, area/3d handle
		// Case #4: String. String convertible to number. 1 of 3 arguments used.
		// Case #5: String,Number. String and number inputs. 2 of 3 arguments used.
		// Case #11: Area,Number. Two-cell range and number. 2 of 3 arguments used.
		// Case #16: Ref3D. 3D reference to cell. 1 of 3 arguments used.
		// Case #17: Area3D. 3D single-cell range. 1 of 3 arguments used.
		// Case #7: Area. Multi-cell range with text returns #VALUE!. 1 of 3 arguments used.
		// Case #8: Array. Array with boolean treated as 0. 1 of 3 arguments used.
		// Case #11: Ref3D. 3D reference to text cell returns #VALUE!. 1 of 3 arguments used.
		// Case #12: Area3D. 3D multi-cell range with text returns #VALUE!. 1 of 3 arguments used.

		testArrayFormula2(assert, "PRODUCT", 1, 8, null, true);
	});

	QUnit.test("Test: \"QUOTIENT\"", function (assert) {
		oParser = new parserFormula("QUOTIENT(1,6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("QUOTIENT(-10,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -3);

		oParser = new parserFormula("QUOTIENT(5,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("QUOTIENT(5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(2). Basic valid input: integer numerator and denominator. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(10,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(10,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number(2). Basic valid input: integer numerator and denominator. 2 of 2 arguments used.');
		// Case #2: Number(2). Integer division with remainder ignored. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(15,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(15,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2). Integer division with remainder ignored. 2 of 2 arguments used.');
		// Case #3: Number(2). Float inputs, valid division. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(7.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(7.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2). Float inputs, valid division. 2 of 2 arguments used.');
		// Case #4: String(2). String convertible to number. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT("10","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT("10","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String(2). String convertible to number. 2 of 2 arguments used.');
		// Case #5: Formula(2). Nested formula evaluating to valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(SQRT(100),SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(SQRT(100),SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula(2). Nested formula evaluating to valid numbers. 2 of 2 arguments used.');
		// Case #6: Formula(2). Nested IF formulas returning valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(IF(TRUE,10,5),IF(TRUE,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(IF(TRUE,10,5),IF(TRUE,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula(2). Nested IF formulas returning valid numbers. 2 of 2 arguments used.');
		// Case #7: Reference link(2). References to cells with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link(2). References to cells with valid numbers. 2 of 2 arguments used.');
		// Case #8: Area(2). Single-cell ranges with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area(2). Single-cell ranges with valid numbers. 2 of 2 arguments used.');
		// Case #9: Array(2). Arrays with single valid number elements. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT({10},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT({10},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 5, 'Test: Positive case: Array(2). Arrays with single valid number elements. 2 of 2 arguments used.');
		// Case #10: Name(2). Named ranges with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name(2). Named ranges with valid numbers. 2 of 2 arguments used.');
		// Case #11: Name3D(2). 3D named ranges with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name3D(2). 3D named ranges with valid numbers. 2 of 2 arguments used.');
		// Case #12: Ref3D(2). 3D references to cells with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D(2). 3D references to cells with valid numbers. 2 of 2 arguments used.');
		// Case #13: Area3D(2). 3D single-cell ranges with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(2). 3D single-cell ranges with valid numbers. 2 of 2 arguments used.');
		// Case #14: Table(2). Table structured references with valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table(2). Table structured references with valid numbers. 2 of 2 arguments used.');
		// Case #15: Date(2). Dates as serial numbers, valid division. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(DATE(2025,1,1),DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(DATE(2025,1,1),DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date(2). Dates as serial numbers, valid division. 2 of 2 arguments used.');
		// Case #16: Time(2). Time values adjusted to valid numbers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(TIME(12,0,0)*100,TIME(6,0,0)*100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(TIME(12,0,0)*100,TIME(6,0,0)*100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Time(2). Time values adjusted to valid numbers. 2 of 2 arguments used.');
		// Case #17: Formula. =QUOTIENT(SUM(8;2);2)
		oParser = new parserFormula('QUOTIENT(SUM(8,2),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(SUM(8,2),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. =QUOTIENT(SUM(8;2);2)');
		// Case #18: String. =QUOTIENT("15";F2)
		oParser = new parserFormula('QUOTIENT("15",A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT("15",A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String. =QUOTIENT("15";F2)');
		// Case #19: Number. =QUOTIENT(10;SQRT(4))
		oParser = new parserFormula('QUOTIENT(10,SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(10,SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number. =QUOTIENT(10;SQRT(4))');
		// Case #20: Array(2). Arrays with multiple valid number elements. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT({10,20},{2,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT({10,20},{2,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 5, 'Test: Positive case: Array(2). Arrays with multiple valid number elements. 2 of 2 arguments used.');
		// Case #21: Number(2). Negative numerator, valid division. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(-10,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(-10,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -5, 'Test: Positive case: Number(2). Negative numerator, valid division. 2 of 2 arguments used.');
		// Case #22: Number(2). Negative denominator, valid division. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(10,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(10,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -5, 'Test: Positive case: Number(2). Negative denominator, valid division. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number(2). Division by zero returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Division by zero returns #DIV/0!. 2 of 2 arguments used.');
		// Case #2: String(2). Non-numeric string numerator returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT("abc","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT("abc","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric string numerator returns #VALUE!. 2 of 2 arguments used.');
		// Case #3: String(2). Non-numeric string denominator returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT("10","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT("10","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric string denominator returns #VALUE!. 2 of 2 arguments used.');
		// Case #4: Empty(2). Both arguments empty returns #VALUE!. 0 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(2). Both arguments empty returns #VALUE!. 0 of 2 arguments used.');
		// Case #5: Empty. =QUOTIENT(;2)
		oParser = new parserFormula('QUOTIENT(,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. =QUOTIENT(;2)');
		// Case #6: Number. =QUOTIENT(10;)
		oParser = new parserFormula('QUOTIENT(10,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(10,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. =QUOTIENT(10;)');
		// Case #7: Error(2). Error inputs propagate #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(NA(),NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(NA(),NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). Error inputs propagate #N/A. 2 of 2 arguments used.');
		// Case #8: Boolean(2). Boolean inputs (1,0) cause division by zero, returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Boolean inputs (1,0) cause division by zero, returns #DIV/0!. 2 of 2 arguments used.');
		// Case #9: Area(2). Multi-cell ranges return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(A104:A105,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(A104:A105,A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2). Multi-cell ranges return #VALUE!. 2 of 2 arguments used.');
		// Case #10: Name(2). Named ranges with areas return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(TestNameArea,TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(TestNameArea,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name(2). Named ranges with areas return #VALUE!. 2 of 2 arguments used.');
		// Case #11: Name3D(2). 3D named ranges with areas return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(TestNameArea3D,TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(TestNameArea3D,TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D(2). 3D named ranges with areas return #VALUE!. 2 of 2 arguments used.');
		// Case #12: Ref3D(2). 3D multi-cell ranges return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(Sheet2!A5:A6,Sheet2!A7:A8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(Sheet2!A5:A6,Sheet2!A7:A8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(2). 3D multi-cell ranges return #VALUE!. 2 of 2 arguments used.');
		// Case #13: Area3D(2). 3D multi-cell ranges return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(Sheet2!A9:A10,Sheet2!A9:A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(Sheet2!A9:A10,Sheet2!A9:A10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(2). 3D multi-cell ranges return #VALUE!. 2 of 2 arguments used.');
		// Case #15: Formula(2). Numerator formula returns #NUM!, propagates error. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). Numerator formula returns #NUM!, propagates error. 2 of 2 arguments used.');
		// Case #16: Formula(2). Denominator formula returns #NUM!, propagates error. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(10,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(10,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). Denominator formula returns #NUM!, propagates error. 2 of 2 arguments used.');
		// Case #17: Array(2). Array with boolean numerator returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT({TRUE},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT({TRUE},{2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: Array(2). Array with boolean numerator returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Array(2). Array with boolean denominator (0) returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT({10},{FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT({10},{FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: Array(2). Array with boolean denominator (0) returns #DIV/0!. 2 of 2 arguments used.');
		// Case #19: Time(2). Time values (0.5,0.25) return valid result but fractional, testing edge case. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(TIME(12,0,0),TIME(6,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(TIME(12,0,0),TIME(6,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Time(2). Time values (0.5,0.25) return valid result but fractional, testing edge case. 2 of 2 arguments used.');
		// Case #20: String(2). Empty string numerator returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT("","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT("","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Empty string numerator returns #VALUE!. 2 of 2 arguments used.');
		// Case #21: String(2). Empty string denominator returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT("10","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT("10","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Empty string denominator returns #VALUE!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number(2). Minimum valid positive integers. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Minimum valid positive integers. 2 of 2 arguments used.');
		// Case #2: Number(2). Maximum valid Excel number as numerator. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(9.99999999999999E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(9.99999999999999E+307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number(2). Maximum valid Excel number as numerator. 2 of 2 arguments used.');
		// Case #3: Number(2). Maximum valid Excel number as denominator. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(1,9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(1,9.99999999999999E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Maximum valid Excel number as denominator. 2 of 2 arguments used.');
		// Case #4: Number(2). Maximum negative Excel number as numerator, negative denominator. 2 of 2 arguments used.
		oParser = new parserFormula('QUOTIENT(-9.99999999999999E+307,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUOTIENT(-9.99999999999999E+307,-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number(2). Maximum negative Excel number as numerator, negative denominator. 2 of 2 arguments used.');

		// Need to fix: empty hanlde, boundary cases diff, error types diff
		// Case #4: Empty(2). Both arguments empty returns #VALUE!. 0 of 2 arguments used.
		// Case #5: Empty. =QUOTIENT(;2)
		// Case #6: Number. =QUOTIENT(10;)
		// Case #8: Boolean(2). Boolean inputs (1,0) cause division by zero, returns #DIV/0!. 2 of 2 arguments used.
		// Case #17: Array(2). Array with boolean numerator returns #VALUE!. 2 of 2 arguments used.
		// Case #18: Array(2). Array with boolean denominator (0) returns #DIV/0!. 2 of 2 arguments used.
		// Case #2: Number(2). Maximum valid Excel number as numerator. 2 of 2 arguments used.
		// Case #3: Number(2). Maximum valid Excel number as denominator. 2 of 2 arguments used.
		// Case #4: Number(2). Maximum negative Excel number as numerator, negative denominator. 2 of 2 arguments used.

		testArrayFormula2(assert, "QUOTIENT", 2, 2, true)
	});

	QUnit.test("Test: \"RADIANS\"", function (assert) {
		oParser = new parserFormula("RADIANS(270)", "A1", ws);
		assert.ok(oParser.parse(), "RADIANS(270)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 4.712389);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: integer. 1 argument used.
		oParser = new parserFormula('RADIANS(90)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(90) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: Number. Basic valid input: integer. 1 argument used.');
		// Case #2: Number. Zero input. 1 argument used.
		oParser = new parserFormula('RADIANS(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero input. 1 argument used.');
		// Case #3: Number. Negative integer input. 1 argument used.
		oParser = new parserFormula('RADIANS(-90)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(-90) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.5707963267948966, 'Test: Positive case: Number. Negative integer input. 1 argument used.');
		// Case #4: Number. Float input. 1 argument used.
		oParser = new parserFormula('RADIANS(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02617993877991494, 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #5: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('RADIANS("90")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS("90") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #6: Formula. Nested formula returning valid number. 1 argument used.
		oParser = new parserFormula('RADIANS(SQRT(8100))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(SQRT(8100)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: Formula. Nested formula returning valid number. 1 argument used.');
		// Case #7: Reference link. Ref to cell with valid number. 1 argument used.
		oParser = new parserFormula('RADIANS(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.008726646259971648, 'Test: Positive case: Reference link. Ref to cell with valid number. 1 argument used.');
		// Case #8: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('RADIANS(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02617993877991494, 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #9: Array. Array with single element. 1 argument used.
		oParser = new parserFormula('RADIANS({90})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS({90}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1.5707963267948966, 'Test: Positive case: Array. Array with single element. 1 argument used.');
		// Case #10: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('RADIANS(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.008726646259971648, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #11: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('RADIANS(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.008726646259971648, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #12: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('RADIANS(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(Sheet2!A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.017453293, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #13: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('RADIANS(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.034906585, 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #14: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('RADIANS(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.017453292519943295, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #15: Date. Date as serial number. 1 argument used.
		oParser = new parserFormula('RADIANS(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 796.882429875571, 'Test: Positive case: Date. Date as serial number. 1 argument used.');
		// Case #16: Time. Time converted to degrees. 1 argument used.
		oParser = new parserFormula('RADIANS(TIME(12,0,0)*3600)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(TIME(12,0,0)*3600) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31.41592653589793, 'Test: Positive case: Time. Time converted to degrees. 1 argument used.');
		// Case #17: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('RADIANS(IF(TRUE,90,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(IF(TRUE,90,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');
		// Case #18: String. String of float convertible to number. 1 argument used.
		oParser = new parserFormula('RADIANS("1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS("1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02617993877991494, 'Test: Positive case: String. String of float convertible to number. 1 argument used.');
		// Case #19: Array. Multi-element array, takes first element. 1 argument used.
		oParser = new parserFormula('RADIANS({90,180})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS({90,180}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1.5707963267948966, 'Test: Positive case: Array. Multi-element array, takes first element. 1 argument used.');
		// Case #20: Formula. Nested formula with negative input. 1 argument used.
		oParser = new parserFormula('RADIANS(ABS(-90))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(ABS(-90)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: Formula. Nested formula with negative input. 1 argument used.');
		// Case #21: Name. Named range with float number. 1 argument used.
		oParser = new parserFormula('RADIANS(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.008726646259971648, 'Test: Positive case: Name. Named range with float number. 1 argument used.');
		// Case #22: Name3D. 3D named range with float number. 1 argument used.
		oParser = new parserFormula('RADIANS(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.008726646259971648, 'Test: Positive case: Name3D. 3D named range with float number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Multiple arguments return #VALUE!. 2 arguments used.
		oParser = new parserFormula('RADIANS(90.180)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(90.180) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5739379194484864, 'Test: Negative case: Number. Multiple arguments return #VALUE!. 2 arguments used.');
		// Case #2: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #3: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('RADIANS(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #4: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.008726646259971648, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #5: Boolean. Boolean FALSE (0) returns valid result, treated as number. 1 argument used.
		oParser = new parserFormula('RADIANS(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean FALSE (0) returns valid result, treated as number. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #7: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS(TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1832595714594046, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Name3D. 3D named range with multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with multi-cell range returns #VALUE!. 1 argument used.');
		// Case #11: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('RADIANS(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #12: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #13: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS({TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.017453292519943295, 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');
		// Case #14: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(Sheet2!A4:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #15: Name. Named range with multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.013962634015954637, 'Test: Negative case: Name. Named range with multi-cell range returns #VALUE!. 1 argument used.');
		// Case #16: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('RADIANS(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #17: String. Date string not convertible to number returns #VALUE!. 1 argument used.
		oParser = new parserFormula('RADIANS("01/01/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS("01/01/2025") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 796.882429875571, 'Test: Negative case: String. Date string not convertible to number returns #VALUE!. 1 argument used.');
		// Case #18: Time. Time value (0.5) returns valid result, treated as number. 1 argument used.
		oParser = new parserFormula('RADIANS(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.008726646259971648, 'Test: Negative case: Time. Time value (0.5) returns valid result, treated as number. 1 argument used.');
		// Case #19: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('RADIANS(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7453292519943297e+305, 'Test: Negative case: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.');
		// Case #20: Formula. Formula exceeding Excels numeric limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('RADIANS(1E+307*10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(1E+307*10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.7453292519943297e+305, 'Test: Negative case: Formula. Formula exceeding Excels numeric limit returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('RADIANS(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7453292519943297e+305, 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #2: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('RADIANS(-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.7453292519943297e+305, 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #3: Number. Smallest non-zero positive number. 1 argument used.
		oParser = new parserFormula('RADIANS(2.2E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RADIANS(2.2E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest non-zero positive number. 1 argument used.');

		// Need to fix: 3d ref handle, error types diff, ms results diff
		// Case #12: Ref3D. 3D reference to cell with valid number. 1 argument used.
		// Case #13: Area3D. 3D single-cell range. 1 argument used.
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #14: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		// Case #20: Formula. Formula exceeding Excels numeric limit returns #NUM!. 1 argument used.
		// Case #3: Number. Smallest non-zero positive number. 1 argument used.

		testArrayFormula(assert, "RADIANS");
	});

	QUnit.test("Test: \"RANDARRAY\"", function (assert) {
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("test1");
		ws.getRange2("A104").setValue("-4");
		ws.getRange2("A105").setValue("-1");

		var res;
		oParser = new parserFormula("RANDARRAY(A101,A102)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getElementRowCol(0, 0).getValue();
		assert.ok(res >= 0 && res <= 1);
		res = oParser.calculate().getElementRowCol(1, 0).getValue();
		assert.ok(res >= 0 && res <= 1);
		res = oParser.calculate().getElementRowCol(0, 1).getValue();
		assert.ok(res >= 0 && res <= 1);
		res = oParser.calculate().getElementRowCol(1, 1).getValue();
		assert.ok(res >= 0 && res <= 1);

		oParser = new parserFormula("RANDARRAY(A101,A102,A104,A105)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getElementRowCol(0, 0).getValue();
		assert.ok(res >= -4 && res <= -1);
		res = oParser.calculate().getElementRowCol(1, 0).getValue();
		assert.ok(res >= -4 && res <= -1);
		res = oParser.calculate().getElementRowCol(0, 1).getValue();
		assert.ok(res >= -4 && res <= -1);
		res = oParser.calculate().getElementRowCol(1, 1).getValue();
		assert.ok(res >= -4 && res <= -1);

		oParser = new parserFormula("RANDARRAY()", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getElementRowCol(0, 0).getValue();
		assert.ok(res >= 0 && res <= 1);

		oParser = new parserFormula("RANDARRAY(2,2)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getElementRowCol(0, 0).getValue();
		assert.ok(res >= 0 && res <= 1);
		res = oParser.calculate().getElementRowCol(1, 0).getValue();
		assert.ok(res >= 0 && res <= 1);
		res = oParser.calculate().getElementRowCol(0, 1).getValue();
		assert.ok(res >= 0 && res <= 1);
		res = oParser.calculate().getElementRowCol(1, 1).getValue();
		assert.ok(res >= 0 && res <= 1);

		oParser = new parserFormula("RANDARRAY(2,2,-10,-5)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getElementRowCol(0, 0).getValue();
		assert.ok(res >= -10 && res <= -5);
		res = oParser.calculate().getElementRowCol(1, 0).getValue();
		assert.ok(res >= -10 && res <= -5);
		res = oParser.calculate().getElementRowCol(0, 1).getValue();
		assert.ok(res >= -10 && res <= -5);
		res = oParser.calculate().getElementRowCol(1, 1).getValue();
		assert.ok(res >= -10 && res <= -5);

		oParser = new parserFormula("RANDARRAY(2,2,-10,-5, true)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getElementRowCol(0, 0).getValue();
		assert.ok(res >= -10 && res <= -5);
		res = oParser.calculate().getElementRowCol(1, 0).getValue();
		assert.ok(res >= -10 && res <= -5);
		res = oParser.calculate().getElementRowCol(0, 1).getValue();
		assert.ok(res >= -10 && res <= -5);
		res = oParser.calculate().getElementRowCol(1, 1).getValue();
		assert.ok(res >= -10 && res <= -5);

		oParser = new parserFormula("RANDARRAY(2,2,,, true)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getElementRowCol(0, 0).getValue();
		assert.ok(res >= 0 && res <= 1);
		res = oParser.calculate().getElementRowCol(1, 0).getValue();
		assert.ok(res >= 0 && res <= 1);
		res = oParser.calculate().getElementRowCol(0, 1).getValue();
		assert.ok(res >= 0 && res <= 1);
		res = oParser.calculate().getElementRowCol(1, 1).getValue();
		assert.ok(res >= 0 && res <= 1);

		oParser = new parserFormula("RANDARRAY(-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("RANDARRAY(1, -1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("RANDARRAY(-1, -1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("RANDARRAY(1, 1, 5, 2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("RANDARRAY(0, 0, 5, 2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("RANDARRAY(0, 1, 5, 2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("RANDARRAY(1, 0, 5, 2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("RANDARRAY(1,1,,-2,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("RANDARRAY(1,1,2,,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("RANDARRAY(A103,1,2,,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		ws.getRange2("A101").setValue("#DIV/0!");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("3");
		ws.getRange2("A104").setValue("4");
		ws.getRange2("A105").setValue("5");
		ws.getRange2("A105").setValue("6");

		ws.getRange2("B101").setValue("-3");
		ws.getRange2("B102").setValue("-5");
		ws.getRange2("B103").setValue("2");
		ws.getRange2("B104").setValue("1");
		ws.getRange2("B105").setValue("12");
		ws.getRange2("B105").setValue("13");

		oParser = new parserFormula("RANDARRAY({1,123,3},{1,2,3,4},,2,A101:C101)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getElementRowCol(0, 0).getValue();
		assert.strictEqual(res, "#DIV/0!");
		res = oParser.calculate().getElementRowCol(0, 1).getValue();
		assert.ok(res >= 0 && res <= 2);
		res = oParser.calculate().getElementRowCol(0, 2).getValue();
		assert.ok(res >= 0 && res <= 2);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("2");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("1");
		ws.getRange2("A103").setValue("10");
		ws.getRange2("A104").setValue("TRUE");
		ws.getRange2("A105").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		let array;
		// Positive cases:
		// Case #1: Number(5). Returns a 2x2 array of integers between 1 and 10. All arguments are numbers. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(2,2,1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(2,2,1,10,TRUE) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Number(5). Returns a 2x2 array of integers between 1 and 10. All arguments are numbers. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 2, 'Test: Positive case: Number(5). Returns a 2x2 array of integers between 1 and 10. All arguments are numbers. 5 of 5 arguments used.');
		// Case #2: Number(4). Returns a 3x3 array of decimals between 0 and 5. Integer is FALSE. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(3,3,0,5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(3,3,0,5,FALSE) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Number(4). Returns a 3x3 array of decimals between 0 and 5. Integer is FALSE. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 3, 'Test: Positive case: Number(5). Returns a 2x2 array of integers between 1 and 10. All arguments are numbers. 5 of 5 arguments used.');
		// Case #3: Number(3), Empty(2). Returns a 2x2 array of numbers between 1 and 100 (default max). Max and Integer omitted. 3 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(2,2,1,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(2,2,1,,) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Number(3), Empty(2). Returns a 2x2 array of numbers between 1 and 100 (default max). Max and Integer omitted. 3 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 2, 'Test: Positive case: Number(5). Returns a 2x2 array of integers between 1 and 10. All arguments are numbers. 5 of 5 arguments used.');
		// Case #4: Number(2), Empty(3). Returns a 2x2 array of numbers between 0 and 1 (default min/max). Min, Max, Integer omitted. 2 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(2,2,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(2,2,,,) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Number(2), Empty(3). Returns a 2x2 array of numbers between 0 and 1 (default min/max). Min, Max, Integer omitted. 2 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 2, 'Test: Positive case: Number(2), Empty(3). Returns a 2x2 array of numbers between 0 and 1 (default min/max). Min, Max, Integer omitted. 2 of 5 arguments used.');
		// Case #5: Number, Empty(4). Returns a 1x1 array (single number) between 0 and 1. Only rows specified. 1 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(1,,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(1,,,,) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Number, Empty(4). Returns a 1x1 array (single number) between 0 and 1. Only rows specified. 1 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 1, 'Test: Positive case: Number, Empty(4). Returns a 1x1 array (single number) between 0 and 1. Only rows specified. 1 of 5 arguments used.');
		// Case #6: String(5). Returns a 2x2 array of integers between 1 and 10. All arguments as strings convertible to valid types. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY("2","2","1","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY("2","2","1","10","TRUE") is parsed.');
		array = oParser.calculate();
		//? assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: String(5). Returns a 2x2 array of integers between 1 and 10. All arguments as strings convertible to valid types. 5 of 5 arguments used.');
		//? assert.strictEqual(array.rowCount, 2, 'Test: Positive case: String(5). Returns a 2x2 array of integers between 1 and 10. All arguments as strings convertible to valid types. 5 of 5 arguments used.');
		// Case #7: Formula(5). Returns a 3x3 array of integers between -1 and 10. All arguments filled with formulas. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(ROUND(2.5,0),ROUND(2.5,0),ABS(-1),ABS(10),IF(TRUE,1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(ROUND(2.5,0),ROUND(2.5,0),ABS(-1),ABS(10),IF(TRUE,1,0)) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Formula(5). Returns a 2x2 array of integers between -1 and 10. All arguments filled with formulas. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 3, 'Test: Positive case: Formula(5). Returns a 2x2 array of integers between -1 and 10. All arguments filled with formulas. 5 of 5 arguments used.');
		// Case #8: Reference link(5). Returns a 2x2 array of integers between 1 and 10. All arguments as cell references. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(A100,A101,A102,A103,A104) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Reference link(5). Returns a 2x2 array of integers between 1 and 10. All arguments as cell references. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 2, 'Test: Positive case: Reference link(5). Returns a 2x2 array of integers between 1 and 10. All arguments as cell references. 5 of 5 arguments used.');
		// Case #9: Area(5). Returns a 2x2 array of integers between 1 and 10. All arguments as single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Area(5). Returns a 2x2 array of integers between 1 and 10. All arguments as single-cell ranges. 5 of 5 arguments used.');
		//? assert.strictEqual(array.rowCount, 2, 'Test: Positive case: Area(5). Returns a 2x2 array of integers between 1 and 10. All arguments as single-cell ranges. 5 of 5 arguments used.');
		// Case #10: Array(5). Returns a 2x2 array of integers between 1 and 10. All arguments as single-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY({2},{2},{1},{10},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY({2},{2},{1},{10},{TRUE}) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Array(5). Returns a 2x2 array of integers between 1 and 10. All arguments as single-element arrays. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 1, 'Test: Positive case: Array(5). Returns a 2x2 array of integers between 1 and 10. All arguments as single-element arrays. 5 of 5 arguments used.');
		// Case #11: Name(5). Returns a 2x2 array of integers between 1 and 10. All arguments as named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(TestName,TestName1,TestName2,TestName2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(TestName,TestName1,TestName2,TestName3,TestNameArea2) is parsed.');
		//? array = oParser.calculate();
		//? assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Name(5). Returns a 2x2 array of integers between 1 and 10. All arguments as named ranges. 5 of 5 arguments used.');
		//? assert.strictEqual(array.rowCount, 1, 'Test: Positive case: Name(5). Returns a 2x2 array of integers between 1 and 10. All arguments as named ranges. 5 of 5 arguments used.');
		// Case #12: Name3D(5). Returns a 2x2 array of integers between 1 and 10. All arguments as 3D named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(TestName3D,TestName3D,TestName3D,TestName3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(TestName3D,TestName3D,TestName3D,TestName3D,TestNameArea3D2) is parsed.');
		//? array = oParser.calculate();
		//? assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Name3D(5). Returns a 2x2 array of integers between 1 and 10. All arguments as 3D named ranges. 5 of 5 arguments used.');
		//? assert.strictEqual(array.rowCount, 1, 'Test: Positive case: Name3D(5). Returns a 2x2 array of integers between 1 and 10. All arguments as 3D named ranges. 5 of 5 arguments used.');
		// Case #13: Ref3D(5). Returns a 2x2 array of integers between 1 and 10. All arguments as 3D references. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		array = oParser.calculate();
		//? assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Ref3D(5). Returns a 2x2 array of integers between 1 and 10. All arguments as 3D references. 5 of 5 arguments used.');
		//? assert.strictEqual(array.rowCount, 1, 'Test: Positive case: Ref3D(5). Returns a 2x2 array of integers between 1 and 10. All arguments as 3D references. 5 of 5 arguments used.');
		// Case #14: Area3D(5). Returns a 2x2 array of integers between 1 and 10. All arguments as 3D single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		//? array = oParser.calculate();
		//? assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Area3D(5). Returns a 2x2 array of integers between 1 and 10. All arguments as 3D single-cell ranges. 5 of 5 arguments used.');
		//? assert.strictEqual(array.rowCount, 1, 'Test: Positive case: Area3D(5). Returns a 2x2 array of integers between 1 and 10. All arguments as 3D single-cell ranges. 5 of 5 arguments used.');
		// Case #15: Table(5). Returns a 2x2 array of integers between 1 and 10. All arguments as table references. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Table(5). Returns a 2x2 array of integers between 1 and 10. All arguments as table references. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 5, 'Test: Positive case: Table(5). Returns a 2x2 array of integers between 1 and 10. All arguments as table references. 5 of 5 arguments used.');
		// Case #16: Date(2), Number(3). Returns a 45292x45293 array of integers between 1 and 10. Rows and Columns as dates (serial numbers). 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(DATE(2025,1,1),DATE(2025,1,2),1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(DATE(2025,1,1),DATE(2025,1,2),1,10,TRUE) is parsed.');
		//? array = oParser.calculate();
		//? assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Date(2), Number(3). Returns a 45292x45293 array of integers between 1 and 10. Rows and Columns as dates (serial numbers). 5 of 5 arguments used.');
		//? assert.strictEqual(array.rowCount, 5, 'Test: Positive case: Date(2), Number(3). Returns a 45292x45293 array of integers between 1 and 10. Rows and Columns as dates (serial numbers). 5 of 5 arguments used.');
		// Case #17: Time(2), Number(3). Returns a 0.04167x0.08333 array of decimals between 1 and 10. Rows and Columns as time (fractional numbers). 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(TIME(1,0,0),TIME(2,0,0),1,10,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(TIME(1,0,0),TIME(2,0,0),1,10,FALSE) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.error, 'Test: Positive case: Time(2), Number(3). Returns a 0.04167x0.08333 array of decimals between 1 and 10. Rows and Columns as time (fractional numbers). 5 of 5 arguments used.');
		// Case #18: Number(2), Formula(3). Returns a 2x2 array of integers between 1 and 10. Min, Max, Integer as formulas. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(2,2,SQRT(1),ABS(10),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(2,2,SQRT(1),ABS(10),IF(TRUE,TRUE,FALSE)) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Number(2), Formula(3). Returns a 2x2 array of integers between 1 and 10. Min, Max, Integer as formulas. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 2, 'Test: Positive case: Number(2), Formula(3). Returns a 2x2 array of integers between 1 and 10. Min, Max, Integer as formulas. 5 of 5 arguments used.');
		// Case #19: Number(4), Boolean. Returns a 2x2 array of integers between 1 and 10. Integer as boolean TRUE. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(2,2,1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(2,2,1,10,TRUE) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: Number(4), Boolean. Returns a 2x2 array of integers between 1 and 10. Integer as boolean TRUE. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 2, 'Test: Positive case: Number(4), Boolean. Returns a 2x2 array of integers between 1 and 10. Integer as boolean TRUE. 5 of 5 arguments used.');
		// Case #20: String(4), Number. Returns a 2x2 array of integers between 1 and 10. Integer as number (coerced to TRUE). 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY("2","2","1","10",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY("2","2","1","10",1) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: String(4), Number. Returns a 2x2 array of integers between 1 and 10. Integer as number (coerced to TRUE). 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 2, 'Test: Positive case: String(4), Number. Returns a 2x2 array of integers between 1 and 10. Integer as number (coerced to TRUE). 5 of 5 arguments used.');

		// Negative cases:
		// Case #1: Number(5). Returns #NUM! due to negative rows. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(-1,2,1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(-1,2,1,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5). Returns #NUM! due to negative rows. 5 of 5 arguments used.');
		// Case #2: Number(5). Returns #NUM! due to negative columns. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(2,-2,1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(2,-2,1,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5). Returns #NUM! due to negative columns. 5 of 5 arguments used.');
		// Case #3: Number(5). Returns #NUM! as min > max. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(2,2,10,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(2,2,10,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5). Returns #NUM! as min > max. 5 of 5 arguments used.');
		// Case #4: String(5). Returns #VALUE! due to non-numeric string in rows. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY("abc","2","1","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY("abc","2","1","10","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Returns #VALUE! due to non-numeric string in rows. 5 of 5 arguments used.');
		// Case #5: String(5). Returns #VALUE! due to non-numeric string in columns. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY("2","abc","1","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY("2","abc","1","10","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Returns #VALUE! due to non-numeric string in columns. 5 of 5 arguments used.');
		// Case #6: String(5). Returns #VALUE! due to non-numeric string in min. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY("2","2","abc","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY("2","2","abc","10","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Returns #VALUE! due to non-numeric string in min. 5 of 5 arguments used.');
		// Case #7: String(5). Returns #VALUE! due to non-numeric string in max. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY("2","2","1","abc","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY("2","2","1","abc","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Returns #VALUE! due to non-numeric string in max. 5 of 5 arguments used.');
		// Case #8: String(5). Returns #VALUE! due to non-boolean string in integer. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY("2","2","1","10","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY("2","2","1","10","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Returns #VALUE! due to non-boolean string in integer. 5 of 5 arguments used.');
		// Case #9: Empty(5). Returns #NUM! as no arguments are provided. 0 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(,,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(,,,,) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Positive case: String(4), Number. Returns a 2x2 array of integers between 1 and 10. Integer as number (coerced to TRUE). 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 1, 'Test: Positive case: String(4), Number. Returns a 2x2 array of integers between 1 and 10. Integer as number (coerced to TRUE). 5 of 5 arguments used.');
		// Case #10: Error(5). Returns #N/A due to error in rows. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(NA(),2,1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(NA(),2,1,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(5). Returns #N/A due to error in rows. 5 of 5 arguments used.');
		// Case #11: Boolean(5). Returns #NUM! as boolean rows is invalid. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(TRUE,2,1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(TRUE,2,1,10,TRUE) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Negative case: Boolean(5). Returns #NUM! as boolean rows is invalid. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 1, 'Test: Negative case: Boolean(5). Returns #NUM! as boolean rows is invalid. 5 of 5 arguments used.');
		// Case #12: Reference link(5). Returns #VALUE! as rows reference contains text. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(A105,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(A105,A101,A102,A103,A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Negative case: Reference link(5). Returns #VALUE! as rows reference contains text. 5 of 5 arguments used.');
		// Case #13: Area(5). Returns #NUM! as rows is a multi-cell range. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(A100:A101,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(A100:A101,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Negative case: Area(5). Returns #NUM! as rows is a multi-cell range. 5 of 5 arguments used.');
		//? assert.strictEqual(array.rowCount, 2, 'Test: Negative case: Area(5). Returns #NUM! as rows is a multi-cell range. 5 of 5 arguments used.');
		// Case #14: Array(5). Returns #NUM! as rows is a multi-element array. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY({2,3},{2},{1},{10},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY({2,3},{2},{1},{10},{TRUE}) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Negative case: Array(5). Returns #NUM! as rows is a multi-element array. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 1, 'Test: Negative case: Area(5). Returns #NUM! as rows is a multi-cell range. 5 of 5 arguments used.');
		// Case #15: Name(5). Returns #VALUE! as rows is a named range with text. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(TestNameArea2,TestName1,TestName2,TestName2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(TestNameArea2,TestName1,TestName2,TestName2,TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#SPILL!', 'Test: Negative case: Name(5). Returns #VALUE! as rows is a named range with text. 5 of 5 arguments used.');
		// Case #16: Name3D(5). Returns #VALUE! as rows is a 3D named range with text. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(TestNameArea3D2,TestName3D,TestName3D,TestName3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(TestNameArea3D2,TestName3D,TestName3D,TestName3D,TestNameArea3D2) is parsed.');
		// ? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name3D(5). Returns #VALUE! as rows is a 3D named range with text. 5 of 5 arguments used.');
		// Case #17: Ref3D(5). Returns #VALUE! as rows is a 3D reference with text. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(Sheet2!A6,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(Sheet2!A6,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(5). Returns #VALUE! as rows is a 3D reference with text. 5 of 5 arguments used.');
		// Case #18: Area3D(5). Returns #NUM! as rows is a 3D multi-cell range. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#SPILL!', 'Test: Negative case: Area3D(5). Returns #NUM! as rows is a 3D multi-cell range. 5 of 5 arguments used.');
		// Case #19: Table(5). Returns #VALUE! as rows is a table reference with text. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column3]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Negative case: Table(5). Returns #VALUE! as rows is a table reference with text. 5 of 5 arguments used.');
		// Case #20: Number(5). Returns #NUM! as rows is zero. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(0,2,1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(0,2,1,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Negative case: Number(5). Returns #NUM! as rows is zero. 5 of 5 arguments used.');

		// Bounded cases:
		// Case #1: Number(5). Returns a 1x1 array of integers between 1E-307 and 9.99999999999999E+307. Minimum valid min and maximum valid max. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(1,1,1E-307,9.99999999999999E+307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(1,1,1E-307,9.99999999999999E+307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number(5). Returns a 1x1 array of integers between 1E-307 and 9.99999999999999E+307. Minimum valid min and maximum valid max. 5 of 5 arguments used.');
		// Case #2: Number(5). Returns a 1048576x16384 array of integers between 1 and 10. Maximum valid rows and columns for Excel. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(1048576,16384,1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(1048576,16384,1,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 'RANDARRAY(1048576,16384,1,10,TRUE)', 'Test: Bounded case: Number(5). Returns a 1048576x16384 array of integers between 1 and 10. Maximum valid rows and columns for Excel. 5 of 5 arguments used.');
		// Case #3: Number(5). Returns a 1x1 array of decimals between -9.99999999999999E+307 and 9.99999999999999E+307. Minimum and maximum valid min/max. 5 of 5 arguments used.
		oParser = new parserFormula('RANDARRAY(1,1,-9.99999999999999E+307,9.99999999999999E+307,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDARRAY(1,1,-9.99999999999999E+307,9.99999999999999E+307,FALSE) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.type, AscCommonExcel.cElementType.array, 'Test: Bounded case: Number(5). Returns a 1x1 array of decimals between -9.99999999999999E+307 and 9.99999999999999E+307. Minimum and maximum valid min/max. 5 of 5 arguments used.');
		assert.strictEqual(array.rowCount, 1, 'Test: Bounded case: Number(5). Returns a 1x1 array of decimals between -9.99999999999999E+307 and 9.99999999999999E+307. Minimum and maximum valid min/max. 5 of 5 arguments used.');

		// TODO many problems with this formula
		// Need to fix: 3D sheets/cells handle, area handle, differences in results from MS, critical err in some cases with 3D, too long calc when big num encounter in row/col


	});

	QUnit.test("Test: \"RANDBETWEEN\"", function (assert) {
		let res;
		oParser = new parserFormula("RANDBETWEEN(1,6)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getValue();
		assert.ok(res >= 1 && res <= 6);

		oParser = new parserFormula("RANDBETWEEN(-10,10)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getValue();
		assert.ok(res >= -10 && res <= 10);

		oParser = new parserFormula("RANDBETWEEN(-25,-3)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getValue();
		assert.ok(res >= -25 && res <= -3);

		oParser = new parserFormula("RANDBETWEEN(1,100)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getValue();
		assert.ok(res >= 1 && res <= 100);

		oParser = new parserFormula("RANDBETWEEN(0,999999999999999999999999999)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getValue();
		assert.ok(res >= 9 && res <= 999999999999999999999999999n);

		oParser = new parserFormula("RANDBETWEEN(-1,100)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getValue();
		assert.ok(res >= -1 && res <= 100);

		oParser = new parserFormula("RANDBETWEEN(1,-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("RANDBETWEEN(1.1,22.9)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getValue();
		assert.ok(res >= 2 && res <= 22);

		oParser = new parserFormula("RANDBETWEEN(-22.9,-1.1)", "A1", ws);
		assert.ok(oParser.parse());
		res = oParser.calculate().getValue();
		assert.ok(res >= -22 && res <= -1);

		oParser = new parserFormula("RANDBETWEEN(DATE(2022,1,1), DATE(2022,4,12))", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(55, DATE(2022,4,12))");
		res = oParser.calculate().getValue();
		assert.ok(res >= 44562 && res <= 44663);

		oParser = new parserFormula("RANDBETWEEN(55, DATE(2022,4,12))", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(55, DATE(2022,4,12))");
		res = oParser.calculate().getValue();
		assert.ok(res >= 55 && res <= 44663);

		oParser = new parserFormula("RANDBETWEEN(DATE(2022,4,12), 55)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(DATE(2022,4,12), 55)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result RANDBETWEEN(DATE(2022,4,12), 55)");

		oParser = new parserFormula("RANDBETWEEN(1,)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(1,)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result RANDBETWEEN(1,) ");

		oParser = new parserFormula("RANDBETWEEN(,1)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(,1)");
		res = oParser.calculate().getValue();
		assert.ok(res >= 0 && res <= 1, "Result RANDBETWEEN(,1) ");

		oParser = new parserFormula("RANDBETWEEN(,)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(,)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result RANDBETWEEN(,) ");

		oParser = new parserFormula("RANDBETWEEN({1.5,2.5},{2.5,3.5})", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN('{1.5,2.5}',{2.5,3.5})");
		let array = oParser.calculate();
		res = array.getElementRowCol(0, 0).getValue();
		assert.strictEqual(res, 2, "Result RANDBETWEEN({1.5,2.5},{2.5,3.5})[0,0] ");
		res = array.getElementRowCol(0, 1).getValue();
		assert.strictEqual(res, 3, "Result RANDBETWEEN({1.5,2.5},{2.5,3.5})[0,1] ");
		res = array.getElementRowCol(0, 2).getValue();
		assert.strictEqual(res, "", "Result RANDBETWEEN({1.5,2.5},{2.5,3.5})[0,2] ");

		oParser = new parserFormula("RANDBETWEEN(1,{5.5,3.5})", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(1,{5.5,3.5})");
		array = oParser.calculate();
		res = array.getElementRowCol(0, 0).getValue();
		assert.ok(res >= 1 && res <= 5, "Result RANDBETWEEN(1,{5.5,3.5})[0,0]");
		res = array.getElementRowCol(0, 1).getValue();
		assert.ok(res >= 1 && res <= 5, "Result RANDBETWEEN(1,{5.5,3.5})[0,1]");
		res = array.getElementRowCol(1, 0).getValue();
		assert.strictEqual(res, "", "Result RANDBETWEEN(1,{5.5,3.5})[1,0] ");
		res = array.getElementRowCol(2, 0).getValue();
		assert.strictEqual(res, "#N/A", "Result RANDBETWEEN(1,{5.5,3.5})[2,0] ");


		oParser = new parserFormula("RANDBETWEEN(null, undefined)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(null, undefined)");
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", "Result RANDBETWEEN(null, undefined)");

		ws.getRange2("A3").setValue("1.5");
		ws.getRange2("A4").setValue("2.5");
		ws.getRange2("A5").setValue("13");
		ws.getRange2("A6").setValue("23");
		ws.getRange2("A7").setValue("25");
		ws.getRange2("A8").setValue("55");
		ws.getRange2("A9").setValue("-2");
		ws.getRange2("A10").setValue("0.01");
		ws.getRange2("A11").setValue("-0.01");
		ws.getRange2("A12").setValue("#N/A");
		ws.getRange2("A13").setValue("test1");
		ws.getRange2("A14").setValue("TRUE");
		ws.getRange2("A15").setValue("");
		ws.getRange2("A16").setValue();
		ws.getRange2("A17").setValue("1/1/2000");
		ws.getRange2("A18").setValue("2/2/2000");

		// data in cells
		oParser = new parserFormula("RANDBETWEEN(A3,A4)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(1.5,2.5) in cells");
		assert.strictEqual(oParser.calculate().getValue(), 2, "Result RANDBETWEEN(1.5,2.5) in cells");

		oParser = new parserFormula("RANDBETWEEN(A3,A8)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(1.5,55) in cells");
		res = oParser.calculate().getValue();
		assert.ok(res >= 2 && res <= 55, "Result RANDBETWEEN(1.5,55) in cells");

		oParser = new parserFormula("RANDBETWEEN(A11,A10)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(-0.01,0.01) in cells");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result RANDBETWEEN(-0.01,0.01) in cells");

		oParser = new parserFormula("RANDBETWEEN(A8,A7)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(55,25) in cells");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result RANDBETWEEN(55,25) in cells");

		oParser = new parserFormula("RANDBETWEEN(A14,A14)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(TRUE,TRUE) in cells");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result RANDBETWEEN(TRUE,TRUE) in cells");

		oParser = new parserFormula("RANDBETWEEN(A14,A7)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(TRUE,25) in cells");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result RANDBETWEEN(TRUE,25) in cells");

		oParser = new parserFormula("RANDBETWEEN(A10,A14)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(0.01,TRUE) in cells");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result RANDBETWEEN(TRUE,25) in cells");

		oParser = new parserFormula("RANDBETWEEN(A12,A8)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(N/A,55) in cells");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result RANDBETWEEN(N/A,55) in cells");

		oParser = new parserFormula("RANDBETWEEN(A13,A13)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(test1,test1) in cells");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result RANDBETWEEN(test1,test1) in cells");

		oParser = new parserFormula("RANDBETWEEN(A15,A15)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN('','') in cells");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result RANDBETWEEN('','') in cells");

		oParser = new parserFormula("RANDBETWEEN(A16,A16)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(,) in cells");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result RANDBETWEEN(,) in cells");

		oParser = new parserFormula("RANDBETWEEN(,A15)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN('','') in cells");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result RANDBETWEEN('','') in cells");

		oParser = new parserFormula("RANDBETWEEN(A15,)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN('','') in cells");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result RANDBETWEEN('','') in cells");

		oParser = new parserFormula("RANDBETWEEN(A17,A17)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN('1/1/2000','1/1/2000') in cells");
		assert.strictEqual(oParser.calculate().getValue(), 36526, "Result RANDBETWEEN('1/1/2000','1/1/2000') in cells");

		oParser = new parserFormula("RANDBETWEEN(A17,A18)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN('1/1/2000','2/2/2000') in cells");
		res = oParser.calculate().getValue();
		assert.ok(res >= 36526 && res <= 36558, "Result RANDBETWEEN('1/1/2000','2/2/2000') in cells");

		oParser = new parserFormula("RANDBETWEEN(A8,A18)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN(55,'2/2/2000') in cells");
		res = oParser.calculate().getValue();
		assert.ok(res >= 55 && res <= 36558, "Result RANDBETWEEN(55,'2/2/2000') in cells");

		oParser = new parserFormula("RANDBETWEEN(A18,A8)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN('2/2/2000',55) in cells");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result RANDBETWEEN('2/2/2000',55) in cells");

		oParser = new parserFormula("RANDBETWEEN(A3:A4,A5:A6)", "A2", ws);
		assert.ok(oParser.parse(), "RANDBETWEEN('{1.5,2.5}',{13,23}) in cells");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result RANDBETWEEN({1.5,2.5},{13,23}) in cells");

		// special cases
		oParser = new parserFormula("RANDBETWEEN(1.5,2.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2, "Result RANDBETWEEN(1.5,2.5)");

		oParser = new parserFormula("RANDBETWEEN(-2.5,-1.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -2, "Result RANDBETWEEN(-2.5,-1.5)");

		oParser = new parserFormula("RANDBETWEEN(0.00000000005,0.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1, "RANDBETWEEN(0.00000000005,0.1)");

		oParser = new parserFormula("RANDBETWEEN(-0.1,-0.00000000005)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0, "RANDBETWEEN(-0.1,-0.00000000005)");

		// for bug 67684
		/* Sample of 10 thousand values */
		ws.getRange2("A1:Z10002").cleanAll();
		wb.dependencyFormulas.unlockRecal();

		ws.getRange2("A10002:C10002").setValue("0");
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102:A10002").setValue("=RANDBETWEEN(A100,A101)");		// [1,2]
		ws.getRange2("B101").setValue("3");

		ws.getRange2("B102:B10002").setValue("=RANDBETWEEN(A100,B101)");		// [1,3]
		ws.getRange2("C101").setValue("4");
		ws.getRange2("C102:C10002").setValue("=RANDBETWEEN(A100,C101)");		// [1,4]
		
		// spreading percentages for range [1,2]
		oParser = new parserFormula("COUNTIF(A102:A10002,1)/100", "A1", ws);
		assert.ok(oParser.parse());
		res = Math.round(oParser.calculate().getValue());
		assert.ok(res >= 47 && res <= 53, "Spreading percentages for number 1 in COUNTIF(A102:A10002,1)/100");

		oParser = new parserFormula("COUNTIF(A102:A10002,2)/100", "A1", ws);
		assert.ok(oParser.parse());
		res = Math.round(oParser.calculate().getValue());
		assert.ok(res >= 47 && res <= 53, "Spreading percentages for number 2 in COUNTIF(A102:A10002,2)/100");

		// spreading percentages for range [1,3]
		oParser = new parserFormula("COUNTIF(B102:B10002,1)/100", "A1", ws);
		assert.ok(oParser.parse());
		res = Math.round(oParser.calculate().getValue());
		assert.ok(res >= 31 && res <= 37, "Spreading percentages for number 1 in COUNTIF(B102:B10002,1)/100");

		oParser = new parserFormula("COUNTIF(B102:B10002,2)/100", "A1", ws);
		assert.ok(oParser.parse());
		res = Math.round(oParser.calculate().getValue());
		assert.ok(res >= 31 && res <= 37, "Spreading percentages for number 2 in COUNTIF(B102:B10002,2)/100");

		oParser = new parserFormula("COUNTIF(B102:B10002,3)/100", "A1", ws);
		assert.ok(oParser.parse());
		res = Math.round(oParser.calculate().getValue());
		assert.ok(res >= 31 && res <= 37, "Spreading percentages for number 3 in COUNTIF(B102:B10002,3)/100");
		
		// spreading percentages for range [1,4]
		oParser = new parserFormula("COUNTIF(C102:C10002,1)/100", "A1", ws);
		assert.ok(oParser.parse());
		res = Math.round(oParser.calculate().getValue());
		assert.ok(res >= 20 && res <= 29, "Spreading percentages for number 1 in COUNTIF(C102:C10002,1)/100");

		oParser = new parserFormula("COUNTIF(C102:C10002,2)/100", "A1", ws);
		assert.ok(oParser.parse());
		res = Math.round(oParser.calculate().getValue());
		assert.ok(res >= 20 && res <= 29, "Spreading percentages for number 2 in COUNTIF(C102:C10002,2)/100");

		oParser = new parserFormula("COUNTIF(C102:C10002,3)/100", "A1", ws);
		assert.ok(oParser.parse());
		res = Math.round(oParser.calculate().getValue());
		assert.ok(res >= 20 && res <= 29, "Spreading percentages for number 3 in COUNTIF(C102:C10002,3)/100");

		oParser = new parserFormula("COUNTIF(C102:C10002,4)/100", "A1", ws);
		assert.ok(oParser.parse());
		res = Math.round(oParser.calculate().getValue());
		assert.ok(res >= 20 && res <= 29, "Spreading percentages for number 4 in COUNTIF(C102:C10002,4)/100");
		
		ws.getRange2("A100:D10002").cleanAll();

		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("2");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("1");
		ws.getRange2("A103").setValue("10");
		ws.getRange2("A104").setValue("TRUE");
		ws.getRange2("A105").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		res;
		// Positive cases:
		// Case #1: Number(2). Returns an integer between 1 and 10. Both arguments are numbers. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(1,10) is parsed.');
		res = oParser.calculate().getValue();
		assert.strictEqual(res > 0 && res < 11, true, 'Test: Positive case: Number(2). Returns an integer between 1 and 10. Both arguments are numbers. 2 of 2 arguments used.');
		// Case #2: String(2). Returns an integer between 1 and 10. Both arguments as strings convertible to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN("1","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN("1","10") is parsed.');
		res = oParser.calculate().getValue();
		assert.strictEqual(res > 0 && res < 11, true, 'Test: Positive case: String(2). Returns an integer between 1 and 10. Both arguments as strings convertible to numbers. 2 of 2 arguments used.');
		// Case #3: Formula(2). Returns an integer between 1 and 10. Both arguments as formulas. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(ABS(-1),ROUND(10.5,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(ABS(-1),ROUND(10.5,0)) is parsed.');
		res = oParser.calculate().getValue();
		assert.strictEqual(res > 0 && res < 12, true, 'Test: Positive case: Formula(2). Returns an integer between 1 and 10. Both arguments as formulas. 2 of 2 arguments used.');
		// Case #4: Reference link(2). Returns an integer between 1 and 10. Both arguments as cell references. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(A100,A101) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Reference link(2). Returns an integer between 1 and 10. Both arguments as cell references. 2 of 2 arguments used.');
		// Case #5: Area(2). Returns an integer between 1 and 10. Both arguments as single-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(A100:A100,A101:A101) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Area(2). Returns an integer between 1 and 10. Both arguments as single-cell ranges. 2 of 2 arguments used.');
		// Case #6: Array(2). Returns an integer between 1 and 10. Both arguments as single-element arrays. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN({1},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN({1},{10}) is parsed.');
		res = oParser.calculate().getElementRowCol(0,0).getValue();
		assert.strictEqual(res > 0 && res < 11, true, 'Test: Positive case: Array(2). Returns an integer between 1 and 10. Both arguments as single-element arrays. 2 of 2 arguments used.');
		// Case #7: Name(2). Returns an integer between 1 and 10. Both arguments as named ranges. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(TestName,TestName1) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Name(2). Returns an integer between 1 and 10. Both arguments as named ranges. 2 of 2 arguments used.');
		// Case #8: Name3D(2). Returns an integer between 1 and 10. Both arguments as 3D named ranges. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(TestName3D,TestName3D) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Name3D(2). Returns an integer between 1 and 10. Both arguments as 3D named ranges. 2 of 2 arguments used.');
		// Case #9: Ref3D(2). Returns an integer between 1 and 10. Both arguments as 3D references. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(Sheet2!A1,Sheet2!A2) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Ref3D(2). Returns an integer between 1 and 10. Both arguments as 3D references. 2 of 2 arguments used.');
		// Case #10: Area3D(2). Returns an integer between 1 and 10. Both arguments as 3D single-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Area3D(2). Returns an integer between 1 and 10. Both arguments as 3D single-cell ranges. 2 of 2 arguments used.');
		// Case #11: Table(2). Returns an integer between 1 and 10. Both arguments as table references. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(Table1[Column1],Table1[Column2]) is parsed.');
		res = oParser.calculate().getValue();
		assert.strictEqual(res > 4 && res < 11, true, 'Test: Positive case: Table(2). Returns an integer between 1 and 10. Both arguments as table references. 2 of 2 arguments used.');
		// Case #12: Date(2). Returns an integer between 45292 and 45301 (date serial numbers). Both arguments as dates. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(DATE(2025,1,1),DATE(2025,1,10))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(DATE(2025,1,1),DATE(2025,1,10)) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Date(2). Returns an integer between 45292 and 45301 (date serial numbers). Both arguments as dates. 2 of 2 arguments used.');
		// Case #13: Time(2). Returns an integer between 0 and 0 (time serial numbers rounded down). Both arguments as times. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(TIME(1,0,0),TIME(2,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(TIME(1,0,0),TIME(2,0,0)) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Time(2). Returns an integer between 0 and 0 (time serial numbers rounded down). Both arguments as times. 2 of 2 arguments used.');
		// Case #14: Formula(2). Returns an integer between 1 and 10. Both arguments as nested IF formulas. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(IF(TRUE,1,0),IF(TRUE,10,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(IF(TRUE,1,0),IF(TRUE,10,0)) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Formula(2). Returns an integer between 1 and 10. Both arguments as nested IF formulas. 2 of 2 arguments used.');
		// Case #15: Number(2). Returns an integer between -10 and -1. Both arguments negative numbers. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(-10,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(-10,-1) is parsed.');
		res = oParser.calculate().getValue();
		assert.strictEqual((res > -11) && (res < 0), true, 'Test: Positive case: Number(2). Returns an integer between -10 and -1. Both arguments negative numbers. 2 of 2 arguments used.');
		// Case #16: String(2). Returns an integer between -10 and -1. Both arguments as strings convertible to negative numbers. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN("-10","-1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN("-10","-1") is parsed.');
		res = oParser.calculate().getValue();
		assert.strictEqual((res > -11) && (res < 0), true, 'Test: Positive case: String(2). Returns an integer between -10 and -1. Both arguments as strings convertible to negative numbers. 2 of 2 arguments used.');
		// Case #17: Formula(2). Returns an integer between 1 and 8. Both arguments as mathematical formulas. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(SQRT(1),POWER(2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(SQRT(1),POWER(2,3)) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Formula(2). Returns an integer between 1 and 8. Both arguments as mathematical formulas. 2 of 2 arguments used.');
		// Case #18: Number(2). Returns an integer between 1 and 10 (decimal inputs rounded down). Both arguments as decimals. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(1.5,10.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(1.5,10.5) is parsed.');
		res = oParser.calculate().getValue();
		assert.strictEqual((res > 0) && (res < 12), true, 'Test: Positive case: Number(2). Returns an integer between 1 and 10 (decimal inputs rounded down). Both arguments as decimals. 2 of 2 arguments used.');
		// Case #19: String(2). Returns an integer between 1 and 10 (decimal strings rounded down). Both arguments as decimal strings. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN("1.5","10.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN("1.5","10.5") is parsed.');
		res = oParser.calculate().getValue();
		assert.strictEqual((res > 0) && (res < 12), true, 'Test: Positive case: String(2). Returns an integer between 1 and 10 (decimal strings rounded down). Both arguments as decimal strings. 2 of 2 arguments used.');
		// Case #20: Reference link(2). Returns an integer between -10 and -1. Both arguments as cell references with negative numbers. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(A102,A103) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Positive case: Reference link(2). Returns an integer between -10 and -1. Both arguments as cell references with negative numbers. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number(2). Returns #NUM! as bottom > top. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(10,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(10,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Returns #NUM! as bottom > top. 2 of 2 arguments used.');
		// Case #2: String(2). Returns #VALUE! due to non-numeric string in bottom. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN("abc","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN("abc","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Returns #VALUE! due to non-numeric string in bottom. 2 of 2 arguments used.');
		// Case #3: String(2). Returns #VALUE! due to non-numeric string in top. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN("1","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN("1","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Returns #VALUE! due to non-numeric string in top. 2 of 2 arguments used.');
		// Case #4: Error(2). Returns #N/A due to error in bottom. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). Returns #N/A due to error in bottom. 2 of 2 arguments used.');
		// Case #5: Error(2). Returns #N/A due to error in top. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). Returns #N/A due to error in top. 2 of 2 arguments used.');
		// Case #6: Boolean(2). Returns #NUM! as boolean arguments are invalid. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Returns #NUM! as boolean arguments are invalid. 2 of 2 arguments used.');
		// Case #7: Reference link(2). Returns #VALUE! as bottom reference contains text. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(A104,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(A104,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(2). Returns #VALUE! as bottom reference contains text. 2 of 2 arguments used.');
		// Case #8: Area(2). Returns #NUM! as bottom is a multi-cell range. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(A100:A101,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(A100:A101,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2). Returns #NUM! as bottom is a multi-cell range. 2 of 2 arguments used.');
		// Case #9: Array(2). Returns #NUM! as bottom is a multi-element array. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN({1,2},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN({1,2},{10}) is parsed.');
		//? res = oParser.calculate().getElementRowCol(0,0).getValue();
		//? res = oParser.calculate();
		//? assert.strictEqual((res > 0) && (res < 11), true, 'Test: Negative case: Array(2). Returns #NUM! as bottom is a multi-element array. 2 of 2 arguments used.');
		// Case #10: Name(2). Returns #VALUE! as bottom is a named range with text. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(TestNameArea2,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(TestNameArea2,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name(2). Returns #VALUE! as bottom is a named range with text. 2 of 2 arguments used.');
		// Case #11: Name3D(2). Returns #VALUE! as bottom is a 3D named range with text. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(TestNameArea3D2,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(TestNameArea3D2,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D(2). Returns #VALUE! as bottom is a 3D named range with text. 2 of 2 arguments used.');
		// Case #12: Ref3D(2). Returns #VALUE! as bottom is a 3D reference with text. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(Sheet2!A3,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(Sheet2!A3,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(2). Returns #VALUE! as bottom is a 3D reference with text. 2 of 2 arguments used.');
		// Case #13: Area3D(2). Returns #NUM! as bottom is a 3D multi-cell range. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(Sheet2!A1:A2,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(Sheet2!A1:A2,Sheet2!A2:A2) is parsed.');
		res = oParser.calculate();
		assert.strictEqual(res.type, AscCommonExcel.cElementType.number, 'Test: Negative case: Area3D(2). Returns #NUM! as bottom is a 3D multi-cell range. 2 of 2 arguments used.');
		// Case #14: Table(2). Returns #VALUE! as bottom is a table reference with text. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table(2). Returns #VALUE! as bottom is a table reference with text. 2 of 2 arguments used.');
		// Case #15: Empty(2). Returns #NUM! as both arguments are empty. 0 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(2). Returns #NUM! as both arguments are empty. 0 of 2 arguments used.');
		// Case #16: String(2). Returns #VALUE! as bottom is an empty string. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN("","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN("","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Returns #VALUE! as bottom is an empty string. 2 of 2 arguments used.');
		// Case #17: String(2). Returns #VALUE! as top is an empty string. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN("1","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN("1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Returns #VALUE! as top is an empty string. 2 of 2 arguments used.');
		// Case #18: Number(2). Returns an integer (0) as bottom equals top. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(2). Returns an integer (0) as bottom equals top. 2 of 2 arguments used.');
		// Case #19: Formula(2). Returns #NUM! as bottom formula results in an error. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). Returns #NUM! as bottom formula results in an error. 2 of 2 arguments used.');
		// Case #20: Reference link(2). Returns #NUM! as top reference is less than bottom (text coerced to 0). 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(A100,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(A100,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(2). Returns #NUM! as top reference is less than bottom (text coerced to 0). 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number(2). Returns an integer between -2147483648 and 2147483647. Minimum and maximum valid integers in Excel. 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(-2147483648,2147483647)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(-2147483648,2147483647) is parsed.');
		res = oParser.calculate().getValue();
		assert.strictEqual((res > -2147483649) && (res < 2147483648), true, 'Test: Bounded case: Number(2). Returns an integer between -2147483648 and 2147483647. Minimum and maximum valid integers in Excel. 2 of 2 arguments used.');
		// Case #2: Number(2). Returns 1 as bottom equals top (minimum valid range). 2 of 2 arguments used.
		oParser = new parserFormula('RANDBETWEEN(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANDBETWEEN(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Returns 1 as bottom equals top (minimum valid range). 2 of 2 arguments used.');

		// Need to fix: different results from MS
		// Case #9: Array(2). Returns #NUM! as bottom is a multi-element array. 2 of 2 arguments used.
		// Case #15: Empty(2). Returns #NUM! as both arguments are empty. 0 of 2 arguments used.

	});

	QUnit.test("Test: \"ROMAN\"", function (assert) {

		oParser = new parserFormula("ROMAN(499,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "CDXCIX");

		oParser = new parserFormula("ROMAN(499,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "LDVLIV");

		oParser = new parserFormula("ROMAN(499,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "XDIX");

		oParser = new parserFormula("ROMAN(499,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "VDIV");

		oParser = new parserFormula("ROMAN(499,4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "ID");

		oParser = new parserFormula("ROMAN(2013,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "MMXIII");

		oParser = new parserFormula("ROMAN(2013,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("ROMAN(-2013,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("ROMAN(2499,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "MMLDVLIV");

		oParser = new parserFormula("ROMAN(499)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "CDXCIX");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("Text"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: integer within 1-3999, no form (default 0). Returns "C".
		oParser = new parserFormula('ROMAN(100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Positive case: Number. Basic valid input: integer within 1-3999, no form (default 0). Returns "C".');
		// Case #2: Number, Number. Valid integer with form 1 (more concise). Returns "C".
		oParser = new parserFormula('ROMAN(100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Positive case: Number, Number. Valid integer with form 1 (more concise). Returns "C".');
		// Case #3: Number, Number. Valid integer with form 4 (simplest). Returns "MMMCMXCIX".
		oParser = new parserFormula('ROMAN(3999,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(3999,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'MMMIM', 'Test: Positive case: Number, Number. Valid integer with form 4 (simplest). Returns "MMMCMXCIX".');
		// Case #4: Number, Boolean. Valid integer with form TRUE (equivalent to 0). Returns "C".
		oParser = new parserFormula('ROMAN(100,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Positive case: Number, Boolean. Valid integer with form TRUE (equivalent to 0). Returns "C".');
		// Case #5: Number, Boolean. Valid integer with form FALSE (equivalent to 4). Returns "C".
		oParser = new parserFormula('ROMAN(100,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Positive case: Number, Boolean. Valid integer with form FALSE (equivalent to 4). Returns "C".');
		// Case #6: String. String convertible to valid number. Returns "C".
		oParser = new parserFormula('ROMAN("100")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN("100") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Positive case: String. String convertible to valid number. Returns "C".');
		// Case #7: String, String. Strings convertible to number and form. Returns "C".
		oParser = new parserFormula('ROMAN("100","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN("100","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Positive case: String, String. Strings convertible to number and form. Returns "C".');
		// Case #8: Formula. Nested formula evaluating to 100. Returns "C".
		oParser = new parserFormula('ROMAN(SQRT(10000))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(SQRT(10000)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Positive case: Formula. Nested formula evaluating to 100. Returns "C".');
		// Case #9: Formula, Number. Nested IF returning valid number with form 3. Returns "C".
		oParser = new parserFormula('ROMAN(IF(TRUE,100,50),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(IF(TRUE,100,50),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Positive case: Formula, Number. Nested IF returning valid number with form 3. Returns "C".');
		// Case #10: Formula. Arithmetic formula evaluating to 150. Returns "CL".
		oParser = new parserFormula('ROMAN(100+50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100+50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'CL', 'Test: Positive case: Formula. Arithmetic formula evaluating to 150. Returns "CL".');
		// Case #12: Area. Single-cell range with valid number (100). Returns "C".
		oParser = new parserFormula('ROMAN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(A101:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 'I', 'Test: Positive case: Area. Single-cell range with valid number (100). Returns "C".');
		// Case #13: Array. Array with single valid number. Returns "C".
		oParser = new parserFormula('ROMAN({100})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN({100}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 'C', 'Test: Positive case: Array. Array with single valid number. Returns "C".');
		// Case #16: Ref3D. 3D reference to cell with valid number (100). Returns "C".
		oParser = new parserFormula('ROMAN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'I', 'Test: Positive case: Ref3D. 3D reference to cell with valid number (100). Returns "C".');
		// Case #17: Area3D. 3D single-cell range with valid number (100). Returns "C".
		oParser = new parserFormula('ROMAN(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 'II', 'Test: Positive case: Area3D. 3D single-cell range with valid number (100). Returns "C".');
		// Case #18: Table. Table structured reference with valid number (1). Returns "I".
		oParser = new parserFormula('ROMAN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 'I', 'Test: Positive case: Table. Table structured reference with valid number (100). Returns "C".');
		// Case #19: Date. Date as serial number (45654, valid). Returns Roman numeral for 45654.
		oParser = new parserFormula('ROMAN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Date. Date as serial number (45654, valid). Returns Roman numeral for 45654.');
		// Case #20: Time, Number. Time adjusted to valid number (100.5) with form 2. Returns "C".
		oParser = new parserFormula('ROMAN(TIME(12,0,0)+100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(TIME(12,0,0)+100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Positive case: Time, Number. Time adjusted to valid number (100.5) with form 2. Returns "C".');
		// Case #21: Number, Formula. Form as nested IF returning 1. Returns "M".
		oParser = new parserFormula('ROMAN(1000,IF(TRUE,1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(1000,IF(TRUE,1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'M', 'Test: Positive case: Number, Formula. Form as nested IF returning 1. Returns "M".');
		// Case #22: String, Formula. String number with formula form (rounds to 2). Returns "D".
		oParser = new parserFormula('ROMAN("500",ROUND(1.6,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN("500",ROUND(1.6,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'D', 'Test: Positive case: String, Formula. String number with formula form (rounds to 2). Returns "D".');

		// Negative cases:

		// Case #1: Number. Negative number returns #NUM!.
		oParser = new parserFormula('ROMAN(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Negative number returns #NUM!.');
		// Case #2: Number. Number > 3999 returns #NUM!.
		oParser = new parserFormula('ROMAN(4000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(4000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Number > 3999 returns #NUM!.');
		// Case #3: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('ROMAN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #4: String. String convertible to negative number returns #NUM!.
		oParser = new parserFormula('ROMAN("-1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN("-1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String convertible to negative number returns #NUM!.');
		// Case #5: Error. Propagates #N/A error.
		oParser = new parserFormula('ROMAN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #7: Empty. Reference to empty cell returns #VALUE!.
		oParser = new parserFormula('ROMAN(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!.');
		// Case #8: String. Empty string returns #VALUE!.
		oParser = new parserFormula('ROMAN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #10: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('ROMAN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #11: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('ROMAN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 'I', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #12: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('ROMAN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #13: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('ROMAN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #14: Number, Number. Negative form returns #VALUE!.
		oParser = new parserFormula('ROMAN(100,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number. Negative form returns #VALUE!.');
		// Case #15: Number, Number. Form > 4 returns #VALUE!.
		oParser = new parserFormula('ROMAN(100,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number. Form > 4 returns #VALUE!.');
		// Case #16: Number, String. Non-numeric form string returns #VALUE!.
		oParser = new parserFormula('ROMAN(100,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric form string returns #VALUE!.');
		// Case #18: Number. Excessively large number returns #NUM!.
		oParser = new parserFormula('ROMAN(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Excessively large number returns #NUM!.');
		// Case #20: Number, Array. Array as form argument returns #VALUE!.
		oParser = new parserFormula('ROMAN(100,{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100,{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 'C', 'Test: Negative case: Number, Array. Array as form argument returns #VALUE!.');
		// Case #21: Number, Empty. Empty form argument treated as 0. Returns "C".
		oParser = new parserFormula('ROMAN(100,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(100,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'C', 'Test: Negative case: Number, Empty. Empty form argument treated as 0. Returns "C".');
		// Case #22: String, String. String convertible to >3999 returns #NUM!.
		oParser = new parserFormula('ROMAN("4000","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN("4000","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. String convertible to >3999 returns #NUM!.');

		// Bounded cases:
		// Case #1: Number. Minimum valid number (1). Returns "I".
		oParser = new parserFormula('ROMAN(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'I', 'Test: Bounded case: Number. Minimum valid number (1). Returns "I".');
		// Case #2: Number. Maximum valid number (3999). Returns "MMMCMXCIX".
		oParser = new parserFormula('ROMAN(3999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(3999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'MMMCMXCIX', 'Test: Bounded case: Number. Maximum valid number (3999). Returns "MMMCMXCIX".');
		// Case #3: Number, Number. Minimum number with simplest form (4). Returns "I".
		oParser = new parserFormula('ROMAN(1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'I', 'Test: Bounded case: Number, Number. Minimum number with simplest form (4). Returns "I".');
		// Case #4: Number, Number. Maximum number with default form (0). Returns "MMMCMXCIX".
		oParser = new parserFormula('ROMAN(3999,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROMAN(3999,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'MMMCMXCIX', 'Test: Bounded case: Number, Number. Maximum number with default form (0). Returns "MMMCMXCIX".');

		// Need to fix: area, table and name handle
		// Case #12: Area. Single-cell range with valid number (100). Returns "C".
		// Case #17: Area3D. 3D single-cell range with valid number (100). Returns "C".
		// Case #18: Table. Table structured reference with valid number (1). Returns "I".
		// Case #11: Name. Named range with text returns #VALUE!.


		testArrayFormula2(assert, "ROMAN", 2, 2);
	});

	QUnit.test("Test: \"ROUND\"", function (assert) {
		oParser = new parserFormula("ROUND(2.15, 1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2.2);

		oParser = new parserFormula("ROUND(2.149, 1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2.1);

		oParser = new parserFormula("ROUND(-1.475, 2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1.48);

		oParser = new parserFormula("ROUND(21.5, -1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 20);

		oParser = new parserFormula("ROUND(626.3,-3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1000);

		oParser = new parserFormula("ROUND(1.98,-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("ROUND(-50.55,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -100);

		oParser = new parserFormula('ROUND("test",-2.1)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('ROUND(123.431,"test")', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('ROUND(123.431,#NUM!)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula('ROUND(#NUM!,123.431)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("ROUND(-50.55,-2.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -100);

		oParser = new parserFormula("ROUND(-50.55,-2.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -100);

		oParser = new parserFormula("ROUND(-50.55,0.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -51);

		oParser = new parserFormula("ROUND(-50.55,0.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -51);

		oParser = new parserFormula("ROUND(183.64, 2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 183.64);

		ws.getRange2("A100").setValue("3.14159");
		ws.getRange2("A101").setValue("2.71828");
		ws.getRange2("A102").setValue("1.005");
		ws.getRange2("A103").setValue("-1.56789");
		ws.getRange2("A104").setValue("123.456");
		ws.getRange2("A105").setValue("0.4999");
		ws.getRange2("A106").setValue("-0.4999");
		ws.getRange2("A107").setValue("1000.567");
		ws.getRange2("A108").setValue("999.999");
		ws.getRange2("A109").setValue("5.55555");
		ws.getRange2("A110").setValue("1.123123");
		ws.getRange2("A111").setValue("1.123123");

		ws.getRange2("B100").setValue("2");
		ws.getRange2("B101").setValue("3");
		ws.getRange2("B102").setValue("2");
		ws.getRange2("B103").setValue("1");
		ws.getRange2("B104").setValue("0");
		ws.getRange2("B105").setValue("2");
		ws.getRange2("B106").setValue("2");
		ws.getRange2("B107").setValue("-1");
		ws.getRange2("B108").setValue("2");
		ws.getRange2("B109").setValue("4");
		ws.getRange2("B110").setValue("6");
		ws.getRange2("B111").setValue("5");


		oParser = new parserFormula("ROUND(A100, B100)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.14, "Round ROUND(A100, B100)");

		oParser = new parserFormula("ROUND(A101, B101)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2.718, "Round ROUND(A101, B101)");

		oParser = new parserFormula("ROUND(A102, B102)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.01, "Round ROUND(A102, B102)");

		oParser = new parserFormula("ROUND(A103, B103)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1.6, "Round ROUND(A103, B103)");

		oParser = new parserFormula("ROUND(A104, B104)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 123, "Round ROUND(A104, B104)");

		oParser = new parserFormula("ROUND(A105, B105)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.5, "Round ROUND(A105, B105)");

		oParser = new parserFormula("ROUND(A106, B106)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -0.5, "Round ROUND(A106, B106)");

		oParser = new parserFormula("ROUND(A107, B107)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1000, "Round ROUND(A107, B107)");

		oParser = new parserFormula("ROUND(A108, B108)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1000, "Round ROUND(A108, B108)");

		oParser = new parserFormula("ROUND(A109, B109)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 5.5556, "Round ROUND(A109, B109)");

		oParser = new parserFormula("ROUND(A110, B110)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.123123, "Round ROUND(A110, B110)");

		oParser = new parserFormula("ROUND(A111, B111)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.12312, "Round ROUND(A111, B111)");


		oParser = new parserFormula("ROUND(1.123,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.12, "ROUND(1.123,2)");

		oParser = new parserFormula("ROUND(1.125,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.13, "ROUND(1.125,2)");

		oParser = new parserFormula("ROUND(1.005,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.01, "ROUND(1.005,2)");

		oParser = new parserFormula("ROUND(1.995,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2.00, "ROUND(1.995,2)");


		oParser = new parserFormula("ROUND(3.14159,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3, "ROUND(3.14159,0)");

		oParser = new parserFormula("ROUND(3.14159,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.1, "ROUND(3.14159,1)");

		oParser = new parserFormula("ROUND(3.14159,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.14, "ROUND(3.14159,2)");

		oParser = new parserFormula("ROUND(3.14159,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.142, "ROUND(3.14159,3)");

		oParser = new parserFormula("ROUND(3.14159,4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.1416, "ROUND(3.14159,4)");


		oParser = new parserFormula("ROUND(-1.123,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1.12, "ROUND(-1.123,2)");

		oParser = new parserFormula("ROUND(-1.125,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1.13, "ROUND(-1.125,2)");

		oParser = new parserFormula("ROUND(-1.005,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1.01, "ROUND(-1.005,2)");

		oParser = new parserFormula("ROUND(-1.995,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -2.00, "ROUND(-1.995,2)");

		oParser = new parserFormula("ROUND(1.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2, "ROUND(1.5,0)");

		oParser = new parserFormula("ROUND(2.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3, "ROUND(2.5,0)");

		oParser = new parserFormula("ROUND(3.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4, "ROUND(3.5,0)");

		oParser = new parserFormula("ROUND(-1.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -2, "ROUND(-1.5,0)");

		oParser = new parserFormula("ROUND(-2.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -3, "ROUND(-2.5,0)");

		// Negative decimal places tests
		oParser = new parserFormula("ROUND(123.456,-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 120, "ROUND(123.456,-1)");

		oParser = new parserFormula("ROUND(123.456,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 100, "ROUND(123.456,-2)");

		oParser = new parserFormula("ROUND(555.555,-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 560, "ROUND(555.555,-1)");

		oParser = new parserFormula("ROUND(555.555,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 600, "ROUND(555.555,-2)");

		oParser = new parserFormula("ROUND(555.555,-3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1000, "ROUND(555.555,-3)");

		oParser = new parserFormula("ROUND(0.123456,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.12, "ROUND(0.123456,2)");

		oParser = new parserFormula("ROUND(0.123456,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.123, "ROUND(0.123456,3)");

		oParser = new parserFormula("ROUND(0.123456,4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.1235, "ROUND(0.123456,4)");

		oParser = new parserFormula("ROUND(0.999999,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.00, "ROUND(0.999999,2)");

		oParser = new parserFormula("ROUND(123456.789,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 123456.79, "ROUND(123456.789,2)");

		oParser = new parserFormula("ROUND(999999.999,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1000000.00, "ROUND(999999.999,2)");

		oParser = new parserFormula("ROUND(1000000.001,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1000000.00, "ROUND(1000000.001,2)");

		oParser = new parserFormula("ROUND(0.0000123456,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.00001, "ROUND(0.0000123456,5)");

		oParser = new parserFormula("ROUND(0.0000123456,6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.000012, "ROUND(0.0000123456,6)");

		oParser = new parserFormula("ROUND(0.0000123456,7)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.0000123, "ROUND(0.0000123456,7)");

		oParser = new parserFormula("ROUND(2.005,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2.01, "ROUND(2.005,2)");

		oParser = new parserFormula("ROUND(3.005,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.01, "ROUND(3.005,2)");

		oParser = new parserFormula("ROUND(4.005,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4.01, "ROUND(4.005,2)");

		oParser = new parserFormula("ROUND(5.005,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 5.01, "ROUND(5.005,2)");

		oParser = new parserFormula("ROUND(0.333333,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.33, "ROUND(0.333333,2)");

		oParser = new parserFormula("ROUND(0.666666,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.67, "ROUND(0.666666,2)");

		oParser = new parserFormula("ROUND(0.166666,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.17, "ROUND(0.166666,2)");

		oParser = new parserFormula("ROUND(0.142857,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.14, "ROUND(0.142857,2)");

		oParser = new parserFormula("ROUND(3.141592653589793,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.14, "ROUND(3.141592653589793,2)");

		oParser = new parserFormula("ROUND(2.718281828459045,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2.72, "ROUND(2.718281828459045,2)");

		oParser = new parserFormula("ROUND(1.414213562373095,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.41, "ROUND(1.414213562373095,2)");

		oParser = new parserFormula("ROUND(0.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1, "ROUND(0.5,0)");

		oParser = new parserFormula("ROUND(1.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2, "ROUND(1.5,0)");

		oParser = new parserFormula("ROUND(2.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3, "ROUND(2.5,0)");

		oParser = new parserFormula("ROUND(-0.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1, "ROUND(-0.5,0)");

		oParser = new parserFormula("ROUND(-1.5,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -2, "ROUND(-1.5,0)");

		oParser = new parserFormula("ROUND(1.23456789,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.2, "ROUND(1.23456789,1)");

		oParser = new parserFormula("ROUND(1.23456789,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.23, "ROUND(1.23456789,2)");

		oParser = new parserFormula("ROUND(1.23456789,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.235, "ROUND(1.23456789,3)");

		oParser = new parserFormula("ROUND(1.23456789,4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.2346, "ROUND(1.23456789,4)");

		oParser = new parserFormula("ROUND(1.23456789,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.23457, "ROUND(1.23456789,5)");

		oParser = new parserFormula("ROUND(0,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0, "ROUND(0,2)");

		oParser = new parserFormula("ROUND(0,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0, "ROUND(0,0)");

		oParser = new parserFormula("ROUND(0,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0, "ROUND(0,-2)");

		oParser = new parserFormula("ROUND(1.15,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.2, "ROUND(1.15,1)");

		oParser = new parserFormula("ROUND(1.25,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.3, "ROUND(1.25,1)");

		oParser = new parserFormula("ROUND(1.35,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.4, "ROUND(1.35,1)");

		oParser = new parserFormula("ROUND(1.45,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.5, "ROUND(1.45,1)");

		oParser = new parserFormula("ROUND(1.55,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.6, "ROUND(1.55,1)");

		oParser = new parserFormula("ROUND(0.01,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.01, "ROUND(0.01,2)");

		oParser = new parserFormula("ROUND(0.02,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.02, "ROUND(0.02,2)");

		oParser = new parserFormula("ROUND(0.03,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.03, "ROUND(0.03,2)");

		oParser = new parserFormula("ROUND(0.04,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.04, "ROUND(0.04,2)");

		oParser = new parserFormula("ROUND(0.05,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.05, "ROUND(0.05,2)");

		oParser = new parserFormula("ROUND(-0.01,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -0.01, "ROUND(-0.01,2)");

		oParser = new parserFormula("ROUND(-0.02,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -0.02, "ROUND(-0.02,2)");

		oParser = new parserFormula("ROUND(-0.03,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -0.03, "ROUND(-0.03,2)");

		oParser = new parserFormula("ROUND(-0.04,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -0.04, "ROUND(-0.04,2)");

		oParser = new parserFormula("ROUND(-0.05,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -0.05, "ROUND(-0.05,2)");


		oParser = new parserFormula("ROUND(19.99,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 19.99, "ROUND(19.99,2)");

		oParser = new parserFormula("ROUND(19.90,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 19.90, "ROUND(19.90,2)");

		oParser = new parserFormula("ROUND(19.00,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 19.00, "ROUND(19.00,2)");

		oParser = new parserFormula("ROUND(19.999,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 20.00, "ROUND(19.999,2)");

		oParser = new parserFormula("ROUND(19.001,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 19.00, "ROUND(19.001,2)");


		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("Text"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(2). Basic valid input: number and num_digits as integers. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.57, 'Test: Positive case: Number(2). Basic valid input: number and num_digits as integers. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #2: Number(2). Number with negative num_digits. Rounds to nearest 10. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Number with negative num_digits. Rounds to nearest 10. 2 of 2 arguments used.');
		// Case #3: Number(2). Number with zero num_digits. Rounds to nearest integer. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2). Number with zero num_digits. Rounds to nearest integer. 2 of 2 arguments used.');
		// Case #4: String(2). String inputs convertible to numbers. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND("2.567", "2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND("2.567", "2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.57, 'Test: Positive case: String(2). String inputs convertible to numbers. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #5: Formula(2). Nested formulas returning valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(SQRT(4), ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(SQRT(4), ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(2). Nested formulas returning valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #6: Reference link(2). References to cells with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link(2). References to cells with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #7: Area(2). Single-cell ranges for number and num_digits. Rounds to 1 decimal place. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(A102:A102, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(A102:A102, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area(2). Single-cell ranges for number and num_digits. Rounds to 1 decimal place. 2 of 2 arguments used.');
		// Case #8: Array(2). Arrays with single valid elements. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND({2.567}, {2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND({2.567}, {2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2.57, 'Test: Positive case: Array(2). Arrays with single valid elements. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #9: Name(2). Named ranges with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name(2). Named ranges with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #10: Name3D(2). 3D named ranges with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(TestName3D, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(TestName3D, TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name3D(2). 3D named ranges with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #11: Ref3D(2). 3D references to cells with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D(2). 3D references to cells with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #12: Area3D(2). 3D single-cell ranges for number and num_digits. Rounds to 1 decimal place. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(Sheet2!A3:A3, Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(Sheet2!A3:A3, Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(2). 3D single-cell ranges for number and num_digits. Rounds to 1 decimal place. 2 of 2 arguments used.');
		// Case #13: Table(2). Table structured references with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(Table1[Column1], Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(Table1[Column1], Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table(2). Table structured references with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #14: Date, Number. Date as serial number, rounds to nearest integer. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(DATE(2025,1,1), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(DATE(2025,1,1), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date, Number. Date as serial number, rounds to nearest integer. 2 of 2 arguments used.');
		// Case #15: Time, Number. Time as decimal (0.5), rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(TIME(12,0,0), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(TIME(12,0,0), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Time, Number. Time as decimal (0.5), rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #16: Formula, Number. ROUND as parent formula with SUM. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(SUM(1.234, 1.333), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(SUM(1.234, 1.333), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.57, 'Test: Positive case: Formula, Number. ROUND as parent formula with SUM. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #17: Number, String. Number and string num_digits convertible to zero. Rounds to nearest integer. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, "0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, "0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number, String. Number and string num_digits convertible to zero. Rounds to nearest integer. 2 of 2 arguments used.');
		// Case #18: Number, Formula. Number with nested IF for num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, IF(TRUE, 2, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, IF(TRUE, 2, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.57, 'Test: Positive case: Number, Formula. Number with nested IF for num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #19: String, Number. String convertible to number, rounds to 3 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND("123.45678", 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND("123.45678", 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.457, 'Test: Positive case: String, Number. String convertible to number, rounds to 3 decimal places. 2 of 2 arguments used.');
		// Case #20: Number, Number. Number with negative num_digits. Rounds to nearest 100. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(123.45678, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(123.45678, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Number, Number. Number with negative num_digits. Rounds to nearest 100. 2 of 2 arguments used.');
		// Case #21: Number, Number. Negative number, rounds to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(-2.567, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(-2.567, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.57, 'Test: Positive case: Number, Number. Negative number, rounds to 2 decimal places. 2 of 2 arguments used.');
		// Case #22: Formula, Number. Mathematical formula (PI), rounds to 4 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(PI(), 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(PI(), 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.1416, 'Test: Positive case: Formula, Number. Mathematical formula (PI), rounds to 4 decimal places. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number, String. Non-numeric string for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #2: String, Number. Non-numeric string for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND("abc", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND("abc", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #3: Error, Number. Error input propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(NA(), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(NA(), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error input propagates #N/A. 2 of 2 arguments used.');
		// Case #4: Number, Error. Error in num_digits propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error in num_digits propagates #N/A. 2 of 2 arguments used.');
		// Case #5: Area, Number. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(A104:A105, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(A104:A105, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Area, Number. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #6: Number, Area. Multi-cell range for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, A104:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number, Area. Multi-cell range for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Empty, Number. Empty reference for number returns 0. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(A106, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(A106, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty, Number. Empty reference for number returns 0. 2 of 2 arguments used.');
		// Case #8: Number, Empty. Empty reference for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Number, Empty. Empty reference for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: String, Number. Empty string for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND("", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND("", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Empty string for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #10: Number, String. Empty string for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Empty string for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Boolean, Number. Boolean number (1) rounds to 2 decimal places, but unexpected input. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(TRUE, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(TRUE, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean, Number. Boolean number (1) rounds to 2 decimal places, but unexpected input. 2 of 2 arguments used.');
		// Case #12: Number, Boolean. Boolean num_digits (0) rounds to integer, but unexpected input. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Number, Boolean. Boolean num_digits (0) rounds to integer, but unexpected input. 2 of 2 arguments used.');
		// Case #13: Ref3D, Number. 3D reference to text cell returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(Sheet2!A5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(Sheet2!A5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D, Number. 3D reference to text cell returns #VALUE!. 2 of 2 arguments used.');
		// Case #14: Number, Ref3D. 3D reference to text cell for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Number, Ref3D. 3D reference to text cell for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #15: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(TestNameArea, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(TestNameArea, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Number, Name. Named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.6, 'Test: Negative case: Number, Name. Named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Name3D, Number. 3D named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(TestNameArea3D, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(TestNameArea3D, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name3D, Number. 3D named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Number, Name3D. 3D named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, TestNameArea3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Number, Name3D. 3D named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #19: Table, Number. Table column with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(Table1[Column2], 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(Table1[Column2], 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table, Number. Table column with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #20: Number, Table. Table column with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Table. Table column with text for num_digits returns #VALUE!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number(2). Smallest positive Excel number, rounds to 0. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(1E-307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(1E-307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Smallest positive Excel number, rounds to 0. 2 of 2 arguments used.');
		// Case #2: Number(2). Largest valid Excel number, rounds to itself. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(9.99999999999999E+307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(9.99999999999999E+307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number(2). Largest valid Excel number, rounds to itself. 2 of 2 arguments used.');
		// Case #3: Number(2). Maximum num_digits (15) for rounding. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, 15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, 15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.567, 'Test: Bounded case: Number(2). Maximum num_digits (15) for rounding. 2 of 2 arguments used.');
		// Case #4: Number(2). Minimum num_digits (-308) for rounding. Rounds to 0. 2 of 2 arguments used.
		oParser = new parserFormula('ROUND(2.567, -308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUND(2.567, -308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Minimum num_digits (-308) for rounding. Rounds to 0. 2 of 2 arguments used.');

		// Need to fix: area handle
		// Case #13: Table(2). Table structured references with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		// Case #5: Area, Number. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.
		// Case #6: Number, Area. Multi-cell range for num_digits returns #VALUE!. 2 of 2 arguments used.
		// Case #15: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.
		// Case #16: Number, Name. Named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		// Case #17: Name3D, Number. 3D named range with text returns #VALUE!. 2 of 2 arguments used.
		// Case #18: Number, Name3D. 3D named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.


		testArrayFormula2(assert, "ROUND", 2, 2);
	});

	QUnit.test("Test: \"ROUNDDOWN\"", function (assert) {
		oParser = new parserFormula("ROUNDDOWN(3.2,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("ROUNDDOWN(3.14159,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.141);

		oParser = new parserFormula("ROUNDDOWN(-3.14159,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -3.1);

		oParser = new parserFormula("ROUNDDOWN(31415.92654,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 31400);

		oParser = new parserFormula("ROUNDDOWN(123.431,0.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 123);

		oParser = new parserFormula("ROUNDDOWN(123.431,0.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 123);

		oParser = new parserFormula("ROUNDDOWN(123.431,-0.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 123);

		oParser = new parserFormula("ROUNDDOWN(123.431,-0.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 123);

		oParser = new parserFormula("ROUNDDOWN(123.431,-2.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 100);

		oParser = new parserFormula('ROUNDDOWN("test",-2.1)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('ROUNDDOWN(123.431,"test")', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('ROUNDDOWN(123.431,#NUM!)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula('ROUNDDOWN(#NUM!,123.431)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("ROUNDDOWN(-50.55,0.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -50);

		oParser = new parserFormula("ROUNDDOWN(-50.55,0.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -50);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("Text"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(2). Basic valid input: number and num_digits as integers. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.56, 'Test: Positive case: Number(2). Basic valid input: number and num_digits as integers. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #2: Number(2). Number with negative num_digits. ROUNDDOWNs to nearest 10. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Number with negative num_digits. ROUNDDOWNs to nearest 10. 2 of 2 arguments used.');
		// Case #3: Number(2). Number with zero num_digits. ROUNDDOWNs to nearest integer. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(2). Number with zero num_digits. ROUNDDOWNs to nearest integer. 2 of 2 arguments used.');
		// Case #4: String(2). String inputs convertible to numbers. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN("2.567", "2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN("2.567", "2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.56, 'Test: Positive case: String(2). String inputs convertible to numbers. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #5: Formula(2). Nested formulas returning valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(SQRT(4), ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(SQRT(4), ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(2). Nested formulas returning valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #6: Reference link(2). References to cells with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link(2). References to cells with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #7: Area(2). Single-cell ranges for number and num_digits. ROUNDDOWNs to 1 decimal place. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(A102:A102, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(A102:A102, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area(2). Single-cell ranges for number and num_digits. ROUNDDOWNs to 1 decimal place. 2 of 2 arguments used.');
		// Case #8: Array(2). Arrays with single valid elements. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN({2.567}, {2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN({2.567}, {2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2.56, 'Test: Positive case: Array(2). Arrays with single valid elements. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #9: Name(2). Named ranges with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name(2). Named ranges with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #10: Name3D(2). 3D named ranges with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(TestName3D, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(TestName3D, TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D(2). 3D named ranges with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #11: Ref3D(2). 3D references to cells with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D(2). 3D references to cells with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #12: Area3D(2). 3D single-cell ranges for number and num_digits. ROUNDDOWNs to 1 decimal place. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(Sheet2!A3:A3, Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(Sheet2!A3:A3, Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(2). 3D single-cell ranges for number and num_digits. ROUNDDOWNs to 1 decimal place. 2 of 2 arguments used.');
		// Case #13: Table(2). Table structured references with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(Table1[Column1], Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(Table1[Column1], Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table(2). Table structured references with valid number and num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #14: Date, Number. Date as serial number, ROUNDDOWNs to nearest integer. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(DATE(2025,1,1), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(DATE(2025,1,1), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date, Number. Date as serial number, ROUNDDOWNs to nearest integer. 2 of 2 arguments used.');
		// Case #15: Time, Number. Time as decimal (0.5), ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(TIME(12,0,0), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(TIME(12,0,0), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Time, Number. Time as decimal (0.5), ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #16: Formula, Number. ROUNDDOWN as parent formula with SUM. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(SUM(1.234, 1.333), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(SUM(1.234, 1.333), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.56, 'Test: Positive case: Formula, Number. ROUNDDOWN as parent formula with SUM. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #17: Number, String. Number and string num_digits convertible to zero. ROUNDDOWNs to nearest integer. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, "0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, "0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, String. Number and string num_digits convertible to zero. ROUNDDOWNs to nearest integer. 2 of 2 arguments used.');
		// Case #18: Number, Formula. Number with nested IF for num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, IF(TRUE, 2, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, IF(TRUE, 2, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.56, 'Test: Positive case: Number, Formula. Number with nested IF for num_digits. ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #19: String, Number. String convertible to number, ROUNDDOWNs to 3 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN("123.45678", 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN("123.45678", 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.456, 'Test: Positive case: String, Number. String convertible to number, ROUNDDOWNs to 3 decimal places. 2 of 2 arguments used.');
		// Case #20: Number, Number. Number with negative num_digits. ROUNDDOWNs to nearest 100. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(123.45678, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(123.45678, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Number, Number. Number with negative num_digits. ROUNDDOWNs to nearest 100. 2 of 2 arguments used.');
		// Case #21: Number, Number. Negative number, ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(-2.567, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(-2.567, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.56, 'Test: Positive case: Number, Number. Negative number, ROUNDDOWNs to 2 decimal places. 2 of 2 arguments used.');
		// Case #22: Formula, Number. Mathematical formula (PI), ROUNDDOWNs to 4 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(PI(), 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(PI(), 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.1415, 'Test: Positive case: Formula, Number. Mathematical formula (PI), ROUNDDOWNs to 4 decimal places. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number, String. Non-numeric string for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #2: String, Number. Non-numeric string for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN("abc", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN("abc", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #3: Error, Number. Error input propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(NA(), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(NA(), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error input propagates #N/A. 2 of 2 arguments used.');
		// Case #4: Number, Error. Error in num_digits propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error in num_digits propagates #N/A. 2 of 2 arguments used.');
		// Case #5: Area, Number. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(A104:A105, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(A104:A105, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Area, Number. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #6: Number, Area. Multi-cell range for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, A104:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Number, Area. Multi-cell range for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Empty, Number. Empty reference for number returns 0. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(A106, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(A106, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty, Number. Empty reference for number returns 0. 2 of 2 arguments used.');
		// Case #8: Number, Empty. Empty reference for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Number, Empty. Empty reference for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: String, Number. Empty string for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN("", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN("", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Empty string for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #10: Number, String. Empty string for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Empty string for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Boolean, Number. Boolean number (1) ROUNDDOWNs to 2 decimal places, but unexpected input. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(TRUE, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(TRUE, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean, Number. Boolean number (1) ROUNDDOWNs to 2 decimal places, but unexpected input. 2 of 2 arguments used.');
		// Case #12: Number, Boolean. Boolean num_digits (0) ROUNDDOWNs to integer, but unexpected input. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Number, Boolean. Boolean num_digits (0) ROUNDDOWNs to integer, but unexpected input. 2 of 2 arguments used.');
		// Case #13: Ref3D, Number. 3D reference to text cell returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(Sheet2!A5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(Sheet2!A5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D, Number. 3D reference to text cell returns #VALUE!. 2 of 2 arguments used.');
		// Case #14: Number, Ref3D. 3D reference to text cell for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Number, Ref3D. 3D reference to text cell for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #15: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(TestNameArea, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(TestNameArea, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Number, Name. Named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Negative case: Number, Name. Named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Name3D, Number. 3D named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(TestNameArea3D, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(TestNameArea3D, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name3D, Number. 3D named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Number, Name3D. 3D named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, TestNameArea3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Number, Name3D. 3D named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #19: Table, Number. Table column with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(Table1[Column2], 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(Table1[Column2], 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table, Number. Table column with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #20: Number, Table. Table column with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Table. Table column with text for num_digits returns #VALUE!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number(2). Smallest positive Excel number, ROUNDDOWNs to 0. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(1E-307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(1E-307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Smallest positive Excel number, ROUNDDOWNs to 0. 2 of 2 arguments used.');
		// Case #2: Number(2). Largest valid Excel number, ROUNDDOWNs to itself. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(9.99999999999999E+307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(9.99999999999999E+307, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number(2). Largest valid Excel number, ROUNDDOWNs to itself. 2 of 2 arguments used.');
		// Case #3: Number(2). Maximum num_digits (15) for ROUNDDOWNing. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, 15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, 15) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.567, 'Test: Bounded case: Number(2). Maximum num_digits (15) for ROUNDDOWNing. 2 of 2 arguments used.');
		// Case #4: Number(2). Minimum num_digits (-308) for ROUNDDOWNing. ROUNDDOWNs to 0. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDDOWN(2.567, -308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDDOWN(2.567, -308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Minimum num_digits (-308) for ROUNDDOWNing. ROUNDDOWNs to 0. 2 of 2 arguments used.');

		// Need to fix: area handle, diff results in boundary cases
		// Case #13: Table(2). Table structured references with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		// Case #5: Area, Number. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.
		// Case #6: Number, Area. Multi-cell range for num_digits returns #VALUE!. 2 of 2 arguments used.
		// Case #15: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.
		// Case #16: Number, Name. Named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		// Case #17: Name3D, Number. 3D named range with text returns #VALUE!. 2 of 2 arguments used.
		// Case #18: Number, Name3D. 3D named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		// Case #2: Number(2). Largest valid Excel number, ROUNDDOWNs to itself. 2 of 2 arguments used.
		// Case #3: Number(2). Maximum num_digits (15) for ROUNDDOWNing. 2 of 2 arguments used.

	});

	QUnit.test("Test: \"ROUNDUP\"", function (assert) {
		let array;

		oParser = new parserFormula("ROUNDUP(2.1123,4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 2.1123);

		//TODO в хроме при расчёте разница, временно убираю
		oParser = new parserFormula("ROUNDUP(2,4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual( oParser.calculate().getValue(), 2);

		oParser = new parserFormula("ROUNDUP(2,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula("ROUNDUP(2.1123,-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 10);

		oParser = new parserFormula("ROUNDUP(2.1123,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("ROUNDUP(123.431,0.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 124);

		oParser = new parserFormula("ROUNDUP(123.431,0.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 124);

		oParser = new parserFormula("ROUNDUP(123.431,-0.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 124);

		oParser = new parserFormula("ROUNDUP(123.431,-0.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 124);

		oParser = new parserFormula("ROUNDUP(123.431,-2.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 200);

		oParser = new parserFormula('ROUNDUP("test",-2.1)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('ROUNDUP(123.431,"test")', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('ROUNDUP(123.431,#NUM!)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula('ROUNDUP(#NUM!,123.431)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula('ROUNDUP(123.431,-1.9)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 130);

		oParser = new parserFormula("ROUNDUP(-50.55,0.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -51);

		oParser = new parserFormula("ROUNDUP(-50.55,0.1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -51);

		oParser = new parserFormula("ROUNDUP(26.7047619,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 26.8);

		oParser = new parserFormula("ROUNDUP(26.7047619,4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 26.7048);

		oParser = new parserFormula("ROUNDUP(26.7047619,8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 26.7047619);

		oParser = new parserFormula("ROUNDUP(267.047619,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 267.1);

		oParser = new parserFormula("ROUNDUP(267.047619,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 267.05);

		oParser = new parserFormula("ROUNDUP(267.047619,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 267.048);

		oParser = new parserFormula("ROUNDUP(267.047619,4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 267.0477);

		oParser = new parserFormula("ROUNDUP(267.047619,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 267.04762);

		oParser = new parserFormula("ROUNDUP(267.047619,6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 267.047619);

		oParser = new parserFormula("ROUNDUP(267.047619,7)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 267.047619);

		oParser = new parserFormula("ROUNDUP(267.047619,8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 267.047619);

		oParser = new parserFormula("ROUNDUP(0.1+0.2,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 0.4);	// 0.4

		oParser = new parserFormula("ROUNDUP(22.123,99999999999999999)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 22.123);

		oParser = new parserFormula("ROUNDUP(22.123,-99999999999999999)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("ROUNDUP(267.047619,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 300);

		oParser = new parserFormula("ROUNDUP(-267.047619,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, -267.05);

		oParser = new parserFormula("ROUNDUP(-267.047619,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, -300);

		oParser = new parserFormula("ROUNDUP(-267.047619,-3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, -1000);

		oParser = new parserFormula("ROUNDUP(26709,-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 26710);

		oParser = new parserFormula("ROUNDUP(26709,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 26800);

		oParser = new parserFormula("ROUNDUP(26709,-3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 27000);

		oParser = new parserFormula("ROUNDUP(26709,-4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 30000);		// 30000

		// cEmpty
		ws.getRange2("B101").setValue();
		
		oParser = new parserFormula("ROUNDUP(,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 0);

		oParser = new parserFormula("ROUNDUP(B101,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 0);

		oParser = new parserFormula("ROUNDUP(2.2,)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 3);

		oParser = new parserFormula("ROUNDUP(B101,B101)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 0);

		oParser = new parserFormula("ROUNDUP(,)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 0);

		// cError
		ws.getRange2("C101").setValue("#NUM!");
		ws.getRange2("C102").setValue("#N/A");
		ws.getRange2("C103").setValue("#DIV/0!");
		
		oParser = new parserFormula("ROUNDUP(#N/A,#NUM!)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#N/A");

		oParser = new parserFormula("ROUNDUP(C102,C101)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#N/A");

		oParser = new parserFormula("ROUNDUP(25,#NUM!)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("ROUNDUP(25,C101)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("ROUNDUP(#DIV/0!,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		oParser = new parserFormula("ROUNDUP(C103,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		// cString
		oParser = new parserFormula('ROUNDUP("22.2567",3)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 22.257);

		oParser = new parserFormula('ROUNDUP("22.2567s",3)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('ROUNDUP("22.2567","3")', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 22.257);

		oParser = new parserFormula('ROUNDUP("22.2567","3s")', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// cBool
		oParser = new parserFormula('ROUNDUP(22.2567,FALSE)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 23);

		oParser = new parserFormula('ROUNDUP(22.2567,TRUE)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 22.3);

		oParser = new parserFormula('ROUNDUP(FALSE, 2)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 0);

		oParser = new parserFormula('ROUNDUP(TRUE, 2)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 1);

		oParser = new parserFormula('ROUNDUP(FALSE, -2)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 0);

		oParser = new parserFormula('ROUNDUP(TRUE, -2)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 100);

		oParser = new parserFormula('ROUNDUP(TRUE, TRUE)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 1);

		oParser = new parserFormula('ROUNDUP(TRUE, FALSE)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 1);

		oParser = new parserFormula('ROUNDUP(FALSE, FALSE)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue() - 0, 0);

		// cArray
		oParser = new parserFormula("ROUNDUP({22.123,2.2},{1;2;3;0})", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F110").bbox);
		assert.ok(oParser.parse());
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 22.2);
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2.2);
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 22.13);
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 2.21);
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 22.123);
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), 2.2);
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), 23);
		assert.strictEqual(array.getElementRowCol(3, 1).getValue(), 3);

		// cellsRange
		ws.getRange2("E101").setValue("22.123");
		ws.getRange2("F101").setValue("3");
		ws.getRange2("G101").setValue();
		ws.getRange2("E102").setValue("1");
		ws.getRange2("F102").setValue("2");
		ws.getRange2("G102").setValue("3");
		ws.getRange2("E103").setValue("1.23");
		ws.getRange2("F103").setValue("1.32");
		ws.getRange2("G103").setValue("3.33");

		oParser = new parserFormula("ROUNDUP(E101:G103,E102:G102)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F110").bbox);
		assert.ok(oParser.parse());
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 22.2);
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 3);
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 0);
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 1);
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 2);
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 3);
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 1.3);
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), 1.32);
		assert.strictEqual(array.getElementRowCol(2, 2).getValue(), 3.33);

		// for bug 71525
		oParser = new parserFormula('ROUNDUP(8.175,3)', "A1", ws);
		assert.ok(oParser.parse(), "ROUNDUP(8.175,3)");
		assert.strictEqual(oParser.calculate().getValue(), 8.175, "Result of ROUNDUP(8.175,3)");

		oParser = new parserFormula('ROUNDUP(8.17529,5)', "A1", ws);
		assert.ok(oParser.parse(), "ROUNDUP(8.17529,5)");
		assert.strictEqual(oParser.calculate().getValue(), 8.17529, "Result of ROUNDUP(8.17529,5)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("Text"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(2). Basic valid input: number and num_digits as integers. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.57, 'Test: Positive case: Number(2). Basic valid input: number and num_digits as integers. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #2: Number(2). Number with negative num_digits. ROUNDUPs to nearest 10. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(2). Number with negative num_digits. ROUNDUPs to nearest 10. 2 of 2 arguments used.');
		// Case #3: Number(2). Number with zero num_digits. ROUNDUPs to nearest integer. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2). Number with zero num_digits. ROUNDUPs to nearest integer. 2 of 2 arguments used.');
		// Case #4: String(2). String inputs convertible to numbers. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP("2.567", "2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP("2.567", "2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.57, 'Test: Positive case: String(2). String inputs convertible to numbers. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #5: Formula(2). Nested formulas returning valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(SQRT(4), ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(SQRT(4), ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(2). Nested formulas returning valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #6: Reference link(2). References to cells with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link(2). References to cells with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #7: Area(2). Single-cell ranges for number and num_digits. ROUNDUPs to 1 decimal place. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(A102:A102, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(A102:A102, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area(2). Single-cell ranges for number and num_digits. ROUNDUPs to 1 decimal place. 2 of 2 arguments used.');
		// Case #8: Array(2). Arrays with single valid elements. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP({2.567}, {2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP({2.567}, {2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2.57, 'Test: Positive case: Array(2). Arrays with single valid elements. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #9: Name(2). Named ranges with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name(2). Named ranges with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #10: Name3D(2). 3D named ranges with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(TestName3D, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(TestName3D, TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name3D(2). 3D named ranges with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #11: Ref3D(2). 3D references to cells with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D(2). 3D references to cells with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #12: Area3D(2). 3D single-cell ranges for number and num_digits. ROUNDUPs to 1 decimal place. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(Sheet2!A3:A3, Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(Sheet2!A3:A3, Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(2). 3D single-cell ranges for number and num_digits. ROUNDUPs to 1 decimal place. 2 of 2 arguments used.');
		// Case #13: Table(2). Table structured references with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(Table1[Column1], Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(Table1[Column1], Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table(2). Table structured references with valid number and num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #14: Date, Number. Date as serial number, ROUNDUPs to nearest integer. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(DATE(2025,1,1), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(DATE(2025,1,1), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date, Number. Date as serial number, ROUNDUPs to nearest integer. 2 of 2 arguments used.');
		// Case #15: Time, Number. Time as decimal (0.5), ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(TIME(12,0,0), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(TIME(12,0,0), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Time, Number. Time as decimal (0.5), ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #16: Formula, Number. ROUNDUP as parent formula with SUM. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(SUM(1.234, 1.333), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(SUM(1.234, 1.333), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.57, 'Test: Positive case: Formula, Number. ROUNDUP as parent formula with SUM. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #17: Number, String. Number and string num_digits convertible to zero. ROUNDUPs to nearest integer. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, "0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, "0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number, String. Number and string num_digits convertible to zero. ROUNDUPs to nearest integer. 2 of 2 arguments used.');
		// Case #18: Number, Formula. Number with nested IF for num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, IF(TRUE, 2, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, IF(TRUE, 2, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.57, 'Test: Positive case: Number, Formula. Number with nested IF for num_digits. ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #19: String, Number. String convertible to number, ROUNDUPs to 3 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP("123.45678", 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP("123.45678", 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123.457, 'Test: Positive case: String, Number. String convertible to number, ROUNDUPs to 3 decimal places. 2 of 2 arguments used.');
		// Case #20: Number, Number. Number with negative num_digits. ROUNDUPs to nearest 100. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(123.45678, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(123.45678, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 200, 'Test: Positive case: Number, Number. Number with negative num_digits. ROUNDUPs to nearest 100. 2 of 2 arguments used.');
		// Case #21: Number, Number. Negative number, ROUNDUPs to 2 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(-2.567, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(-2.567, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.57, 'Test: Positive case: Number, Number. Negative number, ROUNDUPs to 2 decimal places. 2 of 2 arguments used.');
		// Case #22: Formula, Number. Mathematical formula (PI), ROUNDUPs to 4 decimal places. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(PI(), 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(PI(), 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.1416, 'Test: Positive case: Formula, Number. Mathematical formula (PI), ROUNDUPs to 4 decimal places. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number, String. Non-numeric string for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #2: String, Number. Non-numeric string for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP("abc", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP("abc", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #3: Error, Number. Error input propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(NA(), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(NA(), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error input propagates #N/A. 2 of 2 arguments used.');
		// Case #4: Number, Error. Error in num_digits propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error in num_digits propagates #N/A. 2 of 2 arguments used.');
		// Case #5: Area, Number. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(A104:A105, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(A104:A105, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Area, Number. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #6: Number, Area. Multi-cell range for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, A104:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Number, Area. Multi-cell range for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Empty, Number. Empty reference for number returns 0. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(A106, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(A106, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty, Number. Empty reference for number returns 0. 2 of 2 arguments used.');
		// Case #8: Number, Empty. Empty reference for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Number, Empty. Empty reference for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: String, Number. Empty string for number returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP("", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP("", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Empty string for number returns #VALUE!. 2 of 2 arguments used.');
		// Case #10: Number, String. Empty string for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Empty string for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Boolean, Number. Boolean number (1) ROUNDUPs to 2 decimal places, but unexpected input. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(TRUE, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(TRUE, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean, Number. Boolean number (1) ROUNDUPs to 2 decimal places, but unexpected input. 2 of 2 arguments used.');
		// Case #12: Number, Boolean. Boolean num_digits (0) ROUNDUPs to integer, but unexpected input. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Number, Boolean. Boolean num_digits (0) ROUNDUPs to integer, but unexpected input. 2 of 2 arguments used.');
		// Case #13: Ref3D, Number. 3D reference to text cell returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(Sheet2!A5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(Sheet2!A5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D, Number. 3D reference to text cell returns #VALUE!. 2 of 2 arguments used.');
		// Case #14: Number, Ref3D. 3D reference to text cell for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Number, Ref3D. 3D reference to text cell for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #15: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(TestNameArea, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(TestNameArea, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Number, Name. Named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.6, 'Test: Negative case: Number, Name. Named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Name3D, Number. 3D named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(TestNameArea3D, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(TestNameArea3D, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name3D, Number. 3D named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Number, Name3D. 3D named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, TestNameArea3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Number, Name3D. 3D named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.');
		// Case #19: Table, Number. Table column with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(Table1[Column2], 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(Table1[Column2], 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table, Number. Table column with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #20: Number, Table. Table column with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Table. Table column with text for num_digits returns #VALUE!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number(2). Smallest positive Excel number, ROUNDUPs to 0. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(1E-307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(1E-307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Smallest positive Excel number, ROUNDUPs to 0. 2 of 2 arguments used.');
		// Case #2: Number(2). Largest valid Excel number, ROUNDUPs to itself. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(9.99999999999999E+307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(9.99999999999999E+307, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number(2). Largest valid Excel number, ROUNDUPs to itself. 2 of 2 arguments used.');
		// Case #3: Number(2). Maximum num_digits (15) for ROUNDUPing. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, 15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, 15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.567, 'Test: Bounded case: Number(2). Maximum num_digits (15) for ROUNDUPing. 2 of 2 arguments used.');
		// Case #4: Number(2). Minimum num_digits (-308) for ROUNDUPing. ROUNDUPs to 0. 2 of 2 arguments used.
		oParser = new parserFormula('ROUNDUP(2.567, -308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ROUNDUP(2.567, -308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number(2). Minimum num_digits (-308) for ROUNDUPing. ROUNDUPs to 0. 2 of 2 arguments used.');

		// Need to fix: area handle
		// Case #13: Table(2). Table structured references with valid number and num_digits. Rounds to 2 decimal places. 2 of 2 arguments used.
		// Case #5: Area, Number. Multi-cell range for number returns #VALUE!. 2 of 2 arguments used.
		// Case #6: Number, Area. Multi-cell range for num_digits returns #VALUE!. 2 of 2 arguments used.
		// Case #15: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.
		// Case #16: Number, Name. Named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		// Case #17: Name3D, Number. 3D named range with text returns #VALUE!. 2 of 2 arguments used.
		// Case #18: Number, Name3D. 3D named range with text for num_digits returns #VALUE!. 2 of 2 arguments used.
		// Case #2: Number(2). Largest valid Excel number, ROUNDUPs to itself. 2 of 2 arguments used.


	});

	QUnit.test("Test: \"ROUNDUP(31415.92654,-2)\"", function (assert) {
		oParser = new parserFormula("ROUNDUP(31415.92654,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 31500);
	});

	QUnit.test("Test: \"ROUNDUP(3.2,0)\"", function (assert) {
		oParser = new parserFormula("ROUNDUP(3.2,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);
	});

	QUnit.test("Test: \"ROUNDUP(-3.14159,1)\"", function (assert) {
		oParser = new parserFormula("ROUNDUP(-3.14159,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -3.2);
	});

	QUnit.test("Test: \"ROUNDUP(3.14159,3)\"", function (assert) {
		oParser = new parserFormula("ROUNDUP(3.14159,3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.142);

		testArrayFormula2(assert, "ROUNDUP", 2, 2);
	});

	QUnit.test("Test: \"SEC\"", function (assert) {
		oParser = new parserFormula('SEC(45)', "A1", ws);
		assert.ok(oParser.parse(), 'SEC(45)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 1.90359, 'SEC(45)');

		oParser = new parserFormula('SEC(30)', "A1", ws);
		assert.ok(oParser.parse(), 'SEC(30)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 6.48292, 'SEC(30)');

		oParser = new parserFormula('SEC(0)', "A1", ws);
		assert.ok(oParser.parse(), 'SEC(0)');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'SEC(0)');

		oParser = new parserFormula('SEC(1000000000)', "A1", ws);
		assert.ok(oParser.parse(), 'SEC(1000000000)');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'SEC(1000000000)');

		oParser = new parserFormula('SEC(test)', "A1", ws);
		assert.ok(oParser.parse(), 'SEC(test)');
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", 'SEC(test)');

		oParser = new parserFormula('SEC("test")', "A1", ws);
		assert.ok(oParser.parse(), 'SEC("test")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'SEC("test")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("Text"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: zero angle. 1 argument used.
		oParser = new parserFormula('SEC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Basic valid input: zero angle. 1 argument used.');
		// Case #2: Number. Valid input: ?/2 minus small value. 1 argument used.
		oParser = new parserFormula('SEC(1.570796326794896)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(1.570796326794896) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 148752000000000, 'Test: Positive case: Number. Valid input: ?/2 minus small value. 1 argument used.');
		// Case #3: Number. Float input. 1 argument used.
		oParser = new parserFormula('SEC(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.136832902969903, 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #4: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('SEC("1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC("1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.136832902969903, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #5: Formula. Nested formula (PI/4). 1 argument used.
		oParser = new parserFormula('SEC(PI()/4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(PI()/4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.414213562373095, 'Test: Positive case: Formula. Nested formula (PI/4). 1 argument used.');
		// Case #6: Reference link. Ref to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SEC(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.139493927324549, 'Test: Positive case: Reference link. Ref to cell with valid number (0). 1 argument used.');
		// Case #7: Area. Single-cell range with valid number (?/2 minus small value). 1 argument used.
		oParser = new parserFormula('SEC(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.136832902969903, 'Test: Positive case: Area. Single-cell range with valid number (?/2 minus small value). 1 argument used.');
		// Case #8: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('SEC({1.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC({1.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 14.136832902969903, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #9: Name. Named range with valid number (0). 1 argument used.
		oParser = new parserFormula('SEC(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.139493927324549, 'Test: Positive case: Name. Named range with valid number (0). 1 argument used.');
		// Case #10: Name3D. 3D named range with valid number (0). 1 argument used.
		oParser = new parserFormula('SEC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.139493927324549, 'Test: Positive case: Name3D. 3D named range with valid number (0). 1 argument used.');
		// Case #11: Ref3D. 3D reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SEC(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8508157176809255, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (0). 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with valid number (?/2 minus small value). 1 argument used.
		oParser = new parserFormula('SEC(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.402997961722381, 'Test: Positive case: Area3D. 3D single-cell range with valid number (?/2 minus small value). 1 argument used.');
		// Case #13: Table. Table structured reference with valid number (0). 1 argument used.
		oParser = new parserFormula('SEC(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.850815718, 'Test: Positive case: Table. Table structured reference with valid number (0). 1 argument used.');
		// Case #14: Date. Date as serial number (large valid input). 1 argument used.
		oParser = new parserFormula('SEC(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.0257389021427423, 'Test: Positive case: Date. Date as serial number (large valid input). 1 argument used.');
		// Case #15: Time. Time as fractional number (0.5). 1 argument used.
		oParser = new parserFormula('SEC(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.139493927324549, 'Test: Positive case: Time. Time as fractional number (0.5). 1 argument used.');
		// Case #16: Formula. SEC inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(SEC(1.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SEC(1.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15.136832902969903, 'Test: Positive case: Formula. SEC inside SUM formula. 1 argument used.');
		// Case #17: String. String of zero angle. 1 argument used.
		oParser = new parserFormula('SEC("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String of zero angle. 1 argument used.');
		// Case #18: Array. Multi-element array with valid numbers. 1 argument used.
		oParser = new parserFormula('SEC({0,1.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC({0,1.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Multi-element array with valid numbers. 1 argument used.');
		// Case #19: Formula. Nested IF returning valid value. 1 argument used.
		oParser = new parserFormula('SEC(IF(TRUE,1.5,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(IF(TRUE,1.5,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.136832902969903, 'Test: Positive case: Formula. Nested IF returning valid value. 1 argument used.');
		// Case #20: Number. Negative valid input. 1 argument used.
		oParser = new parserFormula('SEC(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.136832902969903, 'Test: Positive case: Number. Negative valid input. 1 argument used.');
		// Case #21: Area3D. 3D multi-cell range with valid numbers. 1 argument used.
		oParser = new parserFormula('SEC(Sheet2!A3:B3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(Sheet2!A3:B3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D multi-cell range with valid numbers. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Input at ?/2 (COS=0) returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SEC(1.5707963267948966)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(1.5707963267948966) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 148752000000000, 'Test: Negative case: Number. Input at ?/2 (COS=0) returns #DIV/0!. 1 argument used.');
		// Case #2: Number. Negative input at -?/2 (COS=0) returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SEC(-1.5707963267948966)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(-1.5707963267948966) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 148752000000000, 'Test: Negative case: Number. Negative input at -?/2 (COS=0) returns #DIV/0!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SEC("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('SEC(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SEC(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.139493927, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #6: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SEC(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8508157176809255, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SEC("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Boolean. Boolean TRUE (1) returns valid result but not meaningful. 1 argument used.
		oParser = new parserFormula('SEC(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8508157176809255, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result but not meaningful. 1 argument used.');
		// Case #9: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SEC(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SEC(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.43532419967224, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SEC(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.43532419967224, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SEC(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('SEC(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #14: Number. Input at ? (COS=0) returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SEC(3.141592653589793)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(3.141592653589793) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Number. Input at ? (COS=0) returns #DIV/0!. 1 argument used.');
		// Case #15: Array. Array with value at ?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SEC({1.5707963267948966})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC({1.5707963267948966}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 148752000000000, 'Test: Negative case: Array. Array with value at ?/2 returns #DIV/0!. 1 argument used.');
		// Case #16: String. String convertible to -?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SEC("-1.5707963267948966")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC("-1.5707963267948966") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 148752000000000, 'Test: Negative case: String. String convertible to -?/2 returns #DIV/0!. 1 argument used.');
		// Case #17: Reference link. Reference to cell with ?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SEC(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8508157176809255, 'Test: Negative case: Reference link. Reference to cell with ?/2 returns #DIV/0!. 1 argument used.');
		// Case #18: Area3D. 3D multi-cell range with ?/2 returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SEC(Sheet2!A5:B5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(Sheet2!A5:B5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area3D. 3D multi-cell range with ?/2 returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #DIV/0! error. 1 argument used.
		oParser = new parserFormula('SEC(MMULT(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(MMULT(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Formula. Formula resulting in #DIV/0! error. 1 argument used.');
		// Case #20: Name. Named range with ?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SEC(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.139493927324549, 'Test: Negative case: Name. Named range with ?/2 returns #DIV/0!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Smallest positive valid number in Excel. 1 argument used.
		oParser = new parserFormula('SEC(2.2250738585072014E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(2.2250738585072014E-308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Smallest positive valid number in Excel. 1 argument used.');
		// Case #2: Number. Largest valid number in Excel. 1 argument used.
		oParser = new parserFormula('SEC(1.7976931348623157E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(1.7976931348623157E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Largest valid number in Excel. 1 argument used.');
		// Case #3: Number. Value slightly above ?/2 (valid). 1 argument used.
		oParser = new parserFormula('SEC(1.570796326794896+1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(1.570796326794896+1E-15) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 178178000000000, 'Test: Bounded case: Number. Value slightly above ?/2 (valid). 1 argument used.');
		// Case #4: Number. Value slightly below -?/2 (valid). 1 argument used.
		oParser = new parserFormula('SEC(-1.570796326794896-1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEC(-1.570796326794896-1E-15) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 178178000000000, 'Test: Bounded case: Number. Value slightly below -?/2 (valid). 1 argument used.');

		// Need to fix: diff results from ms, area handle
		// Case #2: Number. Valid input: ?/2 minus small value. 1 argument used.
		// Case #13: Table. Table structured reference with valid number (0). 1 argument used.
		// Case #1: Number. Input at ?/2 (COS=0) returns #DIV/0!. 1 argument used.
		// Case #2: Number. Negative input at -?/2 (COS=0) returns #DIV/0!. 1 argument used.
		// Case #5: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #15: Array. Array with value at ?/2 returns #DIV/0!. 1 argument used.
		// Case #16: String. String convertible to -?/2 returns #DIV/0!. 1 argument used.
		// Case #3: Number. Value slightly above ?/2 (valid). 1 argument used.
		// Case #4: Number. Value slightly below -?/2 (valid). 1 argument used.


		testArrayFormula(assert, "SEC");
	});

	QUnit.test("Test: \"SECH\"", function (assert) {
		oParser = new parserFormula('SECH(5)', "A1", ws);
		assert.ok(oParser.parse(), 'SECH(5)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.013, 'SECH(5)');

		oParser = new parserFormula('SECH(0)', "A1", ws);
		assert.ok(oParser.parse(), 'SECH(0)');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'SECH(0)');

		oParser = new parserFormula('SECH(1000000000)', "A1", ws);
		assert.ok(oParser.parse(), 'SECH(1000000000)');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'SECH(1000000000)');

		oParser = new parserFormula('SECH(test)', "A1", ws);
		assert.ok(oParser.parse(), 'SECH(test)');
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", 'SECH(test)');

		oParser = new parserFormula('SECH("test")', "A1", ws);
		assert.ok(oParser.parse(), 'SECH("test")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'SECH("test")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("Text"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: zero angle. 1 argument used.
		oParser = new parserFormula('SECH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Basic valid input: zero angle. 1 argument used.');
		// Case #2: Number. Valid input: ?/2 minus small value. 1 argument used.
		oParser = new parserFormula('SECH(1.570796326794896)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(1.570796326794896) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.398536815338387, 'Test: Positive case: Number. Valid input: ?/2 minus small value. 1 argument used.');
		// Case #3: Number. Float input. 1 argument used.
		oParser = new parserFormula('SECH(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4250960349422805, 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #4: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('SECH("1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH("1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4250960349422805, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #5: Formula. Nested formula (PI/4). 1 argument used.
		oParser = new parserFormula('SECH(PI()/4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(PI()/4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7549397087141313, 'Test: Positive case: Formula. Nested formula (PI/4). 1 argument used.');
		// Case #6: Reference link. Ref to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SECH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.886818883970074, 'Test: Positive case: Reference link. Ref to cell with valid number (0). 1 argument used.');
		// Case #7: Area. Single-cell range with valid number (?/2 minus small value). 1 argument used.
		oParser = new parserFormula('SECH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4250960349422805, 'Test: Positive case: Area. Single-cell range with valid number (?/2 minus small value). 1 argument used.');
		// Case #8: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('SECH({1.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH({1.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.4250960349422805, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #9: Name. Named range with valid number (0). 1 argument used.
		oParser = new parserFormula('SECH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.886818883970074, 'Test: Positive case: Name. Named range with valid number (0). 1 argument used.');
		// Case #10: Name3D. 3D named range with valid number (0). 1 argument used.
		oParser = new parserFormula('SECH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.886818883970074, 'Test: Positive case: Name3D. 3D named range with valid number (0). 1 argument used.');
		// Case #11: Ref3D. 3D reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SECH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6480542736638855, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (0). 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with valid number (?/2 minus small value). 1 argument used.
		oParser = new parserFormula('SECH(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2658022288340797, 'Test: Positive case: Area3D. 3D single-cell range with valid number (?/2 minus small value). 1 argument used.');
		// Case #13: Table. Table structured reference with valid number (0). 1 argument used.
		oParser = new parserFormula('SECH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.648054274, 'Test: Positive case: Table. Table structured reference with valid number (0). 1 argument used.');
		// Case #14: Date. Date as serial number (large valid input). 1 argument used.
		oParser = new parserFormula('SECH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date. Date as serial number (large valid input). 1 argument used.');
		// Case #15: Time. Time as fractional number (0.5). 1 argument used.
		oParser = new parserFormula('SECH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.886818883970074, 'Test: Positive case: Time. Time as fractional number (0.5). 1 argument used.');
		// Case #16: Formula. SEC inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(SECH(1.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SECH(1.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4250960349422805, 'Test: Positive case: Formula. SEC inside SUM formula. 1 argument used.');
		// Case #17: String. String of zero angle. 1 argument used.
		oParser = new parserFormula('SECH("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String of zero angle. 1 argument used.');
		// Case #18: Array. Multi-element array with valid numbers. 1 argument used.
		oParser = new parserFormula('SECH({0,1.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH({0,1.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Multi-element array with valid numbers. 1 argument used.');
		// Case #19: Formula. Nested IF returning valid value. 1 argument used.
		oParser = new parserFormula('SECH(IF(TRUE,1.5,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(IF(TRUE,1.5,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4250960349422805, 'Test: Positive case: Formula. Nested IF returning valid value. 1 argument used.');
		// Case #20: Number. Negative valid input. 1 argument used.
		oParser = new parserFormula('SECH(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4250960349422805, 'Test: Positive case: Number. Negative valid input. 1 argument used.');
		// Case #21: Area3D. 3D multi-cell range with valid numbers. 1 argument used.
		oParser = new parserFormula('SECH(Sheet2!A3:B3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(Sheet2!A3:B3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D multi-cell range with valid numbers. 1 argument used.');

		// Negative cases:

		// Case #1: Number. Input at ?/2 (COS=0) returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SECH(1.5707963267948966)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(1.5707963267948966) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3985368153383867, 'Test: Negative case: Number. Input at ?/2 (COS=0) returns #DIV/0!. 1 argument used.');
		// Case #2: Number. Negative input at -?/2 (COS=0) returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SECH(-1.5707963267948966)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(-1.5707963267948966) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3985368153383867, 'Test: Negative case: Number. Negative input at -?/2 (COS=0) returns #DIV/0!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SECH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('SECH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SECH(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.886818884, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #6: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SECH(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6480542736638855, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SECH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Boolean. Boolean TRUE (1) returns valid result but not meaningful. 1 argument used.
		oParser = new parserFormula('SECH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6480542736638855, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result but not meaningful. 1 argument used.');
		// Case #9: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SECH(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SECH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7476999182374197, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SECH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7476999182374197, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SECH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('SECH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #14: Number. Input at ? (COS=0) returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SECH(3.141592653589793)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(3.141592653589793) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08626673833405445, 'Test: Negative case: Number. Input at ? (COS=0) returns #DIV/0!. 1 argument used.');
		// Case #15: Array. Array with value at ?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SECH({1.5707963267948966})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH({1.5707963267948966}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.3985368153383867, 'Test: Negative case: Array. Array with value at ?/2 returns #DIV/0!. 1 argument used.');
		// Case #16: String. String convertible to -?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SECH("-1.5707963267948966")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH("-1.5707963267948966") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3985368153383867, 'Test: Negative case: String. String convertible to -?/2 returns #DIV/0!. 1 argument used.');
		// Case #17: Reference link. Reference to cell with ?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SECH(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6480542736638855, 'Test: Negative case: Reference link. Reference to cell with ?/2 returns #DIV/0!. 1 argument used.');
		// Case #18: Area3D. 3D multi-cell range with ?/2 returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SECH(Sheet2!A5:B5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(Sheet2!A5:B5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area3D. 3D multi-cell range with ?/2 returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #DIV/0! error. 1 argument used.
		oParser = new parserFormula('SECH(MMULT(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(MMULT(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Formula. Formula resulting in #DIV/0! error. 1 argument used.');
		// Case #20: Name. Named range with ?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SECH(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.886818883970074, 'Test: Negative case: Name. Named range with ?/2 returns #DIV/0!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Smallest positive valid number in Excel. 1 argument used.
		oParser = new parserFormula('SECH(2.2250738585072014E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(2.2250738585072014E-308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Smallest positive valid number in Excel. 1 argument used.');
		// Case #2: Number. Largest valid number in Excel. 1 argument used.
		oParser = new parserFormula('SECH(1.7976931348623157E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(1.7976931348623157E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Largest valid number in Excel. 1 argument used.');
		// Case #3: Number. Value slightly above ?/2 (valid). 1 argument used.
		oParser = new parserFormula('SECH(1.570796326794896+1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(1.570796326794896+1E-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3985368153383866, 'Test: Bounded case: Number. Value slightly above ?/2 (valid). 1 argument used.');
		// Case #4: Number. Value slightly below -?/2 (valid). 1 argument used.
		oParser = new parserFormula('SECH(-1.570796326794896-1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SECH(-1.570796326794896-1E-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3985368153383866, 'Test: Bounded case: Number. Value slightly below -?/2 (valid). 1 argument used.');

		// Need to fix: diff results from ms
		// Case #13: Table. Table structured reference with valid number (0). 1 argument used.
		// Case #5: Area. Multi-cell range returns #VALUE!. 1 argument used.


		testArrayFormula(assert, "SECH");
	});

	QUnit.test("Test: \"SERIESSUM\"", function (assert) {


		ws.getRange2("A2").setValue("1");
		ws.getRange2("A3").setValue(numDivFact(-1, 2));
		ws.getRange2("A4").setValue(numDivFact(1, 4));
		ws.getRange2("A5").setValue(numDivFact(-1, 6));

		oParser = new parserFormula("SERIESSUM(PI()/4,0,2,A2:A5)", "A7", ws);
		assert.ok(oParser.parse());
		assert.ok(Math.abs(
				oParser.calculate().getValue() - (1 - 1 / 2 * Math.pow(Math.PI / 4, 2) + 1 / Math.fact(4) * Math.pow(Math.PI / 4, 4) - 1 / Math.fact(6) * Math.pow(Math.PI / 4, 6))) <
			dif);

		ws.getRange2("B2").setValue("1");
		ws.getRange2("B3").setValue(numDivFact(-1, 3));
		ws.getRange2("B4").setValue(numDivFact(1, 5));
		ws.getRange2("B5").setValue(numDivFact(-1, 7));

		oParser = new parserFormula("SERIESSUM(PI()/4,1,2,B2:B5)", "B7", ws);
		assert.ok(oParser.parse());
		assert.ok(Math.abs(oParser.calculate().getValue() -
			(Math.PI / 4 - 1 / Math.fact(3) * Math.pow(Math.PI / 4, 3) + 1 / Math.fact(5) * Math.pow(Math.PI / 4, 5) - 1 / Math.fact(7) * Math.pow(Math.PI / 4, 7))) < dif);


		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A104").setValue("5");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A105").setValue("6");
		ws.getRange2("A106").setValue("7");
		ws.getRange2("A107").setValue("8");
		ws.getRange2("A108").setValue("9");
		ws.getRange2("A109").setValue("10");
		ws.getRange2("A110").setValue("11");
		ws.getRange2("A111").setValue("11");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("A4").setValue("TRUE");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number(3), Array. Basic valid input: numbers for x, n, m, and array for coefficients. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 34, 'Test: Positive case: Number(3), Array. Basic valid input: numbers for x, n, m, and array for coefficients. 4 of 4 arguments used.');
		// Case #1: Formula(3), Array. x as formula returning number. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(SQRT(4),1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(SQRT(4),1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 34, 'Test: Positive case: Formula(3), Array. x as formula returning number. 4 of 4 arguments used.');
		// Case #2: Number, Formula, Number, Array. n as formula returning number. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,SQRT(1),1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,SQRT(1),1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 34, 'Test: Positive case: Number, Formula, Number, Array. n as formula returning number. 4 of 4 arguments used.');
		// Case #3: Number(2), Formula, Array. m as formula returning number. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,SQRT(1),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,SQRT(1),{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 34, 'Test: Positive case: Number(2), Formula, Array. m as formula returning number. 4 of 4 arguments used.');
		// Case #4: String(3), Array. String arguments convertible to numbers. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM("2","1","1",{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM("2","1","1",{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 34, 'Test: Positive case: String(3), Array. String arguments convertible to numbers. 4 of 4 arguments used.');
		// Case #5: Reference link(3), Array. Reference links to valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(A100,A101,A102,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(A100,A101,A102,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Reference link(3), Array. Reference links to valid numbers. 4 of 4 arguments used.');
		// Case #6: Area(3), Array. Single-cell ranges for x, n, m. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(A100:A100,A101:A101,A102:A102,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(A100:A100,A101:A101,A102:A102,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Area(3), Array. Single-cell ranges for x, n, m. 4 of 4 arguments used.');
		// Case #7: Number(3), Area. Coefficients as multi-cell range. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,1,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,1,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 76, 'Test: Positive case: Number(3), Area. Coefficients as multi-cell range. 4 of 4 arguments used.');
		// Case #8: Name(3), Array. Named ranges for x, n, m. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(TestName,TestName1,TestName2,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(TestName,TestName1,TestName2,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.0009765625, 'Test: Positive case: Name(3), Array. Named ranges for x, n, m. 4 of 4 arguments used.');
		// Case #9: Name3D(3), Array. 3D named ranges for x, n, m. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(TestName3D,TestName3D,TestName3D,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(TestName3D,TestName3D,TestName3D,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Name3D(3), Array. 3D named ranges for x, n, m. 4 of 4 arguments used.');
		// Case #10: Ref3D(3), Array. 3D references for x, n, m. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(Sheet2!A1,Sheet2!A2,Sheet2!A3,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(Sheet2!A1,Sheet2!A2,Sheet2!A3,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(3), Array. 3D references for x, n, m. 4 of 4 arguments used.');
		// Case #11: Area3D(3), Array. 3D single-cell ranges for x, n, m. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(3), Array. 3D single-cell ranges for x, n, m. 4 of 4 arguments used.');
		// Case #12: Table. Table structured references. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured references. 4 of 4 arguments used.');
		// Case #13: Date(3), Array. x as date serial number. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(DATE(2025,1,1),1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(DATE(2025,1,1),1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 285547424442522, 'Test: Positive case: Date(3), Array. x as date serial number. 4 of 4 arguments used.');
		// Case #14: Time(3), Array. x as time adjusted to valid number. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(TIME(12,0,0)+1,1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(TIME(12,0,0)+1,1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16.125, 'Test: Positive case: Time(3), Array. x as time adjusted to valid number. 4 of 4 arguments used.');
		// Case #15: Number(3), Array. n as zero (valid). 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,0,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,0,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 17, 'Test: Positive case: Number(3), Array. n as zero (valid). 4 of 4 arguments used.');
		// Case #16: Number(3), Array. m as zero (valid). 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,0,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,0,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Number(3), Array. m as zero (valid). 4 of 4 arguments used.');
		// Case #17: String(3), Array. Numeric strings converted to numbers. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM("1.5","1","1",{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM("1.5","1","1",{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16.125, 'Test: Positive case: String(3), Array. Numeric strings converted to numbers. 4 of 4 arguments used.');
		// Case #18: Number(3), Array. Float numbers for x, n, m. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(1.5,1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(1.5,1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16.125, 'Test: Positive case: Number(3), Array. Float numbers for x, n, m. 4 of 4 arguments used.');
		// Case #19: Formula(3), Array. Nested IF formula for x. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(IF(TRUE,2,1),1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(IF(TRUE,2,1),1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 34, 'Test: Positive case: Formula(3), Array. Nested IF formula for x. 4 of 4 arguments used.');
		// Case #20: Number(3), Array. Float coefficients in array. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,1,{1.5,2.5,3.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,1,{1.5,2.5,3.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 41, 'Test: Positive case: Number(3), Array. Float coefficients in array. 4 of 4 arguments used.');
		// Case #21: Array, Number(2), Array. Float coefficients in array. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM({1,2,3},1,1,{1.5,2.5,3.5})', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A1:C2").bbox);
		assert.ok(oParser.parse(), 'Test: SERIESSUM({1,2,3},1,1,{1.5,2.5,3.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 7.5, 'Test: Positive case: Number(3), Array. Float coefficients in array. 4 of 4 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 41, 'Test: Positive case: Number(3), Array. Float coefficients in array. 4 of 4 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,2).getValue(), 121.5, 'Test: Positive case: Number(3), Array. Float coefficients in array. 4 of 4 arguments used.');
		// Case #22: Cell3D, Number(2), Array . Float coefficients in array. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(Sheet2!A2,1,1,{1.5,2.5,3.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(Sheet2!A2,1,1,{1.5,2.5,3.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 19.6875, 'Test: Positive case: Number(3), Array. Float coefficients in array. 4 of 4 arguments used.');
		// Case #23: Cell3D(Text), Number(2), . Float coefficients in array. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(Sheet2!A3,1,1,{1.5,2.5,3.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(Sheet2!A3,1,1,{1.5,2.5,3.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Positive case: Number(3), Array. Float coefficients in array. 4 of 4 arguments used.');
		// Case #24: Cell3D(Boolean), Number(2), . Float coefficients in array. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(Sheet2!A4,1,1,{1.5,2.5,3.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(Sheet2!A4,1,1,{1.5,2.5,3.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Positive case: Number(3), Array. Float coefficients in array. 4 of 4 arguments used.');


		// Negative cases:
		// Case #1: Number(3), Array. Negative x may cause #NUM! depending on coefficients. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(-1,1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(-1,1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Negative case: Number(3), Array. Negative x may cause #NUM! depending on coefficients. 4 of 4 arguments used.');
		// Case #2: Number(2), String, Array. Non-numeric string for m returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,"abc",{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,"abc",{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Array. Non-numeric string for m returns #VALUE!. 4 of 4 arguments used.');
		// Case #3: Number(2), Error, Array. Error value for m propagates #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,NA(),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,NA(),{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Array. Error value for m propagates #N/A. 4 of 4 arguments used.');
		// Case #4: Number(2), Boolean, Array. Boolean for m returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,FALSE,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,FALSE,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Array. Boolean for m returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: Number(3), String. Non-numeric string for coefficients returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,1,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String. Non-numeric string for coefficients returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: Number(3), Empty. Empty coefficients returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Empty. Empty coefficients returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: Empty, Number(2), Array. Empty x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(,1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(,1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(2), Array. Empty x returns #VALUE!. 4 of 4 arguments used.');
		// Case #8: Number, Empty, Number, Array. Empty n returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number, Array. Empty n returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Number(2), Empty, Array. Empty m returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty, Array. Empty m returns #VALUE!. 4 of 4 arguments used.');
		// Case #10: Area(3), Array. Multi-cell range for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(A100:A101,A102:A102,A103:A103,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(A100:A101,A102:A102,A103:A103,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(3), Array. Multi-cell range for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Number(3), Area. Multi-cell range for coefficients with text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,1,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,1,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Number(3), Area. Multi-cell range for coefficients with text returns #VALUE!. 4 of 4 arguments used.');
		// Case #12: Ref3D(3), Array. 3D ref to text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(Sheet2!A4,Sheet2!A5,Sheet2!A6,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(Sheet2!A4,Sheet2!A5,Sheet2!A6,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(3), Array. 3D ref to text returns #VALUE!. 4 of 4 arguments used.');
		// Case #13: Name(3), Array. Named range with text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(TestNameArea2,TestName1,TestName2,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(TestNameArea2,TestName1,TestName2,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name(3), Array. Named range with text returns #VALUE!. 4 of 4 arguments used.');
		// Case #14: Name3D(3), Array. 3D named range with text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(TestNameArea3D2,TestName3D,TestName3D,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(TestNameArea3D2,TestName3D,TestName3D,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Name3D(3), Array. 3D named range with text returns #VALUE!. 4 of 4 arguments used.');
		// Case #15: Table. Table column with text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Table. Table column with text returns #VALUE!. 4 of 4 arguments used.');
		// Case #16: Number(3), Array. x as zero may cause #NUM! with certain n values. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(0,1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(0,1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(3), Array. x as zero may cause #NUM! with certain n values. 4 of 4 arguments used.');
		// Case #17: Number(3), Array. Negative n returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,-1,1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,-1,1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.5, 'Test: Negative case: Number(3), Array. Negative n returns #NUM!. 4 of 4 arguments used.');
		// Case #18: Number(3), Array. Negative m returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,-1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,-1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.5, 'Test: Negative case: Number(3), Array. Negative m returns #NUM!. 4 of 4 arguments used.');
		// Case #19: Area3D(3), Array. 3D multi-cell range for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(Sheet2!A1:A2,Sheet2!A3:A3,Sheet2!A4:A4,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(Sheet2!A1:A2,Sheet2!A3:A3,Sheet2!A4:A4,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(3), Array. 3D multi-cell range for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #20: Number(3), Array. Boolean in coefficients array returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(2,1,1,{FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(2,1,1,{FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Array. Boolean in coefficients array returns #VALUE!. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number(3), Array. Minimum valid Excel numbers for x and coefficients. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(1E-307,0,0,{1E-307,1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(1E-307,0,0,{1E-307,1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2e-307, 'Test: Bounded case: Number(3), Array. Minimum valid Excel numbers for x and coefficients. 4 of 4 arguments used.');
		// Case #2: Number(3), Array. Maximum valid Excel numbers for x and coefficients. 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(1E+307,0,0,{1E+307,1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(1E+307,0,0,{1E+307,1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2e+307, 'Test: Bounded case: Number(3), Array. Maximum valid Excel numbers for x and coefficients. 4 of 4 arguments used.');
		// Case #3: Number(3), Array. Maximum integer values for n and m (Excelâ??s 32-bit integer limit). 4 of 4 arguments used.
		oParser = new parserFormula('SERIESSUM(1,2^31-1,2^31-1,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SERIESSUM(1,2^31-1,2^31-1,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Bounded case: Number(3), Array. Maximum integer values for n and m (Excelâ??s 32-bit integer limit). 4 of 4 arguments used.');


		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "SERIESSUM", 4, 4);
	});

	QUnit.test("Test: \"SIGN\"", function (assert) {

		oParser = new parserFormula("SIGN(10)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("SIGN(4-4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("SIGN(-0.00001)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: zero angle. 1 argument used.
		oParser = new parserFormula('SIGN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: zero angle. 1 argument used.');
		// Case #2: Number. Valid input: ?/2 minus small value. 1 argument used.
		oParser = new parserFormula('SIGN(1.570796326794896)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(1.570796326794896) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Valid input: ?/2 minus small value. 1 argument used.');
		// Case #3: Number. Float input. 1 argument used.
		oParser = new parserFormula('SIGN(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #4: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('SIGN("1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN("1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #5: Formula. Nested formula (PI/4). 1 argument used.
		oParser = new parserFormula('SIGN(PI()/4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(PI()/4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested formula (PI/4). 1 argument used.');
		// Case #6: Reference link. Ref to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SIGN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Ref to cell with valid number (0). 1 argument used.');
		// Case #7: Area. Single-cell range with valid number (?/2 minus small value). 1 argument used.
		oParser = new parserFormula('SIGN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Single-cell range with valid number (?/2 minus small value). 1 argument used.');
		// Case #8: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('SIGN({1.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN({1.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #9: Name. Named range with valid number (0). 1 argument used.
		oParser = new parserFormula('SIGN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name. Named range with valid number (0). 1 argument used.');
		// Case #10: Name3D. 3D named range with valid number (0). 1 argument used.
		oParser = new parserFormula('SIGN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name3D. 3D named range with valid number (0). 1 argument used.');
		// Case #11: Ref3D. 3D reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SIGN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (0). 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with valid number (?/2 minus small value). 1 argument used.
		oParser = new parserFormula('SIGN(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell range with valid number (?/2 minus small value). 1 argument used.');
		// Case #13: Table. Table structured reference with valid number (0). 1 argument used.
		oParser = new parserFormula('SIGN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid number (0). 1 argument used.');
		// Case #14: Date. Date as serial number (large valid input). 1 argument used.
		oParser = new parserFormula('SIGN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number (large valid input). 1 argument used.');
		// Case #15: Time. Time as fractional number (0.5). 1 argument used.
		oParser = new parserFormula('SIGN(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time. Time as fractional number (0.5). 1 argument used.');
		// Case #16: Formula. SEC inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(SIGN(1.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SIGN(1.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. SEC inside SUM formula. 1 argument used.');
		// Case #17: String. String of zero angle. 1 argument used.
		oParser = new parserFormula('SIGN("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String of zero angle. 1 argument used.');
		// Case #18: Array. Multi-element array with valid numbers. 1 argument used.
		oParser = new parserFormula('SIGN({0,1.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN({0,1.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array. Multi-element array with valid numbers. 1 argument used.');
		// Case #19: Formula. Nested IF returning valid value. 1 argument used.
		oParser = new parserFormula('SIGN(IF(TRUE,1.5,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(IF(TRUE,1.5,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested IF returning valid value. 1 argument used.');
		// Case #20: Number. Negative valid input. 1 argument used.
		oParser = new parserFormula('SIGN(-1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(-1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Number. Negative valid input. 1 argument used.');
		// Case #21: Area3D. 3D multi-cell range with valid numbers. 1 argument used.
		oParser = new parserFormula('SIGN(Sheet2!A3:B3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(Sheet2!A3:B3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D multi-cell range with valid numbers. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Input at ?/2 (COS=0) returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SIGN(1.5707963267948966)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(1.5707963267948966) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Input at ?/2 (COS=0) returns #DIV/0!. 1 argument used.');
		// Case #2: Number. Negative input at -?/2 (COS=0) returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SIGN(-1.5707963267948966)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(-1.5707963267948966) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Number. Negative input at -?/2 (COS=0) returns #DIV/0!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIGN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('SIGN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIGN(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #6: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIGN(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIGN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Boolean. Boolean TRUE (1) returns valid result but not meaningful. 1 argument used.
		oParser = new parserFormula('SIGN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result but not meaningful. 1 argument used.');
		// Case #9: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIGN(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIGN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIGN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIGN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('SIGN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #14: Number. Input at ? (COS=0) returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SIGN(3.141592653589793)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(3.141592653589793) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Input at ? (COS=0) returns #DIV/0!. 1 argument used.');
		// Case #15: Array. Array with value at ?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SIGN({1.5707963267948966})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN({1.5707963267948966}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Array. Array with value at ?/2 returns #DIV/0!. 1 argument used.');
		// Case #16: String. String convertible to -?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SIGN("-1.5707963267948966")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN("-1.5707963267948966") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: String. String convertible to -?/2 returns #DIV/0!. 1 argument used.');
		// Case #17: Reference link. Reference to cell with ?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SIGN(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Reference link. Reference to cell with ?/2 returns #DIV/0!. 1 argument used.');
		// Case #18: Area3D. 3D multi-cell range with ?/2 returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIGN(Sheet2!A5:B5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(Sheet2!A5:B5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D multi-cell range with ?/2 returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #DIV/0! error. 1 argument used.
		oParser = new parserFormula('SIGN(MMULT(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(MMULT(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Formula. Formula resulting in #DIV/0! error. 1 argument used.');
		// Case #20: Name. Named range with ?/2 returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('SIGN(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with ?/2 returns #DIV/0!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Smallest positive valid number in Excel. 1 argument used.
		oParser = new parserFormula('SIGN(2.2250738585072014E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(2.2250738585072014E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive valid number in Excel. 1 argument used.');
		// Case #2: Number. Largest valid number in Excel. 1 argument used.
		oParser = new parserFormula('SIGN(1.7976931348623157E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(1.7976931348623157E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Largest valid number in Excel. 1 argument used.');
		// Case #3: Number. Value slightly above ?/2 (valid). 1 argument used.
		oParser = new parserFormula('SIGN(1.570796326794896+1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(1.570796326794896+1E-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Value slightly above ?/2 (valid). 1 argument used.');
		// Case #4: Number. Value slightly below -?/2 (valid). 1 argument used.
		oParser = new parserFormula('SIGN(-1.570796326794896-1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIGN(-1.570796326794896-1E-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Number. Value slightly below -?/2 (valid). 1 argument used.');

		// Need to fix: different results from MS
		// Case #1: Number. Smallest positive valid number in Excel. 1 argument used.
		// Case #5: Area. Multi-cell range returns #VALUE!. 1 argument used.

		testArrayFormula(assert, "SIGN");
	});

	QUnit.test("Test: \"SIN\"", function (assert) {

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: zero radians. 1 argument used.
		oParser = new parserFormula('SIN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: zero radians. 1 argument used.');
		// Case #2: Number. Approximation of ?/2 radians, returns ~1. 1 argument used.
		oParser = new parserFormula('SIN(1.5708)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(1.5708) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Number. Approximation of ?/2 radians, returns ~1. 1 argument used.');
		// Case #3: Number. Negative angle, returns ~-1. 1 argument used.
		oParser = new parserFormula('SIN(-1.5708)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(-1.5708) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '-1', 'Test: Positive case: Number. Negative angle, returns ~-1. 1 argument used.');
		// Case #4: Formula. Nested formula converting degrees to radians, returns ~1. 1 argument used.
		oParser = new parserFormula('SIN(RADIANS(90))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(RADIANS(90)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested formula converting degrees to radians, returns ~1. 1 argument used.');
		// Case #5: Formula. Nested formula resulting in valid number (2). 1 argument used.
		oParser = new parserFormula('SIN(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9092974268256817, 'Test: Positive case: Formula. Nested formula resulting in valid number (2). 1 argument used.');
		// Case #6: Reference link. Reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SIN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.479425538604203, 'Test: Positive case: Reference link. Reference to cell with valid number (0). 1 argument used.');
		// Case #7: Area. Single-cell range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SIN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9974949866040544, 'Test: Positive case: Area. Single-cell range with valid number (1.5708). 1 argument used.');
		// Case #8: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('SIN({1.5708})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN({1.5708}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(), '1', 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #9: Name. Named range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SIN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.479425538604203, 'Test: Positive case: Name. Named range with valid number (1.5708). 1 argument used.');
		// Case #10: Name3D. 3D named range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SIN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.479425538604203, 'Test: Positive case: Name3D. 3D named range with valid number (1.5708). 1 argument used.');
		// Case #11: Ref3D. 3D reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SIN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8414709848078965, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (0). 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SIN(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9092974268256817, 'Test: Positive case: Area3D. 3D single-cell range with valid number (1.5708). 1 argument used.');
		// Case #13: Table. Table structured reference with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SIN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8414709848078965, 'Test: Positive case: Table. Table structured reference with valid number (1.5708). 1 argument used.');
		// Case #14: Formula. Nested IF returning valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SIN(IF(TRUE, 1.5708, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(IF(TRUE, 1.5708, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Formula. Nested IF returning valid number (1.5708). 1 argument used.');
		// Case #15: Formula. Date as serial number, valid input. 1 argument used.
		oParser = new parserFormula('SIN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.9438067679532646, 'Test: Positive case: Formula. Date as serial number, valid input. 1 argument used.');
		// Case #16: Formula. Time as fraction of day, valid input. 1 argument used.
		oParser = new parserFormula('SIN(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.479425538604203, 'Test: Positive case: Formula. Time as fraction of day, valid input. 1 argument used.');
		// Case #17: Formula. Nested formula returning positive number. 1 argument used.
		oParser = new parserFormula('SIN(ABS(-1.5708))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(ABS(-1.5708)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Formula. Nested formula returning positive number. 1 argument used.');
		// Case #18: String. String convertible to valid number. 1 argument used.
		oParser = new parserFormula('SIN("1.5708")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN("1.5708") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: String. String convertible to valid number. 1 argument used.');
		// Case #19: Formula. SIN as part of SUM formula, returns ~1. 1 argument used.
		oParser = new parserFormula('SUM(SIN(1.5708), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SIN(1.5708), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Formula. SIN as part of SUM formula, returns ~1. 1 argument used.');
		// Case #20: Number. Approximation of ? radians, returns ~0. 1 argument used.
		oParser = new parserFormula('SIN(3.1416)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(3.1416) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.000007346410206643587, 'Test: Positive case: Number. Approximation of ? radians, returns ~0. 1 argument used.');
		// Case #21: String. String convertible to zero. 1 argument used.
		oParser = new parserFormula('SIN("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String convertible to zero. 1 argument used.');
		// Case #22: Array. Array with multiple valid elements, processes first element (0). 1 argument used.
		oParser = new parserFormula('SIN({0, 1.5708})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN({0, 1.5708}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array. Array with multiple valid elements, processes first element (0). 1 argument used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('SIN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #3: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.479425539, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #4: Empty. Reference to empty cell returns 0 (Excel treats as 0). 1 argument used.
		oParser = new parserFormula('SIN(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.8414709848078965, 'Test: Negative case: Empty. Reference to empty cell returns 0 (Excel treats as 0). 1 argument used.');
		// Case #5: Boolean. Boolean TRUE (1) returns ~0.8415, but testing for type handling. 1 argument used.
		oParser = new parserFormula('SIN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8414709848078965, 'Test: Negative case: Boolean. Boolean TRUE (1) returns ~0.8415, but testing for type handling. 1 argument used.');
		// Case #6: Boolean. Boolean FALSE (0) returns 0, but testing for type handling. 1 argument used.
		oParser = new parserFormula('SIN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean FALSE (0) returns 0, but testing for type handling. 1 argument used.');
		// Case #7: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7173560908995228, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #8: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7173560908995228, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Ref3D. 3D reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #10: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(Sheet2!A4:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #11: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.8414709848078965, 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #12: Formula. Nested formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('SIN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #13: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #14: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('SIN(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.');
		// Case #15: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN({TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.8414709848078965, 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');
		// Case #16: Array. Array with mixed valid and invalid elements, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN({1, "abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN({1, "abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.8414709848078965, 'Test: Negative case: Array. Array with mixed valid and invalid elements, returns #VALUE!. 1 argument used.');
		// Case #17: Formula. Nested formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('SIN(MMULT(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(MMULT(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Formula. Nested formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #18: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8414709848078965, 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #19: Area. Area with text in one cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SIN(A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(A106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Area with text in one cell returns #VALUE!. 1 argument used.');
		// Case #20: Formula. String convertible to number exceeding limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('SIN("1E+309")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN("1E+309") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. String convertible to number exceeding limit returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.
		oParser = new parserFormula('SIN(1E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(1E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.');
		// Case #2: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.
		oParser = new parserFormula('SIN(-1E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(-1E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.');
		// Case #3: Number. Largest number Excel can handle, returns valid sine value. 1 argument used.
		oParser = new parserFormula('SIN(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SIN(1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Largest number Excel can handle, returns valid sine value. 1 argument used.');

		// Need to fix: area handle, different results from ms
		// Case #3: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #14: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.
		// Case #19: Area. Area with text in one cell returns #VALUE!. 1 argument used.
		// Case #1: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.
		// Case #2: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.
		// Case #3: Number. Largest number Excel can handle, returns valid sine value. 1 argument used.


	});

	QUnit.test("Test: \"SIN have wrong arguments count\"", function (assert) {
		oParser = new parserFormula('SIN(3.1415926,3.1415926*2)', "A1", ws);
		assert.ok(!oParser.parse());
	});

    QUnit.test("Test: \"SIN(3.1415926)\"", function (assert) {
		oParser = new parserFormula('SIN(3.1415926)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), Math.sin(3.1415926));

		testArrayFormula(assert, "SIN");
	});

	QUnit.test("Test: \"SINH\"", function (assert) {

		oParser = new parserFormula("SINH(0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("SINH(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), ((Math.E - 1 / Math.E) / 2));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: zero radians. 1 argument used.
		oParser = new parserFormula('SINH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: zero radians. 1 argument used.');
		// Case #2: Number. Approximation of ?/2 radians, returns ~1. 1 argument used.
		oParser = new parserFormula('SINH(1.5708)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(1.5708) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.301308119050013, 'Test: Positive case: Number. Approximation of ?/2 radians, returns ~1. 1 argument used.');
		// Case #3: Number. Negative angle, returns ~-1. 1 argument used.
		oParser = new parserFormula('SINH(-1.5708)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(-1.5708) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.301308119050013, 'Test: Positive case: Number. Negative angle, returns ~-1. 1 argument used.');
		// Case #4: Formula. Nested formula converting degrees to radians, returns ~1. 1 argument used.
		oParser = new parserFormula('SINH(RADIANS(90))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(RADIANS(90)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.3012989023072947, 'Test: Positive case: Formula. Nested formula converting degrees to radians, returns ~1. 1 argument used.');
		// Case #5: Formula. Nested formula resulting in valid number (2). 1 argument used.
		oParser = new parserFormula('SINH(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.6268604078470186, 'Test: Positive case: Formula. Nested formula resulting in valid number (2). 1 argument used.');
		// Case #6: Reference link. Reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SINH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5210953054937474, 'Test: Positive case: Reference link. Reference to cell with valid number (0). 1 argument used.');
		// Case #7: Area. Single-cell range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SINH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.1292794550948173, 'Test: Positive case: Area. Single-cell range with valid number (1.5708). 1 argument used.');
		// Case #8: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('SINH({1.5708})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH({1.5708}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2.301308119050013, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #9: Name. Named range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SINH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5210953054937474, 'Test: Positive case: Name. Named range with valid number (1.5708). 1 argument used.');
		// Case #10: Name3D. 3D named range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SINH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5210953054937474, 'Test: Positive case: Name3D. 3D named range with valid number (1.5708). 1 argument used.');
		// Case #11: Ref3D. 3D reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('SINH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1752011936438014, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (0). 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SINH(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.6268604078470186, 'Test: Positive case: Area3D. 3D single-cell range with valid number (1.5708). 1 argument used.');
		// Case #13: Table. Table structured reference with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('SINH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1752011936438014, 'Test: Positive case: Table. Table structured reference with valid number (1.5708). 1 argument used.');
		// Case #15: Formula. Date as serial number, valid input. 1 argument used.
		oParser = new parserFormula('SINH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Date as serial number, valid input. 1 argument used.');
		// Case #16: Formula. Time as fraction of day, valid input. 1 argument used.
		oParser = new parserFormula('SINH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5210953054937474, 'Test: Positive case: Formula. Time as fraction of day, valid input. 1 argument used.');
		// Case #17: Formula. Nested formula returning positive number. 1 argument used.
		oParser = new parserFormula('SINH(ABS(-1.5708))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(ABS(-1.5708)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.301308119050013, 'Test: Positive case: Formula. Nested formula returning positive number. 1 argument used.');
		// Case #18: String. String convertible to valid number. 1 argument used.
		oParser = new parserFormula('SINH("1.5708")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH("1.5708") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.301308119050013, 'Test: Positive case: String. String convertible to valid number. 1 argument used.');
		// Case #19: Formula. SIN as part of SUM formula, returns ~1. 1 argument used.
		oParser = new parserFormula('SUM(SINH(1.5708), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SINH(1.5708), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.301308119050013, 'Test: Positive case: Formula. SIN as part of SUM formula, returns ~1. 1 argument used.');
		// Case #20: Number. Approximation of ? radians, returns ~0. 1 argument used.
		oParser = new parserFormula('SINH(3.1416)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(3.1416) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11.548824516813248, 'Test: Positive case: Number. Approximation of ? radians, returns ~0. 1 argument used.');
		// Case #21: String. String convertible to zero. 1 argument used.
		oParser = new parserFormula('SINH("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String convertible to zero. 1 argument used.');
		// Case #22: Array. Array with multiple valid elements, processes first element (0). 1 argument used.
		oParser = new parserFormula('SINH({0, 1.5708})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH({0, 1.5708}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array. Array with multiple valid elements, processes first element (0). 1 argument used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('SINH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #3: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.521095305, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #4: Empty. Reference to empty cell returns 0 (Excel treats as 0). 1 argument used.
		oParser = new parserFormula('SINH(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.1752011936438014, 'Test: Negative case: Empty. Reference to empty cell returns 0 (Excel treats as 0). 1 argument used.');
		// Case #5: Boolean. Boolean TRUE (1) returns ~0.8415, but testing for type handling. 1 argument used.
		oParser = new parserFormula('SINH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1752011936438014, 'Test: Negative case: Boolean. Boolean TRUE (1) returns ~0.8415, but testing for type handling. 1 argument used.');
		// Case #6: Boolean. Boolean FALSE (0) returns 0, but testing for type handling. 1 argument used.
		oParser = new parserFormula('SINH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean FALSE (0) returns 0, but testing for type handling. 1 argument used.');
		// Case #7: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8881059821876229, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #8: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8881059821876229, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Ref3D. 3D reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #10: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(Sheet2!A4:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #11: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.1752011936438014, 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #12: Formula. Nested formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('SINH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #13: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #14: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('SINH(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.');
		// Case #15: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH({TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1.1752011936438014, 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');
		// Case #16: Array. Array with mixed valid and invalid elements, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH({1, "abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH({1, "abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1.1752011936438014, 'Test: Negative case: Array. Array with mixed valid and invalid elements, returns #VALUE!. 1 argument used.');
		// Case #17: Formula. Nested formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('SINH(MMULT(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(MMULT(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Formula. Nested formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #18: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1752011936438014, 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #19: Area. Area with text in one cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SINH(A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(A106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Area with text in one cell returns #VALUE!. 1 argument used.');
		// Case #20: Formula. String convertible to number exceeding limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('SINH("1E+309")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH("1E+309") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. String convertible to number exceeding limit returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.
		oParser = new parserFormula('SINH(1E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(1E-308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.');
		// Case #2: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.
		oParser = new parserFormula('SINH(-1E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(-1E-308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.');
		// Case #3: Number. Largest number Excel can handle, returns valid sine value. 1 argument used.
		oParser = new parserFormula('SINH(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SINH(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Largest number Excel can handle, returns valid sine value. 1 argument used.');

		// Need to fix: area handle
		// Case #3: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #10: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		// Case #19: Area. Area with text in one cell returns #VALUE!. 1 argument used.

		testArrayFormula(assert, "SINH");
	});

	QUnit.test("Test: \"SQRT\"", function (assert) {
		ws.getRange2("A202").setValue("-16");

		oParser = new parserFormula('SQRT(16)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		oParser = new parserFormula('SQRT(A202)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula('SQRT(ABS(A202))', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Square root of 4
		oParser = new parserFormula('SQRT(4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Square root of 4');
		// Case #2: Number. Square root of zero
		oParser = new parserFormula('SQRT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Square root of zero');
		// Case #3: Number. Square root of a decimal number
		oParser = new parserFormula('SQRT(2.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(2.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Number. Square root of a decimal number');
		// Case #4: String. Numeric string converted to number
		oParser = new parserFormula('SQRT("9")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT("9") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String. Numeric string converted to number');
		// Case #5: Formula. Nested formula result is number
		oParser = new parserFormula('SQRT(POWER(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(POWER(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. Nested formula result is number');
		// Case #6: Empty. Empty argument leads to error
		oParser = new parserFormula('SQRT()', 'A2', ws);
		assert.ok(oParser.parse() === false, 'Test: SQRT() is not parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Positive case: Empty. Empty argument leads to error');
		// Case #7: Date. Date difference as number
		oParser = new parserFormula('SQRT(DATE(2020,1,1)-DATE(2019,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(DATE(2020,1,1)-DATE(2019,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 19.1049731745428, 'Test: Positive case: Date. Date difference as number');
		// Case #8: Time. Time converted to decimal hours
		oParser = new parserFormula('SQRT(TIME(4,0,0)*24)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TIME(4,0,0)*24) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Time. Time converted to decimal hours');
		// Case #9: Reference link. Reference to a cell
		oParser = new parserFormula('SQRT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Reference link. Reference to a cell');
		// Case #10: Area. Area reference
		oParser = new parserFormula('SQRT(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Area. Area reference');
		// Case #11: Array. Array constant
		oParser = new parserFormula('SQRT({4,9})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT({4,9}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Array. Array constant');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 3, 'Test: Positive case: Array. Array constant');
		// Case #12: Name. Named cell reference
		oParser = new parserFormula('SQRT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named cell reference');
		// Case #13: Name3D. Named cell reference on another sheet
		oParser = new parserFormula('SQRT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. Named cell reference on another sheet');
		// Case #14: Ref3D. 3D reference to a cell
		oParser = new parserFormula('SQRT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to a cell');
		// Case #15: Area3D. 3D area reference
		oParser = new parserFormula('SQRT(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D area reference');
		// Case #16: Table. Table column reference
		oParser = new parserFormula('SQRT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table column reference');
		// Case #17: Name. Second named cell
		oParser = new parserFormula('SQRT(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Name. Second named cell');
		// Case #18: Name. Named range
		oParser = new parserFormula('SQRT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8944271909999159, 'Test: Positive case: Name. Named range');
		// Case #19: Name3D. Named 3D range
		oParser = new parserFormula('SQRT(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8944271909999159, 'Test: Positive case: Name3D. Named 3D range');
		// Case #20: Formula. Complex nested formula
		oParser = new parserFormula('SQRT(SQRT(16)^2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(SQRT(16)^2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Complex nested formula');

		// Negative cases:
		// Case #1: Number. Negative number results in #NUM!
		oParser = new parserFormula('SQRT(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number results in #NUM!');
		// Case #2: String. Non-numeric string results in #VALUE!
		oParser = new parserFormula('SQRT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string results in #VALUE!');
		// Case #3: Formula. Result negative number
		oParser = new parserFormula('SQRT(POWER(-2,2)*-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(POWER(-2,2)*-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Result negative number');
		// Case #4: Empty. Empty string results in #VALUE!
		oParser = new parserFormula('SQRT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty string results in #VALUE!');
		// Case #5: Reference link. Reference to negative number
		oParser = new parserFormula('SQRT(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.224744871391589, 'Test: Negative case: Reference link. Reference to negative number');
		// Case #6: Area. Area containing negative number
		oParser = new parserFormula('SQRT(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.707106781, 'Test: Negative case: Area. Area containing negative number');
		// Case #7: Array. Array with negative number
		oParser = new parserFormula('SQRT({-4,9})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT({-4,9}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with negative number');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 3, 'Test: Negative case: Array. Array with negative number');
		// Case #8: Date. Negative date difference
		oParser = new parserFormula('SQRT(DATE(2019,1,1)-DATE(2020,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(DATE(2019,1,1)-DATE(2020,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Negative date difference');
		// Case #9: Time. Negative time invalid
		oParser = new parserFormula('SQRT(TIME(-1,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TIME(-1,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Negative time invalid');
		// Case #10: Name. Named cell with negative number
		oParser = new parserFormula('SQRT(TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.24037034920393, 'Test: Negative case: Name. Named cell with negative number');
		// Case #11: Name3D. Named cell on another sheet with negative
		oParser = new parserFormula('SQRT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. Named cell on another sheet with negative');
		// Case #12: Ref3D. 3D reference negative
		oParser = new parserFormula('SQRT(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4142135623730951, 'Test: Negative case: Ref3D. 3D reference negative');
		// Case #13: Area3D. 3D area with negative
		oParser = new parserFormula('SQRT(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D area with negative');
		// Case #14: Table. Table column negative
		oParser = new parserFormula('SQRT(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column negative');
		// Case #15: Name. Another named cell negative
		oParser = new parserFormula('SQRT(TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Another named cell negative');
		// Case #16: Name. Named range with negative
		oParser = new parserFormula('SQRT(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with negative');
		// Case #17: Name3D. Named 3D range negative
		oParser = new parserFormula('SQRT(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(TestNameArea3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. Named 3D range negative');
		// Case #18: Formula. Nested formula result negative
		oParser = new parserFormula('SQRT(SQRT(-16)^2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(SQRT(-16)^2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula result negative');
		// Case #19: Error. SQRT of division by zero error
		oParser = new parserFormula('SQRT(#DIV/0!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(#DIV/0!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. SQRT of division by zero error');
		// Case #20: Error. SQRT of invalid reference
		oParser = new parserFormula('SQRT(#REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(#REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Error. SQRT of invalid reference');

		// Bounded cases:
		// Case #1: Number. Maximum number Excel can handle
		oParser = new parserFormula('SQRT(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.1622776601683792e+153, 'Test: Bounded case: Number. Maximum number Excel can handle');
		// Case #2: Number. Minimum positive number
		oParser = new parserFormula('SQRT(2.2250738585072E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRT(2.2250738585072E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum positive number');

		// Need to fix: area handle
		// Case #10: Area. Area reference
		// Case #6: Area. Area containing negative number
		// Case #16: Name. Named range with negative
		// Case #17: Name3D. Named 3D range negative
		// Case #2: Number. Minimum positive number

		testArrayFormula(assert, "SQRT");
	});

	QUnit.test("Test: \"SQRTPI\"", function (assert) {
		oParser = new parserFormula('SQRTPI(1)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 1.772454);

		oParser = new parserFormula('SQRTPI(2)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 2.506628);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Square root of 4
		oParser = new parserFormula('SQRTPI(4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5449077018110318, 'Test: Positive case: Number. Square root of 4');
		// Case #2: Number. Square root of zero
		oParser = new parserFormula('SQRTPI(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Square root of zero');
		// Case #3: Number. Square root of a decimal number
		oParser = new parserFormula('SQRTPI(2.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(2.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.658680776358274, 'Test: Positive case: Number. Square root of a decimal number');
		// Case #4: String. Numeric string converted to number
		oParser = new parserFormula('SQRTPI("9")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI("9") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.317361552716548, 'Test: Positive case: String. Numeric string converted to number');
		// Case #5: Formula. Nested formula result is number
		oParser = new parserFormula('SQRTPI(POWER(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(POWER(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.317361552716548, 'Test: Positive case: Formula. Nested formula result is number');
		// Case #6: Empty. Empty argument leads to error
		oParser = new parserFormula('SQRTPI()', 'A2', ws);
		assert.ok(oParser.parse() === false, 'Test: SQRTPI() is NOT parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Positive case: Empty. Empty argument leads to error');
		// Case #7: Date. Date difference as number
		oParser = new parserFormula('SQRTPI(DATE(2020,1,1)-DATE(2019,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(DATE(2020,1,1)-DATE(2019,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 33.86268327466497, 'Test: Positive case: Date. Date difference as number');
		// Case #8: Time. Time converted to decimal hours
		oParser = new parserFormula('SQRTPI(TIME(4,0,0)*24)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TIME(4,0,0)*24) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5449077018110318, 'Test: Positive case: Time. Time converted to decimal hours');
		// Case #9: Reference link. Reference to a cell
		oParser = new parserFormula('SQRTPI(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.2533141373155001, 'Test: Positive case: Reference link. Reference to a cell');
		// Case #10: Area. Area reference
		oParser = new parserFormula('SQRTPI(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area. Area reference');
		// Case #11: Array. Array constant
		oParser = new parserFormula('SQRTPI({4,9})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI({4,9}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3.5449077018110318, 'Test: Positive case: Array. Array constant');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 5.317361552716548, 'Test: Positive case: Array. Array constant');
		// Case #12: Name. Named cell reference
		oParser = new parserFormula('SQRTPI(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named cell reference');
		// Case #13: Name3D. Named cell reference on another sheet
		oParser = new parserFormula('SQRTPI(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. Named cell reference on another sheet');
		// Case #14: Ref3D. 3D reference to a cell
		oParser = new parserFormula('SQRTPI(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7724538509055159, 'Test: Positive case: Ref3D. 3D reference to a cell');
		// Case #15: Area3D. 3D area reference
		oParser = new parserFormula('SQRTPI(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(Sheet2!A1:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D area reference');
		// Case #16: Table. Table column reference
		oParser = new parserFormula('SQRTPI(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7724538509055159, 'Test: Positive case: Table. Table column reference');
		// Case #17: Name. Second named cell
		oParser = new parserFormula('SQRTPI(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.2533141373155001, 'Test: Positive case: Name. Second named cell');
		// Case #18: Name. Named range
		oParser = new parserFormula('SQRTPI(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5853309190424043, 'Test: Positive case: Name. Named range');
		// Case #19: Name3D. Named 3D range
		oParser = new parserFormula('SQRTPI(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5853309190424043, 'Test: Positive case: Name3D. Named 3D range');
		// Case #20: Formula. Complex nested formula
		oParser = new parserFormula('SQRTPI(SQRTPI(16)^2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(SQRTPI(16)^2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.56637061435917, 'Test: Positive case: Formula. Complex nested formula');

		// Negative cases:
		// Case #1: Number. Negative number results in #NUM!
		oParser = new parserFormula('SQRTPI(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number results in #NUM!');
		// Case #2: String. Non-numeric string results in #VALUE!
		oParser = new parserFormula('SQRTPI("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string results in #VALUE!');
		// Case #3: Formula. Result negative number
		oParser = new parserFormula('SQRTPI(POWER(-2,2)*-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(POWER(-2,2)*-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Result negative number');
		// Case #4: Empty. Empty string results in #VALUE!
		oParser = new parserFormula('SQRTPI("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty string results in #VALUE!');
		// Case #5: Reference link. Reference to negative number
		oParser = new parserFormula('SQRTPI(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.1708037636748028, 'Test: Negative case: Reference link. Reference to negative number');
		// Case #6: Area. Area containing negative number
		oParser = new parserFormula('SQRTPI(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Area containing negative number');
		// Case #7: Array. Array with negative number
		oParser = new parserFormula('SQRTPI({-4,9})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI({-4,9}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with negative number');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 5.317361552716548, 'Test: Negative case: Array. Array with negative number');
		// Case #8: Date. Negative date difference
		oParser = new parserFormula('SQRTPI(DATE(2019,1,1)-DATE(2020,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(DATE(2019,1,1)-DATE(2020,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Negative date difference');
		// Case #9: Time. Negative time invalid
		oParser = new parserFormula('SQRTPI(TIME(-1,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TIME(-1,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Negative time invalid');
		// Case #10: Name. Named cell with negative number
		oParser = new parserFormula('SQRTPI(TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.743406903806558, 'Test: Negative case: Name. Named cell with negative number');
		// Case #11: Name3D. Named cell on another sheet with negative
		oParser = new parserFormula('SQRTPI(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. Named cell on another sheet with negative');
		// Case #12: Ref3D. 3D reference negative
		oParser = new parserFormula('SQRTPI(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5066282746310002, 'Test: Negative case: Ref3D. 3D reference negative');
		// Case #13: Area3D. 3D area with negative
		oParser = new parserFormula('SQRTPI(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D area with negative');
		// Case #14: Table. Table column negative
		oParser = new parserFormula('SQRTPI(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column negative');
		// Case #15: Name. Another named cell negative
		oParser = new parserFormula('SQRTPI(TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Another named cell negative');
		// Case #16: Name. Named range with negative
		oParser = new parserFormula('SQRTPI(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with negative');
		// Case #17: Name3D. Named 3D range negative
		oParser = new parserFormula('SQRTPI(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. Named 3D range negative');
		// Case #18: Formula. Nested formula result negative
		oParser = new parserFormula('SQRTPI(SQRTPI(-16)^2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(SQRTPI(-16)^2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula result negative');
		// Case #19: Error. SQRT of division by zero error
		oParser = new parserFormula('SQRTPI(#DIV/0!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(#DIV/0!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. SQRT of division by zero error');
		// Case #20: Error. SQRT of invalid reference
		oParser = new parserFormula('SQRTPI(#REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(#REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Error. SQRT of invalid reference');

		// Bounded cases:
		// Case #1: Number. Maximum number Excel can handle
		oParser = new parserFormula('SQRTPI(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.604991216397929e+153, 'Test: Bounded case: Number. Maximum number Excel can handle');
		// Case #2: Number. Minimum positive number
		oParser = new parserFormula('SQRTPI(2.2250738585072E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SQRTPI(2.2250738585072E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum positive number');

		// Need to fix: area handle, small number result diff
		// Case #15: Area3D. 3D area reference
		// Case #2: Number. Minimum positive number

		testArrayFormula(assert, "SQRTPI", true);
	});

	QUnit.test("Test: \"SUBTOTAL\"", function (assert) {
		let array;
		ws.getRange2("A102").setValue("120");
		ws.getRange2("A103").setValue("10");
		ws.getRange2("A104").setValue("150");
		ws.getRange2("A105").setValue("23");

		ws.getRange2("A106").setValue("1");

		ws.getRange2("B100").setValue("#N/A");

		oParser = new parserFormula("SUBTOTAL(-1,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(-1,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "SUBTOTAL(-1,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(0,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(0,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "SUBTOTAL(0,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(1,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(1,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 75.75, "SUBTOTAL(1,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(2,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(2,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 4, "SUBTOTAL(2,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(3,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(3,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 4, "SUBTOTAL(3,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(4,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(4,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 150, "SUBTOTAL(4,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(5,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(5,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 10, "SUBTOTAL(5,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(6,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(6,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 4140000, "SUBTOTAL(6,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(7,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(7,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 69.70592992, "SUBTOTAL(7,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(8,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(8,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 60.36710611, "SUBTOTAL(8,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(9,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 303, "SUBTOTAL(9,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(99,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(99,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "SUBTOTAL(99,A102:A105)");

		oParser = new parserFormula('SUBTOTAL("str",A102:A105)', "A2", ws);
		assert.ok(oParser.parse(), 'SUBTOTAL("str",A102:A105)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'SUBTOTAL("str",A102:A105)');

		oParser = new parserFormula('SUBTOTAL(B100,A102:A105)', "A2", ws);
		assert.ok(oParser.parse(), 'SUBTOTAL(B100,A102:A105)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", 'SUBTOTAL(B100,A102:A105)');

		oParser = new parserFormula("SUBTOTAL(2,A102,A102)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(2,A102,A102)");
		assert.strictEqual(oParser.calculate().getValue(), 2, "Two refs in SUBTOTAL(2,A102,A102)");

		oParser = new parserFormula("SUBTOTAL(2,A102,A102,A102)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(2,A102,A102,A102)");
		assert.strictEqual(oParser.calculate().getValue(), 3, "Three refs in SUBTOTAL(2,A102,A102,A102)");

		oParser = new parserFormula("SUBTOTAL(2,A102,A102,A102,A102)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(2,A102,A102,A102,A102)");
		assert.strictEqual(oParser.calculate().getValue(), 4, "Four refs in SUBTOTAL(2,A102,A102,A102,A102)");

		oParser = new parserFormula("SUBTOTAL(9,A102,A102,A102,A102)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102,A102,A102,A102)");
		assert.strictEqual(oParser.calculate().getValue(), 480, "Four refs in SUBTOTAL(9,A102,A102,A102,A102)");

		oParser = new parserFormula("SUBTOTAL(9,A102:A105,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102:A105,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 606, "Two refs in SUBTOTAL(9,A102:A105,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(9,A102:A105,A102:A105,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102:A105,A102:A105,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 909, "Three refs in SUBTOTAL(9,A102:A105,A102:A105,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(9,A102:A105,A102:A105,A102:A105,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102:A105,A102:A105,A102:A105,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 1212, "Four refs in SUBTOTAL(9,A102:A105,A102:A105,A102:A105,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(9,A102:A105,A102:A105,A102:A105,A102:A105,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102:A105,A102:A105,A102:A105,A102:A105,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 1515, "Five refs in SUBTOTAL(9,A102:A105,A102:A105,A102:A105,A102:A105,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(9,A102,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 423, "SUBTOTAL(9,A102,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(9,A102,A102:A105,A106)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102,A102:A105,A106)");
		assert.strictEqual(oParser.calculate().getValue(), 424, "SUBTOTAL(9,A102,A102:A106)");

		oParser = new parserFormula("SUBTOTAL(9,A102,A102:A105,A106,A102:A105)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102,A102:A105,A106,A102:A105)");
		assert.strictEqual(oParser.calculate().getValue(), 727, "SUBTOTAL(9,A102,A102:A106,A102:A105)");

		oParser = new parserFormula("SUBTOTAL(9,A102,A102:A105,A106,A102:A105,A106)", "A2", ws);
		assert.ok(oParser.parse(), "SUBTOTAL(9,A102,A102:A105,A106,A102:A105,A106)");
		assert.strictEqual(oParser.calculate().getValue(), 728, "SUBTOTAL(9,A102,A102:A106,A102:A105,A106)");


		// for bug 68820
		ws.getRange2("B100").setValue("-2");
		ws.getRange2("B101").setValue("1");
		ws.getRange2("B102").setValue("-1");
		ws.getRange2("B103").setValue("0");
		ws.getRange2("B104").setValue("1");
		ws.getRange2("B105").setValue("1");
		ws.getRange2("B106").setValue("-2");
		ws.getRange2("B107").setValue("0");
		ws.getRange2("B108").setValue("0");

		ws.getRange2("B109").setValue("1");
		ws.getRange2("B110").setValue("1");
		
		oParser = new parserFormula('SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))', "A2", ws);
		assert.ok(oParser.parse(), 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue(), -2, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');
		assert.strictEqual(array.getElementRowCol(1,0).getValue(), 1, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');
		assert.strictEqual(array.getElementRowCol(2,0).getValue(), -1, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');
		assert.strictEqual(array.getElementRowCol(3,0).getValue(), 0, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');
		assert.strictEqual(array.getElementRowCol(4,0).getValue(), 1, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');
		assert.strictEqual(array.getElementRowCol(5,0).getValue(), 1, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');
		assert.strictEqual(array.getElementRowCol(6,0).getValue(), -2, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');
		assert.strictEqual(array.getElementRowCol(7,0).getValue(), 0, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');
		assert.strictEqual(array.getElementRowCol(8,0).getValue(), 0, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))');

		oParser = new parserFormula('SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)', "A2", ws);
		assert.ok(oParser.parse(), 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue(), 0, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');
		assert.strictEqual(array.getElementRowCol(1,0).getValue(), 3, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');
		assert.strictEqual(array.getElementRowCol(2,0).getValue(), 1, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');
		assert.strictEqual(array.getElementRowCol(3,0).getValue(), 2, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');
		assert.strictEqual(array.getElementRowCol(4,0).getValue(), 3, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');
		assert.strictEqual(array.getElementRowCol(5,0).getValue(), 3, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');
		assert.strictEqual(array.getElementRowCol(6,0).getValue(), 0, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');
		assert.strictEqual(array.getElementRowCol(7,0).getValue(), 2, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');
		assert.strictEqual(array.getElementRowCol(8,0).getValue(), 2, 'SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),B109:B110)');

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A104").setValue("5");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A105").setValue("6");
		ws.getRange2("A106").setValue("7");
		ws.getRange2("A107").setValue("8");
		ws.getRange2("A108").setValue("9");
		ws.getRange2("A109").setValue("10");
		ws.getRange2("A110").setValue("11");
		ws.getRange2("A111").setValue("11");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2



		// Positive cases:
		// Case #1: Number. Simple number as input.
		oParser = new parserFormula('SUBTOTAL(1,1)', 'A2', ws);
		//? assert.ok(oParser.parse() === false, 'Test: SUBTOTAL(1,1) is not parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,1)', 'Test: Positive case: Number. Simple number as input.');
		// Case #2: Reference link. Reference link to single cell.
		oParser = new parserFormula('SUBTOTAL(1,A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference link to single cell.');
		// Case #3: Area. Range of 2 cells.
		oParser = new parserFormula('SUBTOTAL(1,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area. Range of 2 cells.');
		// Case #4: Array. Array constant as input.
		oParser = new parserFormula('SUBTOTAL(1,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse() === false, 'Test: SUBTOTAL(1,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,{1,2,3})', 'Test: Positive case: Array. Array constant as input.');
		// Case #5: Name. Named range.
		oParser = new parserFormula('SUBTOTAL(1,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name. Named range.');
		// Case #6: Table. Table column as input.
		oParser = new parserFormula('SUBTOTAL(1,Table1[Column1])', 'A2', ws);
		//? assert.ok(oParser.parse() === false, 'Test: SUBTOTAL(1,Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,Table1[Column1])', 'Test: Positive case: Table. Table column as input.');
		// Case #7: Ref3D. 3D reference to another sheet.
		oParser = new parserFormula('SUBTOTAL(1,Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Ref3D. 3D reference to another sheet.');
		// Case #8: Area3D. 3D area reference.
		oParser = new parserFormula('SUBTOTAL(1,Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D area reference.');
		// Case #9: Number. Simple number as input.
		oParser = new parserFormula('SUBTOTAL(2,1)', 'A2', ws);
		//? assert.ok(oParser.parse() === false, 'Test: SUBTOTAL(2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(2,1)', 'Test: Positive case: Number. Simple number as input.');
		// Case #10: Reference link. Reference link to single cell.
		oParser = new parserFormula('SUBTOTAL(2,A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(2,A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference link to single cell.');
		// Case #11: Area. Range of 2 cells.
		oParser = new parserFormula('SUBTOTAL(2,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(2,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area. Range of 2 cells.');
		// Case #12: Array. Array constant as input.
		oParser = new parserFormula('SUBTOTAL(2,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse() === false, 'Test: SUBTOTAL(2,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(2,{1,2,3})', 'Test: Positive case: Array. Array constant as input.');
		// Case #13: Name. Named range.
		oParser = new parserFormula('SUBTOTAL(2,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(2,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name. Named range.');
		// Case #14: Table. Table column as input.
		oParser = new parserFormula('SUBTOTAL(2,Table1[Column1])', 'A2', ws);
		//? assert.ok(oParser.parse() === false, 'Test: SUBTOTAL(2,Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(2,Table1[Column1])', 'Test: Positive case: Table. Table column as input.');
		// Case #15: Ref3D. 3D reference to another sheet.
		oParser = new parserFormula('SUBTOTAL(2,Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(2,Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to another sheet.');
		// Case #16: Area3D. 3D area reference.
		oParser = new parserFormula('SUBTOTAL(2,Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(2,Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D area reference.');
		// Case #17: Number. Simple number as input.
		oParser = new parserFormula('SUBTOTAL(3,1)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(3,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(3,1)', 'Test: Positive case: Number. Simple number as input.');
		// Case #18: Reference link. Reference link to single cell.
		oParser = new parserFormula('SUBTOTAL(3,A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(3,A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference link to single cell.');
		// Case #19: Area. Range of 2 cells.
		oParser = new parserFormula('SUBTOTAL(3,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(3,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area. Range of 2 cells.');
		// Case #20: Array. Array constant as input.
		oParser = new parserFormula('SUBTOTAL(3,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(3,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(3,{1,2,3})', 'Test: Positive case: Array. Array constant as input.');
		// Case #21: Name. Named range.
		oParser = new parserFormula('SUBTOTAL(3,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(3,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name. Named range.');
		// Case #22: Table. Table column as input.
		oParser = new parserFormula('SUBTOTAL(3,Table1[Column11])', 'A2', ws);
		//? assert.ok(oParser.parse() === false, 'Test: SUBTOTAL(3,Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(3,Table1[Column1])', 'Test: Positive case: Table. Table column as input.');
		// Case #23: Ref3D. 3D reference to another sheet.
		oParser = new parserFormula('SUBTOTAL(3,Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(3,Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to another sheet.');
		// Case #24: Area3D. 3D area reference.
		oParser = new parserFormula('SUBTOTAL(3,Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(3,Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D area reference.');
		// Case #25: Number. Simple number as input.
		oParser = new parserFormula('SUBTOTAL(4,1)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(4,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(4,1)', 'Test: Positive case: Number. Simple number as input.');
		// Case #26: Reference link. Reference link to single cell.
		oParser = new parserFormula('SUBTOTAL(4,A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(4,A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference link to single cell.');
		// Case #27: Area. Range of 2 cells.
		oParser = new parserFormula('SUBTOTAL(4,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(4,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area. Range of 2 cells.');
		// Case #28: Array. Array constant as input.
		oParser = new parserFormula('SUBTOTAL(4,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse() === false, 'Test: SUBTOTAL(4,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(4,{1,2,3})', 'Test: Positive case: Array. Array constant as input.');
		// Case #29: Name. Named range.
		oParser = new parserFormula('SUBTOTAL(4,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(4,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name. Named range.');
		// Case #30: Table. Table column as input.
		oParser = new parserFormula('SUBTOTAL(4,Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(4,Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table column as input.');
		// Case #35: Name. Extra: Named range input.
		oParser = new parserFormula('SUBTOTAL(5,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(5,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Extra: Named range input.');
		// Case #36: Array. Extra: Array input.
		oParser = new parserFormula('SUBTOTAL(6,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(6,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(6,{1,2,3})', 'Test: Positive case: Array. Extra: Array input.');
		// Case #37: Name. Extra: Named range input.
		oParser = new parserFormula('SUBTOTAL(7,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(7,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Extra: Named range input.');
		// Case #39: Name. Extra: Named range input.
		oParser = new parserFormula('SUBTOTAL(9,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(9,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Extra: Named range input.');
		// Case #40: Array. Extra: Array input.
		oParser = new parserFormula('SUBTOTAL(10,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(10,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(10,{1,2,3})', 'Test: Positive case: Array. Extra: Array input.');
		// Case #41: Name. Extra: Named range input.
		oParser = new parserFormula('SUBTOTAL(11,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(11,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name. Extra: Named range input.');
		// Case #42: Array. Extra: Array input.
		oParser = new parserFormula('SUBTOTAL(101,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(101,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(101,{1,2,3})', 'Test: Positive case: Array. Extra: Array input.');
		// Case #43: Name. Extra: Named range input.
		oParser = new parserFormula('SUBTOTAL(102,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(102,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name. Extra: Named range input.');
		// Case #44: Array. Extra: Array input.
		oParser = new parserFormula('SUBTOTAL(103,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(103,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(103,{1,2,3})', 'Test: Positive case: Array. Extra: Array input.');
		// Case #45: Name. Extra: Named range input.
		oParser = new parserFormula('SUBTOTAL(104,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(104,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Extra: Named range input.');
		// Case #46: Array. Extra: Array input.
		oParser = new parserFormula('SUBTOTAL(105,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(105,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(105,{1,2,3})', 'Test: Positive case: Array. Extra: Array input.');
		// Case #47: Name. Extra: Named range input.
		oParser = new parserFormula('SUBTOTAL(106,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(106,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Extra: Named range input.');
		// Case #48: Array. Extra: Array input.
		oParser = new parserFormula('SUBTOTAL(107,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(107,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(107,{1,2,3})', 'Test: Positive case: Array. Extra: Array input.');
		// Case #49: Name. Extra: Named range input.
		oParser = new parserFormula('SUBTOTAL(108,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(108,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name. Extra: Named range input.');
		// Case #50: Array. Extra: Array input.
		oParser = new parserFormula('SUBTOTAL(109,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(109,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(109,{1,2,3})', 'Test: Positive case: Array. Extra: Array input.');
		// Case #51: Name. Extra: Named range input.
		oParser = new parserFormula('SUBTOTAL(110,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(110,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Extra: Named range input.');
		// Case #52: Array. Extra: Array input.
		oParser = new parserFormula('SUBTOTAL(111,{1,2,3})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(111,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(111,{1,2,3})', 'Test: Positive case: Array. Extra: Array input.');

		// Negative cases:
		// Case #1: Number. Invalid function_num -> #VALUE!
		oParser = new parserFormula('SUBTOTAL(0,1)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(0,1)', 'Test: Negative case: Number. Invalid function_num -> #VALUE!');
		// Case #2: Number. Invalid function_num -> #VALUE!
		oParser = new parserFormula('SUBTOTAL(200,1)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(200,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(200,1)', 'Test: Negative case: Number. Invalid function_num -> #VALUE!');
		// Case #3: String. String instead of function_num -> #VALUE!
		oParser = new parserFormula('SUBTOTAL("text",1)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL("text",1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL("text",1)', 'Test: Negative case: String. String instead of function_num -> #VALUE!');
		// Case #4: Error. Error in function_num -> #N/A
		oParser = new parserFormula('SUBTOTAL(#N/A,1)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(#N/A,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(#N/A,1)', 'Test: Negative case: Error. Error in function_num -> #N/A');
		// Case #5: Empty. Empty function_num -> #VALUE!
		oParser = new parserFormula('SUBTOTAL(,1)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(,1)', 'Test: Negative case: Empty. Empty function_num -> #VALUE!');
		// Case #6: Reference link. Reference link with error value.
		oParser = new parserFormula('SUBTOTAL(1,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Reference link. Reference link with error value.');
		// Case #7: Area. Range contains error.
		oParser = new parserFormula('SUBTOTAL(1,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Area. Range contains error.');
		// Case #8: Formula. Division by zero inside argument.
		oParser = new parserFormula('SUBTOTAL(1,1/0)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,1/0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,1/0)', 'Test: Negative case: Formula. Division by zero inside argument.');
		// Case #9: Array. Array of strings -> #VALUE!
		oParser = new parserFormula('SUBTOTAL(1,{"a","b"})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,{"a","b"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,{"a","b"})', 'Test: Negative case: Array. Array of strings -> #VALUE!');
		// Case #10: Table. Invalid table column reference.
		oParser = new parserFormula('SUBTOTAL(1,Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Negative case: Table. Invalid table column reference.');
		// Case #11: Ref3D. Invalid 3D reference.
		oParser = new parserFormula('SUBTOTAL(1,Sheet2!Z99)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,Sheet2!Z99) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. Invalid 3D reference.');
		// Case #12: Area3D. Invalid 3D area reference.
		oParser = new parserFormula('SUBTOTAL(1,Sheet2!Z99:Z100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,Sheet2!Z99:Z100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. Invalid 3D area reference.');
		// Case #13: Name. Non-existent name reference.
		oParser = new parserFormula('SUBTOTAL(1,NotExistingName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,NotExistingName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name. Non-existent name reference.');
		// Case #15: Empty. Missing second argument.
		oParser = new parserFormula('SUBTOTAL(1,)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,)', 'Test: Negative case: Empty. Missing second argument.');
		// Case #16: Error. Error value in ref.
		oParser = new parserFormula('SUBTOTAL(1,#DIV/0!)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,#DIV/0!) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,#DIV/0!)', 'Test: Negative case: Error. Error value in ref.');
		// Case #17: Formula. Nested with invalid function_num.
		oParser = new parserFormula('SUBTOTAL(1,SUBTOTAL(0,1))', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,SUBTOTAL(0,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,=SUBTOTAL(0,1))', 'Test: Negative case: Formula. Nested with invalid function_num.');
		// Case #18: String. Text argument instead of number -> #VALUE!
		oParser = new parserFormula('SUBTOTAL(1,"abc")', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,"abc")', 'Test: Negative case: String. Text argument instead of number -> #VALUE!');
		// Case #19: Number. Overflow number.
		oParser = new parserFormula('SUBTOTAL(1,999999999999999999999)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,999999999999999999999) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,999999999999999999999)', 'Test: Negative case: Number. Overflow number.');
		// Case #20: Array. Error inside array.
		oParser = new parserFormula('SUBTOTAL(1,{1,#N/A})', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(1,{1,#N/A}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(1,{1,#N/A})', 'Test: Negative case: Array. Error inside array.');

		// Bounded cases:
		// Case #1: Number. Minimum positive number.
		oParser = new parserFormula('SUBTOTAL(9,1E-307)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(9,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(9,1E-307)', 'Test: Bounded case: Number. Minimum positive number.');
		// Case #2: Number. Minimum negative number.
		oParser = new parserFormula('SUBTOTAL(9,-1E-307)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(9,-1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(9,-1E-307)', 'Test: Bounded case: Number. Minimum negative number.');
		// Case #3: Number. Maximum positive number.
		oParser = new parserFormula('SUBTOTAL(9,1E+307)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(9,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(9,1E+307)', 'Test: Bounded case: Number. Maximum positive number.');
		// Case #4: Number. Maximum negative number.
		oParser = new parserFormula('SUBTOTAL(9,-1E+307)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: SUBTOTAL(9,-1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=SUBTOTAL(9,-1E+307)', 'Test: Bounded case: Number. Maximum negative number.');
		// Case #5: Number. Maximum negative number.
		oParser = new parserFormula('SUBTOTAL(-1E+307,A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUBTOTAL(-1E+307,A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number. Maximum negative number.');

		// TODO много отрицательных кейсов по парсингу формулы, добавить ошибку при отсутсвии нужного типа reference в аргументах
		// Need to fix:
		// Case #2: Reference link. Reference link to single cell.
		// Case #3: Area. Range of 2 cells.
		// Case #11: Ref3D. Invalid 3D reference.
		// Case #12: Area3D. Invalid 3D area reference.


	});

	QUnit.test("Test: \"SUBTOTAL with multiple ranges\"", function (assert) {
        // Setup test data with 5 columns for testing
        ws.getRange2("E2").setValue("10");
        ws.getRange2("E3").setValue("20");
        ws.getRange2("E4").setValue("30");
        ws.getRange2("E5").setValue("40");
        ws.getRange2("E6").setValue("50");
        ws.getRange2("E7").setValue("60");

        ws.getRange2("F2").setValue("Red");
        ws.getRange2("F3").setValue("Blue");
        ws.getRange2("F4").setValue("Green");
        ws.getRange2("F5").setValue("Red");
        ws.getRange2("F6").setValue("Blue");
        ws.getRange2("F7").setValue("Green");

        ws.getRange2("G2").setValue("Small");
        ws.getRange2("G3").setValue("Medium");
        ws.getRange2("G4").setValue("Large");
        ws.getRange2("G5").setValue("Large");
        ws.getRange2("G6").setValue("Medium");
        ws.getRange2("G7").setValue("Small");

        ws.getRange2("H2").setValue("15");
        ws.getRange2("H3").setValue("25");
        ws.getRange2("H4").setValue("35");
        ws.getRange2("H5").setValue("45");
        ws.getRange2("H6").setValue("55");
        ws.getRange2("H7").setValue("65");

        // Test SUBTOTAL with multiple ranges

        // Function 2 (COUNT) with multiple ranges
        oParser = new parserFormula("SUBTOTAL(2, E2:E4, F2:F4, G2:G4, H2:H4, E5:E7, F5:F7, G5:G7, H5:H7)", "A1", ws);
        assert.ok(oParser.parse(), "SUBTOTAL COUNT with multiple ranges");
        assert.strictEqual(oParser.calculate().getValue(), 12, "SUBTOTAL COUNT with multiple ranges");

        // Function 3 (COUNTA) with multiple ranges
        oParser = new parserFormula("SUBTOTAL(3, E2:E4, F2:F4, G2:G4, H2:H4, E5:E7, F5:F7, G5:G7, H5:H7)", "A1", ws);
        assert.ok(oParser.parse(), "SUBTOTAL COUNTA with multiple ranges");
        assert.strictEqual(oParser.calculate().getValue(), 24, "SUBTOTAL COUNTA with multiple ranges");

        // Function 4 (MAX) with multiple ranges
        oParser = new parserFormula("SUBTOTAL(4, E2:E4, F2:F4, G2:G4, H2:H4, E5:E7, F5:F7, G5:G7, H5:H7)", "A1", ws);
        assert.ok(oParser.parse(), "SUBTOTAL MAX with multiple ranges");
        assert.strictEqual(oParser.calculate().getValue(), 65, "SUBTOTAL MAX with multiple ranges");

        // Function 5 (MIN) with multiple ranges
        oParser = new parserFormula("SUBTOTAL(5, E2:E4, F2:F4, G2:G4, H2:H4, E5:E7, F5:F7, G5:G7, H5:H7)", "A1", ws);
        assert.ok(oParser.parse(), "SUBTOTAL MIN with multiple ranges");
        assert.strictEqual(oParser.calculate().getValue(), 10, "SUBTOTAL MIN with multiple ranges");
    });

	QUnit.test("Test: \"SUM\"", function (assert) {

		ws.getRange2("S5").setValue("1");
		ws.getRange2("S6").setValue(numDivFact(-1, 2));
		ws.getRange2("S7").setValue(numDivFact(1, 4));
		ws.getRange2("S8").setValue(numDivFact(-1, 6));

		oParser = new parserFormula("SUM(S5:S8)", "A1", ws);
		assert.ok(oParser.parse());
//        assert.strictEqual( oParser.calculate().getValue(), 1-1/Math.fact(2)+1/Math.fact(4)-1/Math.fact(6) );
		assert.ok(Math.abs(oParser.calculate().getValue() - (1 - 1 / Math.fact(2) + 1 / Math.fact(4) - 1 / Math.fact(6))) < dif);

		// for bug 66800
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("3");

		oParser = new parserFormula("SUM(A101:A103+A101:A103)", "A1", ws);
		assert.ok(oParser.parse(), 'SUM(A101:A103+A101:A103)');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Result of SUM(A101:A103+A101:A103)');

		oParser = new parserFormula("SUM(SIN(A101:A103))", "A1", ws);
		assert.ok(oParser.parse(), 'SUM(SIN(A101:A103))');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), "1.89", 'Result of SUM(SIN(A101:A103))');


		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: single integer. 1 argument used.
		oParser = new parserFormula('SUM(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number. Basic valid input: single integer. 1 argument used.');
		// Case #2: Number. Float input. 1 argument used.
		oParser = new parserFormula('SUM(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #3: Number. Multiple integer inputs. 3 arguments used.
		oParser = new parserFormula('SUM(1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number. Multiple integer inputs. 3 arguments used.');
		// Case #5: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('SUM("10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM("10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #6: String. Multiple numeric strings converted to numbers. 3 arguments used.
		oParser = new parserFormula('SUM("1","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM("1","2","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: String. Multiple numeric strings converted to numbers. 3 arguments used.');
		// Case #7: Formula. Nested formula returning valid number. 1 argument used.
		oParser = new parserFormula('SUM(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Nested formula returning valid number. 1 argument used.');
		// Case #8: Formula. Multiple nested formulas. 3 arguments used.
		oParser = new parserFormula('SUM(SQRT(4),ABS(-5),ROUND(3.6,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SQRT(4),ABS(-5),ROUND(3.6,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Formula. Multiple nested formulas. 3 arguments used.');
		// Case #9: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('SUM(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #10: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('SUM(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #11: Array. Array with multiple elements. 1 argument used.
		oParser = new parserFormula('SUM({1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM({1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Array. Array with multiple elements. 1 argument used.');
		// Case #12: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('SUM(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #13: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('SUM(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #14: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('SUM(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #15: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('SUM(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #16: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('SUM(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #17: Date. Date as serial number. 1 argument used.
		oParser = new parserFormula('SUM(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date. Date as serial number. 1 argument used.');
		// Case #18: Time. Time adjusted to valid number. 1 argument used.
		oParser = new parserFormula('SUM(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Time. Time adjusted to valid number. 1 argument used.');
		// Case #19: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('SUM(IF(TRUE,10,5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IF(TRUE,10,5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');
		// Case #20: Formula. SUM as nested formula. 2 arguments used.
		oParser = new parserFormula('SUM(SUM(1,2),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SUM(1,2),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. SUM as nested formula. 2 arguments used.');
		// Case #21: Area. Multi-cell range with valid numbers. 1 argument used.
		oParser = new parserFormula('SUM(A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(A101:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area. Multi-cell range with valid numbers. 1 argument used.');
		// Case #22: String. Numeric strings with decimal points. 2 arguments used.
		oParser = new parserFormula('SUM("1.5","2.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM("1.5","2.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: String. Numeric strings with decimal points. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('SUM(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #3: Error. Propagates #DIV/0! error. 1 argument used.
		oParser = new parserFormula('SUM(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Propagates #DIV/0! error. 1 argument used.');
		// Case #4: Boolean. Boolean treated as number (TRUE=1). 1 argument used.
		oParser = new parserFormula('SUM(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean treated as number (TRUE=1). 1 argument used.');
		// Case #5: Boolean. Boolean treated as number (FALSE=0). 1 argument used.
		oParser = new parserFormula('SUM(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean treated as number (FALSE=0). 1 argument used.');
		// Case #6: Empty. Reference to empty cell returns 0. 1 argument used.
		oParser = new parserFormula('SUM(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Reference to empty cell returns 0. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Area. Range with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM(A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Range with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #9: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(TestNameArea3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('SUM(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #14: String. Invalid numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM("0.5abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM("0.5abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Invalid numeric string returns #VALUE!. 1 argument used.');
		// Case #15: Array. Array with booleans treated as numbers (1,0). 1 argument used.
		oParser = new parserFormula('SUM({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM({TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with booleans treated as numbers (1,0). 1 argument used.');
		// Case #16: Array. Array with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM({"abc",1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM({"abc",1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Array with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #17: Area3D. 3D range with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUM(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D range with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #18: Number,String. Mixed valid and invalid inputs returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SUM(10,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(10,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. Mixed valid and invalid inputs returns #VALUE!. 2 arguments used.');
		// Case #19: Formula,Error. Mixed valid number and error propagates #N/A. 2 arguments used.
		oParser = new parserFormula('SUM(5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula,Error. Mixed valid number and error propagates #N/A. 2 arguments used.');
		// Case #20: Reference link. Reference to cell with error value propagates error. 1 argument used.
		oParser = new parserFormula('SUM(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to cell with error value propagates error. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('SUM(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #2: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('SUM(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -9.99999999999999e+307, 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #3: Number. Smallest non-zero positive value. 1 argument used.
		oParser = new parserFormula('SUM(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Smallest non-zero positive value. 1 argument used.');
		// Case #4: Number. Smallest non-zero negative value. 1 argument used.
		oParser = new parserFormula('SUM(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-307, 'Test: Bounded case: Number. Smallest non-zero negative value. 1 argument used.');

		// Need to fix: name handle, text handle
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.

	});

	QUnit.test("Test: SUM(S7:S9,{1,2,3})", function (assert) {
		ws.getRange2("S7").setValue("1");
		ws.getRange2("S8").setValue("2");
		ws.getRange2("S9").setValue("3");

		oParser = new parserFormula("SUM(S7:S9,{1,2,3})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 12);
	});

	QUnit.test("Test: \"SUM(1,2,3)\"", function (assert) {
		oParser = new parserFormula('SUM(1,2,3)', "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1 + 2 + 3);

		testArrayFormula2(assert, "SUM", 1, 8, null, true);
	});

	QUnit.test("Test: \"SUMIF\"", function (assert) {

		ws.getRange2("A2").setValue("100000");
		ws.getRange2("A3").setValue("200000");
		ws.getRange2("A4").setValue("300000");
		ws.getRange2("A5").setValue("400000");

		ws.getRange2("B2").setValue("7000");
		ws.getRange2("B3").setValue("14000");
		ws.getRange2("B4").setValue("21000");
		ws.getRange2("B5").setValue("28000");

		ws.getRange2("C2").setValue("250000");

		oParser = new parserFormula("SUMIF(A2:A5,\">160000\",B2:B5)", "A7", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 63000);

		oParser = new parserFormula("SUMIF(A2:A5,\">160000\")", "A8", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 900000);

		oParser = new parserFormula("SUMIF(A2:A5,300000,B2:B5)", "A9", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 21000);

		oParser = new parserFormula("SUMIF(A2:A5,\">\" & C2,B2:B5)", "A10", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 49000);

		oParser = new parserFormula("SUMIF(A2,\">160000\",B2:B5)", "A7", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("SUMIF(A3,\">160000\",B2:B5)", "A7", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 7000);

		oParser = new parserFormula("SUMIF(A4,\">160000\",B4:B5)", "A7", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 21000);

		oParser = new parserFormula("SUMIF(A4,\">160000\")", "A7", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 300000);


		ws.getRange2("A12").setValue("Vegetables");
		ws.getRange2("A13").setValue("Vegetables");
		ws.getRange2("A14").setValue("Fruits");
		ws.getRange2("A15").setValue("");
		ws.getRange2("A16").setValue("Vegetables");
		ws.getRange2("A17").setValue("Fruits");

		ws.getRange2("B12").setValue("Tomatoes");
		ws.getRange2("B13").setValue("Celery");
		ws.getRange2("B14").setValue("Oranges");
		ws.getRange2("B15").setValue("Butter");
		ws.getRange2("B16").setValue("Carrots");
		ws.getRange2("B17").setValue("Apples");

		ws.getRange2("C12").setValue("2300");
		ws.getRange2("C13").setValue("5500");
		ws.getRange2("C14").setValue("800");
		ws.getRange2("C15").setValue("400");
		ws.getRange2("C16").setValue("4200");
		ws.getRange2("C17").setValue("1200");

		oParser = new parserFormula("SUMIF(A12:A17,\"Fruits\",C12:C17)", "A19", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2000);

		oParser = new parserFormula("SUMIF(A12:A17,\"Vegetables\",C12:C17)", "A20", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 12000);

		oParser = new parserFormula("SUMIF(B12:B17,\"*es\",C12:C17)", "A21", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4300);

		oParser = new parserFormula("SUMIF(A12:A17,\"\",C12:C17)", "A22", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 400);

	});

	QUnit.test("Test: \"SUMIFS\"", function (assert) {

		ws.getRange2("A2").setValue("5");
		ws.getRange2("A3").setValue("4");
		ws.getRange2("A4").setValue("15");
		ws.getRange2("A5").setValue("3");
		ws.getRange2("A6").setValue("22");
		ws.getRange2("A7").setValue("12");
		ws.getRange2("A8").setValue("10");
		ws.getRange2("A9").setValue("33");

		ws.getRange2("B2").setValue("Apples");
		ws.getRange2("B3").setValue("Apples");
		ws.getRange2("B4").setValue("Artichokes");
		ws.getRange2("B5").setValue("Artichokes");
		ws.getRange2("B6").setValue("Bananas");
		ws.getRange2("B7").setValue("Bananas");
		ws.getRange2("B8").setValue("Carrots");
		ws.getRange2("B9").setValue("Carrots");

		ws.getRange2("C2").setValue("Tom");
		ws.getRange2("C3").setValue("Sarah");
		ws.getRange2("C4").setValue("Tom");
		ws.getRange2("C5").setValue("Sarah");
		ws.getRange2("C6").setValue("Tom");
		ws.getRange2("C7").setValue("Sarah");
		ws.getRange2("C8").setValue("Tom");
		ws.getRange2("C9").setValue("Sarah");

		ws.getRange2("D:E").cleanAll();
		oParser = new parserFormula("SUMIFS(A2:A9, B2:B9, \"=A*\", C2:C9, \"Tom\")", "A10", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 20);

		oParser = new parserFormula("SUMIFS(A2:A9, B2:B9, \"<>Bananas\", C2:C9, \"Tom\")", "A11", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 30);

		oParser = new parserFormula("SUMIFS(D:D,E:E,$H2)", "A11", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("SUMIFS(C:D,E:E,$H2)", "A11", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// for bug 58684
		let calculateResult = new AscCommonExcel.CalculateResult(true);

		oParser = new parserFormula("SUMIFS({1,2,3},A2:A9,A2)", "A11", ws);
		assert.ok(oParser.parse(), 'SUMIFS({1,2,3},A2:A9,A2) - wrong argument type check');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Result of SUMIFS({1,2,3},A2:A9,A2) - wrong argument type check');

		oParser = new parserFormula("SUMIFS(MONTH(A2:A9),A2:A9,A2)", "A11", ws);
		assert.ok(oParser.parse(), 'SUMIFS(MONTH(A2:A9),A2:A9,A2) - wrong argument type check');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Result of SUMIFS(MONTH(A2:A9),A2:A9,A2) - wrong argument type check');

		oParser = new parserFormula("SUMIFS(A2:A9,{1,2,3},A2)", "A11", ws);
		assert.ok(oParser.parse(), 'SUMIFS(A2:A9,{1,2,3},A2) - wrong argument type check');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Result of SUMIFS(A2:A9,{1,2,3},A2) - wrong argument type check');

		oParser = new parserFormula("SUMIFS(A2:A9,A2:A9*2,A2)", "A11", ws);
		assert.ok(oParser.parse(), 'SUMIFS(A2:A9,A2:A9*2,A2) - wrong argument type check');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Result of SUMIFS(A2:A9,A2:A9*2,A2) - wrong argument type check');

		oParser = new parserFormula("SUMIFS(A2:A9,A2:A9,A2,{1,2,3},A2)", "A11", ws);
		assert.ok(oParser.parse(), 'SUMIFS(A2:A9,A2:A9,A2,{1,2,3},A2) - wrong argument type check');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Result of SUMIFS(A2:A9,A2:A9,A2,{1,2,3},A2) - wrong argument type check');

		oParser = new parserFormula("SUMIFS(A2:A9,A2:A9,A2,A2:A9*2,A2)", "A11", ws);
		assert.ok(oParser.parse(), 'SUMIFS(A2:A9,A2:A9,A2,A2:A9*2,A2) - wrong argument type check');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Result of SUMIFS(A2:A9,A2:A9,A2,A2:A9*2,A2) - wrong argument type check');


	});

	QUnit.test("Test: \"SUMIFS with multiple criteria ranges\"", function (assert) {
		// Setup test data with 5 columns for testing
		ws.getRange2("E2").setValue("10");
		ws.getRange2("E3").setValue("20");
		ws.getRange2("E4").setValue("30");
		ws.getRange2("E5").setValue("40");
		ws.getRange2("E6").setValue("50");
		ws.getRange2("E7").setValue("60");

		ws.getRange2("F2").setValue("Red");
		ws.getRange2("F3").setValue("Blue");
		ws.getRange2("F4").setValue("Green");
		ws.getRange2("F5").setValue("Red");
		ws.getRange2("F6").setValue("Blue");
		ws.getRange2("F7").setValue("Green");

		ws.getRange2("G2").setValue("Small");
		ws.getRange2("G3").setValue("Medium");
		ws.getRange2("G4").setValue("Large");
		ws.getRange2("G5").setValue("Large");
		ws.getRange2("G6").setValue("Medium");
		ws.getRange2("G7").setValue("Small");

		ws.getRange2("H2").setValue("2023");
		ws.getRange2("H3").setValue("2023");
		ws.getRange2("H4").setValue("2024");
		ws.getRange2("H5").setValue("2024");
		ws.getRange2("H6").setValue("2025");
		ws.getRange2("H7").setValue("2025");

		ws.getRange2("I2").setValue("A");
		ws.getRange2("I3").setValue("B");
		ws.getRange2("I4").setValue("C");
		ws.getRange2("I5").setValue("A");
		ws.getRange2("I6").setValue("B");
		ws.getRange2("I7").setValue("C");

		// Test with 11 arguments (1 sum_range + 5 criteria pairs)
		oParser = new parserFormula("SUMIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Large\", H2:H7, 2024, I2:I7, \"A\", I2:I7, \"*\")", "A1", ws);
		assert.ok(oParser.parse(), "SUMIFS with 5 criteria pairs");
		assert.strictEqual(oParser.calculate().getValue(), 40, "SUMIFS with 5 criteria pairs");

		// Test with 11 arguments where none match all criteria
		oParser = new parserFormula("SUMIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Small\", H2:H7, 2024, I2:I7, \"A\", I2:I7, \"Z\")", "A1", ws);
		assert.ok(oParser.parse(), "SUMIFS with 5 criteria pairs - no match");
		assert.strictEqual(oParser.calculate().getValue(), 0, "SUMIFS with 5 criteria pairs - no match");

		// Test with OR condition using multiple SUMIFS with max params
		oParser = new parserFormula("SUMIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Large\", H2:H7, 2024, I2:I7, \"A\")" +
			"+SUMIFS(E2:E7, F2:F7, \"Blue\", G2:G7, \"Medium\", H2:H7, 2025, I2:I7, \"B\")", "A1", ws);
		assert.ok(oParser.parse(), "Multiple SUMIFS with 4 criteria pairs");
		assert.strictEqual(oParser.calculate().getValue(), 40 + 50, "Multiple SUMIFS with 4 criteria pairs");


		// Test with cell references for criteria
		ws.getRange2("J2").setValue("Red");
		ws.getRange2("J3").setValue("Large");
		ws.getRange2("J4").setValue("2024");
		ws.getRange2("J5").setValue("A");
		oParser = new parserFormula("SUMIFS(E2:E7, F2:F7, J2, G2:G7, J3, H2:H7, J4, I2:I7, J5, I2:I7, \"*\")", "A1", ws);
		assert.ok(oParser.parse(), "SUMIFS with cell references for all criteria");
		assert.strictEqual(oParser.calculate().getValue(), 40, "SUMIFS with cell references for all criteria");

		// Test with complex criteria expressions
		oParser = new parserFormula("SUMIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"*\", H2:H7, \">\" & 2023, I2:I7, \"A\", I2:I7, \"<>Z\")", "A1", ws);
		assert.ok(oParser.parse(), "SUMIFS with complex criteria expressions");
		assert.strictEqual(oParser.calculate().getValue(), 40, "SUMIFS with complex criteria expressions");


		// Test with criteria that select a single row
		oParser = new parserFormula("SUMIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Large\", H2:H7, 2024, I2:I7, \"A\", E2:E7, 40)", "A1", ws);
		assert.ok(oParser.parse(), "SUMIFS with criteria selecting one row");
		assert.strictEqual(oParser.calculate().getValue(), 40, "SUMIFS with criteria selecting one row");
	});

	QUnit.test("Test: \"SUMPRODUCT\"", function (assert) {

		oParser = new parserFormula("SUMPRODUCT({2,3})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 5);

		oParser = new parserFormula("SUMPRODUCT({2,3},{4,5})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 23);

		oParser = new parserFormula("SUMPRODUCT({2,3},{4,5},{2,2})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 46);

		oParser = new parserFormula("SUMPRODUCT({2,3;4,5},{2,2;3,4})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 42);

		ws.getRange2("N44").setValue("1");
		ws.getRange2("N45").setValue("2");
		ws.getRange2("N46").setValue("3");
		ws.getRange2("N47").setValue("4");

		ws.getRange2("O44").setValue("5");
		ws.getRange2("O45").setValue("6");
		ws.getRange2("O46").setValue("7");
		ws.getRange2("O47").setValue("8");

		ws.getRange2("P44").setValue("9");
		ws.getRange2("P45").setValue("10");
		ws.getRange2("P46").setValue("11");
		ws.getRange2("P47").setValue("12");
		ws.getRange2("P48").setValue("");
		ws.getRange2("P49").setValue("");
		ws.getRange2("N48").setValue("0.456");
		ws.getRange2("O48").setValue("0.123212");

		oParser = new parserFormula("SUMPRODUCT(N44:N47,O44:O47,P44:P47)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 780);

		oParser = new parserFormula("SUMPRODUCT(N44:N47*O44:O47)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 70);

		oParser = new parserFormula("SUMPRODUCT(SUM(N44:N47*O44:O47))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 70);

		oParser = new parserFormula("SUMPRODUCT({1,2,TRUE,3})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 6);

		oParser = new parserFormula("SUMPRODUCT({1,2,FALSE,3})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 6);

		oParser = new parserFormula("SUMPRODUCT({TRUE,TRUE,FALSE,3})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("SUMPRODUCT(P48)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("SUMPRODUCT(P48, P44:P47)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("SUMPRODUCT(P48:P49)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("SUM(SUMPRODUCT(N44:N47*O44:O47))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 70);

		oParser = new parserFormula("SUMPRODUCT(N44:O47*P44:P47)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 388);

		oParser = new parserFormula("SUM(SUMPRODUCT(N44:O47*P44:P47))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 388);

		oParser = new parserFormula("SUM(SUMPRODUCT(N44:O47))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUM(SUMPRODUCT(N44:O47))");
		assert.strictEqual(oParser.calculate().getValue(), 36);

		oParser = new parserFormula("SUMPRODUCT(YEAR(N45:O47))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 11400);

		oParser = new parserFormula("SUMPRODUCT(MONTH(N45:O47))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 6);

		oParser = new parserFormula("SUMPRODUCT(DAY(N45:O47))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 30);

		oParser = new parserFormula("SUMPRODUCT(HOUR(N45:P48))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 12);

		oParser = new parserFormula("SUMPRODUCT(MINUTE(N45:P48))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 113);

		oParser = new parserFormula("SUMPRODUCT(SECOND(N45:P48))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 64);

		oParser = new parserFormula("SUMPRODUCT(DAY(N44:P49))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 78);

		oParser = new parserFormula("SUMPRODUCT(MONTH(N44:P49))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 18);

		oParser = new parserFormula("SUMPRODUCT(YEAR(N44:P49))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 34200);

		oParser = new parserFormula("SUMPRODUCT(({1,2,3})*({TRUE,TRUE,TRUE}))", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 6);

		/*oParser = new parserFormula( "SUMPRODUCT(({1,2,3})*({TRUE;TRUE;TRUE;TRUE}))", "A2", ws );
		assert.ok( oParser.parse() );
		assert.strictEqual( oParser.calculate().getValue(), 24 );*/

		oParser = new parserFormula("SUMPRODUCT({TRUE,TRUE,FALSE})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("SUMPRODUCT({1,2,3,3,TRUE})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 9);

		oParser = new parserFormula("SUMPRODUCT({1,2,3,3,TRUE})+SUMPRODUCT({1,2,3,3,TRUE})", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUMPRODUCT({1,2,3,3,TRUE})+SUMPRODUCT({1,2,3,3,TRUE})");
		assert.strictEqual(oParser.calculate().getValue(), 18);

		oParser = new parserFormula("SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE})", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE})");
		assert.strictEqual(oParser.calculate().getValue(), 81);

		oParser = new parserFormula("SUMPRODUCT(SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE}))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUMPRODUCT(SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE}))");
		assert.strictEqual(oParser.calculate().getValue(), 81);

		oParser = new parserFormula("SUM(SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE}))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUM(SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE}))");
		assert.strictEqual(oParser.calculate().getValue(), 81);

		oParser = new parserFormula("SUM(SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE}),1,2,3)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUM(SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE}),1,2,3)");
		assert.strictEqual(oParser.calculate().getValue(), 87);

		oParser = new parserFormula("SUM(SUMPRODUCT(N44:O47))+SUM(SUMPRODUCT(N44:O47))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUM(SUMPRODUCT(N44:O47))+SUM(SUMPRODUCT(N44:O47))");
		assert.strictEqual(oParser.calculate().getValue(), 72);

		oParser = new parserFormula("SUM(SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE}),SUMPRODUCT({1,2,3,3,TRUE}),2,SUMPRODUCT({1,2,3,3}))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUM(SUMPRODUCT({1,2,3,3,TRUE})*SUMPRODUCT({1,2,3,3,TRUE}),SUMPRODUCT({1,2,3,3,TRUE}),2,SUMPRODUCT({1,2,3,3}))");
		assert.strictEqual(oParser.calculate().getValue(), 101);

		ws.getRange2("A101").setValue("5");
		ws.getRange2("A102").setValue("6");
		ws.getRange2("A103").setValue("7");
		ws.getRange2("A104").setValue("8");
		ws.getRange2("A105").setValue("9");

		ws.getRange2("B101").setValue("1");
		ws.getRange2("B102").setValue("1");
		ws.getRange2("B103").setValue("0");
		ws.getRange2("B104").setValue("1");
		ws.getRange2("B105").setValue("1");

		oParser = new parserFormula("SUMPRODUCT((A101:A105)*((B101:B105)=1))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUMPRODUCT((A101:A105)*((B101:B105)=1))");
		assert.strictEqual(oParser.calculate().getValue(), 28);

		oParser = new parserFormula("SUMPRODUCT((A101:A105)*((B101:B105)=1))+SUMPRODUCT((A101:A104)*((B101:B104)=1))+SUMPRODUCT((A101:A103)*((B101:B103)=1))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUMPRODUCT((A101:A105)*((B101:B105)=1))+SUMPRODUCT((A101:A104)*((B101:B104)=1))+SUMPRODUCT((A101:A103)*((B101:B103)=1))");
		assert.strictEqual(oParser.calculate().getValue(), 58);

		oParser = new parserFormula("SUMPRODUCT(({3})*({TRUE,TRUE,TRUE,TRUE}))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUMPRODUCT(({3})*({TRUE,TRUE,TRUE,TRUE}))");
		assert.strictEqual(oParser.calculate().getValue(), 12);

		oParser = new parserFormula("SUMPRODUCT(({3;2;2;2})*({TRUE;TRUE;TRUE;TRUE}))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUMPRODUCT(({3;2;2;2})*({TRUE;TRUE;TRUE;TRUE}))");
		assert.strictEqual(oParser.calculate().getValue(), 9);

		oParser = new parserFormula("SUMPRODUCT(--ISNUMBER({5;6;7;1;2;3;4}))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUMPRODUCT(--ISNUMBER({5;6;7;1;2;3;4}))");
		assert.strictEqual(oParser.calculate().getValue(), 7);

		oParser = new parserFormula("SUMPRODUCT(--ISNUMBER(SEARCH({5;6;7;1;2;3;4},123)))", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "SUMPRODUCT(--ISNUMBER(SEARCH({5;6;7;1;2;3;4},123)))");
		assert.strictEqual(oParser.calculate().getValue(), 3);

		// for bug 68820
		ws.getRange2("B100").setValue("-2");
		ws.getRange2("B101").setValue("1");
		ws.getRange2("B102").setValue("-1");
		ws.getRange2("B103").setValue("0");
		ws.getRange2("B104").setValue("1");
		ws.getRange2("B105").setValue("1");
		ws.getRange2("B106").setValue("-2");
		ws.getRange2("B107").setValue("0");
		ws.getRange2("B108").setValue("0");
		
		oParser = new parserFormula('SUMPRODUCT(SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0)))', "A2", ws);
		assert.ok(oParser.parse(), 'SUMPRODUCT(SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0)))');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'SUMPRODUCT(SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0)))');

		oParser = new parserFormula('SUMPRODUCT(SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))*(B100:B108>0))', "A2", ws);
		assert.ok(oParser.parse(), 'SUMPRODUCT(SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))*(B100:B108>0))');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'SUMPRODUCT(SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0))*(B100:B108>0))');

		oParser = new parserFormula('SUMPRODUCT(SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),OFFSET(B100,ROW(B100:B108)-ROW(B100),0))*(B100:B108>0))', "A2", ws);
		assert.ok(oParser.parse(), 'SUMPRODUCT(SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),OFFSET(B100,ROW(B100:B108)-ROW(B100),0))*(B100:B108>0))');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'SUMPRODUCT(SUBTOTAL(9,OFFSET(B100,ROW(B100:B108)-ROW(B100),0),OFFSET(B100,ROW(B100:B108)-ROW(B100),0))*(B100:B108>0))');

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A104").setValue("5");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A105").setValue("6");
		ws.getRange2("A106").setValue("7");
		ws.getRange2("A107").setValue("8");
		ws.getRange2("A108").setValue("9");
		ws.getRange2("A109").setValue("10");
		ws.getRange2("A110").setValue("11");
		ws.getRange2("A111").setValue("11");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		ws.getRange2("C601").setValue("123rds"); // Text (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: arrays with 2 numbers each. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Number. Basic valid input: arrays with 2 numbers each. 2 arguments used.');
		// Case #2: Number. Arrays with 3 numbers each. 3 arguments used.
		oParser = new parserFormula('SUMPRODUCT({1,2,3},{4,5,6},{7,8,9})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({1,2,3},{4,5,6},{7,8,9}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 270, 'Test: Positive case: Number. Arrays with 3 numbers each. 3 arguments used.');
		// Case #3: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({"1","2"},{"3","4"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({"1","2"},{"3","4"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #4: Formula. Arrays with numbers from formulas. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({2,2},{3,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({2,2},{3,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Formula. Arrays with numbers from formulas. 2 arguments used.');
		// Case #5: Reference link. Reference to ranges with numbers (1,2,3,4). 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Reference link. Reference to ranges with numbers (1,2,3,4). 2 arguments used.');
		// Case #6: Area. Ranges with 3 cells each (1,2,3; 4,5,6). 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(A100:A102,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 32, 'Test: Positive case: Area. Ranges with 3 cells each (1,2,3; 4,5,6). 2 arguments used.');
		// Case #7: Array. Arrays with float numbers. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({0.1,0.2},{0.3,0.4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({0.1,0.2},{0.3,0.4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.11000000000000001, 'Test: Positive case: Array. Arrays with float numbers. 2 arguments used.');
		// Case #8: Name. Named ranges with numbers (1,2; 3,4). 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.25, 'Test: Positive case: Name. Named ranges with numbers (1,2; 3,4). 2 arguments used.');
		// Case #9: Name3D. 3D named ranges with numbers (1,2; 3,4). 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Name3D. 3D named ranges with numbers (1,2; 3,4). 2 arguments used.');
		// Case #10: Ref3D. 3D references to ranges (1,2; 3,4). 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D references to ranges (1,2; 3,4). 2 arguments used.');
		// Case #11: Area3D. 3D ranges with 3 cells each (1,2,3; 4,5,6). 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(Sheet2!A1:A3,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(Sheet2!A1:A3,Sheet2!A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D ranges with 3 cells each (1,2,3; 4,5,6). 2 arguments used.');
		// Case #12: Table. Table references with numbers (1,2; 3,4). 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(Table1[Column1],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Table. Table references with numbers (1,2; 3,4). 2 arguments used.');
		// Case #13: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({38777,38778},{38838,38839})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({38777,38778},{38838,38839}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3012119868, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #14: Time. Time values as fractions. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({0.5,0.6},{0.7,0.8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({0.5,0.6},{0.7,0.8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.83, 'Test: Positive case: Time. Time values as fractions. 2 arguments used.');
		// Case #15: Formula. Nested IF returning array. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(IF(TRUE,{1,2},{3,4}),{5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(IF(TRUE,{1,2},{3,4}),{5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 17, 'Test: Positive case: Formula. Nested IF returning array. 2 arguments used.');
		// Case #16: Number. Single array with 2 numbers. 1 argument used.
		oParser = new parserFormula('SUMPRODUCT({1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number. Single array with 2 numbers. 1 argument used.');
		// Case #17: String. Strings with float numbers. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({"1.5","2.5"},{"3.5","4.5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({"1.5","2.5"},{"3.5","4.5"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Strings with float numbers. 2 arguments used.');
		// Case #18: Array. Arrays with 4 numbers each. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({1,2,3,4},{5,6,7,8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({1,2,3,4},{5,6,7,8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Positive case: Array. Arrays with 4 numbers each. 2 arguments used.');
		// Case #19: Formula. Arrays with formula-generated numbers. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({2,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({2,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14, 'Test: Positive case: Formula. Arrays with formula-generated numbers. 2 arguments used.');
		// Case #20: Reference link. Single range with numbers (1,2,3). 1 argument used.
		oParser = new parserFormula('SUMPRODUCT(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Reference link. Single range with numbers (1,2,3). 1 argument used.');
		// Case #21: Name. Single named range with numbers (1,2). 1 argument used.
		oParser = new parserFormula('SUMPRODUCT(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Single named range with numbers (1,2). 1 argument used.');
		// Case #22: Area3D. Single 3D range with numbers (1,2). 1 argument used.
		oParser = new parserFormula('SUMPRODUCT(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. Single 3D range with numbers (1,2). 1 argument used.');

		// Negative cases:
		// Case #1: Number. Negative numbers are valid but included for completeness. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({0.5,-1},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({0.5,-1},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Negative case: Number. Negative numbers are valid but included for completeness. 2 arguments used.');
		// Case #2: String. Non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({"abc","2"},{"3","4"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({"abc","2"},{"3","4"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String. Non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #3: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(NA(),2,3,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(NA(),2,3,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #4: Empty. Empty array returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({""},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({""},{3,4}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty array returns #VALUE!. 2 arguments used.');
		// Case #5: Boolean. Booleans treated as 1/0, valid but included for testing. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({TRUE,FALSE},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({TRUE,FALSE},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Booleans treated as 1/0, valid but included for testing. 2 arguments used.');
		// Case #6: Area. Mismatched range sizes (3 vs 2 cells) returns #VALUE!.
		oParser = new parserFormula('SUMPRODUCT(A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(A100:A102,A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Mismatched range sizes (3 vs 2 cells) returns #VALUE!.');
		// Case #7: Reference link. Reference to empty range returns #VALUE!.
		oParser = new parserFormula('SUMPRODUCT(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Negative case: Reference link. Reference to empty range returns #VALUE!.');
		// Case #8: String. Empty string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({"","2"},{"3","4"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({"","2"},{"3","4"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String. Empty string returns #VALUE!. 2 arguments used.');
		// Case #9: Ref3D. Mismatched 3D range sizes returns #VALUE!.
		oParser = new parserFormula('SUMPRODUCT(Sheet2!A5:A6,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(Sheet2!A5:A6,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. Mismatched 3D range sizes returns #VALUE!.');
		// Case #10: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('SUMPRODUCT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('SUMPRODUCT(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(TestNameArea3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #12: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('SUMPRODUCT(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(Table1[Column3]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #13: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT(SQRT(-1),2,{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(SQRT(-1),2,{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.');
		// Case #14: Number. All zeros return 0, valid but tested for edge case. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({0,0},{0,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({0,0},{0,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. All zeros return 0, valid but tested for edge case. 2 arguments used.');
		// Case #15: Array. Arrays with booleans treated as 1/0, valid but tested. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({TRUE,TRUE},{FALSE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({TRUE,TRUE},{FALSE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Arrays with booleans treated as 1/0, valid but tested. 2 arguments used.');
		// Case #16: Number. Mismatched array sizes returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({1},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({1},{2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Mismatched array sizes returns #VALUE!. 2 arguments used.');
		// Case #17: Reference link. Mismatched range sizes (2 vs 1 cell) returns #VALUE!.
		oParser = new parserFormula('SUMPRODUCT(A100:A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(A100:A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Mismatched range sizes (2 vs 1 cell) returns #VALUE!.');
		// Case #18: Area3D. Mismatched 3D range sizes returns #VALUE!.
		oParser = new parserFormula('SUMPRODUCT(Sheet2!A1:A2,Sheet2!A3:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(Sheet2!A1:A2,Sheet2!A3:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. Mismatched 3D range sizes returns #VALUE!.');
		// Case #19: Name. Mismatched named range sizes returns #VALUE!.
		oParser = new parserFormula('SUMPRODUCT(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT(TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.25, 'Test: Negative case: Name. Mismatched named range sizes returns #VALUE!.');
		// Case #20: Date. Valid dates as serial numbers, included for completeness. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({38777,38778},{38778,38777})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({38777,38778},{38778,38777}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3007389012, 'Test: Negative case: Date. Valid dates as serial numbers, included for completeness. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid number (1). 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({1,1},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({1,1},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Number. Minimum valid number (1). 2 arguments used.');
		// Case #2: Number. Maximum valid Excel number. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({9.99999999999999E+307,1},{1,9.99999999999999E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({9.99999999999999E+307,1},{1,9.99999999999999E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number. 2 arguments used.');
		// Case #3: Date. Maximum valid Excel date (12/31/9999 as serial number). 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({2958465,2958465},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({2958465,2958465},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5916930, 'Test: Bounded case: Date. Maximum valid Excel date (12/31/9999 as serial number). 2 arguments used.');
		// Case #4: Number. Minimum positive Excel number. 2 arguments used.
		oParser = new parserFormula('SUMPRODUCT({2.2E-308,2.2E-308},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMPRODUCT({2.2E-308,2.2E-308},{1,1}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum positive Excel number. 2 arguments used.');

		// Need to fix: ms resultl diff with arrays, table handle, boudary case diff
		// Case #3: String. Strings convertible to numbers. 2 arguments used.
		// Case #17: String. Strings with float numbers. 2 arguments used.
		// Case #2: String. Non-numeric string returns #VALUE!. 2 arguments used
		// Case #4: Empty. Empty array returns #VALUE!. 2 arguments used.
		// Case #6: Area. Mismatched range sizes (3 vs 2 cells) returns #VALUE!.
		// Case #8: String. Empty string returns #VALUE!. 2 arguments used.
		// Case #10: Name. Named range with text returns #VALUE!.
		// Case #11: Name3D. 3D named range with text returns #VALUE!.
		// Case #16: Number. Mismatched array sizes returns #VALUE!. 2 arguments used.
		// Case #17: Reference link. Mismatched range sizes (2 vs 1 cell) returns #VALUE!.
		// Case #18: Area3D. Mismatched 3D range sizes returns #VALUE!.
		// Case #12: Table. Table references with numbers (1,2; 3,4). 2 arguments used.
		// Case #4: Number. Minimum positive Excel number. 2 arguments used.


		testArrayFormula2(assert, "SUMPRODUCT", 1, 8, null, true);
	});

	QUnit.test("Test: \"SUMSQ\"", function (assert) {
		oParser = new parserFormula("SUMSQ(2.5,-3.6,2.4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2.5 * 2.5 + 3.6 * 3.6 + 2.4 * 2.4);

		oParser = new parserFormula("SUMSQ(2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		oParser = new parserFormula("SUMSQ(150,50)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 150 * 150 + 50 * 50);

		oParser = new parserFormula("SUMSQ(150,\"f\")", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: single integer. 1 argument used.
		oParser = new parserFormula('SUMSQ(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Number. Basic valid input: single integer. 1 argument used.');
		// Case #2: Number. Float input. 1 argument used.
		oParser = new parserFormula('SUMSQ(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #3: Number. Multiple integer inputs. 3 arguments used.
		oParser = new parserFormula('SUMSQ(1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14, 'Test: Positive case: Number. Multiple integer inputs. 3 arguments used.');
		// Case #5: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('SUMSQ("10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ("10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #6: String. Multiple numeric strings converted to numbers. 3 arguments used.
		oParser = new parserFormula('SUMSQ("1","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ("1","2","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14, 'Test: Positive case: String. Multiple numeric strings converted to numbers. 3 arguments used.');
		// Case #7: Formula. Nested formula returning valid number. 1 argument used.
		oParser = new parserFormula('SUMSQ(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Nested formula returning valid number. 1 argument used.');
		// Case #8: Formula. Multiple nested formulas. 3 arguments used.
		oParser = new parserFormula('SUMSQ(SQRT(4),ABS(-5),ROUND(3.6,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(SQRT(4),ABS(-5),ROUND(3.6,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45, 'Test: Positive case: Formula. Multiple nested formulas. 3 arguments used.');
		// Case #9: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('SUMSQ(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #10: Area. Single-cell range. 1 argument used.
		oParser = new parserFormula('SUMSQ(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Positive case: Area. Single-cell range. 1 argument used.');
		// Case #11: Array. Array with multiple elements. 1 argument used.
		oParser = new parserFormula('SUMSQ({1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ({1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14, 'Test: Positive case: Array. Array with multiple elements. 1 argument used.');
		// Case #12: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('SUMSQ(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #13: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('SUMSQ(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #14: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('SUMSQ(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #15: Area3D. 3D single-cell range. 1 argument used.
		oParser = new parserFormula('SUMSQ(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Area3D. 3D single-cell range. 1 argument used.');
		// Case #16: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('SUMSQ(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #17: Date. Date as serial number. 1 argument used.
		oParser = new parserFormula('SUMSQ(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2084652964, 'Test: Positive case: Date. Date as serial number. 1 argument used.');
		// Case #18: Time. Time adjusted to valid number. 1 argument used.
		oParser = new parserFormula('SUMSQ(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Positive case: Time. Time adjusted to valid number. 1 argument used.');
		// Case #19: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('SUMSQ(IF(TRUE,10,5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(IF(TRUE,10,5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');
		// Case #20: Formula. SUM as nested formula. 2 arguments used.
		oParser = new parserFormula('SUMSQ(SUM(1,2),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(SUM(1,2),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18, 'Test: Positive case: Formula. SUM as nested formula. 2 arguments used.');
		// Case #21: Area. Multi-cell range with valid numbers. 1 argument used.
		oParser = new parserFormula('SUMSQ(A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(A101:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Area. Multi-cell range with valid numbers. 1 argument used.');
		// Case #22: String. Numeric strings with decimal points. 2 arguments used.
		oParser = new parserFormula('SUMSQ("1.5","2.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ("1.5","2.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.5, 'Test: Positive case: String. Numeric strings with decimal points. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('SUMSQ(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #3: Error. Propagates #DIV/0! error. 1 argument used.
		oParser = new parserFormula('SUMSQ(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Propagates #DIV/0! error. 1 argument used.');
		// Case #4: Boolean. Boolean treated as number (TRUE=1). 1 argument used.
		oParser = new parserFormula('SUMSQ(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean treated as number (TRUE=1). 1 argument used.');
		// Case #5: Boolean. Boolean treated as number (FALSE=0). 1 argument used.
		oParser = new parserFormula('SUMSQ(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean treated as number (FALSE=0). 1 argument used.');
		// Case #6: Empty. Reference to empty cell returns 0. 1 argument used.
		oParser = new parserFormula('SUMSQ(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Reference to empty cell returns 0. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Area. Range with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ(A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Area. Range with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #9: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.28', 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.28', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('SUMSQ(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #14: String. Invalid numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ("0.5abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ("0.5abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Invalid numeric string returns #VALUE!. 1 argument used.');
		// Case #15: Array. Array with booleans treated as numbers (1,0). 1 argument used.
		oParser = new parserFormula('SUMSQ({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ({TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with booleans treated as numbers (1,0). 1 argument used.');
		// Case #16: Array. Array with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ({"abc",1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ({"abc",1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Array with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #17: Area3D. 3D range with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('SUMSQ(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D range with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #18: Number,String. Mixed valid and invalid inputs returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SUMSQ(10,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(10,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. Mixed valid and invalid inputs returns #VALUE!. 2 arguments used.');
		// Case #19: Formula,Error. Mixed valid number and error propagates #N/A. 2 arguments used.
		oParser = new parserFormula('SUMSQ(5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula,Error. Mixed valid number and error propagates #N/A. 2 arguments used.');
		// Case #20: Reference link. Reference to cell with error value propagates error. 1 argument used.
		oParser = new parserFormula('SUMSQ(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to cell with error value propagates error. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('SUMSQ(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #2: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('SUMSQ(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #3: Number. Smallest non-zero positive value. 1 argument used.
		oParser = new parserFormula('SUMSQ(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest non-zero positive value. 1 argument used.');
		// Case #4: Number. Smallest non-zero negative value. 1 argument used.
		oParser = new parserFormula('SUMSQ(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMSQ(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest non-zero negative value. 1 argument used.');

		// Need to fix: string handle as table link
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.

		testArrayFormula2(assert, "SUMSQ", 1, 8, null, true);
	});

	QUnit.test("Test: \"SUMX2MY2\"", function (assert) {

		ws.getRange2("A101").setValue("5");
		ws.getRange2("A102").setValue("6");
		ws.getRange2("A103").setValue("test1");
		ws.getRange2("A104").setValue("");
		ws.getRange2("A105").setValue("false");

		ws.getRange2("B101").setValue("1");
		ws.getRange2("B102").setValue("1");
		ws.getRange2("B103").setValue("test2");
		ws.getRange2("B104").setValue("");
		ws.getRange2("B105").setValue("false");

		oParser = new parserFormula("SUMX2MY2({2,3,9,1,8,7,5},{6,5,11,7,5,4,4})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -55);

		oParser = new parserFormula("SUMX2MY2({2,3,9;1,8,7},{6,5,11;7,5,4})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -64);

		oParser = new parserFormula("SUMX2MY2(7,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 24);

		oParser = new parserFormula("SUMX2MY2(A101,B101)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 24);

		oParser = new parserFormula("SUMX2MY2(A103,B103)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("SUMX2MY2(A101:A102,B101:B102)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 59);

		/*oParser = new parserFormula( "SUMX2MY2(A101:A105,B101:B105)", "A1", ws );
		assert.ok( oParser.parse() );
		assert.strictEqual( oParser.calculate().getValue(), 59 );*/

		oParser = new parserFormula("SUMX2MY2(A105,B105)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Array. Basic valid input: arrays with integer elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -20, 'Test: Positive case: Array. Basic valid input: arrays with integer elements. 2 of 2 arguments used.');
		// Case #2: Array. Arrays with float numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({1.5,2.5},{3.5,4.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({1.5,2.5},{3.5,4.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -24, 'Test: Positive case: Array. Arrays with float numbers. 2 of 2 arguments used.');
		// Case #3: String. String arrays convertible to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({"1","2"},{"3","4"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({"1","2"},{"3","4"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String arrays convertible to numbers. 2 of 2 arguments used.');
		// Case #4: Formula. Single-cell ranges with formula-generated references to arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Formula. Single-cell ranges with formula-generated references to arrays. 2 of 2 arguments used.');
		// Case #5: Reference link. Reference to cells with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Reference link. Reference to cells with valid arrays. 2 of 2 arguments used.');
		// Case #6: Area. Single-cell ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area. Single-cell ranges with valid arrays. 2 of 2 arguments used.');
		// Case #7: Area. Two-cell ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A104:A105,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A104:A105,A106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area. Two-cell ranges with valid arrays. 2 of 2 arguments used.');
		// Case #8: Table. Table structured references with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured references with valid arrays. 2 of 2 arguments used.');
		// Case #9: Ref3D. 3D references to cells with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Positive case: Ref3D. 3D references to cells with valid arrays. 2 of 2 arguments used.');
		// Case #10: Area3D. 3D single-cell ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid arrays. 2 of 2 arguments used.');
		// Case #11: Name. Named ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -110, 'Test: Positive case: Name. Named ranges with valid arrays. 2 of 2 arguments used.');
		// Case #12: Name3D. 3D named ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named ranges with valid arrays. 2 of 2 arguments used.');
		// Case #13: Formula. Nested IF formulas returning valid array references. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(IF(TRUE,A100,A101),IF(TRUE,A101,A100))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(IF(TRUE,A100,A101),IF(TRUE,A101,A100)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Formula. Nested IF formulas returning valid array references. 2 of 2 arguments used.');
		// Case #14: Formula. SUMX2MY2 nested in SUM formula. 2 of 2 arguments used.
		oParser = new parserFormula('SUM(SUMX2MY2(A100,A101),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SUMX2MY2(A100,A101),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Formula. SUMX2MY2 nested in SUM formula. 2 of 2 arguments used.');
		// Case #15: Array. Single-element arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({1},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({1},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -8, 'Test: Positive case: Array. Single-element arrays. 2 of 2 arguments used.');
		// Case #16: String. String arrays with decimal numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({"1.5","2.5"},{"3.5","4.5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({"1.5","2.5"},{"3.5","4.5"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String arrays with decimal numbers. 2 of 2 arguments used.');
		// Case #17: Date. Date serial numbers as array elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({45656,45657},{45658,45659})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({45656,45657},{45658,45659}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -365260, 'Test: Positive case: Date. Date serial numbers as array elements. 2 of 2 arguments used.');
		// Case #18: Time. Time values (1hr, 2hr, 3hr, 4hr) as array elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({0.04167,0.08333},{0.125,0.16667})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({0.04167,0.08333},{0.125,0.16667}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.0347236111, 'Test: Positive case: Time. Time values (1hr, 2hr, 3hr, 4hr) as array elements. 2 of 2 arguments used.');
		// Case #19: Array. Arrays with three elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -63, 'Test: Positive case: Array. Arrays with three elements. 2 of 2 arguments used.');
		// Case #20: Reference link. Reference to cells with larger numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. Reference to cells with larger numbers. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Non-array inputs return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Negative case: Number. Non-array inputs return #VALUE!. 2 of 2 arguments used.');
		// Case #2: String. Non-array string inputs return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2("1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2("1","2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-array string inputs return #VALUE!. 2 of 2 arguments used.');
		// Case #3: Empty. Empty arguments return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty arguments return #VALUE!. 2 of 2 arguments used.');
		// Case #4: Error. Error in first argument propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(NA(),A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(NA(),A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in first argument propagates #N/A. 2 of 2 arguments used.');
		// Case #5: Array. Mismatched array lengths return #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({1,2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({1,2},{3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Mismatched array lengths return #N/A. 2 of 2 arguments used.');
		// Case #6: Array. Non-numeric array element returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({1,"abc"},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({1,"abc"},{3,4}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -8, 'Test: Negative case: Array. Non-numeric array element returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Boolean. Boolean array elements return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({TRUE,FALSE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({TRUE,FALSE},{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean array elements return #VALUE!. 2 of 2 arguments used.');
		// Case #8: Reference link. Reference to cells with non-numeric data returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A110,A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A110,A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to cells with non-numeric data returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: Area. Multi-cell ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A102:A103,A104:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.75, 'Test: Negative case: Area. Multi-cell ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #10: Table. Table columns with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(Table1[Column2],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Table. Table columns with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #11: Ref3D. 3D references to non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D references to non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #12: Area3D. 3D ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(Sheet2!A7:A8,Sheet2!A9:A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(Sheet2!A7:A8,Sheet2!A9:A10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #13: Name. Named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #14: Name3D. 3D named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #15: Array. Empty arrays return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({""},{""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({""},{""}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Empty arrays return #VALUE!. 2 of 2 arguments used.');
		// Case #16: Reference link. Reference to empty cells returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A110,A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A110,A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to empty cells returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Formula. Formula resulting in #DIV/0! propagates error. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A100/0,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A100/0,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 2 of 2 arguments used.');
		// Case #18: Area. Ranges with more than 2 cells return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2(A102:A104,A105:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2(A102:A104,A105:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.75, 'Test: Negative case: Area. Ranges with more than 2 cells return #VALUE!. 2 of 2 arguments used.');
		// Case #19: Array. Negative overflow in computation returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({-1E+307,1},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({-1E+307,1},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Negative overflow in computation returns #NUM!. 2 of 2 arguments used.');
		// Case #20: Array. Overflow in computation returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({1E+307,1},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({1E+307,1},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Overflow in computation returns #NUM!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Array. Minimum array size (single element). 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Minimum array size (single element). 2 of 2 arguments used.');
		// Case #2: Array. Maximum valid Excel number in arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({9.99999999999999E+307},{9.99999999999999E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({9.99999999999999E+307},{9.99999999999999E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array. Maximum valid Excel number in arrays. 2 of 2 arguments used.');
		// Case #3: Array. Minimum positive number in arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2MY2({1E-307},{1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2MY2({1E-307},{1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Minimum positive number in arrays. 2 of 2 arguments used.');

		// Need to fix: error type difference, empty arg handle

		testArrayFormula2(assert, "SUMX2MY2", 2, 2, null, true);
	});

	QUnit.test("Test: \"SUMX2PY2\"", function (assert) {

		ws.getRange2("A101").setValue("5");
		ws.getRange2("A102").setValue("6");
		ws.getRange2("A103").setValue("test1");
		ws.getRange2("A104").setValue("");
		ws.getRange2("A105").setValue("false");

		ws.getRange2("B101").setValue("1");
		ws.getRange2("B102").setValue("1");
		ws.getRange2("B103").setValue("test2");
		ws.getRange2("B104").setValue("");
		ws.getRange2("B105").setValue("false");

		oParser = new parserFormula("SUMX2PY2({2,3,9,1,8,7,5},{6,5,11,7,5,4,4})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 521);

		oParser = new parserFormula("SUMX2PY2({2,3,9;1,8,7},{6,5,11;7,5,4})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 480);

		oParser = new parserFormula("SUMX2PY2(7,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 74);


		oParser = new parserFormula("SUMX2PY2(A101,B101)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 26);

		oParser = new parserFormula("SUMX2PY2(A103,B103)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("SUMX2PY2(A101:A102,B101:B102)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 63);

		oParser = new parserFormula("SUMX2PY2(A105,B105)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Array. Basic valid input: arrays with integer elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Array. Basic valid input: arrays with integer elements. 2 of 2 arguments used.');
		// Case #2: Array. Arrays with float numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({1.5,2.5},{3.5,4.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({1.5,2.5},{3.5,4.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 41, 'Test: Positive case: Array. Arrays with float numbers. 2 of 2 arguments used.');
		// Case #3: String. String arrays convertible to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({"1","2"},{"3","4"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({"1","2"},{"3","4"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String arrays convertible to numbers. 2 of 2 arguments used.');
		// Case #4: Formula. Single-cell ranges with formula-generated references to arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Formula. Single-cell ranges with formula-generated references to arrays. 2 of 2 arguments used.');
		// Case #5: Reference link. Reference to cells with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Reference link. Reference to cells with valid arrays. 2 of 2 arguments used.');
		// Case #6: Area. Single-cell ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area. Single-cell ranges with valid arrays. 2 of 2 arguments used.');
		// Case #7: Area. Two-cell ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A104:A105,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A104:A105,A106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area. Two-cell ranges with valid arrays. 2 of 2 arguments used.');
		// Case #8: Table. Table structured references with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Table. Table structured references with valid arrays. 2 of 2 arguments used.');
		// Case #9: Ref3D. 3D references to cells with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Ref3D. 3D references to cells with valid arrays. 2 of 2 arguments used.');
		// Case #10: Area3D. 3D single-cell ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid arrays. 2 of 2 arguments used.');
		// Case #11: Name. Named ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110.5, 'Test: Positive case: Name. Named ranges with valid arrays. 2 of 2 arguments used.');
		// Case #12: Name3D. 3D named ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name3D. 3D named ranges with valid arrays. 2 of 2 arguments used.');
		// Case #13: Formula. Nested IF formulas returning valid array references. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(IF(TRUE,A100,A101),IF(TRUE,A101,A100))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(IF(TRUE,A100,A101),IF(TRUE,A101,A100)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Formula. Nested IF formulas returning valid array references. 2 of 2 arguments used.');
		// Case #14: Formula. SUMX2MY2 nested in SUM formula. 2 of 2 arguments used.
		oParser = new parserFormula('SUM(SUMX2PY2(A100,A101),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SUMX2PY2(A100,A101),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.5, 'Test: Positive case: Formula. SUMX2MY2 nested in SUM formula. 2 of 2 arguments used.');
		// Case #15: Array. Single-element arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({1},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({1},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Array. Single-element arrays. 2 of 2 arguments used.');
		// Case #16: String. String arrays with decimal numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({"1.5","2.5"},{"3.5","4.5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({"1.5","2.5"},{"3.5","4.5"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String arrays with decimal numbers. 2 of 2 arguments used.');
		// Case #17: Date. Date serial numbers as array elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({45656,45657},{45658,45659})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({45656,45657},{45658,45659}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8338429230, 'Test: Positive case: Date. Date serial numbers as array elements. 2 of 2 arguments used.');
		// Case #18: Time. Time values (1hr, 2hr, 3hr, 4hr) as array elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({0.04167,0.08333},{0.125,0.16667})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({0.04167,0.08333},{0.125,0.16667}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.052084166700000004, 'Test: Positive case: Time. Time values (1hr, 2hr, 3hr, 4hr) as array elements. 2 of 2 arguments used.');
		// Case #19: Array. Arrays with three elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 91, 'Test: Positive case: Array. Arrays with three elements. 2 of 2 arguments used.');
		// Case #20: Reference link. Reference to cells with larger numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. Reference to cells with larger numbers. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Non-array inputs return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Number. Non-array inputs return #VALUE!. 2 of 2 arguments used.');
		// Case #2: String. Non-array string inputs return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2("1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2("1","2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-array string inputs return #VALUE!. 2 of 2 arguments used.');
		// Case #3: Empty. Empty arguments return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty arguments return #VALUE!. 2 of 2 arguments used.');
		// Case #4: Error. Error in first argument propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(NA(),A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(NA(),A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in first argument propagates #N/A. 2 of 2 arguments used.');
		// Case #5: Array. Mismatched array lengths return #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({1,2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({1,2},{3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Mismatched array lengths return #N/A. 2 of 2 arguments used.');
		// Case #6: Array. Non-numeric array element returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({1,"abc"},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({1,"abc"},{3,4}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Array. Non-numeric array element returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Boolean. Boolean array elements return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({TRUE,FALSE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({TRUE,FALSE},{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean array elements return #VALUE!. 2 of 2 arguments used.');
		// Case #8: Reference link. Reference to cells with non-numeric data returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A110,A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A110,A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to cells with non-numeric data returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: Area. Multi-cell ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A102:A103,A104:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Negative case: Area. Multi-cell ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #10: Table. Table columns with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table columns with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #11: Ref3D. 3D references to non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D references to non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #12: Area3D. 3D ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(Sheet2!A7:A8,Sheet2!A9:A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(Sheet2!A7:A8,Sheet2!A9:A10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #13: Name. Named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '2.56', 'Test: Negative case: Name. Named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #14: Name3D. 3D named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '2.56', 'Test: Negative case: Name3D. 3D named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #15: Array. Empty arrays return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({""},{""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({""},{""}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Empty arrays return #VALUE!. 2 of 2 arguments used.');
		// Case #16: Reference link. Reference to empty cells returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A110,A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A110,A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to empty cells returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Formula. Formula resulting in #DIV/0! propagates error. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A100/0,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A100/0,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 2 of 2 arguments used.');
		// Case #18: Area. Ranges with more than 2 cells return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2(A102:A104,A105:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2(A102:A104,A105:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Negative case: Area. Ranges with more than 2 cells return #VALUE!. 2 of 2 arguments used.');
		// Case #19: Array. Negative overflow in computation returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({-1E+307,1},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({-1E+307,1},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Negative overflow in computation returns #NUM!. 2 of 2 arguments used.');
		// Case #20: Array. Overflow in computation returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({1E+307,1},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({1E+307,1},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Overflow in computation returns #NUM!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Array. Minimum array size (single element). 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Array. Minimum array size (single element). 2 of 2 arguments used.');
		// Case #2: Array. Maximum valid Excel number in arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({9.99999999999999E+307},{9.99999999999999E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({9.99999999999999E+307},{9.99999999999999E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array. Maximum valid Excel number in arrays. 2 of 2 arguments used.');
		// Case #3: Array. Minimum positive number in arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMX2PY2({1E-307},{1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMX2PY2({1E-307},{1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Minimum positive number in arrays. 2 of 2 arguments used.');

		// Need to fix: string handle, bool handle, empty handle, error types diff

		testArrayFormula2(assert, "SUMX2PY2", 2, 2, null, true);
	});

	QUnit.test("Test: \"SUMXMY2\"", function (assert) {

		ws.getRange2("A101").setValue("5");
		ws.getRange2("A102").setValue("6");
		ws.getRange2("A103").setValue("test1");
		ws.getRange2("A104").setValue("");
		ws.getRange2("A105").setValue("false");

		ws.getRange2("B101").setValue("1");
		ws.getRange2("B102").setValue("1");
		ws.getRange2("B103").setValue("test2");
		ws.getRange2("B104").setValue("");
		ws.getRange2("B105").setValue("false");

		oParser = new parserFormula("SUMXMY2(A101,B101)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 16);

		oParser = new parserFormula("SUMXMY2(A103,B103)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("SUMXMY2(A101:A102,B101:B102)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 41);

		oParser = new parserFormula("SUMXMY2(A105,B105)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("SUMXMY2({2,3,9,1,8,7,5},{6,5,11,7,5,4,4})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 79);

		oParser = new parserFormula("SUMXMY2({2,3,9;1,8,7},{6,5,11;7,5,4})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 78);

		oParser = new parserFormula("SUMXMY2(7,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Array. Basic valid input: arrays with integer elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Array. Basic valid input: arrays with integer elements. 2 of 2 arguments used.');
		// Case #2: Array. Arrays with float numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({1.5,2.5},{3.5,4.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({1.5,2.5},{3.5,4.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Array. Arrays with float numbers. 2 of 2 arguments used.');
		// Case #3: String. String arrays convertible to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({"1","2"},{"3","4"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({"1","2"},{"3","4"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String arrays convertible to numbers. 2 of 2 arguments used.');
		// Case #4: Formula. Single-cell ranges with formula-generated references to arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Single-cell ranges with formula-generated references to arrays. 2 of 2 arguments used.');
		// Case #5: Reference link. Reference to cells with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference to cells with valid arrays. 2 of 2 arguments used.');
		// Case #6: Area. Single-cell ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area. Single-cell ranges with valid arrays. 2 of 2 arguments used.');
		// Case #7: Area. Two-cell ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A104:A105,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A104:A105,A106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area. Two-cell ranges with valid arrays. 2 of 2 arguments used.');
		// Case #8: Table. Table structured references with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured references with valid arrays. 2 of 2 arguments used.');
		// Case #9: Ref3D. 3D references to cells with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D references to cells with valid arrays. 2 of 2 arguments used.');
		// Case #10: Area3D. 3D single-cell ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid arrays. 2 of 2 arguments used.');
		// Case #11: Name. Named ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Name. Named ranges with valid arrays. 2 of 2 arguments used.');
		// Case #12: Name3D. 3D named ranges with valid arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named ranges with valid arrays. 2 of 2 arguments used.');
		// Case #13: Formula. Nested IF formulas returning valid array references. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(IF(TRUE,A100,A101),IF(TRUE,A101,A100))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(IF(TRUE,A100,A101),IF(TRUE,A101,A100)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested IF formulas returning valid array references. 2 of 2 arguments used.');
		// Case #14: Formula. SUMX2MY2 nested in SUM formula. 2 of 2 arguments used.
		oParser = new parserFormula('SUM(SUMXMY2(A100,A101),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SUMXMY2(A100,A101),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Formula. SUMX2MY2 nested in SUM formula. 2 of 2 arguments used.');
		// Case #15: Array. Single-element arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({1},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({1},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Array. Single-element arrays. 2 of 2 arguments used.');
		// Case #16: String. String arrays with decimal numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({"1.5","2.5"},{"3.5","4.5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({"1.5","2.5"},{"3.5","4.5"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String arrays with decimal numbers. 2 of 2 arguments used.');
		// Case #17: Date. Date serial numbers as array elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({45656,45657},{45658,45659})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({45656,45657},{45658,45659}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Date. Date serial numbers as array elements. 2 of 2 arguments used.');
		// Case #18: Time. Time values (1hr, 2hr, 3hr, 4hr) as array elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({0.04167,0.08333},{0.125,0.16667})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({0.04167,0.08333},{0.125,0.16667}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.013889444500000002, 'Test: Positive case: Time. Time values (1hr, 2hr, 3hr, 4hr) as array elements. 2 of 2 arguments used.');
		// Case #19: Array. Arrays with three elements. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 27, 'Test: Positive case: Array. Arrays with three elements. 2 of 2 arguments used.');
		// Case #20: Reference link. Reference to cells with larger numbers. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. Reference to cells with larger numbers. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Non-array inputs return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Non-array inputs return #VALUE!. 2 of 2 arguments used.');
		// Case #2: String. Non-array string inputs return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2("1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2("1","2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-array string inputs return #VALUE!. 2 of 2 arguments used.');
		// Case #3: Empty. Empty arguments return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty arguments return #VALUE!. 2 of 2 arguments used.');
		// Case #4: Error. Error in first argument propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(NA(),A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(NA(),A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in first argument propagates #N/A. 2 of 2 arguments used.');
		// Case #5: Array. Mismatched array lengths return #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({1,2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({1,2},{3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Mismatched array lengths return #N/A. 2 of 2 arguments used.');
		// Case #6: Array. Non-numeric array element returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({1,"abc"},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({1,"abc"},{3,4}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Negative case: Array. Non-numeric array element returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Boolean. Boolean array elements return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({TRUE,FALSE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({TRUE,FALSE},{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean array elements return #VALUE!. 2 of 2 arguments used.');
		// Case #8: Reference link. Reference to cells with non-numeric data returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A110,A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A110,A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to cells with non-numeric data returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: Area. Multi-cell ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A102:A103,A104:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Negative case: Area. Multi-cell ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #10: Table. Table columns with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 	"#VALUE!", 'Test: Negative case: Table. Table columns with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #11: Ref3D. 3D references to non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D references to non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #12: Area3D. 3D ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(Sheet2!A7:A8,Sheet2!A9:A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(Sheet2!A7:A8,Sheet2!A9:A10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #13: Name. Named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #14: Name3D. 3D named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named ranges with non-numeric data return #VALUE!. 2 of 2 arguments used.');
		// Case #15: Array. Empty arrays return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({""},{""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({""},{""}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Empty arrays return #VALUE!. 2 of 2 arguments used.');
		// Case #16: Reference link. Reference to empty cells returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A110,A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A110,A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Reference to empty cells returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Formula. Formula resulting in #DIV/0! propagates error. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A100/0,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A100/0,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 2 of 2 arguments used.');
		// Case #18: Area. Ranges with more than 2 cells return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2(A102:A104,A105:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2(A102:A104,A105:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Area. Ranges with more than 2 cells return #VALUE!. 2 of 2 arguments used.');
		// Case #19: Array. Negative overflow in computation returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({-1E+308,1},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({-1E+308,1},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Negative overflow in computation returns #NUM!. 2 of 2 arguments used.');
		// Case #20: Array. Overflow in computation returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({1E+308,1},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({1E+308,1},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Overflow in computation returns #NUM!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Array. Minimum array size (single element). 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Minimum array size (single element). 2 of 2 arguments used.');
		// Case #2: Array. Maximum valid Excel number in arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({9.99999999999999E+307},{9.99999999999999E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({9.99999999999999E+307},{9.99999999999999E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Maximum valid Excel number in arrays. 2 of 2 arguments used.');
		// Case #3: Array. Minimum positive number in arrays. 2 of 2 arguments used.
		oParser = new parserFormula('SUMXMY2({1E-307},{1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUMXMY2({1E-307},{1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Minimum positive number in arrays. 2 of 2 arguments used.');

		// Need to fix: bool,string,empty,array handle, error types diff in results

		testArrayFormula2(assert, "SUMXMY2", 2, 2, null, true)
	});

	QUnit.test("Test: \"TAN\"", function (assert) {

		oParser = new parserFormula("TAN(0.785)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 0.99920);

		oParser = new parserFormula("TAN(45*PI()/180)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: zero radians. 1 argument used.
		oParser = new parserFormula('TAN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: zero radians. 1 argument used.');
		// Case #2: Number. Approximation of ?/2 radians, returns ~1. 1 argument used.
		oParser = new parserFormula('TAN(1.5708)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(1.5708) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -272241.80840927624, 'Test: Positive case: Number. Approximation of ?/2 radians, returns ~1. 1 argument used.');
		// Case #3: Number. Negative angle, returns ~-1. 1 argument used.
		oParser = new parserFormula('TAN(-1.5708)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(-1.5708) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 272241.80840927624, 'Test: Positive case: Number. Negative angle, returns ~-1. 1 argument used.');
		// Case #4: Formula. Nested formula converting degrees to radians, returns ~1. 1 argument used.
		oParser = new parserFormula('TAN(RADIANS(90))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(RADIANS(90)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16331239353195370, 'Test: Positive case: Formula. Nested formula converting degrees to radians, returns ~1. 1 argument used.');
		// Case #5: Formula. Nested formula resulting in valid number (2). 1 argument used.
		oParser = new parserFormula('TAN(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.185039863261519, 'Test: Positive case: Formula. Nested formula resulting in valid number (2). 1 argument used.');
		// Case #6: Reference link. Reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('TAN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5463024898437905, 'Test: Positive case: Reference link. Reference to cell with valid number (0). 1 argument used.');
		// Case #7: Area. Single-cell range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TAN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.101419947171719, 'Test: Positive case: Area. Single-cell range with valid number (1.5708). 1 argument used.');
		// Case #8: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('TAN({1.5708})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN({1.5708}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -272241.80840927624, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #9: Name. Named range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TAN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5463024898437905, 'Test: Positive case: Name. Named range with valid number (1.5708). 1 argument used.');
		// Case #10: Name3D. 3D named range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TAN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5463024898437905, 'Test: Positive case: Name3D. 3D named range with valid number (1.5708). 1 argument used.');
		// Case #11: Ref3D. 3D reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('TAN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5574077246549023, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (0). 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TAN(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.185039863261519, 'Test: Positive case: Area3D. 3D single-cell range with valid number (1.5708). 1 argument used.');
		// Case #13: Table. Table structured reference with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TAN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5574077246549023, 'Test: Positive case: Table. Table structured reference with valid number (1.5708). 1 argument used.');
		// Case #14: Formula. Nested IF returning valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TAN(IF(TRUE, 1.5708, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(IF(TRUE, 1.5708, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -272241.80840927624, 'Test: Positive case: Formula. Nested IF returning valid number (1.5708). 1 argument used.');
		// Case #15: Formula. Date as serial number, valid input. 1 argument used.
		oParser = new parserFormula('TAN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.855712853901801, 'Test: Positive case: Formula. Date as serial number, valid input. 1 argument used.');
		// Case #16: Formula. Time as fraction of day, valid input. 1 argument used.
		oParser = new parserFormula('TAN(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5463024898437905, 'Test: Positive case: Formula. Time as fraction of day, valid input. 1 argument used.');
		// Case #17: Formula. Nested formula returning positive number. 1 argument used.
		oParser = new parserFormula('TAN(ABS(-1.5708))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(ABS(-1.5708)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -272241.80840927624, 'Test: Positive case: Formula. Nested formula returning positive number. 1 argument used.');
		// Case #18: String. String convertible to valid number. 1 argument used.
		oParser = new parserFormula('TAN("1.5708")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN("1.5708") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -272241.80840927624, 'Test: Positive case: String. String convertible to valid number. 1 argument used.');
		// Case #19: Formula. SIN as part of SUM formula, returns ~1. 1 argument used.
		oParser = new parserFormula('SUM(TAN(1.5708), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(TAN(1.5708), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -272241.80840927624, 'Test: Positive case: Formula. SIN as part of SUM formula, returns ~1. 1 argument used.');
		// Case #20: Number. Approximation of ? radians, returns ~0. 1 argument used.
		oParser = new parserFormula('TAN(3.1416)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(3.1416) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.000007346410206841829, 'Test: Positive case: Number. Approximation of ? radians, returns ~0. 1 argument used.');
		// Case #21: String. String convertible to zero. 1 argument used.
		oParser = new parserFormula('TAN("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String convertible to zero. 1 argument used.');
		// Case #22: Array. Array with multiple valid elements, processes first element (0). 1 argument used.
		oParser = new parserFormula('TAN({0, 1.5708})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN({0, 1.5708}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array. Array with multiple valid elements, processes first element (0). 1 argument used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('TAN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #3: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.54630249, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #4: Empty. Reference to empty cell returns 0 (Excel treats as 0). 1 argument used.
		oParser = new parserFormula('TAN(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.5574077246549023, 'Test: Negative case: Empty. Reference to empty cell returns 0 (Excel treats as 0). 1 argument used.');
		// Case #5: Boolean. Boolean TRUE (1) returns ~0.8415, but testing for type handling. 1 argument used.
		oParser = new parserFormula('TAN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5574077246549023, 'Test: Negative case: Boolean. Boolean TRUE (1) returns ~0.8415, but testing for type handling. 1 argument used.');
		// Case #6: Boolean. Boolean FALSE (0) returns 0, but testing for type handling. 1 argument used.
		oParser = new parserFormula('TAN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean FALSE (0) returns 0, but testing for type handling. 1 argument used.');
		// Case #7: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0296385570503641, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #8: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0296385570503641, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Ref3D. 3D reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #10: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(Sheet2!A4:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #11: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #12: Formula. Nested formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('TAN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #13: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #14: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('TAN(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.');
		// Case #15: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN({TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1.5574077246549023, 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');
		// Case #16: Array. Array with mixed valid and invalid elements, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN({1, "abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN({1, "abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1.5574077246549023, 'Test: Negative case: Array. Array with mixed valid and invalid elements, returns #VALUE!. 1 argument used.');
		// Case #17: Formula. Nested formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('TAN(MMULT(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(MMULT(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Formula. Nested formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #18: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5574077246549023, 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #19: Area. Area with text in one cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TAN(A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(A106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Area with text in one cell returns #VALUE!. 1 argument used.');
		// Case #20: Formula. String convertible to number exceeding limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('TAN("1E+309")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN("1E+309") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. String convertible to number exceeding limit returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.
		oParser = new parserFormula('TAN(1E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(1E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.');
		// Case #2: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.
		oParser = new parserFormula('TAN(-1E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(-1E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.');
		// Case #3: Number. Largest number Excel can handle, returns valid sine value. 1 argument used.
		oParser = new parserFormula('TAN(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TAN(1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Largest number Excel can handle, returns valid sine value. 1 argument used.');

		// Need to fix: area handle, diff results from ms, boundary cases
		// Case #3: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #10: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		// Case #14: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.
		// Case #19: Area. Area with text in one cell returns #VALUE!. 1 argument used.


		testArrayFormula(assert, "TAN");
	});

	QUnit.test("Test: \"TANH\"", function (assert) {

		oParser = new parserFormula("TANH(0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("TANH(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(difBetween(oParser.calculate().getValue(), ((Math.E * Math.E - 1) / (Math.E * Math.E + 1))), true);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: zero radians. 1 argument used.
		oParser = new parserFormula('TANH(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: zero radians. 1 argument used.');
		// Case #2: Number. Approximation of ?/2 radians, returns ~1. 1 argument used.
		oParser = new parserFormula('TANH(1.5708)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(1.5708) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9171529190863275, 'Test: Positive case: Number. Approximation of ?/2 radians, returns ~1. 1 argument used.');
		// Case #3: Number. Negative angle, returns ~-1. 1 argument used.
		oParser = new parserFormula('TANH(-1.5708)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(-1.5708) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.9171529190863275, 'Test: Positive case: Number. Negative angle, returns ~-1. 1 argument used.');
		// Case #4: Formula. Nested formula converting degrees to radians, returns ~1. 1 argument used.
		oParser = new parserFormula('TANH(RADIANS(90))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(RADIANS(90)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9171523356672744, 'Test: Positive case: Formula. Nested formula converting degrees to radians, returns ~1. 1 argument used.');
		// Case #5: Formula. Nested formula resulting in valid number (2). 1 argument used.
		oParser = new parserFormula('TANH(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9640275800758169, 'Test: Positive case: Formula. Nested formula resulting in valid number (2). 1 argument used.');
		// Case #6: Reference link. Reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('TANH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46211715726000974, 'Test: Positive case: Reference link. Reference to cell with valid number (0). 1 argument used.');
		// Case #7: Area. Single-cell range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TANH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9051482536448664, 'Test: Positive case: Area. Single-cell range with valid number (1.5708). 1 argument used.');
		// Case #8: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('TANH({1.5708})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH({1.5708}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.9171529190863275, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #9: Name. Named range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TANH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.46211715726000974, 'Test: Positive case: Name. Named range with valid number (1.5708). 1 argument used.');
		// Case #10: Name3D. 3D named range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TANH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.46211715726000974, 'Test: Positive case: Name3D. 3D named range with valid number (1.5708). 1 argument used.');
		// Case #11: Ref3D. 3D reference to cell with valid number (0). 1 argument used.
		oParser = new parserFormula('TANH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7615941559557649, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (0). 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TANH(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9640275800758169, 'Test: Positive case: Area3D. 3D single-cell range with valid number (1.5708). 1 argument used.');
		// Case #13: Table. Table structured reference with valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TANH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7615941559557649, 'Test: Positive case: Table. Table structured reference with valid number (1.5708). 1 argument used.');
		// Case #14: Formula. Nested IF returning valid number (1.5708). 1 argument used.
		oParser = new parserFormula('TANH(IF(TRUE, 1.5708, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(IF(TRUE, 1.5708, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9171529190863275, 'Test: Positive case: Formula. Nested IF returning valid number (1.5708). 1 argument used.');
		// Case #15: Formula. Date as serial number, valid input. 1 argument used.
		oParser = new parserFormula('TANH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Date as serial number, valid input. 1 argument used.');
		// Case #16: Formula. Time as fraction of day, valid input. 1 argument used.
		oParser = new parserFormula('TANH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46211715726000974, 'Test: Positive case: Formula. Time as fraction of day, valid input. 1 argument used.');
		// Case #17: Formula. Nested formula returning positive number. 1 argument used.
		oParser = new parserFormula('TANH(ABS(-1.5708))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(ABS(-1.5708)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9171529190863275, 'Test: Positive case: Formula. Nested formula returning positive number. 1 argument used.');
		// Case #18: String. String convertible to valid number. 1 argument used.
		oParser = new parserFormula('TANH("1.5708")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH("1.5708") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9171529190863275, 'Test: Positive case: String. String convertible to valid number. 1 argument used.');
		// Case #19: Formula. SIN as part of SUM formula, returns ~1. 1 argument used.
		oParser = new parserFormula('SUM(TANH(1.5708), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(TANH(1.5708), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9171529190863275, 'Test: Positive case: Formula. SIN as part of SUM formula, returns ~1. 1 argument used.');
		// Case #20: Number. Approximation of ? radians, returns ~0. 1 argument used.
		oParser = new parserFormula('TANH(3.1416)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(3.1416) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9962721308919683, 'Test: Positive case: Number. Approximation of ? radians, returns ~0. 1 argument used.');
		// Case #21: String. String convertible to zero. 1 argument used.
		oParser = new parserFormula('TANH("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String convertible to zero. 1 argument used.');
		// Case #22: Array. Array with multiple valid elements, processes first element (0). 1 argument used.
		oParser = new parserFormula('TANH({0, 1.5708})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH({0, 1.5708}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array. Array with multiple valid elements, processes first element (0). 1 argument used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('TANH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #3: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.462117157, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #4: Empty. Reference to empty cell returns 0 (Excel treats as 0). 1 argument used.
		oParser = new parserFormula('TANH(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.7615941559557649, 'Test: Negative case: Empty. Reference to empty cell returns 0 (Excel treats as 0). 1 argument used.');
		// Case #5: Boolean. Boolean TRUE (1) returns ~0.8415, but testing for type handling. 1 argument used.
		oParser = new parserFormula('TANH(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7615941559557649, 'Test: Negative case: Boolean. Boolean TRUE (1) returns ~0.8415, but testing for type handling. 1 argument used.');
		// Case #6: Boolean. Boolean FALSE (0) returns 0, but testing for type handling. 1 argument used.
		oParser = new parserFormula('TANH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean FALSE (0) returns 0, but testing for type handling. 1 argument used.');
		// Case #7: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6640367702678491, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #8: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6640367702678491, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Ref3D. 3D reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #10: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(Sheet2!A4:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #11: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #12: Formula. Nested formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('TANH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #13: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #14: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('TANH(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Number exceeding Excels limit returns #NUM!. 1 argument used.');
		// Case #15: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH({TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.7615941559557649, 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');
		// Case #16: Array. Array with mixed valid and invalid elements, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH({1, "abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH({1, "abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.7615941559557649, 'Test: Negative case: Array. Array with mixed valid and invalid elements, returns #VALUE!. 1 argument used.');
		// Case #17: Formula. Nested formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('TANH(MMULT(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(MMULT(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Formula. Nested formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #18: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7615941559557649, 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!. 1 argument used.');
		// Case #19: Area. Area with text in one cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('TANH(A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(A106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Area with text in one cell returns #VALUE!. 1 argument used.');
		// Case #20: Formula. String convertible to number exceeding limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('TANH("1E+309")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH("1E+309") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. String convertible to number exceeding limit returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.
		oParser = new parserFormula('TANH(1E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(1E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.');
		// Case #2: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.
		oParser = new parserFormula('TANH(-1E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(-1E-308) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.');
		// Case #3: Number. Largest number Excel can handle, returns valid sine value. 1 argument used.
		oParser = new parserFormula('TANH(1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TANH(1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Largest number Excel can handle, returns valid sine value. 1 argument used.');

		// Need to fix: ms results diff, area handle
		// Case #3: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #10: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		// Case #19: Area. Area with text in one cell returns #VALUE!. 1 argument used.
		// Case #1: Number. Smallest positive number Excel can handle, returns ~1E-308. 1 argument used.
		// Case #2: Number. Smallest negative number Excel can handle, returns ~-1E-308. 1 argument used.


		testArrayFormula(assert, "TANH");
	});

	QUnit.test("Test: \"TRUNC\"", function (assert) {
		let array;
		// https://0.30000000000000004.com/
		oParser = new parserFormula("TRUNC(PI())", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("TRUNC(PI(),3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3.141);

		oParser = new parserFormula("TRUNC(PI(),-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("TRUNC(-PI(),2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -3.14);

		oParser = new parserFormula("TRUNC(8.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 8);

		oParser = new parserFormula("TRUNC(-8.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -8);

		oParser = new parserFormula("TRUNC(0.45)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);


		oParser = new parserFormula("TRUNC(43214)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 43214);

		oParser = new parserFormula("TRUNC(43214.43214)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 43214);

		oParser = new parserFormula("TRUNC(43214.43214, 0.25678)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 43214);

		oParser = new parserFormula("TRUNC(43214.43214, 1.25678)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 43214.4);

		oParser = new parserFormula("TRUNC(-43214.43214, 1.25678)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -43214.4);

		oParser = new parserFormula("TRUNC(-43214.43214, -2.25678)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -43200);

		oParser = new parserFormula("TRUNC(43214.43214, -2.25678)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 43200);

		oParser = new parserFormula("TRUNC(44.3244, -2.25678)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("TRUNC(444.3244, -2.25678)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 400);

		oParser = new parserFormula("TRUNC(0.43214, 10)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.43214);

		oParser = new parserFormula("TRUNC(0.4321443214432144321443214432144321443214, 100)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.43214432144321435);

		oParser = new parserFormula("TRUNC(43214, 10)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 43214);

		oParser = new parserFormula("TRUNC(43214, -2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 43200);

		oParser = new parserFormula("TRUNC(43214, -10)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("TRUNC(34123.123, -2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 34100);

		oParser = new parserFormula("TRUNC(123.23423,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 123.2);

		// bool
		oParser = new parserFormula("TRUNC(TRUE,1)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(TRUE,1)");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of TRUNC(TRUE,1)");

		oParser = new parserFormula("TRUNC(FALSE,1)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(FALSE,1)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of TRUNC(FALSE,1)");

		oParser = new parserFormula("TRUNC(123.123,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(123.123,TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), 123.1, "Result of TRUNC(123.123,TRUE)");

		oParser = new parserFormula("TRUNC(123.123,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(123.123,FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), 123, "Result of TRUNC(123.123,FALSE)");

		oParser = new parserFormula("TRUNC(TRUE,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(TRUE,TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of TRUNC(TRUE,TRUE)");

		oParser = new parserFormula("TRUNC(FALSE,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(FALSE,FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of TRUNC(FALSE,FALSE)");

		// string
		oParser = new parserFormula("TRUNC(\"string\",1)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(string,1)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of TRUNC(string,1)");

		oParser = new parserFormula("TRUNC(\"252.252\",1)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('252.252',1)");
		assert.strictEqual(oParser.calculate().getValue(), 252.2, "Result of TRUNC('252.252',1)");

		oParser = new parserFormula("TRUNC(\"252.252s\",1)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('252.252s',1)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of TRUNC('252.252s',1)");

		oParser = new parserFormula("TRUNC(\"252.252\",\"1\")", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('252.252','1')");
		assert.strictEqual(oParser.calculate().getValue(), 252.2, "Result of TRUNC('252.252','1')");

		oParser = new parserFormula("TRUNC(\"252.252\",\"1s\")", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('252.252','1s')");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of TRUNC('252.252','1s')");
		
		ws.getRange2("E101").setValue("123.335");
		ws.getRange2("E102").setValue("2");
		ws.getRange2("E103").setValue("231.13");
		ws.getRange2("E104").setValue("959.00001");
		ws.getRange2("E105").setValue("0.30000000000000004");
		ws.getRange2("E106").setValue("1.7999999999999998");
		ws.getRange2("E107").setValue("str");
		ws.getRange2("E108").setValue("TRUE");
		ws.getRange2("E109").setValue("#N/A");
		ws.getRange2("E110").setValue("");
		ws.getRange2("E111").setValue();
		ws.getRange2("E112").setValue("22.22");
		ws.getRange2("E112").setNumFormat("@");

		// cell|cellsrange
		oParser = new parserFormula("TRUNC(E101,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('252.252','1')");
		assert.strictEqual(oParser.calculate().getValue(), 123.33, "Result of TRUNC('252.252','1')");

		oParser = new parserFormula("TRUNC(E101:E101,E102:E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('252.252','1')");
		assert.strictEqual(oParser.calculate().getValue(), 123.33, "Result of TRUNC('252.252','1')");

		oParser = new parserFormula("TRUNC(E101:E102,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(E101:E102,'1')");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of TRUNC(E101:E102,'1')");

		oParser = new parserFormula("TRUNC(E101,E102:E104)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(E101,E102:E104)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of TRUNC(E101,E102:E104)");

		oParser = new parserFormula("TRUNC(E106,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(E106,2)");
		assert.strictEqual(oParser.calculate().getValue(), 1.79, "Result of TRUNC(E106,2)");

		oParser = new parserFormula("TRUNC(E107,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('str',2)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of TRUNC('str',2)");

		oParser = new parserFormula("TRUNC(E108,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('22.22','2')");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of TRUNC('22.22','2')");

		oParser = new parserFormula("TRUNC(E109,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('22.22','2')");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of TRUNC('22.22','2')");

		oParser = new parserFormula("TRUNC(E110,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('22.22','2')");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of TRUNC('22.22','2')");

		oParser = new parserFormula("TRUNC(E111,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('22.22','2')");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of TRUNC('22.22','2')");

		oParser = new parserFormula("TRUNC(E112,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('22.22','2')");
		assert.strictEqual(oParser.calculate().getValue(), 22.22, "Result of TRUNC('22.22','2')");

		oParser = new parserFormula("TRUNC(,2)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(,2)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of TRUNC(,2)");
		
		oParser = new parserFormula("TRUNC(2,E110)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(2,'')");
		assert.strictEqual(oParser.calculate().getValue(), 2, "Result of TRUNC(2,'')");

		oParser = new parserFormula("TRUNC(2,E111)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(2,'')");
		assert.strictEqual(oParser.calculate().getValue(), 2, "Result of TRUNC(2,'')");

		oParser = new parserFormula("TRUNC(2,)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(2,)");
		assert.strictEqual(oParser.calculate().getValue(), 2, "Result of TRUNC(2,)");


		oParser = new parserFormula("TRUNC(E101:E101,E102)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC('252.252','1')");
		assert.strictEqual(oParser.calculate().getValue(), 123.33, "Result of TRUNC('252.252','1')");

		// array
		oParser = new parserFormula("TRUNC({2,3,5,12},2)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC({2,3,5,12},2)");
		assert.strictEqual(oParser.calculate().getValue(), 2, "Result of TRUNC({2,3,5,12},2)");

		oParser = new parserFormula("TRUNC({999.025,3,5,12},2)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC({999.025,3,5,12},2)");
		assert.strictEqual(oParser.calculate().getValue(), 999.02, "Result of TRUNC({999.025,3,5,12},2)");

		oParser = new parserFormula("TRUNC({999.025,3,5,12},{3,2,25})", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC({999.025,3,5,12},{3,2,25})");
		assert.strictEqual(oParser.calculate().getValue(), 999.025, "Result of TRUNC({999.025,3,5,12},{3,2,25})");

		// err
		oParser = new parserFormula("TRUNC(#N/A,2)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(#N/A,2)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of TRUNC(#N/A,2)");

		oParser = new parserFormula("TRUNC(2,#VALUE!)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(2,#VALUE!)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of TRUNC(2,#VALUE!)");

		oParser = new parserFormula("TRUNC(#N/A,#VALUE!)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(#N/A,#VALUE!)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of TRUNC(#N/A,#VALUE!)");

		// bug cases
		oParser = new parserFormula("TRUNC(2.1999999999999997,1)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(2.1999999999999997,1)");
		assert.strictEqual(oParser.calculate().getValue(), 2.1, "Result of TRUNC(2.1999999999999997,1)");

		oParser = new parserFormula("TRUNC((0.6*3),1)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC((0.6*3),1)");
		assert.strictEqual(oParser.calculate().getValue(), 1.8, "Result of TRUNC((0.6*3),1)");

		oParser = new parserFormula("TRUNC((0.4*1)+(0.6*3),1)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC((0.4*1)+(0.6*3),1)");
		assert.strictEqual(oParser.calculate().getValue(), 2.1, "Result of TRUNC((0.4*1)+(0.6*3),1)");	// 2.2

		oParser = new parserFormula("TRUNC(0.1+0.2,1)", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC(0.1+0.2,1)");
		assert.strictEqual(oParser.calculate().getValue(), 0.3, "Result of TRUNC(0.1+0.2,1)");

		// for bug 41030
		ws.getRange2("A1:C2").cleanAll();

		oParser = new parserFormula("TRUNC({12,4},{1,2})", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC({12,4},{1,2})");
		oParser.setArrayFormulaRef(ws.getRange2("A1:C2").bbox);
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 12);
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 4);

		oParser = new parserFormula("TRUNC({12,4},{1,2,3})", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC({12,4},{1,2,3})");
		oParser.setArrayFormulaRef(ws.getRange2("A1:C2").bbox);
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 12);
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 4);

		oParser = new parserFormula("TRUNC({12,4,2},{1,2})", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC({12,4,2},{1,2})");
		oParser.setArrayFormulaRef(ws.getRange2("A1:C2").bbox);
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 12);
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 4);

		oParser = new parserFormula("TRUNC({12,4,2},{1,2,3})", "A1", ws);
		assert.ok(oParser.parse(), "TRUNC({12,4,2},{1,2,3})");
		oParser.setArrayFormulaRef(ws.getRange2("A1:C2").bbox);
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 12);
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 4);
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 2);

		oParser = new parserFormula('TRUNC({12,"Str",2},{1,2,3})', "A1", ws);
		assert.ok(oParser.parse(), 'TRUNC({12,"Str",2},{1,2,3})');
		oParser.setArrayFormulaRef(ws.getRange2("A1:C2").bbox);
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 12);
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 2);

		oParser = new parserFormula('TRUNC({12,4,2},{1,"str",3})', "A1", ws);
		assert.ok(oParser.parse(), 'TRUNC({12,4,2},{1,"str",3})');
		oParser.setArrayFormulaRef(ws.getRange2("A1:C2").bbox);
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 12);
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 2);

		oParser = new parserFormula('TRUNC({12,"Str",2},"str")', "A1", ws);
		assert.ok(oParser.parse(), 'TRUNC({12,"Str",2},"str")');
		oParser.setArrayFormulaRef(ws.getRange2("A1:C2").bbox);
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), "#VALUE!");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), "#VALUE!");

		testArrayFormula2(assert, "TRUNC", 1, 2);
	});

	QUnit.test("Test: \"SEQUENCE\"", function (assert) {

		ws.getRange2("G10").setValue("");
		ws.getRange2("G11").setValue();
		ws.getRange2("G12").setValue("10");
		ws.getRange2("G13").setValue("-10");
		ws.getRange2("G14").setValue("TRUE");
		ws.getRange2("G15").setValue("FALSE");
		ws.getRange2("G16").setValue("2s");
		ws.getRange2("G17").setValue("#N/A");
		ws.getRange2("G18").setValue("{2;3;4;5}");
		// vertical test
		ws.getRange2("G19").setValue("1");
		ws.getRange2("G20").setValue("2");
		ws.getRange2("G21").setValue("3");
		ws.getRange2("G22").setValue("4");
		// horizontal test
		ws.getRange2("H19").setValue("1");
		ws.getRange2("I19").setValue("2");
		ws.getRange2("J19").setValue("3");
		ws.getRange2("K19").setValue("4");

		ws.getRange2("C102").setValue("1");
		ws.getRange2("D102").setValue("2");
		ws.getRange2("E102").setValue("3");
		ws.getRange2("F102").setValue("4");
		ws.getRange2("E103").setValue("");
		ws.getRange2("F103").setValue("");

		// cellsRange
		oParser = new parserFormula('SEQUENCE(G19:G22)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G19:G22)');
		let array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(G19:G22)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(G19:G22)[0,1]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 1, "Result of SEQUENCE(G19:G22)[1,0]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 1, "Result of SEQUENCE(G19:G22)[2,0]");
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), 1, "Result of SEQUENCE(G19:G22)[3,0]");

		oParser = new parserFormula('SEQUENCE(C102:F102,C102:D102,E102:F103)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(C102:F102,C102:D102,E102:F103)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 3, "Result of SEQUENCE(C102:F102,C102:D102,E102:F103)[0,0]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 0, "Result of SEQUENCE(C102:F102,C102:D102,E102:F103)[1,0]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), "", "Result of SEQUENCE(C102:F102,C102:D102,E102:F103)[2,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 4, "Result of SEQUENCE(C102:F102,C102:D102,E102:F103)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 0, "Result of SEQUENCE(C102:F102,C102:D102,E102:F103)[1,1]");
		assert.strictEqual(array.getElementRowCol(2, 1).getValue(), "", "Result of SEQUENCE(C102:F102,C102:D102,E102:F103)[2,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), "#N/A", "Result of SEQUENCE(C102:F102,C102:D102,E102:F103)[0,2]");
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), "#N/A", "Result of SEQUENCE(C102:F102,C102:D102,E102:F103)[1,2]");		
		assert.strictEqual(array.getElementRowCol(2, 2).getValue(), "", "Result of SEQUENCE(C102:F102,C102:D102,E102:F103)[2,2]");

		oParser = new parserFormula('SEQUENCE(G19:G22, G19:G20, G21:G22)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G19:G22, G19:G20, G21:G22)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 3, "Result of SEQUENCE(G19:G22, G19:G20, G21:G22)[0,0]");		
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(G19:G22, G19:G20, G21:G22)[0,1]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 4, "Result of SEQUENCE(G19:G22, G19:G20, G21:G22)[1,0]");		
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), "#N/A", "Result of SEQUENCE(G19:G22, G19:G20, G21:G22)[2,0]");		
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), "#N/A", "Result of SEQUENCE(G19:G22, G19:G20, G21:G22)[3,0]");

		oParser = new parserFormula('SEQUENCE(H19:K19, H19:I19, J19:K19)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(H19:K19, H19:I19, J19:K19)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 3, "Result of SEQUENCE(H19:K19, H19:I19, J19:K19)[0,0]");		
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 4, "Result of SEQUENCE(H19:K19, H19:I19, J19:K19)[0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), "#N/A", "Result of SEQUENCE(H19:K19, H19:I19, J19:K19)[0,2]");
		assert.strictEqual(array.getElementRowCol(0, 3).getValue(), "#N/A", "Result of SEQUENCE(H19:K19, H19:I19, J19:K19)[0,3]");	
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(H19:K19, H19:I19, J19:K19)[1,0]");

		oParser = new parserFormula('SEQUENCE(H19:K19, H19:I19, J19)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(H19:K19, H19:I19, J19)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 3, "Result of SEQUENCE(H19:K19, H19:I19, J19)[0,0]");		
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 3, "Result of SEQUENCE(H19:K19, H19:I19, J19)[0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), "#N/A", "Result of SEQUENCE(H19:K19, H19:I19, J19)[0,2]");
		assert.strictEqual(array.getElementRowCol(0, 3).getValue(), "#N/A", "Result of SEQUENCE(H19:K19, H19:I19, J19)[0,3]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(H19:K19, H19:I19, J19)[1,0]");


		oParser = new parserFormula('SEQUENCE(G10)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G10)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G10)");	// #CALC!

		oParser = new parserFormula('SEQUENCE(G11)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G11)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G11)"); 	// #CALC!

		oParser = new parserFormula('SEQUENCE(G10,2)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G10,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G10,2)"); // #CALC!

		oParser = new parserFormula('SEQUENCE(G11,2)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G11,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G11,2)"); // #CALC!

		oParser = new parserFormula("SEQUENCE(G12)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(G12)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(10)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(10)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(10)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(10)[1,1]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 3, "Result of SEQUENCE(10)[2,0]");
		assert.strictEqual(array.getElementRowCol(5, 0).getValue(), 6, "Result of SEQUENCE(10)[5,0]");
		assert.strictEqual(array.getElementRowCol(9, 0).getValue(), 10, "Result of SEQUENCE(10)[9,0]");

		oParser = new parserFormula('SEQUENCE(G13)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G13)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G13)");

		oParser = new parserFormula('SEQUENCE(G14)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G14)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(G14)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(G14)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(G14)[1,0]");

		oParser = new parserFormula('SEQUENCE(G15)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G15)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G15)"); 	// #CALC!

		oParser = new parserFormula('SEQUENCE(G16)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G16)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G16)");

		oParser = new parserFormula('SEQUENCE(G17)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G17)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of SEQUENCE(G17)");

		oParser = new parserFormula('SEQUENCE(G18)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G18)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G18)");

		// arg[0] tests (rows)
		oParser = new parserFormula("SEQUENCE(2)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(2)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(2)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(2)[1,1]");

		oParser = new parserFormula("SEQUENCE(0.9)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(0.9)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(0.9)");	// #CALC!

		oParser = new parserFormula("SEQUENCE(2.9)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(2.9)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2.9)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(2.9)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2.9)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(2.9)[1,1]");

		oParser = new parserFormula("SEQUENCE(,2)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(,2)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(,2)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(,2)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(,2)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(,2)[1,1]");

		oParser = new parserFormula("SEQUENCE(-2)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(-2)");
		array = oParser.calculate();
		assert.strictEqual(array.getValue(), "#VALUE!");

		oParser = new parserFormula('SEQUENCE("2")', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE("2")');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE('2')[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE('2')[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE('2')[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE('2')[1,1]");

		oParser = new parserFormula('SEQUENCE("2s")', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE("2s")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE('2s')");

		oParser = new parserFormula('SEQUENCE(TRUE)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(TRUE)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(TRUE)");

		oParser = new parserFormula('SEQUENCE(FALSE)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(FALSE)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(FALSE)");		// #CALC!

		oParser = new parserFormula("SEQUENCE(,)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(,)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(,)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(,)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(,)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(,)[1,1]");

		oParser = new parserFormula("SEQUENCE(,,)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(,,)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(,,)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(,,)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(,,)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(,,)[1,1]");

		oParser = new parserFormula("SEQUENCE(,,,)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(,,,)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(,,,)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(,,,)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(,,,)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(,,,)[1,1]");

		oParser = new parserFormula("SEQUENCE(,,,2)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(,,,2)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(,,,2)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(,,,2)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(,,,2)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(,,,2)[1,1]");

		// arg[1] tests (columns)
		oParser = new parserFormula("SEQUENCE(2,3)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(2,3)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2,3)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,3)[0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 3, "Result of SEQUENCE(2,3)[0,2]");
		assert.strictEqual(array.getElementRowCol(0, 3).getValue(), "", "Result of SEQUENCE(2,3)[0,3]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 4, "Result of SEQUENCE(2,3)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 5, "Result of SEQUENCE(2,3)[1,1]");
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 6, "Result of SEQUENCE(2,3)[1,2]");
		assert.strictEqual(array.getElementRowCol(1, 3).getValue(), "", "Result of SEQUENCE(2,3)[1,3]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), "", "Result of SEQUENCE(2,3)[2,0]");

		oParser = new parserFormula("SEQUENCE(1,1)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(1,1)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(1,1)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(1,1)[0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), "#N/A", "Result of SEQUENCE(1,1)[0,2]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(1,1)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(1,1)[1,1]");
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), "#N/A", "Result of SEQUENCE(1,1)[1,2]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), "#N/A", "Result of SEQUENCE(1,1)[2,0]");

		oParser = new parserFormula("SEQUENCE(1,2)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(1,2)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(1,2)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(1,2)[0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), "", "Result of SEQUENCE(1,2)[0,2]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE(1,2)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(1,2)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,"2")', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,"2")');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2,'2')[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,'2')[0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), "", "Result of SEQUENCE(2,'2')[0,2]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3, "Result of SEQUENCE(2,'2')[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, "Result of SEQUENCE(2,'2')[1,1]");

		oParser = new parserFormula('SEQUENCE(2,"2s")', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,"2s")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,'2s')");

		oParser = new parserFormula('SEQUENCE(2,TRUE)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,TRUE)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2,TRUE)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(2,TRUE)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,TRUE)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(2,TRUE)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,FALSE)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,FALSE)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,FALSE)");		// #CALC!

		oParser = new parserFormula('SEQUENCE(2,G10)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,G10)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,G10)");		// #CALC!

		oParser = new parserFormula('SEQUENCE(2,G11)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,G11)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,G11)"); 	// #CALC!

		oParser = new parserFormula("SEQUENCE(2,G12)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(2,G12)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2,10)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,10)[0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 3, "Result of SEQUENCE(2,10)[0,2]");
		assert.strictEqual(array.getElementRowCol(0, 3).getValue(), 4, "Result of SEQUENCE(2,10)[0,3]");
		assert.strictEqual(array.getElementRowCol(0, 5).getValue(), 6, "Result of SEQUENCE(2,10)[0,5]");
		assert.strictEqual(array.getElementRowCol(0, 9).getValue(), 10, "Result of SEQUENCE(2,10)[0,9]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 11, "Result of SEQUENCE(2,10)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 12, "Result of SEQUENCE(2,10)[1,1]");
		assert.strictEqual(array.getElementRowCol(1, 5).getValue(), 16, "Result of SEQUENCE(2,10)[1,5]");
		assert.strictEqual(array.getElementRowCol(1, 9).getValue(), 20, "Result of SEQUENCE(2,10)[1,9]");

		oParser = new parserFormula('SEQUENCE(2,G13)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,G13)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,G13)");

		oParser = new parserFormula('SEQUENCE(2,G14)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,G14)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2,TRUE)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result of SEQUENCE(2,TRUE)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,TRUE)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result of SEQUENCE(2,TRUE)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,G15)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,G15)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,G15)");		// #CALC!

		oParser = new parserFormula('SEQUENCE(G16)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G16)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G16)");

		oParser = new parserFormula('SEQUENCE(G17)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G17)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of SEQUENCE(G17)");

		oParser = new parserFormula('SEQUENCE(G18)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(G18)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(G18)");

		// arg[2] tests (start)
		oParser = new parserFormula("SEQUENCE(2,2,)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(2,2,)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2,2,)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,2,)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3, "Result of SEQUENCE(2,2,)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, "Result of SEQUENCE(2,2,)[1,1]");

		oParser = new parserFormula("SEQUENCE(2,2,2)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(2,2,2)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 3, "Result of SEQUENCE(2,2,2)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 4, "Result of SEQUENCE(2,2,2)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 5, "Result of SEQUENCE(2,2,2)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,"2")', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,"2")');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 3, "Result of SEQUENCE(2,2,2)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 4, "Result of SEQUENCE(2,2,2)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 5, "Result of SEQUENCE(2,2,2)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,"2s")', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,"2s")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,2,'2s')");

		oParser = new parserFormula('SEQUENCE(2,2,TRUE)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,TRUE)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2,2,TRUE)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,2,TRUE)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3, "Result of SEQUENCE(2,2,TRUE)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, "Result of SEQUENCE(2,2,TRUE)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,FALSE)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,FALSE)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result of SEQUENCE(2,2,FALSE)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE(2,2,FALSE)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,2,FALSE)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 3, "Result of SEQUENCE(2,2,FALSE)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,G10)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,G10)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result of SEQUENCE(2,2,G10)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE(2,2,G10)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,2,G10)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 3, "Result of SEQUENCE(2,2,G10)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,G11)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,G11)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result of SEQUENCE(2,2,G11)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE(2,2,G11)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,2,G11)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 3, "Result of SEQUENCE(2,2,G11)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,G12)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,G12)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 10, "Result of SEQUENCE(2,2,G12)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 11, "Result of SEQUENCE(2,2,G12)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 12, "Result of SEQUENCE(2,2,G12)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 13, "Result of SEQUENCE(2,2,G12)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,G13)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,G13)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), -10, "Result of SEQUENCE(2,2,G13)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), -9, "Result of SEQUENCE(2,2,G13)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), -8, "Result of SEQUENCE(2,2,G13)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), -7, "Result of SEQUENCE(2,2,G13)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,G14)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,G14)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(2,2,G14)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,2,G14)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3, "Result of SEQUENCE(2,2,G14)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, "Result of SEQUENCE(2,2,G14)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,G15)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,G15)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result of SEQUENCE(2,2,G15)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE(2,2,G15)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,2,G15)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 3, "Result of SEQUENCE(2,2,G15)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,G16)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,G16)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,2,G16)");

		oParser = new parserFormula('SEQUENCE(2,2,G17)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,G17)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of SEQUENCE(2,2,G17)");

		oParser = new parserFormula('SEQUENCE(2,2,G18)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,G18)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,2,G18)");

		// arg[3] tests (step)
		oParser = new parserFormula("SEQUENCE(2,2,2,)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(2,2,2,)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 3, "Result of SEQUENCE(2,2,2,)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 4, "Result of SEQUENCE(2,2,2,)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 5, "Result of SEQUENCE(2,2,2,)[1,1]");

		oParser = new parserFormula("SEQUENCE(2,2,0,-2)", "A2", ws);
		assert.ok(oParser.parse(), "SEQUENCE(2,2,0,-2)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result of SEQUENCE(2,2,0,-2)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), -2, "Result of SEQUENCE(2,2,0,-2)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), -4, "Result of SEQUENCE(2,2,0,-2)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), -6, "Result of SEQUENCE(2,2,0,-2)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,0,"2")', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,0,"2")');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result of SEQUENCE(2,2,0,'2')[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,2,0,'2')[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 4, "Result of SEQUENCE(2,2,0,'2')[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 6, "Result of SEQUENCE(2,2,0,'2')[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,0,"2s")', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,0,"2s")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,2,0,'2s')");

		oParser = new parserFormula('SEQUENCE(2,2,2,TRUE)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,TRUE)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,TRUE)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 3, "Result of SEQUENCE(2,2,2,TRUE)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 4, "Result of SEQUENCE(2,2,2,TRUE)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 5, "Result of SEQUENCE(2,2,2,TRUE)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,2,FALSE)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,FALSE)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,FALSE)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,2,2,FALSE)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,FALSE)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 2, "Result of SEQUENCE(2,2,2,FALSE)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,2,G10)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,G10)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,G10)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,2,2,G10)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,G10)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 2, "Result of SEQUENCE(2,2,2,G10)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,2,G11)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,G11)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,G11)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,2,2,G11)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,G11)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 2, "Result of SEQUENCE(2,2,2,G11)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,2,G12)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,G12)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,G12)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 12, "Result of SEQUENCE(2,2,2,G12)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 22, "Result of SEQUENCE(2,2,2,G12)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 32, "Result of SEQUENCE(2,2,2,G12)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,2,G13)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,G13)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,G13)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), -8, "Result of SEQUENCE(2,2,2,G13)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), -18, "Result of SEQUENCE(2,2,2,G13)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), -28, "Result of SEQUENCE(2,2,2,G13)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,2,G14)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,G14)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,G14)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 3, "Result of SEQUENCE(2,2,2,G14)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 4, "Result of SEQUENCE(2,2,2,G14)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 5, "Result of SEQUENCE(2,2,2,G14)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,2,G15)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,G15)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,G15)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2,2,2,G15)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(2,2,2,G15)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 2, "Result of SEQUENCE(2,2,2,G15)[1,1]");

		oParser = new parserFormula('SEQUENCE(2,2,2,G16)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,G16)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,2,2,G16)");

		oParser = new parserFormula('SEQUENCE(2,2,2,G17)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,G17)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of SEQUENCE(2,2,2,G17)");

		oParser = new parserFormula('SEQUENCE(2,2,2,G18)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2,2,2,G18)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of SEQUENCE(2,2,2,G18)");

		// array/cellsRange tests
		oParser = new parserFormula('SEQUENCE({1,2;2,3})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE({1,2;2,3})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE({1,2;2,3})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE({1,2;2,3})[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 1, "Result of SEQUENCE({1,2;2,3})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 1, "Result of SEQUENCE({1,2;2,3})[1,1]");

		oParser = new parserFormula('SEQUENCE(1,{2,2;2,2})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,{2,2;2,2})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(1,{2,2;2,2})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE(1,{2,2;2,2})[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 1, "Result of SEQUENCE(1,{2,2;2,2})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 1, "Result of SEQUENCE(1,{2,2;2,2})[1,1]");

		oParser = new parserFormula('SEQUENCE(1,2,{2,2;2,2})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,2,{2,2;2,2})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result of SEQUENCE(1,2,{2,2;2,2})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(1,2,{2,2;2,2})[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(1,2,{2,2;2,2})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 2, "Result of SEQUENCE(1,2,{2,2;2,2})[1,1]");

		oParser = new parserFormula('SEQUENCE(1,2,4,{2,2;2,2})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,2,4,{2,2;2,2})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 4, "Result of SEQUENCE(1,2,2,{2,2;2,2})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 4, "Result of SEQUENCE(1,2,2,{2,2;2,2})[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 4, "Result of SEQUENCE(1,2,2,{2,2;2,2})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, "Result of SEQUENCE(1,2,2,{2,2;2,2})[1,1]");


		oParser = new parserFormula('SEQUENCE({1,2,3},{1,2},1,1)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE({1,2,3},{1,2},1,1)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE({1,2,3},{1,2},1,1)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE({1,2,3},{1,2},1,1)[0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), "#N/A", "Result of SEQUENCE({1,2,3},{1,2},1,1)[0,2]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result of SEQUENCE({1,2,3},{1,2},1,1)[1,0]");

		oParser = new parserFormula('SEQUENCE({1,2,3;3,2,1},{1;2},1,1)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE({1,2,3;3,2,1},{1;2},1,1)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE({1,2,3;3,2,1},{1;2},1,1)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE({1,2,3;3,2,1},{1;2},1,1)[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 1, "Result of SEQUENCE({1,2,3;3,2,1},{1;2},1,1)[0,2]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 1, "Result of SEQUENCE({1,2,3;3,2,1},{1;2},1,1)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 1, "Result of SEQUENCE({1,2,3;3,2,1},{1;2},1,1)[1,1]");		
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 1, "Result of SEQUENCE({1,2,3;3,2,1},{1;2},1,1)[1,2]");

		oParser = new parserFormula('SEQUENCE(1,{1,2,3;3,2,1},{1;2},1)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,{1,2,3;3,2,1},{1;2},1)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(1,{1,2,3;3,2,1},{1;2},1)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE(1,{1,2,3;3,2,1},{1;2},1)[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 1, "Result of SEQUENCE(1,{1,2,3;3,2,1},{1;2},1)[0,2]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of SEQUENCE(1,{1,2,3;3,2,1},{1;2},1)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 2, "Result of SEQUENCE(1,{1,2,3;3,2,1},{1;2},1)[1,1]");		
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 2, "Result of SEQUENCE(1,{1,2,3;3,2,1},{1;2},1)[1,2]");	

		oParser = new parserFormula('SEQUENCE(1,1,{1,2,3;3,2,1},{1;2})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,1,{1,2,3;3,2,1},{1;2})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(1,1,{1,2,3;3,2,1},{1;2})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(1,1,{1,2,3;3,2,1},{1;2})[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 3, "Result of SEQUENCE(1,1,{1,2,3;3,2,1},{1;2})[0,2]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3, "Result of SEQUENCE(1,1,{1,2,3;3,2,1},{1;2})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 2, "Result of SEQUENCE(1,1,{1,2,3;3,2,1},{1;2})[1,1]");		
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 1, "Result of SEQUENCE(1,1,{1,2,3;3,2,1},{1;2})[1,2]");

		oParser = new parserFormula('SEQUENCE({1;2},1,1,{1,2,3;3,2,1})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE({1;2},1,1,{1,2,3;3,2,1})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE({1;2},1,1,{1,2,3;3,2,1})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE({1;2},1,1,{1,2,3;3,2,1})[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 1, "Result of SEQUENCE({1;2},1,1,{1,2,3;3,2,1})[0,2]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 1, "Result of SEQUENCE({1;2},1,1,{1,2,3;3,2,1})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 1, "Result of SEQUENCE({1;2},1,1,{1,2,3;3,2,1})[1,1]");		
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 1, "Result of SEQUENCE({1;2},1,1,{1,2,3;3,2,1})[1,2]");

		oParser = new parserFormula('SEQUENCE({1;2},{1,2,3;FALSE,"2s",TRUE},1,1)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE({1;2},{1,2,3;FALSE,"2s",TRUE},1,1)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE({1;2},{1,2,3;FALSE,'2s',TRUE},1,1)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE({1;2},{1,2,3;FALSE,'2s',TRUE},1,1)[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 1, "Result of SEQUENCE({1;2},{1,2,3;FALSE,'2s',TRUE},1,1)[0,2]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#VALUE!", "Result of SEQUENCE({1;2},{1,2,3;FALSE,'2s',TRUE},1,1)[1,0]");		// #CALC!
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "#VALUE!", "Result of SEQUENCE({1;2},{1,2,3;FALSE,'2s',TRUE},1,1)[1,1]");		
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 1, "Result of SEQUENCE({1;2},{1,2,3;FALSE,'2s',TRUE},1,1)[1,2]");	

		oParser = new parserFormula('SEQUENCE({1;"3s"},{1,2,3;3,2,1},1,1)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE({1;"3s"},{1,2,3;3,2,1},1,1)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE({1;'3s'},{1,2,3;3,2,1},1,1)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE({1;'3s'},{1,2,3;3,2,1},1,1)[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 1, "Result of SEQUENCE({1;'3s'},{1,2,3;3,2,1},1,1)[0,2]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#VALUE!", "Result of SEQUENCE({1;'3s'},{1,2,3;3,2,1},1,1)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "#VALUE!", "Result of SEQUENCE({1;'3s'},{1,2,3;3,2,1},1,1)[1,1]");		
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), "#VALUE!", "Result of SEQUENCE({1;'3s'},{1,2,3;3,2,1},1,1)[1,2]");

		oParser = new parserFormula('SEQUENCE({1;3},{1,2,3;3,2,1},{1,"2s",TRUE},1)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE({1;3},{1,2,3;3,2,1},{1,"2s",TRUE},1)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE({1;3},{1,2,3;3,2,1},{1,'2s',TRUE},1)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!", "Result of SEQUENCE({1;3},{1,2,3;3,2,1},{1,'2s',TRUE},1)[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 1, "Result of SEQUENCE({1;3},{1,2,3;3,2,1},{1,'2s',TRUE},1)[0,2]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 1, "Result of SEQUENCE({1;3},{1,2,3;3,2,1},{1,'2s',TRUE},1)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "#VALUE!", "Result of SEQUENCE({1;3},{1,2,3;3,2,1},{1,'2s',TRUE},1)[1,1]");	
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 1, "Result of SEQUENCE({1;3},{1,2,3;3,2,1},{1,'2s',TRUE},1)[1,2]");

		oParser = new parserFormula('SEQUENCE(1,{1;3},{1,2,3;3,2,1},{1,"2s",TRUE})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,{1;3},{1,2,3;3,2,1},{1,"2s",TRUE})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(1,{1;3},{1,2,3;3,2,1},{1,'2s',TRUE})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!", "Result of SEQUENCE(1,{1;3},{1,2,3;3,2,1},{1,'2s',TRUE})[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 3, "Result of SEQUENCE(1,{1;3},{1,2,3;3,2,1},{1,'2s',TRUE})[0,2]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3, "Result of SEQUENCE(1,{1;3},{1,2,3;3,2,1},{1,'2s',TRUE})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "#VALUE!", "Result of SEQUENCE(1,{1;3},{1,2,3;3,2,1},{1,'2s',TRUE})[1,1]");
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 1, "Result of SEQUENCE(1,{1;3},{1,2,3;3,2,1},{1,'2s',TRUE})[1,2]");

		oParser = new parserFormula('SEQUENCE({1,"2s",TRUE},{1;3},{1,2,3;3,2,1},1)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE({1,"2s",TRUE},{1;3},{1,2,3;3,2,1},1)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE({1,'2s',TRUE},{1;3},{1,2,3;3,2,1},1)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!", "Result of SEQUENCE({1,'2s',TRUE},{1;3},{1,2,3;3,2,1},1)[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 3, "Result of SEQUENCE({1,'2s',TRUE},{1;3},{1,2,3;3,2,1},1)[0,2]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3, "Result of SEQUENCE({1,'2s',TRUE},{1;3},{1,2,3;3,2,1},1)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "#VALUE!", "Result of SEQUENCE({1,'2s',TRUE},{1;3},{1,2,3;3,2,1},1)[1,1]");	
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 1, "Result of SEQUENCE({1,'2s',TRUE},{1;3},{1,2,3;3,2,1},1)[1,2]");

		oParser = new parserFormula('SEQUENCE(1,{1,"2s",TRUE},{1;3},{1,2,3;3,2,1})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,{1,"2s",TRUE},{1;3},{1,2,3;3,2,1})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(1,{1,'2s',TRUE},{1;3},{1,2,3;3,2,1})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "#VALUE!", "Result of SEQUENCE(1,{1,'2s',TRUE},{1;3},{1,2,3;3,2,1})[0,1]");		
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 1, "Result of SEQUENCE(1,{1,'2s',TRUE},{1;3},{1,2,3;3,2,1})[0,2]");		
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3, "Result of SEQUENCE(1,{1,'2s',TRUE},{1;3},{1,2,3;3,2,1})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "#VALUE!", "Result of SEQUENCE(1,{1,'2s',TRUE},{1;3},{1,2,3;3,2,1})[1,1]");	
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 3, "Result of SEQUENCE(1,{1,'2s',TRUE},{1;3},{1,2,3;3,2,1})[1,2]");

		
		oParser = new parserFormula('SEQUENCE(1,1,,{1,2;3,4})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,1,,{1,2;3,4})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(1,1,,{1,2;3,4})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1, "Result of SEQUENCE(1,1,,{1,2;3,4})[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 1, "Result of SEQUENCE(1,1,,{1,2;3,4})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 1, "Result of SEQUENCE(1,1,,{1,2;3,4})[1,1]");

		oParser = new parserFormula('SEQUENCE(1,1,G10,{1,2;3,4})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,1,G10,{1,2;3,4})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result of SEQUENCE(1,1,G10,{1,2;3,4})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 0, "Result of SEQUENCE(1,1,G10,{1,2;3,4})[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 0, "Result of SEQUENCE(1,1,G10,{1,2;3,4})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 0, "Result of SEQUENCE(1,1,G10,{1,2;3,4})[1,1]");

		oParser = new parserFormula('SEQUENCE(1,1,G11,{1,2;3,4})', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(1,1,G11,{1,2;3,4})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result of SEQUENCE(1,1,G11,{1,2;3,4})[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 0, "Result of SEQUENCE(1,1,G11,{1,2;3,4})[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 0, "Result of SEQUENCE(1,1,G11,{1,2;3,4})[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 0, "Result of SEQUENCE(1,1,G11,{1,2;3,4})[1,1]");

		oParser = new parserFormula('SEQUENCE(2.9,2.1,0.9,1.1)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2.9,2.1,0.9,1.1)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0.9, "Result of SEQUENCE(2.9,2.1,0.9,1.1)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(2.9,2.1,0.9,1.1)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3.1, "Result of SEQUENCE(2.9,2.1,0.9,1.1)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4.2, "Result of SEQUENCE(2.9,2.1,0.9,1.1)[1,1]");

		// =SEQUENCE(2.9,2.1,-0.9,-1.010101)
		oParser = new parserFormula('SEQUENCE(2.4,2.5,-0.9,-1.01010)', "A2", ws);
		assert.ok(oParser.parse(), 'SEQUENCE(2.4,2.5,-0.9,-1.01010)');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), -0.9, "Result of SEQUENCE(2.4,2.5,-0.9,-1.01010)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), -1.9101, "Result of SEQUENCE(2.4,2.5,-0.9,-1.01010)[0,1]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), -2.9202, "Result of SEQUENCE(2.4,2.5,-0.9,-1.01010)[1,0]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), -3.9303, "Result of SEQUENCE(2.4,2.5,-0.9,-1.01010)[1,1]");

		// Max array size (10223960?)
		// oParser = new parserFormula('SEQUENCE(10223960,2,1,1)', "A2", ws);
		// assert.ok(oParser.parse(), 'SEQUENCE(10223960,2,1,1)');
		// array = oParser.calculate();
		// assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of SEQUENCE(10223960,1,1,1)[0,0]");
		// assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of SEQUENCE(10223960,1,1,1)[0,1]");
		// assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 3, "Result of SEQUENCE(10223960,1,1,1)[1,0]");
		// assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 4, "Result of SEQUENCE(10223960,1,1,1)[1,1]");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: integers for all arguments. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(2,2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(2,2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Basic valid input: integers for all arguments. 4 of 4 arguments used.');
		// Case #2: Number. Single argument: rows only. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(3) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Single argument: rows only. 1 of 4 arguments used.');
		// Case #3: Number. Rows and columns specified. 2 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Rows and columns specified. 2 of 4 arguments used.');
		// Case #4: Number. Rows, columns, and start specified. 3 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(2,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(2,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 5, 'Test: Positive case: Number. Rows, columns, and start specified. 3 of 4 arguments used.');
		// Case #5: Number. Float step value. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(2,2,1,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(2,2,1,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Float step value. 4 of 4 arguments used.');
		// Case #6: String. String convertible to numbers. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE("2","2","1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE("2","2","1","1") is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: String. String convertible to numbers. 4 of 4 arguments used.');
		// Case #7: Formula. Nested formula for rows and columns. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(SQRT(4),SQRT(4),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(SQRT(4),SQRT(4),1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Formula. Nested formula for rows and columns. 4 of 4 arguments used.');
		// Case #8: Reference link. Reference to cells with valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(A100,A101,A102,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Positive case: Reference link. Reference to cells with valid numbers. 4 of 4 arguments used.');
		// Case #9: Area. Single-cell range for all arguments. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#CALC!', 'Test: Positive case: Area. Single-cell range for all arguments. 4 of 4 arguments used.');
		// Case #10: Array. Array with single elements. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE({2},{2},{1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE({2},{2},{1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Array with single elements. 4 of 4 arguments used.');
		// Case #11: Name. Named range for all arguments. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(TestName,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(TestName,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Name. Named range for all arguments. 4 of 4 arguments used.');
		// Case #12: Name3D. 3D named range for all arguments. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Name3D. 3D named range for all arguments. 4 of 4 arguments used.');
		// Case #13: Ref3D. 3D reference to cells. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D reference to cells. 4 of 4 arguments used.');
		// Case #14: Area3D. 3D single-cell range. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell range. 4 of 4 arguments used.');
		// Case #15: Table. Table structured reference. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Table. Table structured reference. 4 of 4 arguments used.');
		// Case #16: Formula. SEQUENCE inside SUM formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(SEQUENCE(2,2,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SEQUENCE(2,2,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. SEQUENCE inside SUM formula. 4 of 4 arguments used.');
		// Case #17: Date. Date as serial number for rows. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(DATE(2025,1,1),2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(DATE(2025,1,1),2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Date. Date as serial number for rows. 4 of 4 arguments used.');
		// Case #18: Time. Time adjusted to valid number for start. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(2,2,TIME(0,0,0)+1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(2,2,TIME(0,0,0)+1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Time. Time adjusted to valid number for start. 4 of 4 arguments used.');
		// Case #19: Formula. Nested IF returning valid value. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(IF(TRUE,2,1),2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(IF(TRUE,2,1),2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Formula. Nested IF returning valid value. 4 of 4 arguments used.');
		// Case #20: Array. Multi-element array for rows. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE({2,3},{2},{1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE({2,3},{2},{1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Multi-element array for rows. 4 of 4 arguments used.');
		// Case #21: Number. Zero start and step values. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(1,2,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(1,2,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Number. Zero start and step values. 4 of 4 arguments used.');
		// Case #22: String. String convertible to float numbers. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE("1.5","2","1","0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE("1.5","2","1","0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: String. String convertible to float numbers. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number. Rows <= 0 returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Negative case: Number. Rows <= 0 returns #NUM!. 1 of 4 arguments used.');
		// Case #2: Number. Negative rows returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Negative rows returns #NUM!. 1 of 4 arguments used.');
		// Case #3: Number. Columns <= 0 returns #NUM!. 2 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Negative case: Number. Columns <= 0 returns #NUM!. 2 of 4 arguments used.');
		// Case #4: Number. Negative columns returns #NUM!. 2 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(2,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(2,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Negative columns returns #NUM!. 2 of 4 arguments used.');
		// Case #5: String. Non-numeric string returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 of 4 arguments used.');
		// Case #6: String. String convertible to zero returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE("0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Negative case: String. String convertible to zero returns #NUM!. 1 of 4 arguments used.');
		// Case #7: Error. Propagates #N/A error. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 of 4 arguments used.');
		// Case #8: Area. Multi-cell range returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#CALC!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 of 4 arguments used.');
		// Case #9: Empty. Reference to empty cell returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 of 4 arguments used.');
		// Case #10: Boolean. Boolean FALSE (0) returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!. 1 of 4 arguments used.');
		// Case #11: Ref3D. 3D ref to text returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(Sheet2!A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 1 of 4 arguments used.');
		// Case #12: Name. Named range with text returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 of 4 arguments used.');
		// Case #13: Table. Table column with text returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 of 4 arguments used.');
		// Case #14: Formula. Formula resulting in #NUM! error. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 of 4 arguments used.');
		// Case #15: Array. Array with boolean returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#CALC!', 'Test: Negative case: Array. Array with boolean returns #NUM!. 1 of 4 arguments used.');
		// Case #16: Number. Large negative start returns #NUM!. 3 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(1,1,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(1,1,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -1e+307, 'Test: Negative case: Number. Large negative start returns #NUM!. 3 of 4 arguments used.');
		// Case #17: Number. Large negative step returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(1,1,1,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(1,1,1,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Number. Large negative step returns #NUM!. 4 of 4 arguments used.');
		// Case #18: String. String convertible to negative number returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE("-1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE("-1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. String convertible to negative number returns #NUM!. 1 of 4 arguments used.');
		// Case #19: Time. Time value (0.5) returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(TIME(12,0,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#CALC!', 'Test: Negative case: Time. Time value (0.5) returns #NUM!. 1 of 4 arguments used.');
		// Case #20: Area3D. 3D multi-cell range returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid step value. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(1,1,1,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(1,1,1,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Number. Minimum valid step value. 4 of 4 arguments used.');
		// Case #2: Number. Minimum valid start value. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(1,1,1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(1,1,1E-307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1e-307, 'Test: Bounded case: Number. Minimum valid start value. 4 of 4 arguments used.');
		// Case #3: Number. Maximum valid rows and columns (Excel limits). 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(1048576,16384,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(1048576,16384,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '`=SEQUENCE(1048576,16384,1,1)', 'Test: Bounded case: Number. Maximum valid rows and columns (Excel limits). 4 of 4 arguments used.');
		// Case #4: Number. Maximum valid start value. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(1,1,9.99999999999999E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(1,1,9.99999999999999E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number. Maximum valid start value. 4 of 4 arguments used.');
		// Case #5: Number. Maximum valid step value. 4 of 4 arguments used.
		oParser = new parserFormula('SEQUENCE(1,1,1,9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SEQUENCE(1,1,1,9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Number. Maximum valid step value. 4 of 4 arguments used.');

		// TODO app can crush when we type formula SEQUENCE(10223960,1,1,1)
		// Need to fix: error type diff(#CALC error), too long operations with big nums like 10223960

		// Case #8: Reference link. Reference to cells with valid numbers. 4 of 4 arguments used.
		// Case #9: Area. Single-cell range for all arguments. 4 of 4 arguments used.
		// Case #1: Number. Rows <= 0 returns #NUM!. 1 of 4 arguments used.
		// Case #3: Number. Columns <= 0 returns #NUM!. 2 of 4 arguments used.
		// Case #6: String. String convertible to zero returns #NUM!. 1 of 4 arguments used.
		// Case #10: Boolean. Boolean FALSE (0) returns #NUM!. 1 of 4 arguments used.
		// Case #11: Ref3D. 3D ref to text returns #VALUE!. 1 of 4 arguments used.
		// Case #15: Array. Array with boolean returns #NUM!. 1 of 4 arguments used.
		// Case #8: Area. Multi-cell range returns #VALUE!. 1 of 4 arguments used.
		// Case #12: Name. Named range with text returns #VALUE!. 1 of 4 arguments used.
		// Case #19: Time. Time value (0.5) returns #NUM!. 1 of 4 arguments used.

		// Case #3: Number. Maximum valid rows and columns (Excel limits). 4 of 4 arguments used. - too long operation?

	});

	wb.dependencyFormulas.unlockRecal();
});
