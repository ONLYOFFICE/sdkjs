/*
 * (c) Copyright Ascensio System SIA 2010-2025
 *
 * This program is a free software product. You can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License (AGPL)
 * version 3 as published by the Free Software Foundation. In accordance with
 * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect
 * that Ascensio System SIA expressly excludes the warranty of non-infringement
 * of any third-party rights.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For
 * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html
 *
 * You can contact Ascensio System SIA at 20A-6 Ernesta Birznieka-Upish
 * street, Riga, Latvia, EU, LV-1050.
 *
 * The  interactive user interfaces in modified source and object code versions
 * of the Program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU AGPL version 3.
 *
 * Pursuant to Section 7(b) of the License you must retain the original Product
 * logo when distributing the program. Pursuant to Section 7(e) we decline to
 * grant you any rights under trademark law for use of our trademarks.
 *
 * All the Product's GUI elements, including illustrations and icon sets, as
 * well as technical writing content are licensed under the terms of the
 * Creative Commons Attribution-ShareAlike 4.0 International. See the License
 * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode
 *
 */


$(function () {
	// Mocks for API Testing
	Asc.spreadsheet_api.prototype._init = function () {
		this._loadModules();
	};
	Asc.spreadsheet_api.prototype._loadFonts = function (fonts, callback) {
		callback();
	};
	AscCommonExcel.WorkbookView.prototype._calcMaxDigitWidth = function () {
	};
	AscCommonExcel.WorkbookView.prototype._init = function () {
	};
	AscCommonExcel.WorkbookView.prototype._isLockedUserProtectedRange = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorkbookView.prototype._onWSSelectionChanged = function () {
	};
	AscCommonExcel.WorkbookView.prototype.showWorksheet = function () {
	};
	AscCommonExcel.WorkbookView.prototype.recalculateDrawingObjects = function () {
	};
	AscCommonExcel.WorkbookView.prototype.restoreFocus = function () {
	};
	AscCommonExcel.WorksheetView.prototype._init = function () {
	};
	AscCommonExcel.WorksheetView.prototype.updateRanges = function () {
	};
	AscCommonExcel.WorksheetView.prototype._autoFitColumnsWidth = function () {
	};
	AscCommonExcel.WorksheetView.prototype.cleanSelection = function () {
	};
	AscCommonExcel.WorksheetView.prototype._drawSelection = function () {
	};
	AscCommonExcel.WorksheetView.prototype._scrollToRange = function () {
	};
	AscCommonExcel.WorksheetView.prototype.draw = function () {
	};
	AscCommonExcel.WorksheetView.prototype._prepareDrawingObjects = function () {
	};
	AscCommonExcel.WorksheetView.prototype._initCellsArea = function () {
	};
	AscCommonExcel.WorksheetView.prototype.getZoom = function () {
	};
	AscCommonExcel.WorksheetView.prototype._prepareCellTextMetricsCache = function () {
	};

	AscCommon.baseEditorsApi.prototype._onEndLoadSdk = function () {
	};

	AscCommon.baseEditorsApi.prototype._onEndLoadSdk = function () {
	};
	Asc.ReadDefTableStyles = function () {
	};
	AscCommonExcel.WorksheetView.prototype._isLockedCells = function (oFromRange, subType, callback) {
		callback(true);
		return true;
	};
	AscCommonExcel.WorksheetView.prototype._isLockedAll = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorksheetView.prototype._isLockedFrozenPane = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorksheetView.prototype._updateVisibleColsCount = function () {
	};
	AscCommonExcel.WorksheetView.prototype._calcActiveCellOffset = function () {
	};

	// Init basic data
	const parserFormula = AscCommonExcel.parserFormula;
	const g_oIdCounter = AscCommon.g_oIdCounter;
    const c_msPerDay = AscCommonExcel.c_msPerDay;
	const GetDiffDate360 = AscCommonExcel.GetDiffDate360;
	const fSortAscending = AscCommon.fSortAscending;
	const ParseResult = AscCommonExcel.ParseResult;
	const c_oAscError = Asc.c_oAscError;

	let oParser, wb, ws, sData = AscCommon.getEmpty(), tmp, dif = 1e-9;

	if (AscCommon.c_oSerFormat.Signature === sData.substring(0, AscCommon.c_oSerFormat.Signature.length)) {

		Asc.spreadsheet_api.prototype._init = function() {
			this.isLoadFullApi = true;
		};


		let api = new Asc.spreadsheet_api({
			'id-view': 'editor_sdk'
		});
		api.FontLoader = {
			LoadDocumentFonts: function () {
			}
		};

		let docInfo = new Asc.asc_CDocInfo();
		docInfo.asc_putTitle("TeSt.xlsx");
		api.DocInfo = docInfo;


		window["Asc"]["editor"] = api;
		AscCommon.g_oTableId.init(api);
		api._onEndLoadSdk();
		api.isOpenOOXInBrowser = false;
		api.OpenDocumentFromBin(null, AscCommon.getEmpty());
		api.initCollaborativeEditing({});
		wb = new AscCommonExcel.Workbook(new AscCommonExcel.asc_CHandlersList(), api, true);
		api.wbModel = wb;
		api.wb = new AscCommonExcel.WorkbookView(api.wbModel, api.controller, api.handlers, api.HtmlElement,
			api.topLineEditorElement, api, api.collaborativeEditing, api.fontRenderingMode);
		AscCommon.History.init(wb);
		// There is no operation with history, disabled to avoid unnecessary serializations.
		AscCommon.History.TurnOff();
		wb.maxDigitWidth = 7;
		wb.paddingPlusBorder = 5;

		api.initCollaborativeEditing({});

		if (this.User) {
			g_oIdCounter.Set_UserId(this.User.asc_getId());
		}

		AscCommonExcel.g_oUndoRedoCell = new AscCommonExcel.UndoRedoCell(wb);
		AscCommonExcel.g_oUndoRedoWorksheet = new AscCommonExcel.UndoRedoWoorksheet(wb);
		AscCommonExcel.g_oUndoRedoWorkbook = new AscCommonExcel.UndoRedoWorkbook(wb);
		AscCommonExcel.g_oUndoRedoCol = new AscCommonExcel.UndoRedoRowCol(wb, false);
		AscCommonExcel.g_oUndoRedoRow = new AscCommonExcel.UndoRedoRowCol(wb, true);
		AscCommonExcel.g_oUndoRedoComment = new AscCommonExcel.UndoRedoComment(wb);
		AscCommonExcel.g_oUndoRedoAutoFilters = new AscCommonExcel.UndoRedoAutoFilters(wb);
		AscCommonExcel.g_DefNameWorksheet = new AscCommonExcel.Worksheet(wb, -1);
		g_oIdCounter.Set_Load(false);

		const oBinaryFileReader = new AscCommonExcel.BinaryFileReader();
		oBinaryFileReader.Read(sData, wb);
		ws = wb.getWorksheet(wb.getActive());
		AscCommonExcel.getFormulasInfo();
	}

	// Init basic functions
	function testArrayFormula(assert, func, dNotSupportAreaArg) {

		const getValue = function (ref) {
			oParser = new parserFormula(func + "(" + ref + ")", "A2", ws);
			assert.ok(oParser.parse(), 'Formula is parsed');
			return oParser.calculate().getValue();
		};
		const description = `Test: testArrayFormula. ${func}. `;

		//***array-formula***
		ws.getRange2("A100").setValue("1");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("C100").setValue("-4");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B101").setValue("4");
		ws.getRange2("C101").setValue("5");


		oParser = new parserFormula(func + "(A100:C101)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
		assert.ok(oParser.parse(), 'Formula is parsed.');
		let array = oParser.calculate();
		if (AscCommonExcel.cElementType.array === array.type) {
			assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue("A100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue("B100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue("C100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 0).getValue(), getValue("A101"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 1).getValue(), getValue("B101"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 2).getValue(), getValue("C101"), description + 'Reference Link. Area.');
		} else {
			if (!dNotSupportAreaArg) {
				assert.strictEqual(false, true, 'func: ' + func + ' don\'t support area argument.');
			}
			//consoleLog("func: " + func + " don't return area array");
		}

		oParser = new parserFormula(func + "({1,2,-3})", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
		assert.ok(oParser.parse(), 'Formula is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue(1), description + 'Number.');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue(2), description + 'Number.');
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue(-3), description + 'Number.');
	}
	//returnOnlyValue - those functions that must always be fed arrays as input and that return a single value
	function testArrayFormula2(assert, func, minArgCount, maxArgCount, dNotSupportAreaArg, returnOnlyValue) {

		const getValue = function (ref, countArg) {
			let argStr = "(";
			for (let j = 1; j <= countArg; j++) {
				argStr += ref;
				if (i !== j) {
					argStr += ",";
				} else {
					argStr += ")";
				}
			}
			oParser = new parserFormula(func + argStr, "A2", ws);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + argStr + ' is parsed.');
			return oParser.calculate().getValue();
		};


		//***array-formula***
		ws.getRange2("A100").setValue("1");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("C100").setValue("-4");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B101").setValue("4");
		ws.getRange2("C101").setValue("5");

		//формируем массив значений
		const randomArray = [];
		let randomStrArray = "{";
		let maxArg = 4;
		for (let i = 1; i <= maxArg; i++) {
			let randVal = Math.random();
			randomArray.push(randVal);
			randomStrArray += randVal;
			if (i !== maxArg) {
				randomStrArray += ",";
			} else {
				randomStrArray += "}";
			}
		}

		for (var i = minArgCount; i <= maxArgCount; i++) {
			let argStrArr = "(";
			let randomArgStrArr = "(";
			for (let j = 1; j <= i; j++) {
				argStrArr += "A100:C101";
				randomArgStrArr += randomStrArray;
				if (i !== j) {
					argStrArr += ",";
					randomArgStrArr += ",";
				} else {
					argStrArr += ")";
					randomArgStrArr += ")";
				}
			}

			oParser = new parserFormula(func + argStrArr, "A1", ws);
			oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + argStrArr + ' is parsed.');
			let array = oParser.calculate();
			if (AscCommonExcel.cElementType.array === array.type) {
				assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue("A100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue("B100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue("C100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 0).getValue(), getValue("A101", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 1).getValue(), getValue("B101", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 2).getValue(), getValue("C101", i), 'Test: testArrayFormula2. Area.');
			} else {
				if (!(dNotSupportAreaArg || returnOnlyValue)) {
					assert.strictEqual(false, true);
				}
				//consoleLog("func: " + func + " don't return area array");
			}

			oParser = new parserFormula(func + randomArgStrArr, "A1", ws);
			oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + randomArgStrArr + ' is parsed.');
			array = oParser.calculate();
			if (AscCommonExcel.cElementType.array === array.type) {
				assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue(randomArray[0], i), 'Test: testArrayFormula2. Random array');
				assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue(randomArray[1], i), 'Test: testArrayFormula2. Random array');
				assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue(randomArray[2], i), 'Test: testArrayFormula2. Random array');
			} else {
				if (!returnOnlyValue) {
					assert.strictEqual(false, true);
				}
				//consoleLog("func: " + func + " don't return array");
			}
		}
	}

	function testArrayFormulaEqualsValues(assert, str, formula, isNotLowerCase) {
		//***array-formula***
		ws.getRange2("A1").setValue("1");
		ws.getRange2("B1").setValue("3.123");
		ws.getRange2("C1").setValue("-4");
		ws.getRange2("A2").setValue("2");
		ws.getRange2("B2").setValue("4");
		ws.getRange2("C2").setValue("5");

		oParser = new parserFormula(formula, "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E6:H8").bbox);
		assert.ok(oParser.parse());
		var array = oParser.calculate();

		var splitStr = str.split(";");

		for (var i = 0; i < splitStr.length; i++) {
			var subSplitStr = splitStr[i].split(",");
			for (var j = 0; j < subSplitStr.length; j++) {
				var valMs = subSplitStr[j];
				var element;
				if (array.getElementRowCol) {
					var row = 1 === array.array.length ? 0 : i;
					var col = 1 === array.array[0].length ? 0 : j;
					if (array.array[row] && array.array[row][col]) {
						element = array.getElementRowCol(row, col);
					} else {
						element = new window['AscCommonExcel'].cError(window['AscCommonExcel'].cErrorType.not_available);
					}
				} else {
					element = array;
				}
				var ourVal = element && undefined != element.value ? element.value.toString() : "#N/A";
				if (!isNotLowerCase) {
					valMs = valMs.toLowerCase();
					ourVal = ourVal.toLowerCase();
				}
				assert.strictEqual(valMs, ourVal, "formula: " + formula + " i: " + i + " j: " + j)
			}
		}
	}

	function numDivFact(num, fact) {
		var res = num / Math.fact(fact);
		res = res.toString();
		return res;
	}

	function toFixed(n) {
		return n;//.toFixed( AscCommonExcel.cExcelSignificantDigits ) - 0;
	}

	function difBetween(a, b) {
		return Math.abs(a - b) < dif
	}


	/**
	 * Function creates table or edit existed table.
	 * * Creating happened when the function was called for the first time in the code totally.
	 * In that case, you should set range coordinates like you're creating table, select needed range.
	 * * For editing table you should consider that you have constant row with header and one data row as minimum required.
	 * In that case your minimum row coordinates must be equal 2 rows.
	 * For filling data use cells A601:L6**
	 * @param {number} r1
	 * @param {number} c1
	 * @param {number} r2
	 * @param {number} c2
	 * @returns {TablePart}
	 */
	function getTableType(r1, c1, r2, c2) {
		const range = new window["Asc"].Range(c1, r1, c2, r2);
		const  tableName = 'Table1';
		const tableParts = ws.TableParts;
		/** @type {TablePart} */
		const foundedTable = tableParts.find(function(table) { return table.DisplayName === tableName});
		if (foundedTable) {
			// Change table
			ws.autoFilters.changeTableRange(tableName, range);
			return foundedTable;
		}
		// Create table
		const tableOptFormat = ws.autoFilters.getAddFormatTableOptions(range);
		const styleName = 'TableStyleMedium2';
		ws.autoFilters.addAutoFilter(styleName, range, tableOptFormat);

		return tableParts[tableParts.length - 1]
	}
	function getSecondSheet () {
		let ws2 = wb.getWorksheetByName('Sheet2');
		if (!ws2) {
			ws2 = wb.createWorksheet(null, 'Sheet2');
		}

		return ws2;
	}
	function initDefNames() {
		const defName = new Asc.asc_CDefName('TestName', ws.getName() + '!$A$201');
		const defName2 = new Asc.asc_CDefName('TestName1', ws.getName() + '!$A$202');
		const defName3 = new Asc.asc_CDefName('TestName2', ws.getName() + '!$A$203');
		const defName4 = new Asc.asc_CDefName('TestName3', ws.getName() + '!$A$204');
		const defName5 = new Asc.asc_CDefName('TestName4', ws.getName() + '!$A$205');
		const defNameArea = new Asc.asc_CDefName('TestNameArea', ws.getName() + '!$A$206:$A$207');
		const defNameArea2 = new Asc.asc_CDefName('TestNameArea2', ws.getName() + '!$A$208:$B$208');
		const ws2 = getSecondSheet();
		const defName3D = new Asc.asc_CDefName('TestName3D', ws2.getName() + '!$A$11');
		const defName3D2 = new Asc.asc_CDefName('TestName3D1', ws2.getName() + '!$A$12');
		const defName3D3 = new Asc.asc_CDefName('TestName3D2', ws2.getName() + '!$A$13');
		const defName3D4 = new Asc.asc_CDefName('TestName3D3', ws2.getName() + '!$A$14');
		const defName3D5 = new Asc.asc_CDefName('TestName3D4', ws2.getName() + '!$A$15');
		const defNameArea3D = new Asc.asc_CDefName('TestNameArea3D', ws2.getName() + '!$A$16:$A$17');
		const defNameArea3D2 = new Asc.asc_CDefName('TestNameArea3D2', ws2.getName() + '!$A$18:$B$18');

		wb.editDefinesNames(null, defName);
		wb.editDefinesNames(null, defName2);
		wb.editDefinesNames(null, defName3);
		wb.editDefinesNames(null, defName4);
		wb.editDefinesNames(null, defName5);
		wb.editDefinesNames(null, defNameArea);
		wb.editDefinesNames(null, defNameArea2);
		wb.editDefinesNames(null, defName3D);
		wb.editDefinesNames(null, defName3D2);
		wb.editDefinesNames(null, defName3D3);
		wb.editDefinesNames(null, defName3D4);
		wb.editDefinesNames(null, defName3D5);
		wb.editDefinesNames(null, defNameArea3D);
		wb.editDefinesNames(null, defNameArea3D2);
	}

	wb.dependencyFormulas.lockRecal();
	getTableType(599, 0, 599, 0); // Init table
	initDefNames();

	QUnit.module('Statistical formulas');

	QUnit.test("Test: \"AVEDEV\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("3.5");
		ws.getRange2("A101").setValue("1.4");
		ws.getRange2("A102").setValue("6.9");
		ws.getRange2("A103").setValue("4.5");
		ws.getRange2("A104").setValue("7");
		ws.getRange2("A105").setValue("8");
		ws.getRange2("A106").setValue("");
		ws.getRange2("A107").setValue("30");
		ws.getRange2("A108").setValue("40");
		ws.getRange2("A109").setValue("Test");
		ws.getRange2("A110").setValue("Text");
		ws.getRange2("A111").setValue("TRUE");
		// Table type. Use A601:L6**
		getTableType(599, 0, 603, 4);
		ws.getRange2("A601").setValue("3.5"); // Column1
		ws.getRange2("A602").setValue("1.4"); // Column1
		ws.getRange2("A603").setValue("6.9"); // Column1
		ws.getRange2("A604").setValue("4.5"); // Column1
		ws.getRange2("B601").setValue("Test"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("10");
		ws2.getRange2("A2").setValue("20");
		ws2.getRange2("A3").setValue("Test");
		ws2.getRange2("A4").setValue("Text");
		ws2.getRange2("A5").setValue("");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("2"); // TestName
		ws.getRange2("A202").setValue("Test"); // TestName1
		ws.getRange2("A206").setValue("300"); // TestNameArea
		ws.getRange2("A207").setValue("400"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("4") // TestName3D
		ws2.getRange2("A12").setValue("Test") // TestName3D1
		ws2.getRange2("A16").setValue("30"); // TestNameArea3D
		ws2.getRange2("A17").setValue("40"); // TestNameArea3D

		// Positive cases:

		// Case #1: Number(4). Aguments are number.  4 arguments were used.
		oParser = new parserFormula('AVEDEV(-3.5,1.4,6.9,-4.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(-3.5,1.4,6.9,-4.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 4.075, 'Test: Positive case: Number(4). Aguments are number.  4 arguments were used.');
		// Case #2: Array. Array with 4 elemens. 1 argument was used.
		oParser = new parserFormula('AVEDEV({-3.5,1.4,6.9,-4.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV({-3.5,1.4,6.9,-4.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.075, 'Test: Positive case: Array. Array with 4 elemens. 1 argument was used.');
		// Case #3: Number(5). Arguments are number. 1 argument was used.
		oParser = new parserFormula('AVEDEV(-3.5,1.4,6.9,-4.5,-0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(-3.5,1.4,6.9,-4.5,-0.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 3.32, 'Test: Positive case: Number(5). Arguments are number. 1 argument was used.');
		// Case #4: Number(4). Basic test with 4 positive numbers. 4 arguments used.
		oParser = new parserFormula('AVEDEV(1,2,3,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(1,2,3,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(4). Basic test with 4 positive numbers. 4 arguments used.');
		// Case #5: Number(5). Test with positive, negative numbers and zero. 5 arguments used.
		oParser = new parserFormula('AVEDEV(-2,-1,0,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(-2,-1,0,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1.2, 'Test: Positive case: Number(5). Test with positive, negative numbers and zero. 5 arguments used.');
		// Case #6: Number. Test with a single number. Result is always 0. 1 argument used.
		oParser = new parserFormula('AVEDEV(5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Test with a single number. Result is always 0. 1 argument used.');
		// Case #7: Formula(4). Test with formulas returning numbers. 4 arguments used.
		oParser = new parserFormula('AVEDEV(ABS(-1),SQRT(4),SUM(1,2),ROUND(3.5,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(ABS(-1),SQRT(4),SUM(1,2),ROUND(3.5,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(4). Test with formulas returning numbers. 4 arguments used.');
		// Case #8: String(3). Test with strings convertible to numbers. 3 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#37
		/*oParser = new parserFormula('AVEDEV("1","2.5","3.75")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV("1","2.5","3.75") is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/!*.toFixed(9) - 0*!/, 0.944444444, 'Test: Positive case: String(3). Test with strings convertible to numbers. 3 arguments used.');
		*/// Case #9: Reference link(4). Test with references to cells containing numbers. 4 arguments used.
		oParser = new parserFormula('AVEDEV(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 1.625, 'Test: Positive case: Reference link(4). Test with references to cells containing numbers. 4 arguments used.');
		// Case #10: Area. Test with a range of cells containing numbers. 1 argument used.
		oParser = new parserFormula('AVEDEV(A100:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(A100:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 1.625, 'Test: Positive case: Area. Test with a range of cells containing numbers. 1 argument used.');
		// Case #11: Array. Test with a one-dimensional array of numbers. 1 argument used.
		oParser = new parserFormula('AVEDEV({1,2,3,4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV({1,2,3,4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.2, 'Test: Positive case: Array. Test with a one-dimensional array of numbers. 1 argument used.');
		// Case #12: Name. Test with a named range containing a number. 1 argument used.
		oParser = new parserFormula('AVEDEV(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name. Test with a named range containing a number. 1 argument used.');
		// Case #13: Name3D. Test with a 3D named range containing a number. 1 argument used.
		oParser = new parserFormula('AVEDEV(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. Test with a 3D named range containing a number. 1 argument used.');
		// Case #14: Ref3D. Test with a 3D reference to a cell with a number. 1 argument used.
		oParser = new parserFormula('AVEDEV(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. Test with a 3D reference to a cell with a number. 1 argument used.');
		// Case #15: Area3D. Test with a 3D range of cells containing numbers. 1 argument used.
		oParser = new parserFormula('AVEDEV(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Area3D. Test with a 3D range of cells containing numbers. 1 argument used.');
		// Case #16: Table. Test with a table reference. 1 argument used.
		oParser = new parserFormula('AVEDEV(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 1.625, 'Test: Positive case: Table. Test with a table reference. 1 argument used.');
		// Case #17: Formula(2). Test with dates (converted to serial numbers). 2 arguments used.
		oParser = new parserFormula('AVEDEV(DATE(2025,1,1),DATE(2025,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(DATE(2025,1,1),DATE(2025,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Formula(2). Test with dates (converted to serial numbers). 2 arguments used.');
		// Case #18: Formula(2). Test with time values (converted to decimal fractions). 2 arguments used.
		oParser = new parserFormula('AVEDEV(TIME(1,0,0),TIME(2,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(TIME(1,0,0),TIME(2,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.020833333, 'Test: Positive case: Formula(2). Test with time values (converted to decimal fractions). 2 arguments used.');
		// Case #19: Formula. Test with AVEDEV nested in another formula. 3 arguments used in AVEDEV.
		oParser = new parserFormula('SUM(AVEDEV(1,2,3),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(AVEDEV(1,2,3),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.666666667, 'Test: Positive case: Formula. Test with AVEDEV nested in another formula. 3 arguments used in AVEDEV.');
		// Case #20: Number(3), Empty. Test with numbers and an empty argument (ignored). 4 arguments used.
		oParser = new parserFormula('AVEDEV(1,2,3,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(1,2,3,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3), Empty. Test with numbers and an empty argument (ignored). 4 arguments used.');
		// Case #21: Number, String, Reference link, Array. Test with mixed data types. 4 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#37
		/*oParser = new parserFormula('AVEDEV(1,"2",A100,{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(1,"2",A100,{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/!*.toFixed(2) - 0*!/, 0.96, 'Test: Positive case: Number, String, Reference link, Array. Test with mixed data types. 4 arguments used.');
		*/// Case #22: Boolean(4). Test with boolean values (TRUE=1, FALSE=0). 4 arguments used.
		oParser = new parserFormula('AVEDEV(TRUE,FALSE,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(TRUE,FALSE,TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Boolean(4). Test with boolean values (TRUE=1, FALSE=0). 4 arguments used.');
		// Case #23: Area, Name, Ref3D, Name3D, Table. Test with different reference types. 5 arguments used.
		oParser = new parserFormula('AVEDEV(A100:A101,TestName,Sheet2!A1,TestName3D,Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(A100:A101,TestName,Sheet2!A1,TestName3D,Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, Name, Ref3D, Name3D, Table. Test with different reference types. 5 arguments used.');
		// Case #24: Array(2). Test with multiple arrays. 2 arguments used.
		oParser = new parserFormula('AVEDEV({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1.5, 'Test: Positive case: Array(2). Test with multiple arrays. 2 arguments used.');
		// Case #25: Area. Test with a range containing an empty cell (empties are ignored). 1 argument used.
		oParser = new parserFormula('AVEDEV(A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Area. Test with a range containing an empty cell (empties are ignored). 1 argument used.');
		// Case #26: Number, Reference link(2), Array. Test with a combination of numbers, references and an array. 4 arguments used.
		oParser = new parserFormula('AVEDEV(10,A100,A101,{20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(10,A100,A101,{20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 9.616, 'Test: Positive case: Number, Reference link(2), Array. Test with a combination of numbers, references and an array. 4 arguments used.');
		// Case #27: Formula, String, Boolean. Test with a formula, string and boolean value. 3 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#37
		/*oParser = new parserFormula('AVEDEV(PI(),"3.14",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(PI(),"3.14",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/!*.toFixed(9) - 0*!/, 0.951465034, 'Test: Positive case: Formula, String, Boolean. Test with a formula, string and boolean value. 3 arguments used.');
		*/// Case #28: Number(2), Name. Test with numbers and a named range with multiple values. 3 arguments used.
		oParser = new parserFormula('AVEDEV(100,200,TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(100,200,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Number(2), Name. Test with numbers and a named range with multiple values. 3 arguments used.');
		// Case #29: Number(2), Area. Test with numbers and a range with multiple values. 3 arguments used.
		oParser = new parserFormula('AVEDEV(10,20,A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(10,20,A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(2), Area. Test with numbers and a range with multiple values. 3 arguments used.');
		// Case #30: Number, Array, Reference link. Test with a number, array and reference. 3 arguments used.
		oParser = new parserFormula('AVEDEV(5,{1,2,3},A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(5,{1,2,3},A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 1.12, 'Test: Positive case: Number, Array, Reference link. Test with a number, array and reference. 3 arguments used.');
		// Case #31: Number, Formula(2). Test with a number, date and time. 3 arguments used.
		oParser = new parserFormula('AVEDEV(42,DATE(2025,5,15),TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(42,DATE(2025,5,15),TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 20342.55556, 'Test: Positive case: Number, Formula(2). Test with a number, date and time. 3 arguments used.');
		// Case #32: Number, Reference link, Name, Ref3D. Test with a number, reference, name and 3D reference. 4 arguments used.
		oParser = new parserFormula('AVEDEV(7,A100,TestName,Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(7,A100,TestName,Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 2.875, 'Test: Positive case: Number, Reference link, Name, Ref3D. Test with a number, reference, name and 3D reference. 4 arguments used.');
		// Case #33: Area3D, Name3D. Test with a 3D range and a 3D named range. 2 arguments used.
		oParser = new parserFormula('AVEDEV(Sheet2!A1:A2,TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(Sheet2!A1:A2,TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Area3D, Name3D. Test with a 3D range and a 3D named range. 2 arguments used.');
		// Case #34: Empty(3). Test with empty arguments. 3 arguments used.
		oParser = new parserFormula('AVEDEV(,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty(3). Test with empty arguments. 3 arguments used.');

		// Negative cases:

		// Case #1: String. Test with a non-numeric string. #VALUE! error.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#38
		/*oParser = new parserFormula('AVEDEV("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Test with a non-numeric string. #VALUE! error.');
		// Case #2: Error. Test with #N/A error. Returns #N/A.
		oParser = new parserFormula('AVEDEV(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Test with #N/A error. Returns #N/A.');
		*/// Case #3: Empty. Test with an empty cell.
		oParser = new parserFormula('AVEDEV(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Test with an empty cell.');
		// Case #4: Area. Test with a range containing an error. Returns #NUM! error.
		oParser = new parserFormula('AVEDEV(A109:A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(A109:A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Test with a range containing an error. Returns #NUM! error.');
		// Case #5: String(3). Test with multiple non-numeric strings. #VALUE! error.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#38
		/*oParser = new parserFormula('AVEDEV("abc","def","ghi")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV("abc","def","ghi") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). Test with multiple non-numeric strings. #VALUE! error.');
		*/// Case #6: Array. Test with an array of text values. #VALUE! error.
		oParser = new parserFormula('AVEDEV({"a","b","c"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV({"a","b","c"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Test with an array of text values. #VALUE! error.');
		// Case #7: Table. Test with a table reference to a column with text. #VALUE! error.
		oParser = new parserFormula('AVEDEV(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table. Test with a table reference to a column with text. #VALUE! error.');
		// Case #8: Name. Test with a named range containing text. #VALUE! error.
		oParser = new parserFormula('AVEDEV(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Test with a named range containing text. #VALUE! error.');
		// Case #9: Name3D. Test with a 3D named range containing text. #VALUE! error.
		oParser = new parserFormula('AVEDEV(TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. Test with a 3D named range containing text. #VALUE! error.');
		// Case #10: Area3D. Test with a 3D range containing an error. Returns an error.
		oParser = new parserFormula('AVEDEV(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. Test with a 3D range containing an error. Returns an error.');
		// Case #11: Number, String, Error. Test with mixed types including an error. Returns an error.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#38
		/*oParser = new parserFormula('AVEDEV(1,"abc",NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(1,"abc",NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Error. Test with mixed types including an error. Returns an error.');
		// Case #12: Array. Test with an array containing an error. Returns an error.
		oParser = new parserFormula('AVEDEV({1,2,#N/A})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV({1,2,#N/A}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Test with an array containing an error. Returns an error.');
		// Case #13: Number, String. Test with a number and a non-numeric string. #VALUE! error.
		oParser = new parserFormula('AVEDEV(1,"x")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(1,"x") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Test with a number and a non-numeric string. #VALUE! error.');
		// Case #14: String. Test with an empty string. #VALUE! error.
		oParser = new parserFormula('AVEDEV("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Test with an empty string. #VALUE! error.');
		*/// Case #15: Reference link. Test with a reference to a cell with text. #NUM! error.
		oParser = new parserFormula('AVEDEV(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Test with a reference to a cell with text. #NUM! error.');
		// Case #16: Ref3D. Test with a 3D reference to an empty cell. #NUM! error.
		oParser = new parserFormula('AVEDEV(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. Test with a 3D reference to an empty cell. #NUM! error.');
		// Case #17: Area. Test with a range containing only logical values and text. #NUM! error.
		oParser = new parserFormula('AVEDEV(A110:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(A110:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Test with a range containing only logical values and text. #NUM! error.');

		// Bounded cases:

		// Case #1: Number. Test with the minimum positive number in Excel. 1 argument used.
		oParser = new parserFormula('AVEDEV(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Test with the minimum positive number in Excel. 1 argument used.');
		// Case #2: Number. Test with the maximum number in Excel. 1 argument used.
		oParser = new parserFormula('AVEDEV(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Test with the maximum number in Excel. 1 argument used.');
		// Case #3: Number(2). Test with a mix of minimum and maximum numbers. 2 arguments used.
		oParser = new parserFormula('AVEDEV(1E-307,9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(1E-307,9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.999999999999995e+307, 'Test: Bounded case: Number(2). Test with a mix of minimum and maximum numbers. 2 arguments used.');
		// Case #4: Number(3). Test with maximum numbers of different signs and zero. 3 arguments used.
		oParser = new parserFormula('AVEDEV(9.99999999999999E+306,-9.99999999999999E+307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(9.99999999999999E+306,-9.99999999999999E+307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.666666666666662e+307, 'Test: Bounded case: Number(3). Test with maximum numbers of different signs and zero. 3 arguments used.');
		// Case #5: Number(3). Test with minimum numbers of different signs and zero. 3 arguments used.
		oParser = new parserFormula('AVEDEV(1E-307,-1E-307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(1E-307,-1E-307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.666666666666666e-308, 'Test: Bounded case: Number(3). Test with minimum numbers of different signs and zero. 3 arguments used.');
		// Case #6: Number(5). Test with identical numbers. Result should be 0. 5 arguments used.
		oParser = new parserFormula('AVEDEV(1,1,1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(1,1,1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(5). Test with identical numbers. Result should be 0. 5 arguments used.');
		// Case #7: Number(3). Test with zeros. Result should be 0. 3 arguments used.
		oParser = new parserFormula('AVEDEV(0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVEDEV(0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3). Test with zeros. Result should be 0. 3 arguments used.');


		testArrayFormula2(assert, "AVEDEV", 1, 8, null, true);
	});

	QUnit.test("Test: \"AVERAGE\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("10");
		ws.getRange2("A101").setValue("20");
		ws.getRange2("A102").setValue("30");
		ws.getRange2("A103").setValue("40");
		ws.getRange2("A104").setValue("50");
		ws.getRange2("A105").setValue("60");
		ws.getRange2("A106").setValue("Text");
		ws.getRange2("A107").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("2"); // Column1
		ws.getRange2("B601").setValue("Test"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("10");
		ws2.getRange2("A2").setValue("7");
		ws2.getRange2("A3").setValue("Test");
		ws2.getRange2("A4").setValue("");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("7"); // TestName
		ws.getRange2("A202").setValue("9"); // TestName1
		ws.getRange2("A206").setValue("10"); // TestNameArea
		ws.getRange2("A207").setValue("7"); // TestNameArea
		ws.getRange2("A208").setValue("Test"); // TestNameArea2
		ws.getRange2("B208").setValue("Text"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("27") // TestName3D
		ws2.getRange2("A12").setValue("2") // TestName3D1
		ws2.getRange2("A16").setValue("9"); // TestNameArea3D
		ws2.getRange2("A17").setValue("27"); // TestNameArea3D
		ws2.getRange2("A18").setValue("Test"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("Text"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Number(5). Arguments are number. 5 arguments used.
		oParser = new parserFormula('AVERAGE(1,2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(5). Arguments are number. 5 arguments used.');
		// Case #2: Array. Arguments are array. 1 argument used
		oParser = new parserFormula('AVERAGE({1,2;3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE({1,2;3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array. Arguments are array. 1 argument used');
		// Case #3: Array,Number,String. Array, Number and string. 3 arguments used.
		oParser = new parserFormula('AVERAGE({1,2,3,4,5},6,"7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE({1,2,3,4,5},6,"7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Array,Number,String. Array, Number and string. 3 arguments used.');
		// Case #4: Array. Argument is array with number, array and boolean.
		oParser = new parserFormula('AVERAGE({1,"2",TRUE,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE({1,"2",TRUE,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array. Argument is array with number, array and boolean.');
		// Case #5: Number(2). Basic usage with two integers. 2 arguments used.
		oParser = new parserFormula('AVERAGE(1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1.5, 'Test: Positive case: Number(2). Basic usage with two integers. 2 arguments used.');
		// Case #6: Number(3). Basic usage with three integers. 3 arguments used.
		oParser = new parserFormula('AVERAGE(1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(3). Basic usage with three integers. 3 arguments used.');
		// Case #7: Number(4). Multiple number arguments. 4 arguments used.
		oParser = new parserFormula('AVERAGE(10,20,30,40)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(10,20,30,40) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number(4). Multiple number arguments. 4 arguments used.');
		// Case #8: Number(5). Five number arguments of increasing value. 5 arguments used.
		oParser = new parserFormula('AVERAGE(1,2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(5). Five number arguments of increasing value. 5 arguments used.');
		// Case #9: Number. Single decimal number. 1 argument used.
		oParser = new parserFormula('AVERAGE(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1.5, 'Test: Positive case: Number. Single decimal number. 1 argument used.');
		// Case #10: Number(3). Multiple decimal numbers. 3 arguments used.
		oParser = new parserFormula('AVERAGE(1.5,2.5,3.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1.5,2.5,3.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 2.5, 'Test: Positive case: Number(3). Multiple decimal numbers. 3 arguments used.');
		// Case #11: Number(3). Positive, negative and zero values. 3 arguments used.
		oParser = new parserFormula('AVERAGE(-10,0,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(-10,0,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(3). Positive, negative and zero values. 3 arguments used.');
		// Case #12: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('AVERAGE("10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE("10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #13: String(3). Multiple strings convertible to numbers. 3 arguments used.
		oParser = new parserFormula('AVERAGE("1","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE("1","2","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String(3). Multiple strings convertible to numbers. 3 arguments used.');
		// Case #14: Formula. Nested formula. 1 argument used.
		oParser = new parserFormula('AVERAGE(SUM(1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(SUM(1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. Nested formula. 1 argument used.');
		// Case #15: Formula(3). Multiple nested formulas. 3 arguments used.
		oParser = new parserFormula('AVERAGE(SUM(1,2),PRODUCT(2,3),POWER(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(SUM(1,2),PRODUCT(2,3),POWER(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.333333333, 'Test: Positive case: Formula(3). Multiple nested formulas. 3 arguments used.');
		// Case #16: Reference link. Reference to cell with number. 1 argument used.
		oParser = new parserFormula('AVERAGE(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link. Reference to cell with number. 1 argument used.');
		// Case #17: Reference link(3). Multiple cell references. 3 arguments used.
		oParser = new parserFormula('AVERAGE(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Reference link(3). Multiple cell references. 3 arguments used.');
		// Case #18: Area. Range reference. 1 argument used.
		oParser = new parserFormula('AVERAGE(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Area. Range reference. 1 argument used.');
		// Case #19: Area(2). Multiple range references. 2 arguments used.
		oParser = new parserFormula('AVERAGE(A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A100:A102,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 35, 'Test: Positive case: Area(2). Multiple range references. 2 arguments used.');
		// Case #20: Array. Array of numbers. 1 argument used.
		oParser = new parserFormula('AVERAGE({1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE({1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array. Array of numbers. 1 argument used.');
		// Case #21: Array(2). Multiple arrays. 2 arguments used.
		oParser = new parserFormula('AVERAGE({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 3.5, 'Test: Positive case: Array(2). Multiple arrays. 2 arguments used.');
		// Case #22: Name. Named range with number. 1 argument used.
		oParser = new parserFormula('AVERAGE(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Name. Named range with number. 1 argument used.');
		// Case #23: Name(2). Multiple named ranges with numbers. 2 arguments used.
		oParser = new parserFormula('AVERAGE(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Name(2). Multiple named ranges with numbers. 2 arguments used.');
		// Case #24: Name3D. 3D named range with number. 1 argument used.
		oParser = new parserFormula('AVERAGE(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 27, 'Test: Positive case: Name3D. 3D named range with number. 1 argument used.');
		// Case #25: Name3D(2). Multiple 3D named ranges with numbers. 2 arguments used.
		oParser = new parserFormula('AVERAGE(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 14.5, 'Test: Positive case: Name3D(2). Multiple 3D named ranges with numbers. 2 arguments used.');
		// Case #26: Ref3D. 3D reference to number. 1 argument used.
		oParser = new parserFormula('AVERAGE(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Ref3D. 3D reference to number. 1 argument used.');
		// Case #27: Ref3D(2). Multiple 3D references to numbers. 2 arguments used.
		oParser = new parserFormula('AVERAGE(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 8.5, 'Test: Positive case: Ref3D(2). Multiple 3D references to numbers. 2 arguments used.');
		// Case #28: Area3D. 3D range reference with numbers. 1 argument used.
		oParser = new parserFormula('AVERAGE(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 8.5, 'Test: Positive case: Area3D. 3D range reference with numbers. 1 argument used.');
		// Case #29: Table. Table reference with numbers. 1 argument used.
		oParser = new parserFormula('AVERAGE(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Table. Table reference with numbers. 1 argument used.');
		// Case #30: Number, String, Reference link. Number, string, and reference. 3 arguments used.
		oParser = new parserFormula('AVERAGE(1,"2",A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,"2",A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.333333333, 'Test: Positive case: Number, String, Reference link. Number, string, and reference. 3 arguments used.');
		// Case #31: Number, Empty, Number, Empty. Numbers with empty arguments. Empty arguments ignored. 4 arguments used.
		oParser = new parserFormula('AVERAGE(1,,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.75, 'Test: Positive case: Number, Empty, Number, Empty. Numbers with empty arguments. Empty arguments ignored. 4 arguments used.');
		// Case #32: Formula(2). Dates as numbers. 2 arguments used.
		oParser = new parserFormula('AVERAGE(DATE(2023,1,1),DATE(2023,1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(DATE(2023,1,1),DATE(2023,1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 44928, 'Test: Positive case: Formula(2). Dates as numbers. 2 arguments used.');
		// Case #33: Formula(2). Times as numbers. 2 arguments used.
		oParser = new parserFormula('AVERAGE(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.520833333, 'Test: Positive case: Formula(2). Times as numbers. 2 arguments used.');
		// Case #34: Formula. AVERAGE inside another formula. 2 arguments used.
		oParser = new parserFormula('SUM(AVERAGE(1,2),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(AVERAGE(1,2),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 4.5, 'Test: Positive case: Formula. AVERAGE inside another formula. 2 arguments used.');
		// Case #35: Reference link(2). References to number and text. Text ignored. 2 arguments used.
		oParser = new parserFormula('AVERAGE(A100,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A100,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Reference link(2). References to number and text. Text ignored. 2 arguments used.');
		// Case #36: Area. Range with mixed data types. Text ignored. 1 argument used.
		oParser = new parserFormula('AVERAGE(A100:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A100:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Area. Range with mixed data types. Text ignored. 1 argument used.');
		// Case #37: Number, Reference link. Number and reference to empty cell. Empty cell ignored. 2 arguments used.
		oParser = new parserFormula('AVERAGE(1,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25.5, 'Test: Positive case: Number, Reference link. Number and reference to empty cell. Empty cell ignored. 2 arguments used.');
		// Case #38: Array. Array with mixed data types. Text ignored. 1 argument used.
		oParser = new parserFormula('AVERAGE({1,"text",3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE({1,"text",3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array. Array with mixed data types. Text ignored. 1 argument used.');
		// Case #39: Number, Reference link. Number and reference to cell with error. Returns error. 2 arguments used.
		oParser = new parserFormula('AVERAGE(1,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30.5, 'Test: Positive case: Number, Reference link. Number and reference to cell with error. Returns error. 2 arguments used.');
		// Case #40: String(2). Date strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('AVERAGE("01/01/2023","03/01/2023")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE("01/01/2023","03/01/2023") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 44956.5, 'Test: Positive case: String(2). Date strings convertible to numbers. 2 arguments used.');
		// Case #41: Area, Name. Range and named range. 2 arguments used.
		oParser = new parserFormula('AVERAGE(A100:A102,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A100:A102,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 16.75, 'Test: Positive case: Area, Name. Range and named range. 2 arguments used.');
		// Case #42: Empty(3). Empty arguments. 3 arguments used.
		oParser = new parserFormula('AVERAGE(,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty(3). Empty arguments. 3 arguments used.');
		// Case #43: Array, Number. Array with text and number. 2 arguments used.
		oParser = new parserFormula('AVERAGE({"text"},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE({"text"},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array, Number. Array with text and number. 2 arguments used.');
		// Case #44: Number, Reference link(2). Number with references to text cells returns #VALUE! error. 3 arguments used.
		oParser = new parserFormula('AVERAGE(1,A106,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,A106,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Reference link(2). Number with references to text cells returns #VALUE! error. 3 arguments used.');
		// Case #45: Name, Name3D. Name with area and Name3D with area. 2 arguments used.
		oParser = new parserFormula('AVERAGE(TestNameArea,TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(TestNameArea,TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 13.25, 'Test: Positive case: Name, Name3D. Name with area and Name3D with area. 2 arguments used.');
		// Case #46: Boolean(2). Booleans - TRUE and FALSE. 2 arguments used.
		oParser = new parserFormula('AVERAGE(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Boolean(2). Booleans - TRUE and FALSE. 2 arguments used.');

		// Negative cases:

		// Case #1: String. Non-numeric string returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('AVERAGE("text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE("text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE! error. 1 argument used.');
		// Case #2: String(2). Multiple non-numeric strings return #DIV/0! error. 2 arguments used.
		oParser = new parserFormula('AVERAGE("text1","text2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE("text1","text2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Multiple non-numeric strings return #DIV/0! error. 2 arguments used.');
		// Case #3: Error. Error value propagates. 1 argument used.
		oParser = new parserFormula('AVERAGE(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value propagates. 1 argument used.');
		// Case #4: Error(2). Multiple error values. 2 arguments used.
		oParser = new parserFormula('AVERAGE(NA(),DIV(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(NA(),DIV(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). Multiple error values. 2 arguments used.');
		// Case #5: Error, Number(2). Error with numbers propagates error. 3 arguments used.
		oParser = new parserFormula('AVERAGE(NA(),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(NA(),1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(2). Error with numbers propagates error. 3 arguments used.');
		// Case #6: Reference link. Reference to cell with text. 1 argument used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#40
		/*oParser = new parserFormula('AVERAGE(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cell with text. 1 argument used.');
		// Case #7: Reference link. Reference to empty cell returns #DIV/0! error. 1 argument used.
		oParser = new parserFormula('AVERAGE(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to empty cell returns #DIV/0! error. 1 argument used.');
		// Case #8: Area. Range with non-numeric data returns #DIV/0! error. 1 argument used.
		oParser = new parserFormula('AVERAGE(A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area. Range with non-numeric data returns #DIV/0! error. 1 argument used.');
		// Case #9: Array. Array with non-numeric data returns #DIV/0! error. 1 argument used.
		oParser = new parserFormula('AVERAGE({"text1","text2"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE({"text1","text2"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with non-numeric data returns #DIV/0! error. 1 argument used.');
		*/// Case #10: Formula. Formula resulting in error propagates error. 1 argument used.
		oParser = new parserFormula('AVERAGE(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in error propagates error. 1 argument used.');
		// Case #11: Name. Named range with text returns #VALUE! error. 1 argument used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#40
		/*oParser = new parserFormula('AVERAGE(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name. Named range with text returns #VALUE! error. 1 argument used.');
		// Case #12: Name3D. 3D named range with text returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('AVERAGE(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE! error. 1 argument used.');
		// Case #13: Ref3D. 3D reference to text returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('AVERAGE(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE! error. 1 argument used.');
		// Case #14: Area3D. 3D range with text returns #DIV/0! error. 1 argument used.
		oParser = new parserFormula('AVERAGE(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with text returns #DIV/0! error. 1 argument used.');
		// Case #15: Table. Table column with text returns #VALUE! error. 1 argument used.
		oParser = new parserFormula('AVERAGE(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Table. Table column with text returns #VALUE! error. 1 argument used.');
		// Case #16: Reference link(3). All references to empty cells returns #DIV/0! error. 3 arguments used.
		oParser = new parserFormula('AVERAGE(A107,A107,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(A107,A107,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link(3). All references to empty cells returns #DIV/0! error. 3 arguments used.');
		*/// Case #17: Formula. Division by zero returns #DIV/0! error. 1 argument used.
		oParser = new parserFormula('AVERAGE(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero returns #DIV/0! error. 1 argument used.');
		// Case #18: Number, String. Number with invalid date string returns #VALUE! error. 2 arguments used.
		oParser = new parserFormula('AVERAGE(1,"invalid date")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1,"invalid date") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Number with invalid date string returns #VALUE! error. 2 arguments used.');
		// Case #19: Formula. Formula returning error propagates error. 1 argument used.
		oParser = new parserFormula('AVERAGE(IF(TRUE,#N/A,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(IF(TRUE,#N/A,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Formula returning error propagates error. 1 argument used.');
		// Case #20: Array. Array with error returns error. 1 argument used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#41
		/*oParser = new parserFormula('AVERAGE({#N/A,1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE({#N/A,1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Array with error returns error. 1 argument used.');
*/
		// Bounded cases:

		// Case #1: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('AVERAGE(-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+307, 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #2: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('AVERAGE(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #3: Number. Smallest positive number in Excel. 1 argument used.
		oParser = new parserFormula('AVERAGE(2.2250738585072E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(2.2250738585072E-308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2250738585072e-307, 'Test: Bounded case: Number. Smallest positive number in Excel. 1 argument used.');
		// Case #4: Number(2). Minimum and maximum Excel numbers. 2 arguments used.
		oParser = new parserFormula('AVERAGE(-1E+307,9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(-1E+307,9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.499999999999995e+307, 'Test: Bounded case: Number(2). Minimum and maximum Excel numbers. 2 arguments used.');
		// Case #5: Number(5). Multiple very large numbers. 5 arguments used.
		oParser = new parserFormula('AVERAGE(1E+307,2E+307,3E+307,4E+307,5E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1E+307,2E+307,3E+307,4E+307,5E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3e+307, 'Test: Bounded case: Number(5). Multiple very large numbers. 5 arguments used.');
		// Case #6: Number(5). Multiple very small numbers. 5 arguments used.
		oParser = new parserFormula('AVERAGE(1E-307,2E-307,3E-307,4E-307,5E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1E-307,2E-307,3E-307,4E-307,5E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.9999999999999995e-307, 'Test: Bounded case: Number(5). Multiple very small numbers. 5 arguments used.');
		// Case #7: Number(2). Near-zero numbers. 2 arguments used.
		oParser = new parserFormula('AVERAGE(2.2250738585072E-307,-2.2250738585072E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(2.2250738585072E-307,-2.2250738585072E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Near-zero numbers. 2 arguments used.');
		// Case #8: Number(2). Numbers with vastly different scales. 2 arguments used.
		oParser = new parserFormula('AVERAGE(1E+100,1E-100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(1E+100,1E-100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5e+99, 'Test: Bounded case: Number(2). Numbers with vastly different scales. 2 arguments used.');


		testArrayFormula2(assert, "AVERAGE", 1, 8, null, true);
	});

	QUnit.test("Test: \"AVERAGEA\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("E2").setValue("TRUE");
		ws.getRange2("E3").setValue("FALSE");
		ws.getRange2("F2").setValue("10");
		ws.getRange2("F3").setValue("7");
		ws.getRange2("F4").setValue("9");
		ws.getRange2("F5").setValue("2");
		ws.getRange2("F6").setValue("Not available");
		ws.getRange2("F7").setValue("");
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("0");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A104").setValue("#N/A");
		ws.getRange2("A105").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 605, 1);
		ws.getRange2("A601").setValue("2"); // Column1
		ws.getRange2("A602").setValue("10"); // Column1
		ws.getRange2("A603").setValue("5"); // Column1
		ws.getRange2("A604").setValue("3"); // Column1
		ws.getRange2("A605").setValue("8"); // Column1
		ws.getRange2("A606").setValue("3"); // Column1
		ws.getRange2("B601").setValue("#N/A"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("3");
		ws2.getRange2("A2").setValue("3");
		ws2.getRange2("A3").setValue("");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("4"); // TestName
		ws.getRange2("A206").setValue(""); // TestNameArea
		ws.getRange2("A207").setValue(""); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("5") // TestName3D

		// Positive cases:

		// Case #1: Number, Reference link. Number and ref link to empty cell. 2 arguments were used.
		oParser = new parserFormula('AVERAGEA(10,E1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(10,E1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number, Reference link. Number and ref link to empty cell. 2 arguments were used.');
		// Case #2: Number, Reference link. Number and ref link with boolean (TRUE). 2 arguments were used.
		oParser = new parserFormula('AVERAGEA(10,E2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(10,E2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 5.5, 'Test: Positive case: Number, Reference link. Number and ref link with boolean (TRUE). 2 arguments were used.');
		// Case #3: Number, Reference link. Number anf ref link with boolean (FALSE). 2 arguments were used.
		oParser = new parserFormula('AVERAGEA(10,E3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(10,E3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Reference link. Number anf ref link with boolean (FALSE). 2 arguments were used.');
		// Case #4: Area. Area with numbers and string cells. 1 argument was used.
		oParser = new parserFormula('AVERAGEA(F2:F6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(F2:F6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 5.6, 'Test: Positive case: Area. Area with numbers and string cells. 1 argument was used.');
		// Case #5: Area, Reference link. Area with numbers and ref link to empty cell. 2 arguments were used.
		oParser = new parserFormula('AVERAGEA(F2:F5,F7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(F2:F5,F7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Area, Reference link. Area with numbers and ref link to empty cell. 2 arguments were used.');
		// Case #6: Number(5). Basic test with numeric values only. All values are numbers. 5 arguments used.
		oParser = new parserFormula('AVERAGEA(1,2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(1,2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(5). Basic test with numeric values only. All values are numbers. 5 arguments used.');
		// Case #7: Number, Boolean. Numeric and logical value TRUE (1). 2  arguments used.
		oParser = new parserFormula('AVERAGEA(10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 5.5, 'Test: Positive case: Number, Boolean. Numeric and logical value TRUE (1). 2  arguments used.');
		// Case #8: Number, Boolean. Numeric and logical value FALSE (0). 2  arguments used.
		oParser = new parserFormula('AVERAGEA(10,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(10,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Boolean. Numeric and logical value FALSE (0). 2  arguments used.');
		// Case #9: Number, String. Numeric and number value in string. 2 arguments used.
		oParser = new parserFormula('AVERAGEA(10,"10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(10,"10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number, String. Numeric and number value in string. 2 arguments used.');
		// Case #10: Number, Empty. Numeric value and empty cell (empty counts as 0). 2 arguments used.
		oParser = new parserFormula('AVERAGEA(10,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(10,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Empty. Numeric value and empty cell (empty counts as 0). 2 arguments used.');
		// Case #11: Reference link. Single cell reference with numeric value. 1  arguments used.
		oParser = new parserFormula('AVERAGEA(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Single cell reference with numeric value. 1  arguments used.');
		// Case #12: Area. Range of cells with numeric values. 1  arguments used.
		oParser = new parserFormula('AVERAGEA(A101:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A101:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.333333333, 'Test: Positive case: Area. Range of cells with numeric values. 1  arguments used.');
		// Case #13: Array. Array constant with numeric values. 1 arguments used.
		oParser = new parserFormula('AVERAGEA({1,2,3,4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA({1,2,3,4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array. Array constant with numeric values. 1 arguments used.');
		// Case #14: Formula(5). Formulas that return numeric values. 5 arguments used.
		oParser = new parserFormula('AVERAGEA(1+2,SQRT(9),ABS(-4),INT(4.9),ROUND(5.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(1+2,SQRT(9),ABS(-4),INT(4.9),ROUND(5.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 3.8, 'Test: Positive case: Formula(5). Formulas that return numeric values. 5 arguments used.');
		// Case #15: String(5). Text values that can be converted to numbers. 5  arguments used.
		oParser = new parserFormula('AVERAGEA("1","2","3","4","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA("1","2","3","4","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String(5). Text values that can be converted to numbers. 5  arguments used.');
		// Case #16: Number, String, Boolean(2). Mix of numeric, text convertible to number, logical. 5 arguments used.
		oParser = new parserFormula('AVERAGEA(1,"2",TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(1,"2",TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, String, Boolean(2). Mix of numeric, text convertible to number, logical. 5 arguments used.');
		// Case #17: Formula(2). Date values (internally stored as numbers). 2 arguments used.
		oParser = new parserFormula('AVERAGEA(DATE(2025,1,1),DATE(2025,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(DATE(2025,1,1),DATE(2025,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 45658.5, 'Test: Positive case: Formula(2). Date values (internally stored as numbers). 2 arguments used.');
		// Case #18: Formula(2). Time values (internally stored as fractions of a day). 2 arguments used.
		oParser = new parserFormula('AVERAGEA(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.520833333, 'Test: Positive case: Formula(2). Time values (internally stored as fractions of a day). 2 arguments used.');
		// Case #19: Name. Named range with numeric values. 1 arguments used.
		oParser = new parserFormula('AVERAGEA(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Name. Named range with numeric values. 1 arguments used.');
		// Case #20: Name3D. 3D named range with numeric values. 1  arguments used.
		oParser = new parserFormula('AVERAGEA(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Name3D. 3D named range with numeric values. 1  arguments used.');
		// Case #21: Ref3D. 3D reference to cell with numeric value. 1 arguments used.
		oParser = new parserFormula('AVERAGEA(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Ref3D. 3D reference to cell with numeric value. 1 arguments used.');
		// Case #22: Area3D. 3D area reference with numeric values. 1  arguments used.
		oParser = new parserFormula('AVERAGEA(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area3D. 3D area reference with numeric values. 1  arguments used.');
		// Case #23: Table. Table reference with numeric values. 1 arguments used.
		oParser = new parserFormula('AVERAGEA(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 5.166666667, 'Test: Positive case: Table. Table reference with numeric values. 1 arguments used.');
		// Case #24: Empty(5). All empty arguments (count as 0). 5  arguments used.
		oParser = new parserFormula('AVERAGEA(,,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(,,,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty(5). All empty arguments (count as 0). 5  arguments used.');
		// Case #25: Number, Empty(4). One numeric value with multiple empty arguments (empty count as 0). 5 arguments used.
		oParser = new parserFormula('AVERAGEA(10,,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(10,,,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, Empty(4). One numeric value with multiple empty arguments (empty count as 0). 5 arguments used.');
		// Case #26: Formula. AVERAGEA nested inside another function. 3 arguments used in AVERAGEA.
		oParser = new parserFormula('SUM(AVERAGEA(1,2,3),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(AVERAGEA(1,2,3),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Formula. AVERAGEA nested inside another function. 3 arguments used in AVERAGEA.');
		// Case #27: Reference link, Area. Mix of single cell reference and range. 2  arguments used.
		oParser = new parserFormula('AVERAGEA(A100,A101:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A100,A101:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 2.75, 'Test: Positive case: Reference link, Area. Mix of single cell reference and range. 2  arguments used.');
		// Case #28: Boolean(5). All logical TRUE values (each counts as 1). 5 arguments used.
		oParser = new parserFormula('AVERAGEA(TRUE,TRUE,TRUE,TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(TRUE,TRUE,TRUE,TRUE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean(5). All logical TRUE values (each counts as 1). 5 arguments used.');
		// Case #29: Boolean(5). All logical FALSE values (each counts as 0). 5 arguments used.
		oParser = new parserFormula('AVERAGEA(FALSE,FALSE,FALSE,FALSE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(FALSE,FALSE,FALSE,FALSE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean(5). All logical FALSE values (each counts as 0). 5 arguments used.');
		// Case #30: Formula(2), Number. Mix of date, time, and number. 3 arguments used.
		oParser = new parserFormula('AVERAGEA(DATE(2025,1,1),TIME(12,0,0),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(DATE(2025,1,1),TIME(12,0,0),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 15219.83333, 'Test: Positive case: Formula(2), Number. Mix of date, time, and number. 3 arguments used.');
		// Case #31: String(2), Number(3). Mix of text that can be converted to numbers and actual numbers. 5  arguments used.
		oParser = new parserFormula('AVERAGEA("100","200",300,400,500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA("100","200",300,400,500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 300, 'Test: Positive case: String(2), Number(3). Mix of text that can be converted to numbers and actual numbers. 5  arguments used.');
		// Case #32: Number(4), Empty. All zero values with empty argument (empty counts as 0). 5 arguments used.
		oParser = new parserFormula('AVERAGEA(0,0,0,0,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(0,0,0,0,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(4), Empty. All zero values with empty argument (empty counts as 0). 5 arguments used.');
		// Case #33: Number, String(2), Boolean(2). Mix of number, text zeros, and logical values. 5 arguments used.
		oParser = new parserFormula('AVERAGEA(1,"0","0",FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(1,"0","0",FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.4, 'Test: Positive case: Number, String(2), Boolean(2). Mix of number, text zeros, and logical values. 5 arguments used.');
		// Case #34: Area. Single-cell area reference. 1 arguments used.
		oParser = new parserFormula('AVERAGEA(A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell area reference. 1 arguments used.');
		// Case #35: Formula(2). Nested IF formulas returning numbers. 2 arguments used.
		oParser = new parserFormula('AVERAGEA(IF(TRUE,1,2),IF(FALSE,3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(IF(TRUE,1,2),IF(FALSE,3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 2.5, 'Test: Positive case: Formula(2). Nested IF formulas returning numbers. 2 arguments used.');
		// Case #36: Number, Formula. Number and simple arithmetic formula. 2  arguments used.
		oParser = new parserFormula('AVERAGEA(5,5*2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(5,5*2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 7.5, 'Test: Positive case: Number, Formula. Number and simple arithmetic formula. 2  arguments used.');
		// Case #37: Reference link(3). Multiple cell references. 3 arguments used.
		oParser = new parserFormula('AVERAGEA(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.666666667, 'Test: Positive case: Reference link(3). Multiple cell references. 3 arguments used.');
		// Case #38: Array(2). Multiple array constants. 2  arguments used.
		oParser = new parserFormula('AVERAGEA({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 2.5, 'Test: Positive case: Array(2). Multiple array constants. 2  arguments used.');
		// Case #39: String(3), Empty(2). Text values convertible to numbers with empty cells. 5 arguments used.
		oParser = new parserFormula('AVERAGEA("1","2","3",,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA("1","2","3",,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1.2, 'Test: Positive case: String(3), Empty(2). Text values convertible to numbers with empty cells. 5 arguments used.');
		// Case #40: Name, Name3D. Mix of regular named range and 3D named range. 2 arguments used.
		oParser = new parserFormula('AVERAGEA(TestName,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(TestName,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 4.5, 'Test: Positive case: Name, Name3D. Mix of regular named range and 3D named range. 2 arguments used.');
		// Case #41: Name, Ref3D. Mix of named range and 3D reference. 2 arguments used.
		oParser = new parserFormula('AVERAGEA(TestName,Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(TestName,Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 3.5, 'Test: Positive case: Name, Ref3D. Mix of named range and 3D reference. 2 arguments used.');
		// Case #42: Area, Area3D. Mix of regular range and 3D range. 2 arguments used.
		oParser = new parserFormula('AVERAGEA(A101:A103,Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A101:A103,Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 3.2, 'Test: Positive case: Area, Area3D. Mix of regular range and 3D range. 2 arguments used.');
		// Case #43: Table, Number. Mix of table reference and direct number. 2 arguments used.
		oParser = new parserFormula('AVERAGEA(Table1[Column1],42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(Table1[Column1],42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 10.42857143, 'Test: Positive case: Table, Number. Mix of table reference and direct number. 2 arguments used.');

		// Negative cases:

		// Case #1: Error. Error value propagates. 1  arguments used.
		oParser = new parserFormula('AVERAGEA(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value propagates. 1  arguments used.');
		// Case #2: Number, Error. Mix of number and error (error propagates). 2  arguments used.
		oParser = new parserFormula('AVERAGEA(1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Mix of number and error (error propagates). 2  arguments used.');
		// Case #3: Reference link, Error. Reference and error value (error propagates). 2  arguments used.
		oParser = new parserFormula('AVERAGEA(A100,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A100,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link, Error. Reference and error value (error propagates). 2  arguments used.');
		// Case #4: Area, Error. Range and error value (error propagates). 2  arguments used.
		oParser = new parserFormula('AVERAGEA(A101:A103,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A101:A103,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area, Error. Range and error value (error propagates). 2  arguments used.');
		// Case #5: Formula. Formula that results in error (DIV/0!). 1 arguments used.
		oParser = new parserFormula('AVERAGEA(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula that results in error (DIV/0!). 1 arguments used.');
		// Case #6: Formula. Formula that results in error (NUM!). 1 arguments used.
		oParser = new parserFormula('AVERAGEA(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula that results in error (NUM!). 1 arguments used.');
		// Case #7: String, Error. String and error value (error propagates). 2 arguments used.
		oParser = new parserFormula('AVERAGEA("0/1",NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA("0/1",NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Error. String and error value (error propagates). 2 arguments used.');
		// Case #8: Name. Reference to non-existent name (NAME?). 1 arguments used.
		oParser = new parserFormula('AVERAGEA(NonExistentName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(NonExistentName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name. Reference to non-existent name (NAME?). 1 arguments used.');
		// Case #9: Array, Error. Array with error value (error propagates). 1  arguments used.
		oParser = new parserFormula('AVERAGEA({1,2}; NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA({1,2}; NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Error. Array with error value (error propagates). 1  arguments used.');
		// Case #10: Formula. IF formula that returns error. 1  arguments used.
		oParser = new parserFormula('AVERAGEA(IF(TRUE,NA(),1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(IF(TRUE,NA(),1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. IF formula that returns error. 1  arguments used.');
		// Case #11: String. Empty string. 1 argument used.
		oParser = new parserFormula('AVERAGEA("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string. 1 argument used.');
		// Case #12: Formula(2). Mix of valid formula and formula that returns error. 2  arguments used.
		oParser = new parserFormula('AVERAGEA(1+1,1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(1+1,1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula(2). Mix of valid formula and formula that returns error. 2  arguments used.');
		// Case #13: Error(3). Multiple different error values. 3 arguments used.
		oParser = new parserFormula('AVERAGEA(NA(),DIV0(),REF())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(NA(),DIV0(),REF()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(3). Multiple different error values. 3 arguments used.');
		// Case #14: Reference link. Reference to cell with error value. 1 arguments used.
		oParser = new parserFormula('AVERAGEA(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link. Reference to cell with error value. 1 arguments used.');
		// Case #15: Area. Range containing error values. 1 arguments used.
		oParser = new parserFormula('AVERAGEA(A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area. Range containing error values. 1 arguments used.');
		// Case #16: Ref3D. 3D reference to empty cell. 1  arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#40
		/*oParser = new parserFormula('AVERAGEA(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to empty cell. 1  arguments used.');
		// Case #17: Name. Named range with error values. 1 arguments used.
		oParser = new parserFormula('AVERAGEA(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name. Named range with error values. 1 arguments used.');
		*/// Case #18: Table. Table reference to column with error values. 1  arguments used.
		oParser = new parserFormula('AVERAGEA(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Table. Table reference to column with error values. 1  arguments used.');
		// Case #19: Error(5). All five arguments are different error values. 5  arguments used.
		oParser = new parserFormula('AVERAGEA(NA(),#DIV/0!,#REF!,#VALUE!,#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(NA(),#DIV/0!;#REF!;#VALUE!;#NUM!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(5). All five arguments are different error values. 5  arguments used.');
		// Case #21: String(5). Text values that cannot be converted to numbers. 5 arguments used.
		oParser = new parserFormula('AVERAGEA("A","B","C","D","E")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA("A","B","C","D","E") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Text values that cannot be converted to numbers. 5 arguments used.');
		// Case #22: Reference link, Boolean, String. Mix of reference, logical TRUE, and text. 3 arguments used.
		oParser = new parserFormula('AVERAGEA(A100,TRUE,"Text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(A100,TRUE,"Text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Boolean, String. Mix of reference, logical TRUE, and text. 3 arguments used.');

		// Bounded cases:

		// Case #1: Number. Maximum possible Excel number. 1 of 5 arguments used.
		oParser = new parserFormula('AVERAGEA(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999e+307, 'Test: Bounded case: Number. Maximum possible Excel number. 1 of 5 arguments used.');
		// Case #2: Number. Minimum possible Excel number. 1 of 5 arguments used.
		oParser = new parserFormula('AVERAGEA(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -9.99999999999999e+307, 'Test: Bounded case: Number. Minimum possible Excel number. 1 of 5 arguments used.');
		// Case #3: Number(2). Mix of maximum and minimum Excel numbers. 2 of 5 arguments used.
		oParser = new parserFormula('AVERAGEA(9.99999999999999E+307,-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(9.99999999999999E+307,-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Mix of maximum and minimum Excel numbers. 2 of 5 arguments used.');
		// Case #4: Number. Very small positive number close to zero. 1 of 5 arguments used.
		oParser = new parserFormula('AVERAGEA(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Very small positive number close to zero. 1 of 5 arguments used.');
		// Case #5: Number. Very small negative number close to zero. 1 of 5 arguments used.
		oParser = new parserFormula('AVERAGEA(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEA(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e-307, 'Test: Bounded case: Number. Very small negative number close to zero. 1 of 5 arguments used.');


		testArrayFormula2(assert, "AVERAGEA", 1, 8, null, true);
	});

	QUnit.test("Test: \"AVERAGEIF\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("F2:F3").setValue("");
		ws.getRange2("E2").setValue("10");
		ws.getRange2("E3").setValue("20");
		ws.getRange2("E4").setValue("28");
		ws.getRange2("E5").setValue("30");
		ws.getRange2("E6").setValue("1");
		ws.getRange2("E7").setValue("0");
		ws.getRange2("A100").setValue("10");
		ws.getRange2("A101").setValue("20");
		ws.getRange2("A102").setValue("30");
		ws.getRange2("A103").setValue("40");
		ws.getRange2("A104").setValue("50");
		ws.getRange2("A105").setValue("60");
		ws.getRange2("A106").setValue("70");
		ws.getRange2("A107").setValue("80");
		ws.getRange2("A108").setValue("90");
		ws.getRange2("A109").setValue("3");
		ws.getRange2("A110").setValue("5");
		ws.getRange2("B100").setValue("1");
		ws.getRange2("B101").setValue("2");
		ws.getRange2("B102").setValue("3");
		ws.getRange2("B103").setValue("4");
		ws.getRange2("B104").setValue("5");
		ws.getRange2("B105").setValue("6");
		ws.getRange2("B106").setValue("7");
		ws.getRange2("B107").setValue("8");
		ws.getRange2("B108").setValue("9");
		ws.getRange2("B109").setValue("10");
		ws.getRange2("B110").setValue("11");
		ws.getRange2("A111").setValue("50");
		ws.getRange2("A112").setValue("44927");
		ws.getRange2("A113").setValue("0.5");
		ws.getRange2("B112").setValue("Test");
		ws.getRange2("B113").setValue("Text");
		ws.getRange2("A114").setValue("0");
		ws.getRange2("A115").setValue("1e+308");
		ws.getRange2("A116").setValue("-1e+308");
		// type check
		ws.getRange2("G1").setValue("str1");
		ws.getRange2("G2").setValue("str2");
		ws.getRange2("I1").setValue("TRUE");
		ws.getRange2("I2").setValue("FALSE");
		// Table type. Use A601:L6**
		getTableType(599, 0, 601, 0);
		ws.getRange2("A601").setValue("6"); // Column1
		ws.getRange2("A602").setValue("7"); // Column1
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("10");
		ws2.getRange2("A2").setValue("20");
		ws2.getRange2("A3").setValue("28");
		ws2.getRange2("A4").setValue("30");
		ws2.getRange2("A5").setValue("6");
		ws2.getRange2("A6").setValue("7");
		ws2.getRange2("A7").setValue("8");
		ws2.getRange2("A8").setValue("9");
		ws2.getRange2("A9").setValue("0");
		ws2.getRange2("B1").setValue("");
		ws2.getRange2("B2").setValue("");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("10"); // TestName
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("6") // TestName3D

		// Positive cases:

		// Case #1: Area, String. Area with condition >15. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E5,">15")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E5,">15") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 26, 'Test: Positive case: Area, String. Area with condition >15. 2 of 3 arguments were used.');
		// Case #2: Area, Number. Area with condition =15. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Area, Number. Area with condition =15. 2 of 3 arguments were used.');
		// Case #3: Area, String. Area with condition =1. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E7,"1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E7,"1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, String. Area with condition =1. 2 of 3 arguments were used.');
		// Case #4: Area, String. Area with condition != 0. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E3,"<>0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E3,"<>0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Area, String. Area with condition != 0. 2 of 3 arguments were used.');
		// Case #5: Area, String, Area. Areas with  condition != 0. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E3,"<>0",E4:E5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E3,"<>0",E4:E5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 29, 'Test: Positive case: Area, String, Area. Areas with  condition != 0. 3 of 3 arguments were used.');
		// Case #6: Area3D, String. Area3D with condition != 0. 2  of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(Sheet2!A1:A2,"<>0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(Sheet2!A1:A2,"<>0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Area3D, String. Area3D with condition != 0. 2  of 3 arguments were used.');
		// Case #7: Area3D, String, Area3D. Areas3D with condition != 0. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(Sheet2!A1:A2,"<>0", Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(Sheet2!A1:A2,"<>0", Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 29, 'Test: Positive case: Area3D, String, Area3D. Areas3D with condition != 0. 3 of 3 arguments were used.');
		// Case #8: Area, String, Area. Empty range in the first argument, normal range in third arg. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(F2:F3,"<>0",E2:E3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(F2:F3,"<>0",E2:E3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Area, String, Area. Empty range in the first argument, normal range in third arg. 3 of 3 arguments were used.');
		// Case #9: Area3D, String, Area3D. Empty 3D range in the first arg, normal 3Drange in third arg
		oParser = new parserFormula('AVERAGEIF(Sheet2!B1:B2,"<>0",Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(Sheet2!B1:B2,"<>0",Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Area3D, String, Area3D. Empty 3D range in the first arg, normal 3Drange in third arg');
		// Case #10: Reference link, String, Reference link. String in the first arg. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(G1,"<>0",E2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(G1,"<>0",E2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link, String, Reference link. String in the first arg. 3 of 3 arguments were used.');
		// Case #11: Reference link, String, Area. string in the first arg and third argument is area. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(G1,"<>0",E2:E3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(G1,"<>0",E2:E3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link, String, Area. string in the first arg and third argument is area. 3 of 3 arguments were used.');
		// Case #12: Reference link, String, Reference link. Bool in the first arg, second is ref. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(I1,"<>0",E2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(I1,"<>0",E2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link, String, Reference link. Bool in the first arg, second is ref. 3 of 3 arguments were used.');
		// Case #13: Reference link, String, Area. Bool in the first arg, second is area. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(I1,"<>0",E2:E3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(I1,"<>0",E2:E3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link, String, Area. Bool in the first arg, second is area. 3 of 3 arguments were used.');
		// Case #14: Reference link, String, Reference link. Bool in the first arg, second is ref(FALSE). 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(I2,"<>0",E2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(I2,"<>0",E2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link, String, Reference link. Bool in the first arg, second is ref(FALSE). 3 of 3 arguments were used.');
		// Case #15: Reference link, String, Area. Bool in the first arg, second is area(FALSE). 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(I2,"<>0",E2:E3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(I2,"<>0",E2:E3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link, String, Area. Bool in the first arg, second is area(FALSE). 3 of 3 arguments were used.');
		// Case #16: Area, String. Calculates average of values in range greater than 5. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Area, String. Calculates average of values in range greater than 5. 2 of 3 arguments used.');
		// Case #17: Area(2), String. Calculates average of values in second range where first range meets criteria. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">5", B100:B110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">5", B100:B110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Area(2), String. Calculates average of values in second range where first range meets criteria. 3 of 3 arguments used.');
		// Case #18: Area, Number. Calculates average of cells equal to specific number (10). 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Area, Number. Calculates average of cells equal to specific number (10). 2 of 3 arguments used.');
		// Case #19: Area, String. Calculates average of values greater than or equal to 10. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">=10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">=10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Area, String. Calculates average of values greater than or equal to 10. 2 of 3 arguments used.');
		// Case #20: Area, String. Calculates average of values less than 10. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "<10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "<10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Area, String. Calculates average of values less than 10. 2 of 3 arguments used.');
		// Case #21: Area, String. Calculates average of values less than or equal to 5. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "<=5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "<=5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Area, String. Calculates average of values less than or equal to 5. 2 of 3 arguments used.');
		// Case #22: Area, String. Calculates average of values not equal to 10. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "<>10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "<>10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 44.8, 'Test: Positive case: Area, String. Calculates average of values not equal to 10. 2 of 3 arguments used.');
		// Case #23: Area, String. Calculates average of values equal to 10 with explicit equality operator. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "=10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "=10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Area, String. Calculates average of values equal to 10 with explicit equality operator. 2 of 3 arguments used.');
		// Case #24: Area, Reference link. Uses cell reference as criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Area, Reference link. Uses cell reference as criteria. 2 of 3 arguments used.');
		// Case #25: Area, Formula. Uses formula result as criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ROUND(9.5,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ROUND(9.5,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Area, Formula. Uses formula result as criteria. 2 of 3 arguments used.');
		// Case #26: Reference link, String. Single cell reference for range parameter. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A111, ">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A111, ">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Reference link, String. Single cell reference for range parameter. 2 of 3 arguments used.');
		// Case #27: Area, String, Reference link. Single cell reference for average_range parameter. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">5", A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">5", A111) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, String, Reference link. Single cell reference for average_range parameter. 3 of 3 arguments used.');
		// Case #28: Area, Formula. Nested formula for criteria parameter. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, IF(TRUE,">5","<5"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, IF(TRUE,">5","<5")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Area, Formula. Nested formula for criteria parameter. 2 of 3 arguments used.');
		// Case #29: Name, String. Named range for range parameter. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(TestName, ">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(TestName, ">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Name, String. Named range for range parameter. 2 of 3 arguments used.');
		// Case #30: Area, String, Name. Named range for average_range parameter. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">5", TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">5", TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Area, String, Name. Named range for average_range parameter. 3 of 3 arguments used.');
		// Case #31: Name3D, String. 3D named range for range parameter. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(TestName3D, ">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(TestName3D, ">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Name3D, String. 3D named range for range parameter. 2 of 3 arguments used.');
		// Case #32: Area, String, Name3D. 3D named range for average_range parameter. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">5", TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">5", TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Area, String, Name3D. 3D named range for average_range parameter. 3 of 3 arguments used.');
		// Case #33: Ref3D, String. 3D reference for range parameter. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(Sheet2!A5, ">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(Sheet2!A5, ">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Ref3D, String. 3D reference for range parameter. 2 of 3 arguments used.');
		// Case #34: Area, String, Ref3D. 3D reference for average_range parameter. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">5", Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">5", Sheet2!A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Area, String, Ref3D. 3D reference for average_range parameter. 3 of 3 arguments used.');
		// Case #35: Area3D, String. 3D area for range parameter. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(Sheet2!A5:A9, ">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(Sheet2!A5:A9, ">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 7.5, 'Test: Positive case: Area3D, String. 3D area for range parameter. 2 of 3 arguments used.');
		// Case #36: Area, String, Area3D. 3D area for average_range parameter. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">5", Sheet2!A5:A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">5", Sheet2!A5:A9) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Area, String, Area3D. 3D area for average_range parameter. 3 of 3 arguments used.');
		// Case #37: Table, String. Table reference for range parameter. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(Table1[Column1], ">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(Table1[Column1], ">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 6.5, 'Test: Positive case: Table, String. Table reference for range parameter. 2 of 3 arguments used.');
		// Case #38: Area, String, Table. Table reference for average_range parameter. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">5", Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">5", Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 14980, 'Test: Positive case: Area, String, Table. Table reference for average_range parameter. 3 of 3 arguments used.');
		// Case #40: Area, Formula. Date function as criteria (converts to serial number). 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A112:A113, DATE(2023,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A112:A113, DATE(2023,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 44927, 'Test: Positive case: Area, Formula. Date function as criteria (converts to serial number). 2 of 3 arguments used.');
		// Case #41: Area, Formula. Time function as criteria (converts to fraction of day). 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A112:A113, TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A112:A113, TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Area, Formula. Time function as criteria (converts to fraction of day). 2 of 3 arguments used.');
		// Case #42: Formula. AVERAGEIF used inside another function. 2 of 3 arguments used.
		oParser = new parserFormula('SUM(AVERAGEIF(A100:A110, ">5"),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(AVERAGEIF(A100:A110, ">5"),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 55, 'Test: Positive case: Formula. AVERAGEIF used inside another function. 2 of 3 arguments used.');
		// Case #44: Area, String. All positive numbers and zero. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">=0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">=0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 41.63636364, 'Test: Positive case: Area, String. All positive numbers and zero. 2 of 3 arguments used.');
		// Case #45: Area, String. All non-zero values. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "<>0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "<>0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 41.63636364, 'Test: Positive case: Area, String. All non-zero values. 2 of 3 arguments used.');
		// Case #46: Area, String. Concatenation formula for criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, CONCATENATE(">","5"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, CONCATENATE(">","5")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Area, String. Concatenation formula for criteria. 2 of 3 arguments used.');
		// Case #47: Area(2), String. Positive values in first range, average corresponding cells in second range. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">0", B100:B110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">0", B100:B110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Area(2), String. Positive values in first range, average corresponding cells in second range. 3 of 3 arguments used.');
		// Case #48: Area(3). Reference for criteria parameter. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, A111, B100:B110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, A111, B100:B110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Area(3). Reference for criteria parameter. 3 of 3 arguments used.');
		// Case #49: Area(2). Range as criteria parameter. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Area(2). Range as criteria parameter. 2 of 3 arguments used.');
		// Case #50: Area, Array. Array as criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, {5,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, {5,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Area, Array. Array as criteria. 2 of 3 arguments used.');
		// Case #51: Area, String, Area. Average_range with different dimensions than range. 3 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A105, ">5", B100:C100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A105, ">5", B100:C100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area, String, Area. Average_range with different dimensions than range. 3 of 3 arguments used.');

		// Negative cases:

		// Case #1: Area, String. Area with incorrect condition. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E7,"1s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E7,"1s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Area with incorrect condition. 2 of 3 arguments were used.');
		// Case #2: Area, Boolean. Area with condition =TRUE. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E7,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E7,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Boolean. Area with condition =TRUE. 2 of 3 arguments were used.');
		// Case #3: Area, Boolean. Area with condition =FALSE. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E7,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E7,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Boolean. Area with condition =FALSE. 2 of 3 arguments were used.');
		// Case #4: Area, String. Empty range in the first argument. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(F2:F3, "<>0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(F2:F3, "<>0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Empty range in the first argument. 2 of 3 arguments were used.');
		// Case #5: Area, String, Area. Empty range in the first and third args. 3 of 3 argumenrs were used.
		oParser = new parserFormula('AVERAGEIF(F2:F3, "<>0",F2:F3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(F2:F3, "<>0",F2:F3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String, Area. Empty range in the first and third args. 3 of 3 argumenrs were used.');
		// Case #6: Area, String, Area. Normal range in the first arg, empty range in third arg. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E3,"<>0",F2:F3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E3,"<>0",F2:F3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String, Area. Normal range in the first arg, empty range in third arg. 3 of 3 arguments were used.');
		// Case #7: Area3D, String. Empty 3D range in the first argument. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(Sheet2!B1:B2;"<>0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(Sheet2!B1:B2;"<>0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D, String. Empty 3D range in the first argument. 3 of 3 arguments were used.');
		// Case #8: Reference link, String. String in the first arg. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(G1,"<>0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(G1,"<>0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link, String. String in the first arg. 2 of 3 arguments were used.');
		// Case #9: Area, String, Reference link. String in the third arg. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(E2:E3,"<>0",G1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(E2:E3,"<>0",G1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String, Reference link. String in the third arg. 3 of 3 arguments were used.');
		// Case #10: Reference link, String. Bool in the first arg. 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(I1,"<>0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(I1,"<>0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link, String. Bool in the first arg. 2 of 3 arguments were used.');
		// Case #11: Reference link, String. Bool in the first arg (FALSE). 2 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(I2,"<>0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(I2,"<>0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link, String. Bool in the first arg (FALSE). 2 of 3 arguments were used.');
		/* exact types for arg0, arg2 check */
		let calculateResult = new AscCommonExcel.CalculateResult(true);
		// Case #12: Array, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.
		oParser = new parserFormula("AVERAGEIF({1,2,3},A2:A9,A2)", "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF({1,2,3},A2:A9,A2) is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: Array, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.');
		// Case #13: Number, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.
		oParser = new parserFormula("AVERAGEIF(12,A2:A9,A2)", "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(12,A2:A9,A2) is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: Number, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.');
		// Case #14: String, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF("str",A2:A9,A2)', "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF("str",A2:A9,A2) is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: String, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.');
		// Case #15: Boolean, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(TRUE,A2:A9,A2)', "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(TRUE,A2:A9,A2) is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: Boolean, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.');
		// Case #16: Error, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.
		oParser = new parserFormula('AVERAGEIF(#N/A,A2:A9,A2)', "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(#N/A,A2:A9,A2) is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: Error, Area, Reference link. Arg0 exact type check. 3 of 3 arguments were used.');
		// Case #17: Reference link, Area, Array. Arg2 exact type check. 3 of 3 argumenrs were used.
		oParser = new parserFormula("AVERAGEIF(A2,A2:A9,{1,2,3})", "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A2,A2:A9,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: Reference link, Area, Array. Arg2 exact type check. 3 of 3 argumenrs were used.');
		// Case #18: Reference link, Area, Number. Arg2 exact type check. 3 of 3 argumenrs were used.
		oParser = new parserFormula("AVERAGEIF(A2,A2:A9,12)", "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A2,A2:A9,12) is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: Reference link, Area, Number. Arg2 exact type check. 3 of 3 argumenrs were used.');
		// Case #19: Reference link, Area, String. Arg2 exact type check. 3 of 3 argumenrs were used.
		oParser = new parserFormula('AVERAGEIF(A2,A2:A9,"str")', "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A2,A2:A9,"str") is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: Reference link, Area, String. Arg2 exact type check. 3 of 3 argumenrs were used.');
		// Case #20: Reference link, Area, Boolean. Arg2 exact type check. 3 of 3 argumenrs were used.
		oParser = new parserFormula('AVERAGEIF(A2,A2:A9,TRUE)', "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A2,A2:A9,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: Reference link, Area, Boolean. Arg2 exact type check. 3 of 3 argumenrs were used.');
		// Case #21: Reference link, Area, Error. Arg2 exact type check. 3 of 3 argumenrs were used.
		oParser = new parserFormula('AVERAGEIF(A2,A2:A9,#N/A)', "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A2,A2:A9,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate(null, null, null, null, calculateResult).getValue(), "#NULL!", 'Test: Negative case: Reference link, Area, Error. Arg2 exact type check. 3 of 3 argumenrs were used.');
		// Case #22: Area, Error. Error value as criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Error. Error value as criteria. 2 of 3 arguments used.');
		// Case #23: Area, String. Range containing only text values with numeric criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(B112:B113, ">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(B112:B113, ">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Range containing only text values with numeric criteria. 2 of 3 arguments used.');
		// Case #24: Area, Formula. Formula returning error as criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, SQRT(-1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Formula. Formula returning error as criteria. 2 of 3 arguments used.');
		// Case #25: Area, String. Calculates average of all non-empty values in range using wildcard. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Calculates average of all non-empty values in range using wildcard. 2 of 3 arguments used.');
		// Case #26: Area, String. Calculates average of values starting with 1 using wildcard. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "1*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "1*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Calculates average of values starting with 1 using wildcard. 2 of 3 arguments used.');
		// Case #27: Area, String. Empty string as criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Empty string as criteria. 2 of 3 arguments used.');
		// Case #28: Area, Empty. Empty criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Empty. Empty criteria. 2 of 3 arguments used.');
		// Case #29: Area, Reference link. Reference to empty cell as criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, F7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, F7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Reference link. Reference to empty cell as criteria. 2 of 3 arguments used.');
		// Case #30: Area, String. Text wildcard criteria with range of numbers (no matches). 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "Text*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "Text*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Text wildcard criteria with range of numbers (no matches). 2 of 3 arguments used.');
		// Case #31: Area, String. Invalid operator in string criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">/5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">/5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Invalid operator in string criteria. 2 of 3 arguments used.');
		// Case #32: Area, String. Missing value after operator in criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, ">=")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, ">=") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Missing value after operator in criteria. 2 of 3 arguments used.');
		// Case #33: Area, String. Reversed comparison operator in criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "5>")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "5>") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Reversed comparison operator in criteria. 2 of 3 arguments used.');
		// Case #34: Area, String. Invalid combination of operators in criteria. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A100:A110, "><5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A100:A110, "><5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, String. Invalid combination of operators in criteria. 2 of 3 arguments used.');

		// Bounded cases:

		// Case #1: Area, Number. Minimum numeric criteria (zero). 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A114:A116, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A114:A116, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Area, Number. Minimum numeric criteria (zero). 2 of 3 arguments used.');
		// Case #2: Area, Number. Maximum numeric criteria value. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A114:A116, 9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A114:A116, 9.99999999999999E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Area, Number. Maximum numeric criteria value. 2 of 3 arguments used.');
		// Case #3: Area, Number. Minimum numeric criteria value. 2 of 3 arguments used.
		oParser = new parserFormula('AVERAGEIF(A114:A116, -9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIF(A114:A116, -9.99999999999999E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1e+308, 'Test: Bounded case: Area, Number. Minimum numeric criteria value. 2 of 3 arguments used.');

		// TODO calc problem in this function
		// Need to fix: error handle, results diff from MS

		testArrayFormula2(assert, "AVERAGEIF", 2, 3, null, true);
	});

	QUnit.test("Test: \"AVERAGEIFS\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("100");
		ws.getRange2("A103").setValue("0");
		ws.getRange2("A104").setValue("2");
		ws.getRange2("A105").setValue("5");

		ws.getRange2("B100").setValue("A");
		ws.getRange2("B101").setValue("15");
		ws.getRange2("B102").setValue("10");
		ws.getRange2("B103").setValue("10");
		ws.getRange2("B104").setValue("?A*");
		ws.getRange2("B105").setValue("AB");

		ws.getRange2("C100").setValue("A");
		ws.getRange2("C101").setValue("B");
		ws.getRange2("C102").setValue("B");
		ws.getRange2("C103").setValue("15");
		ws.getRange2("C104").setValue("10");
		ws.getRange2("C105").setValue("5");

		ws.getRange2("D100").setValue("C");
		ws.getRange2("D101").setValue("D");
		ws.getRange2("D102").setValue("C");
		ws.getRange2("D103").setValue("C");
		ws.getRange2("D104").setValue("D");
		ws.getRange2("D105").setValue("D");

		ws.getRange2("E100").setValue("True");
		ws.getRange2("E101").setValue("TRUE");
		ws.getRange2("E102").setValue("45658");
		ws.getRange2("E103").setValue("01.01.2025");
		ws.getRange2("E104").setValue("01.01.2025");
		ws.getRange2("E105").setValue("");

		ws.getRange2("A106").setValue(">0");
		ws.getRange2("A107").setValue("");

		ws.getRange2("C106").setValue("1e+308");
		ws.getRange2("C107").setValue("-1e+308");
		ws.getRange2("C108").setValue("1e+307");
		ws.getRange2("C109").setValue("1e-307");

		ws.getRange2("E2").setValue("Quiz");
		ws.getRange2("E3").setValue("Grade");
		ws.getRange2("E4").setValue("75");
		ws.getRange2("E5").setValue("94");

		ws.getRange2("F2").setValue("Quiz");
		ws.getRange2("F3").setValue("Grade");
		ws.getRange2("F4").setValue("85");
		ws.getRange2("F5").setValue("80");

		ws.getRange2("G2").setValue("Exam");
		ws.getRange2("G3").setValue("Grade");
		ws.getRange2("G4").setValue("87");
		ws.getRange2("G5").setValue("88");
		// Setup test data with 5 columns for testing
		ws.getRange2("D2").setValue("10");
		ws.getRange2("D3").setValue("20");
		ws.getRange2("D4").setValue("30");
		ws.getRange2("D5").setValue("40");
		ws.getRange2("D6").setValue("50");
		ws.getRange2("D7").setValue("60");

		ws.getRange2("B2").setValue("Red");
		ws.getRange2("B3").setValue("Blue");
		ws.getRange2("B4").setValue("Green");
		ws.getRange2("B5").setValue("Red");
		ws.getRange2("B6").setValue("Blue");
		ws.getRange2("B7").setValue("Green");

		ws.getRange2("A2").setValue("Small");
		ws.getRange2("A3").setValue("Medium");
		ws.getRange2("A4").setValue("Large");
		ws.getRange2("A5").setValue("Large");
		ws.getRange2("A6").setValue("Medium");
		ws.getRange2("A7").setValue("Small");

		ws.getRange2("H2").setValue("2023");
		ws.getRange2("H3").setValue("2023");
		ws.getRange2("H4").setValue("2024");
		ws.getRange2("H5").setValue("2024");
		ws.getRange2("H6").setValue("2025");
		ws.getRange2("H7").setValue("2025");

		ws.getRange2("I2").setValue("A");
		ws.getRange2("I3").setValue("B");
		ws.getRange2("I4").setValue("C");
		ws.getRange2("I5").setValue("A");
		ws.getRange2("I6").setValue("B");
		ws.getRange2("I7").setValue("C");

		// Test with cell references for criteria
		ws.getRange2("J2").setValue("Red");
		ws.getRange2("J3").setValue("Large");
		ws.getRange2("J4").setValue("2024");
		ws.getRange2("J5").setValue("A");

		// Table type. Use A601:L6**
		getTableType(599, 0, 604, 1);
		ws.getRange2("A601").setValue("75"); // Column1
		ws.getRange2("A602").setValue("94"); // Column1
		ws.getRange2("A603").setValue("86"); // Column1
		ws.getRange2("A604").setValue("93"); // Column1
		ws.getRange2("A605").setValue("30"); // Column1
		ws.getRange2("B601").setValue("10"); // Column2
		ws.getRange2("B602").setValue("5"); // Column2
		ws.getRange2("B603").setValue("3"); // Column2
		ws.getRange2("B604").setValue("1"); // Column2
		ws.getRange2("B605").setValue("18"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("100");
		ws2.getRange2("A2").setValue("10");
		ws2.getRange2("A3").setValue("2");
		ws2.getRange2("A4").setValue("15");
		ws2.getRange2("A5").setValue("5");
		ws2.getRange2("B1").setValue("10");
		ws2.getRange2("B2").setValue("5");
		ws2.getRange2("B3").setValue("1");
		ws2.getRange2("B4").setValue("A");
		ws2.getRange2("B5").setValue("NAM");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1"); // TestName
		ws.getRange2("A202").setValue("2"); // TestName1
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("2") // TestName3D
		ws2.getRange2("A12").setValue("2") // TestName3D1

		// Positive cases:

		// Case #1: Area(2), String, Area, String. Areas with correct criterias >70 <90
		oParser = new parserFormula('AVERAGEIFS(E2:E5,E2:E5,">70",E2:E5,"<90")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(E2:E5,E2:E5,">70",E2:E5,"<90") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 75, 'Test: Positive case: Area(2), String, Area, String. Areas with correct criterias >70 <90');
		// Case #2: Area(2), String, Area, String. Areas with correct criterias != Incomplete >80
		oParser = new parserFormula('AVERAGEIFS(G2:G5,G2:G5,"<>Incomplete",G2:G5,">80")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(G2:G5,G2:G5,"<>Incomplete",G2:G5,">80") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 87.5, 'Test: Positive case: Area(2), String, Area, String. Areas with correct criterias != Incomplete >80');
		// Case #3: Area(2), String, Area, String, Area, Number,Area, String, Area, String. Test with 11 arguments (1 average_range + 5 criteria pairs)
		oParser = new parserFormula('AVERAGEIFS(D2:D7, B2:B7, "Red", A2:A7, "Large", H2:H7, 2024, I2:I7, "A", I2:I7, "*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(D2:D7, B2:B7, "Red", A2:A7, "Large", H2:H7, 2024, I2:I7, "A", I2:I7, "*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Area(2), String, Area, String, Area, Number,Area, String, Area, String. Test with 11 arguments (1 average_range + 5 criteria pairs)');
		// Case #4: Area(2), Ref, Area, Ref, Area, Ref, Area, Ref, Area, String. Test with cell references for criteria
		oParser = new parserFormula('AVERAGEIFS(D2:D7, B2:B7, J2, A2:A7, J3, H2:H7, J4, I2:I7, J5, I2:I7, "*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(D2:D7, B2:B7, J2, A2:A7, J3, H2:H7, J4, I2:I7, J5, I2:I7, "*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Area(2), Ref, Area, Ref, Area, Ref, Area, Ref, Area, String. Test with cell references for criteria');
		// Case #5: Area(2), String, Area, String. Test with numeric criteria and comparison operators
		oParser = new parserFormula('AVERAGEIFS(D2:D7, H2:H7, ">2023", D2:D7, ">=30")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(D2:D7, H2:H7, ">2023", D2:D7, ">=30") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45, 'Test: Positive case: Area(2), String, Area, String. Test with numeric criteria and comparison operators');
		// Case #6: Area(2), String. Test with blank criteria
		ws.getRange2("B4").setValue("");
		oParser = new parserFormula('AVERAGEIFS(D2:D7, B2:B7, "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(E2:E7, F2:F7, "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Area(2), String. Test with blank criteria');
		ws.getRange2("B4").setValue("Green");
		// Case #7: Area(2), String. Basic usage: Average of values greater than 0.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, A100:A105, ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, A100:A105, ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 23.6, 'Test: Positive case: Area(2), String. Basic usage: Average of values greater than 0.');
		// Case #8: Area(2), String. Average of values less than 20.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, A100:A105, "<20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, A100:A105, "<20") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 3.6, 'Test: Positive case: Area(2), String. Average of values less than 20.');
		// Case #9: Area(2), String, Area,  String. Two criteria: values between 5 and 25.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, A100:A105, ">5", A100:A105, "<25")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, A100:A105, ">5", A100:A105, "<25") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Area(2), String, Area,  String. Two criteria: values between 5 and 25.');
		// Case #10: Area(2), String. Average of values where corresponding text equals "A".
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area(2), String. Average of values where corresponding text equals "A".');
		// Case #11: Area(2), Number. Average of values where corresponding value equals 10.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Area(2), Number. Average of values where corresponding value equals 10.');
		// Case #12: Area(2), String. Average of values where corresponding value is >= 15.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, ">=15")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, ">=15") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Area(2), String. Average of values where corresponding value is >= 15.');
		// Case #13: Area(2), String. Average of values where corresponding value is <= 20.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "<=20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "<=20") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 36.66666667, 'Test: Positive case: Area(2), String. Average of values where corresponding value is <= 20.');
		// Case #14: Area(2), String. Average of values where corresponding text is not "A".
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "<>A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "<>A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 23.4, 'Test: Positive case: Area(2), String. Average of values where corresponding text is not "A".');
		// Case #15: Area(2), String, Area, String. Two criteria: values > 5 and text equals "B".
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, ">5", C100:C105, "B")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, ">5", C100:C105, "B") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 55, 'Test: Positive case: Area(2), String, Area, String. Two criteria: values > 5 and text equals "B".');
		// Case #16: Area(2), String, Area, Number. Two criteria: values < 30 and value equals 15.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "<30", C100:C105, 15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "<30", C100:C105, 15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area(2), String, Area, Number. Two criteria: values < 30 and value equals 15.');
		// Case #17: Area(2), String, Area, String,  Area, String. Three criteria: values > 0, < 30, and text equals "C".
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, ">0", C100:C105, "<30", D100:D105, "C")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, ">0", C100:C105, "<30", D100:D105, "C") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area(2), String, Area, String,  Area, String. Three criteria: values > 0, < 30, and text equals "C".');
		// Case #18: Area(2), Formula. Criteria from formula.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, CONCATENATE(">","5"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, CONCATENATE(">","5")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 36.66666667, 'Test: Positive case: Area(2), Formula. Criteria from formula.');
		// Case #19: Formula, Area, String. Average range is result of SUM formula.
		oParser = new parserFormula('AVERAGEIFS(INDIRECT("A100:A105"), B100:B105, ">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(INDIRECT("A100:A105"), B100:B105, ">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 36.66666667, 'Test: Positive case: Formula, Area, String. Average range is result of SUM formula.');
		// Case #20: Area(2), Reference link. Criteria is reference to cell.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 36.66666667, 'Test: Positive case: Area(2), Reference link. Criteria is reference to cell.');
		// Case #21: Formula. AVERAGEIFS inside another formula.
		oParser = new parserFormula('SUM(AVERAGEIFS(A100:A105, A100:A105, ">0"),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(AVERAGEIFS(A100:A105, A100:A105, ">0"),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 33.6, 'Test: Positive case: Formula. AVERAGEIFS inside another formula.');
		// Case #22: Area(2), String. Wildcard criteria matching text containing "A".
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "*A*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "*A*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.666666667, 'Test: Positive case: Area(2), String. Wildcard criteria matching text containing "A".');
		// Case #23: Area(2), String. Wildcard criteria matching 3-character text.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "???")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "???") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area(2), String. Wildcard criteria matching 3-character text.');
		// Case #24: Area(3). Criteria is the same range.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, A100:A105, A100:A101)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, A100:A105, A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Area(3). Criteria is the same range.');
		// Case #25: Area(2), Array. Average range is array.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, A100:A105, {">0",">10"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, A100:A105, {">0",">10"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 23.6, 'Test: Positive case: Area(2), Array. Average range is array.');
		// Case #26: Area(2), String. Criteria is text "True".
		oParser = new parserFormula('AVERAGEIFS(A100:A105, E100:E105, "True")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, E100:E105, "True") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(1) - 0*/, 5.5, 'Test: Positive case: Area(2), String. Criteria is text "True".');
		// Case #27: Area(2), Boolean. Criteria is boolean TRUE.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, E100:E105, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, E100:E105, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 5.5, 'Test: Positive case: Area(2), Boolean. Criteria is boolean TRUE.');
		// Case #28: Area(2), Formula. Criteria is date.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, E100:E105, DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, E100:E105, DATE(2025,1,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 34, 'Test: Positive case: Area(2), Formula. Criteria is date.');
		// Case #29: Area(2), String. Criteria is date as string.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, E100:E105, "01/01/2025")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, E100:E105, "01/01/2025") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 34, 'Test: Positive case: Area(2), String. Criteria is date as string.');
		// Case #30: Reference link(3). All arguments are reference links.
		oParser = new parserFormula('AVERAGEIFS(A100, A101, A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100, A101, A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link(3). All arguments are reference links.');
		// Case #31: Area3D(2), String. Average and criteria ranges are 3D references.
		oParser = new parserFormula('AVERAGEIFS(Sheet2!A1:A5, Sheet2!B1:B5, ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(Sheet2!A1:A5, Sheet2!B1:B5, ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 37.33333333, 'Test: Positive case: Area3D(2), String. Average and criteria ranges are 3D references.');
		// Case #32: Name(3), String. Named ranges.
		oParser = new parserFormula('AVERAGEIFS(TestName, TestName1, ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(TestName, TestName1, ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name(3), String. Named ranges.');
		// Case #33: Name3D(2), String. 3D named ranges.
		oParser = new parserFormula('AVERAGEIFS(TestName3D, TestName3D1, ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(TestName3D, TestName3D1, ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Name3D(2), String. 3D named ranges.');
		// Case #34: Table(2), String. Table references.
		oParser = new parserFormula('AVERAGEIFS(Table1[Column1], Table1[Column2], ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(Table1[Column1], Table1[Column2], ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 75.6, 'Test: Positive case: Table(2), String. Table references.');
		// Case #35: Area(2), String. Criteria is empty string.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, E100:E105, "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, E100:E105, "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Area(2), String. Criteria is empty string.');
		// Case #36: Area(2), String, Area, String. Two criteria: non-empty and equals 15.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "<>", C100:C105, "=15")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "<>", C100:C105, "=15") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area(2), String, Area, String. Two criteria: non-empty and equals 15.');
		// Case #37: Area(2), String. Criteria with equality operator for text.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "=A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "=A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area(2), String. Criteria with equality operator for text.');
		// Case #38: Area(2), String. Criteria with wildcard \'?\' for one character after \'A\'..
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "A?")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "A?") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Area(2), String. Criteria with wildcard \'?\' for one character after \'A\'..');
		// Case #39: Area(2), Formula. Criteria is  > time.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, CONCAT(">", TIME(12,0,0)))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, CONCAT(">", TIME(12,0,0))) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 36.66666667, 'Test: Positive case: Area(2), Formula. Criteria is  > time.');
		// Case #40: Area(2), String. Criteria is escaped wildcard character.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "*~*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "*~*") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area(2), String. Criteria is escaped wildcard character.');
		// Case #41: Area(2), String. Criteria is escaped wildcard character \'?\'.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "~?*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "~?*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area(2), String. Criteria is escaped wildcard character \'?\'.');
		// Case #42: Area(2), Number. Criteria is numeric zero.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, A100:A105, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, A100:A105, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area(2), Number. Criteria is numeric zero.');
		// Case #43: Area(2), Formula. Criteria is conditional formula.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, IF(TRUE,">10","<5"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, IF(TRUE,">10","<5")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Area(2), Formula. Criteria is conditional formula.');

		// Negative cases:

		// Case #1: Area(2), String. Areas with incorrect criteria >95
		oParser = new parserFormula('AVERAGEIFS(F2:F5,F2:F5,">95")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(F2:F5,F2:F5,">95") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), String. Areas with incorrect criteria >95');
		// Case #2: Area(2), String, Area, String, Area, Number,Area, String, Area, String. Test with 11 arguments where none match all criteria
		oParser = new parserFormula('AVERAGEIFS(D2:D7, B2:B7, "Red", A2:A7, "Small", H2:H7, 2024, I2:I7, "A", I2:I7, "Z")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(D2:D7, B2:B7, "Red", A2:A7, "Small", H2:H7, 2024, I2:I7, "A", I2:I7, "Z") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), String, Area, String, Area, Number,Area, String, Area, String. Test with 11 arguments where none match all criteria');
		// Case #3: Area(2), String. Test with error handling - mismatched ranges
		oParser = new parserFormula('AVERAGEIFS(D2:D7, B2:B6, "Red")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(D2:D7, B2:B6, "Red") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2), String. Test with error handling - mismatched ranges');
		// Case #4: Area(2), String. Mismatched range sizes.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, A100:A106, ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, A100:A106, ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2), String. Mismatched range sizes.');
		// Case #5: Area(2), String. Invalid criteria text.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "#REF!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "#REF!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), String. Invalid criteria text.');
		// Case #6: Area(2), Error. Error as criteria.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), Error. Error as criteria.');
		// Case #7: Area(2), String. Invalid numeric comparison criteria.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, ">ABC")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, ">ABC") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), String. Invalid numeric comparison criteria.');
		// Case #8: Area(2), String. Incomplete comparison criteria.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, ">")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, ">") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), String. Incomplete comparison criteria.');
		// Case #9: Area(2), Formula. Formula resulting in error for criteria.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, IF(FALSE,">0",NA()))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, IF(FALSE,">0",NA())) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), Formula. Formula resulting in error for criteria.');
		// Case #10: Area(2), String. No matching criteria.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "NOT_FOUND")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "NOT_FOUND") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), String. No matching criteria.');
		// Case #11: Area(2), Number. No matching numeric criteria.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, 999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, 999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), Number. No matching numeric criteria.');
		// Case #12: Area(2), Formula. Formula resulting in #N/A for criteria.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, MATCH("xyz",{"a","b","c"},0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, MATCH("xyz",{"a","b","c"},0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), Formula. Formula resulting in #N/A for criteria.');
		// Case #13: Area(2), String, Area, String. Second criteria is invalid.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, ">0", C100:C105, "#NUM!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, ">0", C100:C105, "#NUM!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), String, Area, String. Second criteria is invalid.');
		// Case #14: Name, Area, String. Named range with multiple cells for average.
		oParser = new parserFormula('AVERAGEIFS(TestNameArea, B100:B105, ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(TestNameArea, B100:B105, ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Area, String. Named range with multiple cells for average.');
		// Case #15: Area, Name, String. Named range with multiple cells for criteria.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, TestNameArea, ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, TestNameArea, ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Name, String. Named range with multiple cells for criteria.');
		// Case #16: Area3D, Area, String. 3D multi-cell range for average.
		oParser = new parserFormula('AVERAGEIFS(Sheet2!A1:A2, B100:B105, ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(Sheet2!A1:A2, B100:B105, ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Area, String. 3D multi-cell range for average.');
		// Case #17: Area, Area3D, String. 3D multi-cell range for criteria.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, Sheet2!A1:A2, ">0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, Sheet2!A1:A2, ">0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Area3D, String. 3D multi-cell range for criteria.');
		// Case #18: Area(2), Formula. Criteria is formula causing division by zero error.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, 1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, 1/0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), Formula. Criteria is formula causing division by zero error.');
		// Case #19: Area(2), String. Invalid use of wildcard with comparison operator.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, "?>")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, "?>") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), String. Invalid use of wildcard with comparison operator.');
		// Case #20: Area(2), Empty. Criteria is empty.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, B100:B105, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, B100:B105, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), Empty. Criteria is empty.');
		// Case #21: Area(2), Reference link. Criteria is reference to empty cell.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, E100:E105, A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, E100:E105, A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2), Reference link. Criteria is reference to empty cell.');

		// Bounded cases:

		// Case #1: Area(2), String. Exact match to single value.
		oParser = new parserFormula('AVERAGEIFS(A100:A105, A100:A105, "=5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A105, A100:A105, "=5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Bounded case: Area(2), String. Exact match to single value.');
		// Case #2: Area(2), Number. Maximum acceptable numeric value in Excel.
		oParser = new parserFormula('AVERAGEIFS(A100:A103, C106:C109, 9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A103, C106:C109, 9.99999999999999E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Area(2), Number. Maximum acceptable numeric value in Excel.');
		// Case #3: Area(2), Number. Minimum acceptable numeric value in Excel.
		oParser = new parserFormula('AVERAGEIFS(A100:A103, C106:C109, -9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A103, C106:C109, -9.99999999999999E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Bounded case: Area(2), Number. Minimum acceptable numeric value in Excel.');
		// Case #4: Area(2), Number. Criteria is very large number.
		oParser = new parserFormula('AVERAGEIFS(A100:A103, C106:C109, 1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A103, C106:C109, 1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Bounded case: Area(2), Number. Criteria is very large number.');
		// Case #5: Area(2), Number. Criteria is very small number.
		oParser = new parserFormula('AVERAGEIFS(A100:A103, C106:C109, 1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGEIFS(A100:A103, C106:C109, 1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Area(2), Number. Criteria is very small number.');

		// Need to fix: diff results from MS, error type diff
		// Case #26: Area(2), String. Criteria is text "True".
		// Case #28: Area(2), Formula. Criteria is date.
		// Case #29: Area(2), String. Criteria is date as string.
		// Case #30: Reference link(3). All arguments are reference links.
		// Case #40: Area(2), String. Criteria is escaped wildcard character.
		// Case #6: Area(2), Error. Error as criteria.
		// Case #8: Area(2), String. Incomplete comparison criteria.
		// Case #9: Area(2), Formula. Formula resulting in error for criteria.
		// Case #12: Area(2), Formula. Formula resulting in #N/A for criteria.
		// Case #18: Area(2), Formula. Criteria is formula causing division by zero error.
		// Case #21: Area(2), Reference link. Criteria is reference to empty cell.
		// Case #2: Area(2), Number. Maximum acceptable numeric value in Excel.
		// Case #3: Area(2), Number. Minimum acceptable numeric value in Excel.
		// Case #4: Area(2), Number. Criteria is very large number.
		// Case #5: Area(2), Number. Criteria is very small number.

		testArrayFormulaEqualsValues(assert, "1,3.123,-4,#N/A;2,4,5,#N/A;#N/A,#N/A,#N/A,#N/A", "AVERAGEIFS(A1:C2,A1:C2,A1:C2,A1:C2, A1:C2,A1:C2,A1:C2)");
		testArrayFormulaEqualsValues(assert, "1,#DIV/0!,#DIV/0!,#N/A;#DIV/0!,#DIV/0!,#DIV/0!,#N/A;#N/A,#N/A,#N/A,#N/A", "AVERAGEIFS(A1:C2,A1:C2,A1:A1,A1:C2,A1:C2,A1:C2,A1:C2)");
		testArrayFormulaEqualsValues(assert, "1,#DIV/0!,#DIV/0!,#N/A;2,#DIV/0!,#DIV/0!,#N/A;#N/A,#N/A,#N/A,#N/A", "AVERAGEIFS(A1:C2,A1:C2,A1:A2,A1:C2,A1:C2,A1:C2,A1:C2)");
	});

	QUnit.test("Test: \"AVERAGEIFS with multiple criteria ranges\"", function (assert) {
        // Setup test data with 5 columns for testing
        ws.getRange2("E2").setValue("10");
        ws.getRange2("E3").setValue("20");
        ws.getRange2("E4").setValue("30");
        ws.getRange2("E5").setValue("40");
        ws.getRange2("E6").setValue("50");
        ws.getRange2("E7").setValue("60");

        ws.getRange2("F2").setValue("Red");
        ws.getRange2("F3").setValue("Blue");
        ws.getRange2("F4").setValue("Green");
        ws.getRange2("F5").setValue("Red");
        ws.getRange2("F6").setValue("Blue");
        ws.getRange2("F7").setValue("Green");

        ws.getRange2("G2").setValue("Small");
        ws.getRange2("G3").setValue("Medium");
        ws.getRange2("G4").setValue("Large");
        ws.getRange2("G5").setValue("Large");
        ws.getRange2("G6").setValue("Medium");
        ws.getRange2("G7").setValue("Small");

        ws.getRange2("H2").setValue("2023");
        ws.getRange2("H3").setValue("2023");
        ws.getRange2("H4").setValue("2024");
        ws.getRange2("H5").setValue("2024");
        ws.getRange2("H6").setValue("2025");
        ws.getRange2("H7").setValue("2025");

        ws.getRange2("I2").setValue("A");
        ws.getRange2("I3").setValue("B");
        ws.getRange2("I4").setValue("C");
        ws.getRange2("I5").setValue("A");
        ws.getRange2("I6").setValue("B");
        ws.getRange2("I7").setValue("C");

        // Test with 11 arguments (1 average_range + 5 criteria pairs)
        oParser = new parserFormula("AVERAGEIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Large\", H2:H7, 2024, I2:I7, \"A\", I2:I7, \"*\")", "A1", ws);
        assert.ok(oParser.parse(), "AVERAGEIFS with 5 criteria pairs");
        assert.strictEqual(oParser.calculate().getValue(), 40, "AVERAGEIFS with 5 criteria pairs"); // Only E5 (40) matches all criteria

        // Test with 11 arguments where none match all criteria
        oParser = new parserFormula("AVERAGEIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Small\", H2:H7, 2024, I2:I7, \"A\", I2:I7, \"Z\")", "A1", ws);
        assert.ok(oParser.parse(), "AVERAGEIFS with 5 criteria pairs - no match");
        assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", "AVERAGEIFS with 5 criteria pairs - no match should return #DIV/0!");


        // Test with cell references for criteria
        ws.getRange2("J2").setValue("Red");
        ws.getRange2("J3").setValue("Large");
        ws.getRange2("J4").setValue("2024");
        ws.getRange2("J5").setValue("A");
        oParser = new parserFormula("AVERAGEIFS(E2:E7, F2:F7, J2, G2:G7, J3, H2:H7, J4, I2:I7, J5, I2:I7, \"*\")", "A1", ws);
        assert.ok(oParser.parse(), "AVERAGEIFS with cell references for criteria");
        assert.strictEqual(oParser.calculate().getValue(), 40, "AVERAGEIFS with cell references for criteria");

        // Test with numeric criteria and comparison operators
        oParser = new parserFormula("AVERAGEIFS(E2:E7, H2:H7, \">2023\", E2:E7, \">=30\")", "A1", ws);
        assert.ok(oParser.parse(), "AVERAGEIFS with numeric criteria");
        assert.strictEqual(oParser.calculate().getValue(), 45, "AVERAGEIFS with numeric criteria"); // Average of 30, 40, 50, 60


        // Test with blank criteria
        ws.getRange2("F4").setValue("");
        oParser = new parserFormula("AVERAGEIFS(E2:E7, F2:F7, \"\")", "A1", ws);
        assert.ok(oParser.parse(), "AVERAGEIFS with blank criteria");
        assert.strictEqual(oParser.calculate().getValue(), 30, "AVERAGEIFS with blank criteria");

        // Test with error handling - mismatched ranges
        oParser = new parserFormula("AVERAGEIFS(E2:E7, F2:F6, \"Red\")", "A1", ws);
        assert.ok(oParser.parse(), "AVERAGEIFS with mismatched ranges");
        assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "AVERAGEIFS with mismatched ranges should return #VALUE!");

        // Cleanup
        ws.getRange2("F4").setValue("Green"); // Restore original value
    });

	QUnit.test("Test: \"BETADIST\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2");
		ws.getRange2("A101").setValue("8");
		ws.getRange2("A102").setValue("10");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A104").setValue("3");
		ws.getRange2("A105").setValue("0.5");
		ws.getRange2("A106").setValue("Text");
		ws.getRange2("A107").setValue("#N/A");
		ws.getRange2("A2").setValue("2");
		ws.getRange2("A3").setValue("8");
		ws.getRange2("A4").setValue("10");
		ws.getRange2("A5").setValue("1");
		ws.getRange2("A6").setValue("3");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("2"); // Column1
		ws.getRange2("B601").setValue("8"); // Column2
		ws.getRange2("C601").setValue("10"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		ws.getRange2("E601").setValue("3"); // Column5
		ws.getRange2("F601").setValue("0.5"); // Column6
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("2");
		ws2.getRange2("A2").setValue("8");
		ws2.getRange2("A3").setValue("10");
		ws2.getRange2("A4").setValue("1");
		ws2.getRange2("A5").setValue("3");
		ws2.getRange2("A6").setValue("0.5");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("2"); // TestName
		ws.getRange2("A202").setValue("8"); // TestName1
		ws.getRange2("A203").setValue("10"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		ws.getRange2("A205").setValue("3"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("2") // TestName3D
		ws2.getRange2("A12").setValue("8") // TestName3D1
		ws2.getRange2("A13").setValue("10") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3
		ws2.getRange2("A15").setValue("3") // TestName3D4

		// Positive cases:

		// Case #1: Reference link(5). Example from documentation. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(A2,A3,A4,A5,A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(A2,A3,A4,A5,A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.6854706, 'Test: Positive case: Reference link(5). Example from documentation. 5 of 5 arguments used.');
		// Case #2: Number(5). All arguments is number. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(1,2,3,1,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(1,2,3,1,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(5). All arguments is number. 5 of 5 arguments used.');
		// Case #3: Number(5). All arguments is number. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(6,2,3,1,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(6,2,3,1,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(5). All arguments is number. 5 of 5 arguments used.');
		// Case #4: Number(5). All arguments are numbers. Using optional A and B. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.75,2,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.75,2,5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.995361328, 'Test: Positive case: Number(5). All arguments are numbers. Using optional A and B. 5 of 5 arguments used.');
		// Case #5: Number(3). Using default A=0 and B=1. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.75,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.75,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.995361328, 'Test: Positive case: Number(3). Using default A=0 and B=1. 3 of 5 arguments used.');
		// Case #6: Number, String(2), Number(2). Alpha and Beta are numeric strings, converted to numbers. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,"1","2",0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,"1","2",0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.75, 'Test: Positive case: Number, String(2), Number(2). Alpha and Beta are numeric strings, converted to numbers. 5 of 5 arguments used.');
		// Case #7: Reference link, Number(4). x is a reference to a cell with a number. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(A105,2,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(A105,2,5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.890625, 'Test: Positive case: Reference link, Number(4). x is a reference to a cell with a number. 5 of 5 arguments used.');
		// Case #8: Number, Reference link, Number(3). alpha is a reference to a cell with a number. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.75,A101,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.75,A101,5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.842356324, 'Test: Positive case: Number, Reference link, Number(3). alpha is a reference to a cell with a number. 5 of 5 arguments used.');
		// Case #9: Number(4), Reference link. A is a reference to a cell with a number. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.75,2,5,A105,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.75,2,5,A105,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.890625, 'Test: Positive case: Number(4), Reference link. A is a reference to a cell with a number. 5 of 5 arguments used.');
		// Case #10: Formula, Number(2), Formula(2). Dates are converted to serial numbers. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(DATE(2025,6,15),2,3,DATE(2025,1,1),DATE(2025,12,31))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(DATE(2025,6,15),2,3,DATE(2025,1,1),DATE(2025,12,31)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.614391269, 'Test: Positive case: Formula, Number(2), Formula(2). Dates are converted to serial numbers. 5 of 5 arguments used.');
		// Case #11: Boolean, Number(2). x is TRUE, converted to 1. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(TRUE,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(TRUE,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean, Number(2). x is TRUE, converted to 1. 3 of 5 arguments used.');
		// Case #12: Number, Boolean(2). alpha and beta are TRUE, converted to 1. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,TRUE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Number, Boolean(2). alpha and beta are TRUE, converted to 1. 3 of 5 arguments used.');
		// Case #13: Formula, Number(2). x is a formula. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(1-0.2,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(1-0.2,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 0.9984, 'Test: Positive case: Formula, Number(2). x is a formula. 3 of 5 arguments used.');
		// Case #14: Number, Formula(2). alpha and beta are formulas. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,SQRT(4),ABS(-5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,SQRT(4),ABS(-5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.890625, 'Test: Positive case: Number, Formula(2). alpha and beta are formulas. 3 of 5 arguments used.');
		// Case #15: Area, Number(2). x is a single-cell area reference. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(A105:A105,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(A105:A105,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.890625, 'Test: Positive case: Area, Number(2). x is a single-cell area reference. 3 of 5 arguments used.');
		// Case #16: Ref3D, Number(2). x is a 3D reference. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(Sheet2!A1,4,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(Sheet2!A1,4,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.018534761, 'Test: Positive case: Ref3D, Number(2). x is a 3D reference. 3 of 5 arguments used.');
		// Case #17: Number, Area3D, Number. alpha is a single-cell 3D area reference. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,Sheet2!A2:A2,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,Sheet2!A2:A2,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.5, 'Test: Positive case: Number, Area3D, Number. alpha is a single-cell 3D area reference. 3 of 5 arguments used.');
		// Case #18: Name, Number(2). x is a named range. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(TestName - 1.5,3,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(TestName - 1.5,3,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.85546875, 'Test: Positive case: Name, Number(2). x is a named range. 3 of 5 arguments used.');
		// Case #19: Number, Name, Number. alpha is a named range. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.7,TestName1,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.7,TestName1,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.834602524, 'Test: Positive case: Number, Name, Number. alpha is a named range. 3 of 5 arguments used.');
		// Case #20: Number, Name3D(2). alpha and beta are 3D named ranges. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.8,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.8,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.99950675, 'Test: Positive case: Number, Name3D(2). alpha and beta are 3D named ranges. 3 of 5 arguments used.');
		// Case #21: Table, Number(2). x is a reference to a table cell. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(Table1[Column6],2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(Table1[Column6],2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.890625, 'Test: Positive case: Table, Number(2). x is a reference to a table cell. 3 of 5 arguments used.');
		// Case #22: Number(5). A and B are non-zero values. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(7.5,2,5,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(7.5,2,5,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.890625, 'Test: Positive case: Number(5). A and B are non-zero values. 5 of 5 arguments used.');
		// Case #23: Formula. BETADIST is used as a logical test inside another formula. 3 of 5 arguments used.
		oParser = new parserFormula('IF(BETADIST(0.5,2,3)>0.5, "OK", "FAIL")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(BETADIST(0.5,2,3)>0.5, "OK", "FAIL") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'OK', 'Test: Positive case: Formula. BETADIST is used as a logical test inside another formula. 3 of 5 arguments used.');
		// Case #24: Reference link(5). All arguments are Reference links. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Reference link(5). All arguments are Reference links. 5 of 5 arguments used.');
		// Case #25: Area(5). All arguments are single-cell Areas. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Area(5). All arguments are single-cell Areas. 5 of 5 arguments used.');
		// Case #26: Name(5). All arguments are Names. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(TestName,TestName1,TestName2,TestName3,TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(TestName,TestName1,TestName2,TestName3,TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Name(5). All arguments are Names. 5 of 5 arguments used.');
		// Case #27: Ref3D(5). All arguments are Ref3D. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Ref3D(5). All arguments are Ref3D. 5 of 5 arguments used.');
		// Case #28: Area3D(5). All arguments are single-cell Area3D. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Area3D(5). All arguments are single-cell Area3D. 5 of 5 arguments used.');
		// Case #29: Name3D(5). All arguments are Name3D. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Name3D(5). All arguments are Name3D. 5 of 5 arguments used.');
		// Case #30: Table(5). All arguments are Table references. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Table(5). All arguments are Table references. 5 of 5 arguments used.');

		// Negative cases:

		// Case #1: Number(3). alpha is 0. Returns #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,0,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,0,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). alpha is 0. Returns #NUM!. 3 of 5 arguments used.');
		// Case #2: Number(3). alpha is negative. Returns #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,-1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,-1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). alpha is negative. Returns #NUM!. 3 of 5 arguments used.');
		// Case #3: Number(3). beta is 0. Returns #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). beta is 0. Returns #NUM!. 3 of 5 arguments used.');
		// Case #4: Number(3). beta is negative. Returns #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,2,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,2,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). beta is negative. Returns #NUM!. 3 of 5 arguments used.');
		// Case #5: Number(5). x < A. Returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(-1,2,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(-1,2,5,0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). x < A. Returns #NUM!. 5 of 5 arguments used.');
		// Case #6: Number(5). x > B. Returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(2,2,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(2,2,5,0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). x > B. Returns #NUM!. 5 of 5 arguments used.');
		// Case #7: Number(5). A = B. Returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,2,5,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,2,5,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). A = B. Returns #NUM!. 5 of 5 arguments used.');
		// Case #8: String, Number(2). x is non-numeric string. Returns #VALUE!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST("text",2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST("text",2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(2). x is non-numeric string. Returns #VALUE!. 3 of 5 arguments used.');
		// Case #9: Number, String, Number. alpha is non-numeric string. Returns #VALUE!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,"text",5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,"text",5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number. alpha is non-numeric string. Returns #VALUE!. 3 of 5 arguments used.');
		// Case #10: Number(2), String. beta is non-numeric string. Returns #VALUE!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,2,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,2,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String. beta is non-numeric string. Returns #VALUE!. 3 of 5 arguments used.');
		// Case #11: Number(3), String, Number. A is non-numeric string. Returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,2,5,"text",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,2,5,"text",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String, Number. A is non-numeric string. Returns #VALUE!. 5 of 5 arguments used.');
		// Case #12: Number(4), String. B is non-numeric string. Returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,2,5,0,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,2,5,0,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), String. B is non-numeric string. Returns #VALUE!. 5 of 5 arguments used.');
		// Case #13: Reference link, Number(2). x is a reference to text. Returns #VALUE!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(A106,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(A106,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number(2). x is a reference to text. Returns #VALUE!. 3 of 5 arguments used.');
		// Case #14: Number, Empty, Number. alpha is Empty. Returns #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number. alpha is Empty. Returns #NUM!. 3 of 5 arguments used.');
		// Case #15: Error, Number(2). x is a reference to an error. Returns #N/A. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(A107,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(A107,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(2). x is a reference to an error. Returns #N/A. 3 of 5 arguments used.');
		// Case #16: Area, Number(2). x is a multi-cell range. Returns #VALUE!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(A100:A101,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(A100:A101,2,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number(2). x is a multi-cell range. Returns #VALUE!. 3 of 5 arguments used.');
		// Case #17: Name, Number(2). x is a Name pointing to a negative number. x < default A=0. Returns #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(TestName2,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(TestName2,2,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name, Number(2). x is a Name pointing to a negative number. x < default A=0. Returns #NUM!. 3 of 5 arguments used.');
		// Case #18: Number, Boolean, Number. alpha is FALSE (0). Returns #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,FALSE,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,FALSE,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Boolean, Number. alpha is FALSE (0). Returns #NUM!. 3 of 5 arguments used.');
		// Case #19: Formula, Number(2). x is a formula that returns an error. Returns #DIV/0!. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(1/0,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(1/0,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, Number(2). x is a formula that returns an error. Returns #DIV/0!. 3 of 5 arguments used.');

		// Bounded cases:

		// Case #1: Number(5). x = A. Should return 0. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0,2,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0,2,5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(5). x = A. Should return 0. 5 of 5 arguments used.');
		// Case #2: Number(5). x = B. Should return 1. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(1,2,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(1,2,5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(5). x = B. Should return 1. 5 of 5 arguments used.');
		// Case #3: Number(3). alpha is the smallest positive number. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,1E-9,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,1E-9,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 1, 'Test: Bounded case: Number(3). alpha is the smallest positive number. 3 of 5 arguments used.');
		// Case #4: Number(3). beta is the smallest positive number. 3 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.5,5,1E-9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.5,5,1E-9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0855513909834847e-11, 'Test: Bounded case: Number(3). beta is the smallest positive number. 3 of 5 arguments used.');
		// Case #5: Number(5). x is very close to A. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(1E-9,2,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(1E-9,2,5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4999999959999995e-17, 'Test: Bounded case: Number(5). x is very close to A. 5 of 5 arguments used.');
		// Case #6: Number(5). x is very close to B. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(0.999999999,2,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(0.999999999,2,5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(5). x is very close to B. 5 of 5 arguments used.');
		// Case #7: Number(5). A and B are very close. 5 of 5 arguments used.
		oParser = new parserFormula('BETADIST(1,2,5,0.999999999,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETADIST(1,2,5,0.999999999,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(5). A and B are very close. 5 of 5 arguments used.');

		// Need to fix: diff results from MS
		// Case #16: Ref3D, Number(2). x is a 3D reference. 3 of 5 arguments used.
		// Case #5: Number(5). x < A. Returns #NUM!. 5 of 5 arguments used.
		// Case #6: Number(5). x > B. Returns #NUM!. 5 of 5 arguments used.
		// Case #16: Area, Number(2). x is a multi-cell range. Returns #VALUE!. 3 of 5 arguments used.
		// Case #17: Name, Number(2). x is a Name pointing to a negative number. x < default A=0. Returns #NUM!. 3 of 5 arguments used.

		testArrayFormula2(assert, "BETADIST", 3, 5);
	});

	QUnit.test("Test: \"BETA.DIST\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2");
		ws.getRange2("A101").setValue("8");
		ws.getRange2("A102").setValue("10");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A104").setValue("3");
		ws.getRange2("A105").setValue("0.5");
		ws.getRange2("A106").setValue("0");
		ws.getRange2("A107").setValue("test");
		ws.getRange2("A108").setValue("");
		ws.getRange2("A2").setValue("2");
		ws.getRange2("A3").setValue("8");
		ws.getRange2("A4").setValue("10");
		ws.getRange2("A5").setValue("1");
		ws.getRange2("A6").setValue("3");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 6);
		ws.getRange2("A601").setValue("2"); // Column1
		ws.getRange2("B601").setValue("8"); // Column2
		ws.getRange2("C601").setValue("10"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		ws.getRange2("E601").setValue("3"); // Column5
		ws.getRange2("F601").setValue("TRUE"); // Column6
		ws.getRange2("G601").setValue("0.2"); // Column7
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("2");
		ws2.getRange2("A2").setValue("8");
		ws2.getRange2("A3").setValue("10");
		ws2.getRange2("A4").setValue("1");
		ws2.getRange2("A5").setValue("3");
		ws2.getRange2("A6").setValue("0.5");
		ws2.getRange2("A7").setValue("0");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.2"); // TestName
		ws.getRange2("A202").setValue("8"); // TestName1
		ws.getRange2("A203").setValue("10"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		ws.getRange2("A205").setValue("2"); // TestName4
		ws.getRange2("A206").setValue("3"); // TestNameArea
		ws.getRange2("A207").setValue("4"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.2") // TestName3D
		ws2.getRange2("A12").setValue("8") // TestName3D1
		ws2.getRange2("A13").setValue("10") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3
		ws2.getRange2("A15").setValue("2") // TestName3D4
		ws2.getRange2("A16").setValue("3"); // TestNameArea3D
		ws2.getRange2("A17").setValue("4"); // TestNameArea3D


		// Positive cases:

		// Case #1: Reference link(3), Boolean, Reference link(2). Example from documentation. Cumulative - TRUE. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.DIST(A2,A3,A4,TRUE,A5,A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A2,A3,A4,TRUE,A5,A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.6854706, 'Test: Positive case: Reference link(3), Boolean, Reference link(2). Example from documentation. Cumulative - TRUE. 5 of 5 arguments used.');
		// Case #2: Reference link(3), Boolean, Reference link(2). Example from documentation. Cumulative - FALSE. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.DIST(A2,A3,A4,FALSE,A5,A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A2,A3,A4,FALSE,A5,A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 1.4837646, 'Test: Positive case: Reference link(3), Boolean, Reference link(2). Example from documentation. Cumulative - FALSE. 5 of 5 arguments used.');
		// Case #3: Number(3), Boolean, Number(2). Basic test with standard parameters from documentation. X=2, alpha=8, beta=10, cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, TRUE,1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, TRUE,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Number(3), Boolean, Number(2). Basic test with standard parameters from documentation. X=2, alpha=8, beta=10, cumulative=TRUE. 6 of 6 arguments used.');
		// Case #4: Number(3), Boolean, Number(2). Basic test with standard parameters but cumulative=FALSE. X=2, alpha=8, beta=10. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, FALSE,1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, FALSE,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.483764648, 'Test: Positive case: Number(3), Boolean, Number(2). Basic test with standard parameters but cumulative=FALSE. X=2, alpha=8, beta=10. 6 of 6 arguments used.');
		// Case #5: Number(3), Boolean, Number(2). All 6 arguments used from documentation example. X=2, alpha=8, beta=10, cumulative=TRUE, A=1, B=3.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, TRUE, 1, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, TRUE, 1, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Number(3), Boolean, Number(2). All 6 arguments used from documentation example. X=2, alpha=8, beta=10, cumulative=TRUE, A=1, B=3.');
		// Case #6: Number(3), Boolean, Number(2). All 6 arguments used with cumulative=FALSE. X=2, alpha=8, beta=10, A=1, B=3.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, FALSE, 1, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, FALSE, 1, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.483764648, 'Test: Positive case: Number(3), Boolean, Number(2). All 6 arguments used with cumulative=FALSE. X=2, alpha=8, beta=10, A=1, B=3.');
		// Case #7: Number(4). Cumulative parameter as number (1=TRUE). X=2, alpha=8, beta=10. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.5, 8, 10, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.5, 8, 10, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Number(4). Cumulative parameter as number (1=TRUE). X=2, alpha=8, beta=10. 4 of 6 arguments used.');
		// Case #8: Number(4). Cumulative parameter as number (0=FALSE). X=2, alpha=8, beta=10. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.5, 8, 10, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.5, 8, 10, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.967529297, 'Test: Positive case: Number(4). Cumulative parameter as number (0=FALSE). X=2, alpha=8, beta=10. 4 of 6 arguments used.');
		// Case #9: Number(6). All 6 arguments used with cumulative as number (1=TRUE). X=2, alpha=8, beta=10, A=1, B=3.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, 1, 1, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, 1, 1, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Number(6). All 6 arguments used with cumulative as number (1=TRUE). X=2, alpha=8, beta=10, A=1, B=3.');
		// Case #10: Number(6). All 6 arguments used with cumulative as number (0=FALSE). X=2, alpha=8, beta=10, A=1, B=3.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, 0, 1, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, 0, 1, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.483764648, 'Test: Positive case: Number(6). All 6 arguments used with cumulative as number (0=FALSE). X=2, alpha=8, beta=10, A=1, B=3.');
		// Case #11: String(3), Boolean. X, alpha, beta as strings convertible to numbers. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST("0.5", "8", "10", TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST("0.5", "8", "10", TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: String(3), Boolean. X, alpha, beta as strings convertible to numbers. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #12: String(3), Boolean, String(2). All parameters as strings convertible to numbers. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST("2", "8", "10", FALSE, "1", "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST("2", "8", "10", FALSE, "1", "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.483764648, 'Test: Positive case: String(3), Boolean, String(2). All parameters as strings convertible to numbers. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #13: String(4). X, alpha, beta, cumulative as strings convertible to numbers/boolean. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST("0.5", "8", "10", "TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST("0.5", "8", "10", "TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.685470581, 'Test: Positive case: String(4). X, alpha, beta, cumulative as strings convertible to numbers/boolean. 4 of 6 arguments used.');
		// Case #14: String(6). All parameters as strings convertible to numbers. Cumulative as string "1" (TRUE). 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST("2", "8", "10", "FALSE", "1", "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST("2", "8", "10", "FALSE", "1", "3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 1.483764648, 'Test: Positive case: String(6). All parameters as strings convertible to numbers. Cumulative as string "1" (TRUE). 6 of 6 arguments used.');
		// Case #15: Formula(2), Number, Boolean. X and alpha calculated by nested formulas, beta as number. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(SQRT(0.25), POWER(2,3), 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(SQRT(0.25), POWER(2,3), 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Formula(2), Number, Boolean. X and alpha calculated by nested formulas, beta as number. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #16: Formula(2), Number, Boolean, Formula, Number. X, alpha, A calculated by nested formulas. Beta, B as numbers. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(SQRT(4), POWER(2,3), 10, TRUE, ROUND(1,0), 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(SQRT(4), POWER(2,3), 10, TRUE, ROUND(1,0), 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Formula(2), Number, Boolean, Formula, Number. X, alpha, A calculated by nested formulas. Beta, B as numbers. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #17: Number(3), Formula. Cumulative parameter calculated by nested IF formula (returns 1=TRUE). 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.5, 8, 10, IF(TRUE,1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.5, 8, 10, IF(TRUE,1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Number(3), Formula. Cumulative parameter calculated by nested IF formula (returns 1=TRUE). 4 of 6 arguments used.');
		// Case #18: Number(3), Boolean, Empty(2). Basic 4 parameters used, optional parameters A and B omitted. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.85, 9, 11, TRUE,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.85, 9, 11, TRUE,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.999979875, 'Test: Positive case: Number(3), Boolean, Empty(2). Basic 4 parameters used, optional parameters A and B omitted. 6 of 6 arguments used.');
		// Case #19: Number(3), Boolean, Number, Empty. First 5 parameters used, parameter B omitted. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.35, 5.5, 7.5, FALSE, 0,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.35, 5.5, 7.5, FALSE, 0,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(8) - 0*/, 2.63991779, 'Test: Positive case: Number(3), Boolean, Number, Empty. First 5 parameters used, parameter B omitted. 6 of 6 arguments used.');
		// Case #20: Reference link(3), Boolean. X, alpha, beta as reference links. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(A105, A101, A102, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A105, A101, A102, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Reference link(3), Boolean. X, alpha, beta as reference links. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #21: Reference link(4). X, alpha, beta, cumulative as reference links. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(A105, A101, A102, A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A105, A101, A102, A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.967529297, 'Test: Positive case: Reference link(4). X, alpha, beta, cumulative as reference links. 4 of 6 arguments used.');
		// Case #22: Reference link(3), Boolean, Reference link(2). All parameters as reference links except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(A100, A101, A102, TRUE, A103, A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A100, A101, A102, TRUE, A103, A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Reference link(3), Boolean, Reference link(2). All parameters as reference links except cumulative. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #23: Reference link(6). All parameters as reference links. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(A100, A101, A102, A106, A103, A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A100, A101, A102, A106, A103, A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.483764648, 'Test: Positive case: Reference link(6). All parameters as reference links. 6 of 6 arguments used.');
		// Case #24: Area(3), Boolean. X, alpha, beta as single-cell areas. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(A105:A105, A101:A101, A102:A102, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A105:A105, A101:A101, A102:A102, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Area(3), Boolean. X, alpha, beta as single-cell areas. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #25: Area(4). X, alpha, beta, cumulative as single-cell areas. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(A105:A105, A101:A101, A102:A102, A106:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A105:A105, A101:A101, A102:A102, A106:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.967529297, 'Test: Positive case: Area(4). X, alpha, beta, cumulative as single-cell areas. 4 of 6 arguments used.');
		// Case #26: Area(3), Boolean, Area(2). All parameters as single-cell areas except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(A100:A100, A101:A101, A102:A102, TRUE, A103:A103, A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A100:A100, A101:A101, A102:A102, TRUE, A103:A103, A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Area(3), Boolean, Area(2). All parameters as single-cell areas except cumulative. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #27: Area(6). All parameters as single-cell areas. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(A100:A100, A101:A101, A102:A102, A103:A103, A103:A103, A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A100:A100, A101:A101, A102:A102, A103:A103, A103:A103, A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Area(6). All parameters as single-cell areas. 6 of 6 arguments used.');
		// Case #28: Array(3), Boolean. X, alpha, beta as single-element arrays. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST({0.1}, {2.3}, {3.3}, 1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST({0.1}, {2.3}, {3.3}, 1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.036314314, 'Test: Positive case: Array(3), Boolean. X, alpha, beta as single-element arrays. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #29: Array(4). X, alpha, beta, cumulative as single-element arrays. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST({0.5}, {8}, {10}, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST({0.5}, {8}, {10}, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Array(4). X, alpha, beta, cumulative as single-element arrays. 4 of 6 arguments used.');
		// Case #30: Array(3), Boolean, Array(2). All parameters as single-element arrays except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST({0.2}, {8}, {10}, TRUE, {0.1}, {5.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST({0.2}, {8}, {10}, TRUE, {0.1}, {5.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.8961070353004766e-10, 'Test: Positive case: Array(3), Boolean, Array(2). All parameters as single-element arrays except cumulative. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #31: Array(6). All parameters as single-element arrays. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST({2}, {8}, {10}, {1}, {1}, {3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST({2}, {8}, {10}, {1}, {1}, {3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Array(6). All parameters as single-element arrays. 6 of 6 arguments used.');
		// Case #32: Name(3), Boolean. X, alpha, beta as named ranges. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(TestName, TestName1, TestName2, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(TestName, TestName1, TestName2, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.010934315, 'Test: Positive case: Name(3), Boolean. X, alpha, beta as named ranges. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #33: Name(4). X, alpha, beta, cumulative as named ranges. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(TestName, TestName1, TestName2, TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(TestName, TestName1, TestName2, TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.010934315, 'Test: Positive case: Name(4). X, alpha, beta, cumulative as named ranges. 4 of 6 arguments used.');
		// Case #34: Name(3), Boolean, Name(2). All parameters as named ranges except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(TestName4, TestName1, TestName2, TRUE, TestName3, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(TestName4, TestName1, TestName2, TRUE, TestName3, TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.685470581, 'Test: Positive case: Name(3), Boolean, Name(2). All parameters as named ranges except cumulative. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #35: Name(6). All parameters as named ranges. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(TestName4, TestName1, TestName2, TestName3, TestName4, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(TestName4, TestName1, TestName2, TestName3, TestName4, TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.685470581, 'Test: Positive case: Name(6). All parameters as named ranges. 6 of 6 arguments used.');
		// Case #36: Name3D(3), Boolean. X, alpha, beta as 3D named ranges. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(TestName3D, TestName3D1, TestName3D2, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(TestName3D, TestName3D1, TestName3D2, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.010934315, 'Test: Positive case: Name3D(3), Boolean. X, alpha, beta as 3D named ranges. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #37: Name3D(4). X, alpha, beta, cumulative as 3D named ranges. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(TestName3D, TestName3D1, TestName3D2, TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(TestName3D, TestName3D1, TestName3D2, TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.010934315, 'Test: Positive case: Name3D(4). X, alpha, beta, cumulative as 3D named ranges. 4 of 6 arguments used.');
		// Case #38: Name3D(3), Boolean, Name3D(2). All parameters as 3D named ranges except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(TestName3D4, TestName3D1, TestName3D2, TRUE, TestName3D3, TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(TestName3D4, TestName3D1, TestName3D2, TRUE, TestName3D3, TestNameArea3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.685470581, 'Test: Positive case: Name3D(3), Boolean, Name3D(2). All parameters as 3D named ranges except cumulative. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #39: Name3D(6). All parameters as 3D named ranges. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(TestName3D4, TestName3D1, TestName3D2, TestName3D3, TestName3D3, TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(TestName3D4, TestName3D1, TestName3D2, TestName3D3, TestName3D3, TestNameArea3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.685470581, 'Test: Positive case: Name3D(6). All parameters as 3D named ranges. 6 of 6 arguments used.');
		// Case #40: Ref3D(3), Boolean. X, alpha, beta as 3D references. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Sheet2!A6, Sheet2!A2, Sheet2!A3, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Sheet2!A6, Sheet2!A2, Sheet2!A3, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Ref3D(3), Boolean. X, alpha, beta as 3D references. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #41: Ref3D(4). X, alpha, beta, cumulative as 3D references. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Sheet2!A6, Sheet2!A2, Sheet2!A3, Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Sheet2!A6, Sheet2!A2, Sheet2!A3, Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.967529297, 'Test: Positive case: Ref3D(4). X, alpha, beta, cumulative as 3D references. 4 of 6 arguments used.');
		// Case #42: Ref3D(3), Boolean, Ref3D(2). All parameters as 3D references except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Sheet2!A1, Sheet2!A2, Sheet2!A3, TRUE, Sheet2!A4, Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Sheet2!A1, Sheet2!A2, Sheet2!A3, TRUE, Sheet2!A4, Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Ref3D(3), Boolean, Ref3D(2). All parameters as 3D references except cumulative. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #43: Ref3D(6). All parameters as 3D references. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Sheet2!A1, Sheet2!A2, Sheet2!A3, Sheet2!A4, Sheet2!A4, Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Sheet2!A1, Sheet2!A2, Sheet2!A3, Sheet2!A4, Sheet2!A4, Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Ref3D(6). All parameters as 3D references. 6 of 6 arguments used.');
		// Case #44: Area3D(3), Boolean. X, alpha, beta as 3D single-cell areas. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Sheet2!A6:A6, Sheet2!A2:A2, Sheet2!A3:A3, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Sheet2!A6:A6, Sheet2!A2:A2, Sheet2!A3:A3, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Area3D(3), Boolean. X, alpha, beta as 3D single-cell areas. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #45: Area3D(4). X, alpha, beta, cumulative as 3D single-cell areas. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Sheet2!A6:A6, Sheet2!A2:A2, Sheet2!A3:A3, Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Sheet2!A5:A5, Sheet2!A2:A2, Sheet2!A3:A3, Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.967529297, 'Test: Positive case: Area3D(4). X, alpha, beta, cumulative as 3D single-cell areas. 4 of 6 arguments used.');
		// Case #46: Area3D(3), Boolean, Area3D(2). All parameters as 3D single-cell areas except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Sheet2!A1:A1, Sheet2!A2:A2, Sheet2!A3:A3, TRUE, Sheet2!A4:A4, Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Sheet2!A1:A1, Sheet2!A2:A2, Sheet2!A3:A3, TRUE, Sheet2!A4:A4, Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Area3D(3), Boolean, Area3D(2). All parameters as 3D single-cell areas except cumulative. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #47: Area3D(6). All parameters as 3D single-cell areas. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Sheet2!A1:A1, Sheet2!A2:A2, Sheet2!A3:A3, Sheet2!A4:A4, Sheet2!A4:A4, Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Sheet2!A1:A1, Sheet2!A2:A2, Sheet2!A3:A3, Sheet2!A4:A4, Sheet2!A4:A4, Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Area3D(6). All parameters as 3D single-cell areas. 6 of 6 arguments used.');
		// Case #48: Table(3), Boolean. X, alpha, beta as table references. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Table1[Column7], Table1[Column2], Table1[Column3], TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Table1[Column7], Table1[Column2], Table1[Column3], TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.010934315, 'Test: Positive case: Table(3), Boolean. X, alpha, beta as table references. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #49: Table(4). X, alpha, beta, cumulative as table references. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Table1[Column7], Table1[Column2], Table1[Column3], Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Table1[Column7], Table1[Column2], Table1[Column3], Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.010934315, 'Test: Positive case: Table(4). X, alpha, beta, cumulative as table references. 4 of 6 arguments used.');
		// Case #50: Table(3), Boolean, Table(2). All parameters as table references except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Table1[Column1], Table1[Column2], Table1[Column3], TRUE, Table1[Column4], Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Table1[Column1], Table1[Column2], Table1[Column3], TRUE, Table1[Column4], Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Table(3), Boolean, Table(2). All parameters as table references except cumulative. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #51: Table(6). All parameters as table references. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(Table1[Column1], Table1[Column2], Table1[Column3], Table1[Column6], Table1[Column4], Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(Table1[Column1], Table1[Column2], Table1[Column3], Table1[Column6], Table1[Column4], Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Table(6). All parameters as table references. 6 of 6 arguments used.');
		// Case #52: Formula(3), Boolean. X, alpha, beta calculated by different formulas. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(ROUND(0.255,2), ABS(8), MAX(5,10), TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(ROUND(0.255,2), ABS(8), MAX(5,10), TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.049880973, 'Test: Positive case: Formula(3), Boolean. X, alpha, beta calculated by different formulas. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #53: Formula(4). X, alpha, beta and cumulative calculated by different formulas. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(ROUND(0.255,3), ABS(8), MAX(10,20), IF(FALSE,1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(ROUND(0.255,3), ABS(8), MAX(10,20), IF(FALSE,1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4.63669019, 'Test: Positive case: Formula(4). X, alpha, beta and cumulative calculated by different formulas. 4 of 6 arguments used.');
		// Case #54: Formula. BETA.DIST used inside SUM formula. 4 of 6 arguments used for BETA.DIST.
		oParser = new parserFormula('SUM(BETA.DIST(0.255, 8, 10, TRUE), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BETA.DIST(0.255, 8, 10, TRUE), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.044873701, 'Test: Positive case: Formula. BETA.DIST used inside SUM formula. 4 of 6 arguments used for BETA.DIST.');
		// Case #55: Formula. BETA.DIST used inside IF formula for comparison. 4 of 6 arguments used for BETA.DIST.
		oParser = new parserFormula('IF(BETA.DIST(0.2, 8, 10, TRUE)>0.5, "High", "Low")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(BETA.DIST(0.2, 8, 10, TRUE)>0.5, "High", "Low") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'Low', 'Test: Positive case: Formula. BETA.DIST used inside IF formula for comparison. 4 of 6 arguments used for BETA.DIST.');
		// Case #56: Number(3), Boolean, Number(2). X=1.5 is between A=1 and B=3. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(1.5, 8, 10, TRUE, 1, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(1.5, 8, 10, TRUE, 1, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.04023678, 'Test: Positive case: Number(3), Boolean, Number(2). X=1.5 is between A=1 and B=3. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #57: Number(3), Formula, Number(2). Cumulative parameter calculated by nested IF formula. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, IF(1>0,TRUE,FALSE), 1, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, IF(1>0,TRUE,FALSE), 1, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Number(3), Formula, Number(2). Cumulative parameter calculated by nested IF formula. 6 of 6 arguments used.');
		// Case #58: Number(3), Boolean, Formula(2). Optional parameters A and B calculated by MIN and MAX formulas. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, TRUE, MIN(1,2), MAX(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, TRUE, MIN(1,2), MAX(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.685470581, 'Test: Positive case: Number(3), Boolean, Formula(2). Optional parameters A and B calculated by MIN and MAX formulas. 6 of 6 arguments used.');
		// Case #59: Empty, Number(2), Boolean. Parameter x is empty. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(, 8, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(, 8, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number(2), Boolean. Parameter x is empty. Cumulative=TRUE. 4 of 6 arguments used.');

		// Negative cases:

		// Case #1: Number(3), Boolean. Parameter x < 0 (below default range). Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(-0.1, 8, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(-0.1, 8, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Parameter x < 0 (below default range). Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #2: Number(3), Boolean. Parameter x > 1 (above default range). Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(1.1, 8, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(1.1, 8, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Parameter x > 1 (above default range). Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #3: Number(3), Boolean. Parameter alpha < 0 (invalid). Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, -8, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, -8, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Parameter alpha < 0 (invalid). Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #4: Number(3), Boolean. Parameter beta < 0 (invalid). Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, -10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, -10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Parameter beta < 0 (invalid). Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #5: Number(3), Boolean. Parameter alpha = 0 (invalid). Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 0, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 0, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Parameter alpha = 0 (invalid). Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #6: Number(3), Boolean. Parameter beta = 0 (invalid). Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 0, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 0, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Parameter beta = 0 (invalid). Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #7: Number(3), Boolean, Number(2). Parameter x < A (invalid). Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.5, 8, 10, TRUE, 0.6, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.5, 8, 10, TRUE, 0.6, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean, Number(2). Parameter x < A (invalid). Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #8: Number(3), Boolean, Number(2). Parameter x > B (invalid). Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(1.2, 8, 10, TRUE, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(1.2, 8, 10, TRUE, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean, Number(2). Parameter x > B (invalid). Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #9: Number(3), Boolean, Number(2). Parameter A > B (invalid range). Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, TRUE, 3, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, TRUE, 3, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean, Number(2). Parameter A > B (invalid range). Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #10: Number(3), Boolean, Number(2). Parameter A = B (invalid range). Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, TRUE, 2, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, TRUE, 2, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean, Number(2). Parameter A = B (invalid range). Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #11: String, Number(2), Boolean. Parameter x as non-numeric string. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST("abc", 8, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST("abc", 8, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(2), Boolean. Parameter x as non-numeric string. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #12: Number, String, Number, Boolean. Parameter alpha as non-numeric string. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, "abc", 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, "abc", 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number, Boolean. Parameter alpha as non-numeric string. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #13: Number(2), String, Boolean. Parameter beta as non-numeric string. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, "abc", TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, "abc", TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Boolean. Parameter beta as non-numeric string. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #14: Number(3), String. Parameter cumulative as non-boolean string. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String. Parameter cumulative as non-boolean string. 4 of 6 arguments used.');
		// Case #15: Number(3), Boolean, String. Parameter A as non-numeric string. Cumulative=TRUE. 5 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, TRUE, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, TRUE, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean, String. Parameter A as non-numeric string. Cumulative=TRUE. 5 of 6 arguments used.');
		// Case #16: Number(3), Boolean, Number, String. Parameter B as non-numeric string. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, TRUE, 1, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, TRUE, 1, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean, Number, String. Parameter B as non-numeric string. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #17: String(4). Cumulative can\'t convert to boolean from number to string. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST("0.5", "8", "10", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST("0.5", "8", "10", "1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Cumulative can\'t convert to boolean from number to string. 4 of 6 arguments used.');
		// Case #18: Number, Empty, Number, Boolean. Parameter alpha is empty. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, , 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, , 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number, Boolean. Parameter alpha is empty. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #19: Number(2), Empty, Boolean. Parameter beta is empty. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, , TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, , TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Empty, Boolean. Parameter beta is empty. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #20: Number(3), Empty. Parameter cumulative is empty. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Empty. Parameter cumulative is empty. 4 of 6 arguments used.');
		// Case #21: Error, Number(2), Boolean. Parameter x is error value. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(NA(), 8, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(NA(), 8, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(2), Boolean. Parameter x is error value. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #22: Number, Error, Number, Boolean. Parameter alpha is error value. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, NA(), 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, NA(), 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number, Boolean. Parameter alpha is error value. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #23: Number(2), Error, Boolean. Parameter beta is error value. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, NA(), TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, NA(), TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Boolean. Parameter beta is error value. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #24: Number(3), Error. Parameter cumulative is error value. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(2, 8, 10, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(2, 8, 10, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error. Parameter cumulative is error value. 4 of 6 arguments used.');
		// Case #25: Area, Number(2), Boolean. Parameter x is multi-cell area with incorrect data. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(A100:A101, 8, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(A100:A101, 8, 10, TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number(2), Boolean. Parameter x is multi-cell area with incorrect data. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #26: Number, Area, Number, Boolean. Parameter alpha is multi-cell area with incorrect data. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.2, A106:A107, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.2, A106:A107, 10, TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area, Number, Boolean. Parameter alpha is multi-cell area with incorrect data. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #27: Number(2), Area, Boolean. Parameter beta is multi-cell area with incorrect data. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.2, 8, A106:A107, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.2, 8, A106:A107, TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Area, Boolean. Parameter beta is multi-cell area with incorrect data. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #28: Number(3), Area. Parameter cumulative is multi-cell area with incorrect data. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.2, 8, 10, A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.2, 8, 10, A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Parameter cumulative is multi-cell area with incorrect data. 4 of 6 arguments used.');
		// Case #29: Array, Number(2), Boolean. Parameter x is multi-element array. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST({2, 1.5}, 8, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST({2, 1.5}, 8, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number(2), Boolean. Parameter x is multi-element array. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #30: Number, Array, Number, Boolean. Parameter alpha is multi-element array. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.2, {-1, -2}, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.2, {-1, -2}, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Array, Number, Boolean. Parameter alpha is multi-element array. Cumulative=TRUE. 4 of 6 arguments used.');

		// Bounded cases:

		// Case #1: Number(3), Boolean. Parameter alpha very small but positive. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.5, 1E-10, 10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.5, 1E-10, 10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0) - 0, 1, 'Test: Bounded case: Number(3), Boolean. Parameter alpha very small but positive. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #2: Number(3), Boolean. Parameter beta very small but positive. Cumulative=TRUE. 4 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(0.5, 8, 1E-10, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(0.5, 8, 1E-10, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.852757982171152e-14, 'Test: Bounded case: Number(3), Boolean. Parameter beta very small but positive. Cumulative=TRUE. 4 of 6 arguments used.');
		// Case #3: Number(3), Boolean, Number(2). Parameter x near minimum of extremely wide custom range. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(-999, 8, 10, TRUE, -1000, 1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(-999, 8, 10, TRUE, -1000, 1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.458177674409215e-23, 'Test: Bounded case: Number(3), Boolean, Number(2). Parameter x near minimum of extremely wide custom range. Cumulative=TRUE. 6 of 6 arguments used.');
		// Case #4: Number(3), Boolean, Number(2). Parameter x near maximum of extremely wide custom range. Cumulative=TRUE. 6 of 6 arguments used.
		oParser = new parserFormula('BETA.DIST(999, 8, 10, TRUE, -1000, 1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.DIST(999, 8, 10, TRUE, -1000, 1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean, Number(2). Parameter x near maximum of extremely wide custom range. Cumulative=TRUE. 6 of 6 arguments used.');

		// Need to fix: boolean handle, string handle, diff results from MS, 
		// Case #34: Name(3), Boolean, Name(2). All parameters as named ranges except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		// Case #35: Name(6). All parameters as named ranges. 6 of 6 arguments used.
		// Case #38: Name3D(3), Boolean, Name3D(2). All parameters as 3D named ranges except cumulative. Cumulative=TRUE. 6 of 6 arguments used.
		// Case #39: Name3D(6). All parameters as 3D named ranges. 6 of 6 arguments used.
		// Case #10: Number(3), Boolean, Number(2). Parameter A = B (invalid range). Cumulative=TRUE. 6 of 6 arguments used.
		// Case #17: String(4). Cumulative can\'t convert to boolean from number to string. 4 of 6 arguments used.
		// Case #25: Area, Number(2), Boolean. Parameter x is multi-cell area with incorrect data. Cumulative=TRUE. 4 of 6 arguments used.
		// Case #27: Number(2), Area, Boolean. Parameter beta is multi-cell area with incorrect data. Cumulative=TRUE. 4 of 6 arguments used.


		testArrayFormula2(assert, "BETA.DIST", 4, 6);
	});

	QUnit.test("Test: \"BETA.INV\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A104").setValue("30");
		ws.getRange2("A105").setValue("Test");
		ws.getRange2("A106").setValue("0");
		ws.getRange2("A107").setValue("2");
		ws.getRange2("A2").setValue("0.685470581");
		ws.getRange2("A3").setValue("8");
		ws.getRange2("A4").setValue("10");
		ws.getRange2("A5").setValue("1");
		ws.getRange2("A6").setValue("3");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("0.1"); // Column1
		ws.getRange2("B601").setValue("10"); // Column2
		ws.getRange2("C601").setValue("20"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		ws.getRange2("E601").setValue("30"); // Column5
		ws.getRange2("F601").setValue("test"); // Column6
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.1");
		ws2.getRange2("A2").setValue("10");
		ws2.getRange2("A3").setValue("20");
		ws2.getRange2("A4").setValue("1");
		ws2.getRange2("A5").setValue("30");
		ws2.getRange2("A6").setValue("test");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.1"); // TestName
		ws.getRange2("A202").setValue("10"); // TestName1
		ws.getRange2("A203").setValue("20"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		ws.getRange2("A205").setValue("30"); // TestName4
		ws.getRange2("A206").setValue("30"); // TestNameArea
		ws.getRange2("A207").setValue("40"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.1") // TestName3D
		ws2.getRange2("A12").setValue("10") // TestName3D1
		ws2.getRange2("A13").setValue("20") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3
		ws2.getRange2("A15").setValue("30") // TestName3D4
		ws2.getRange2("A16").setValue("30"); // TestNameArea3D
		ws2.getRange2("A17").setValue("40"); // TestNameArea3D

		// Positive cases:

		// Case #1: Reference link(5). Example from documentation. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(A2,A3,A4,A5,A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(A2,A3,A4,A5,A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 2, 'Test: Positive case: Reference link(5). Example from documentation. 5 of 5 arguments used.');
		// Case #1: Number(5). All arguments are numeric; A and B provided; example from documentation. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.685470581,8,10,1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.685470581,8,10,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 2, 'Test: Positive case: Number(5). All arguments are numeric; A and B provided; example from documentation. 5 of 5 arguments used.');
		// Case #2: Number(3). A and B omitted -> defaults A=0; B=1. 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.5,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.5,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.385727568, 'Test: Positive case: Number(3). A and B omitted -> defaults A=0; B=1. 3 of 5 arguments used.');
		// Case #3: Array,Number(4). Array probability (vertical array of 2) with scalar parameters. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV({0.25;0.75},2,5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV({0.25;0.75},2,5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.161162917, 'Test: Positive case: Array,Number(4). Array probability (vertical array of 2) with scalar parameters. 5 of 5 arguments used.');
		// Case #4: Formula. BETA.INV nested in ROUND to check composition and rounding. 5 of 5 arguments used.
		oParser = new parserFormula('ROUND(BETA.INV(0.5,2,3,0,1),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ROUND(BETA.INV(0.5,2,3,0,1),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.386, 'Test: Positive case: Formula. BETA.INV nested in ROUND to check composition and rounding. 5 of 5 arguments used.');
		// Case #5: Reference link(5). Reference-link test: formula reads args from A100..A104. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 7.566035649, 'Test: Positive case: Reference link(5). Reference-link test: formula reads args from A100..A104. 5 of 5 arguments used.');
		// Case #6: Area,Number(4). Area used for probability. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(A100:A101,2,3,0,1)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(A100:A101,2,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.14255931671003072, 'Test: Positive case: Area,Number(4). Area used for probability. 5 of 5 arguments used.');
		// Case #7: Name(3). Named ranges used for probability, alpha, beta. 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.226415022, 'Test: Positive case: Name(3). Named ranges used for probability, alpha, beta. 3 of 5 arguments used.');
		// Case #8: Table(5). Structured table references for five columns. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 7.566035649, 'Test: Positive case: Table(5). Structured table references for five columns. 5 of 5 arguments used.');
		// Case #9: Formula, Number(4). DATE() and TIME() returns a serial number. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(DATE(1900,1,1)-TIME(0,30,0),2,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(DATE(1900,1,1)-TIME(0,30,0),2,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.817967222, 'Test: Positive case: Formula, Number(4). DATE() and TIME() returns a serial number. 5 of 5 arguments used.');
		// Case #10: Formula. TIME() returns number. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(TIME(0,30,0),2,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(TIME(0,30,0),2,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.061435024, 'Test: Positive case: Formula. TIME() returns number. 5 of 5 arguments used.');
		// Case #11: Number(5). Probability = 0.999 should return the upper bound B. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.999,5,2,0,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.999,5,2,0,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 9.917445072, 'Test: Positive case: Number(5). Probability = 0.999 should return the upper bound B. 5 of 5 arguments used.');
		// Case #12: Number(5). A and B - 5 and 6. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.8,2,3,5,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.8,2,3,5,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 5.582453575, 'Test: Positive case: Number(5). A and B - 5 and 6. 5 of 5 arguments used.');
		// Case #13: Formula. BETA.INV nested in IF. 5 of 5 arguments used.
		oParser = new parserFormula('IF(BETA.INV(0.5,2,3,0,1)>0,BETA.INV(0.5,2,3,0,1),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(BETA.INV(0.5,2,3,0,1)>0,BETA.INV(0.5,2,3,0,1),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.385727568, 'Test: Positive case: Formula. BETA.INV nested in IF. 5 of 5 arguments used.');
		// Case #14: Name(5). TestNameArea — named range (2 cells) for B. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(TestName,TestName1,TestName2,TestName3,TestNameArea)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(TestName,TestName1,TestName2,TestName3,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 7.566035649273711, 'Test: Positive case: Name(5). TestNameArea — named range (2 cells) for B. 5 of 5 arguments used.');
		// Case #15: Ref3D(5). 3D-reference test: Formula uses Sheet2!A1..A5. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 7.566035649, 'Test: Positive case: Ref3D(5). 3D-reference test: Formula uses Sheet2!A1..A5. 5 of 5 arguments used.');
		// Case #16: Area3D,Number(4). 3D-area used for probability. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(Sheet2!A1:A1,2,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(Sheet2!A1:A1,2,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.142559317, 'Test: Positive case: Area3D,Number(4). 3D-area used for probability. 5 of 5 arguments used.');
		// Case #17: Number(5). Small positive alpha/beta and small probability — numeric valid case. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.001,0.1,0.1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.001,0.1,0.1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.86928065555034e-28, 'Test: Positive case: Number(5). Small positive alpha/beta and small probability — numeric valid case. 5 of 5 arguments used.');
		// Case #18: Number,Array,Number(3). Array provided for alpha (length 2) -> result spills per array parameter support. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.5,{2;4},3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.5,{2;4},3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.385727568, 'Test: Positive case: Number,Array,Number(3). Array provided for alpha (length 2) -> result spills per array parameter support. 5 of 5 arguments used.');
		// Case #19: String(3). Numeric strings:  string->number conversion behavior. 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV("0.5","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV("0.5","2","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.385727568, 'Test: Positive case: String(3). Numeric strings:  string->number conversion behavior. 3 of 5 arguments used.');
		// Case #20: Number(5). Very small probability >0 — valid positive case. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.0000001,2,2,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.0000001,2,2,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000182585, 'Test: Positive case: Number(5). Very small probability >0 — valid positive case. 5 of 5 arguments used.');
		// Case #21: Name3D(5). Named 3D references used for all arguments. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 7.566035649, 'Test: Positive case: Name3D(5). Named 3D references used for all arguments. 5 of 5 arguments used.');
		// Case #22: String(5). All arguments are numbers in string. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV("0.5","2","3", "1", "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV("0.5","2","3", "1", "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.771455136, 'Test: Positive case: String(5). All arguments are numbers in string. 5 of 5 arguments used.');
		// Case #23: Name3D(5). B is Name3D Area. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestNameArea3D)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 7.566035649273711, 'Test: Positive case: Name3D(5). B is Name3D Area. 5 of 5 arguments used.');

		// Negative cases:

		// Case #1: Number(5). Probability = 0. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0,0,2,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0,0,2,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Probability = 0. 5 of 5 arguments used.');
		// Case #2: Number(5). Probability > 1 -> #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(1.2,2,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(1.2,2,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Probability > 1 -> #NUM!. 5 of 5 arguments used.');
		// Case #3: Number(5). Probability < 0 -> #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(-0.1,2,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(-0.1,2,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Probability < 0 -> #NUM!. 5 of 5 arguments used.');
		// Case #4: Number(5). alpha = 0 -> #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.5,0,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.5,0,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). alpha = 0 -> #NUM!. 5 of 5 arguments used.');
		// Case #5: Number(5). beta = 0 -> #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.5,2,0,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.5,2,0,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). beta = 0 -> #NUM!. 5 of 5 arguments used.');
		// Case #6: String,Number(4). Non-numeric string -> #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV("text",2,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV("text",2,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Number(4). Non-numeric string -> #VALUE!. 5 of 5 arguments used.');
		// Case #7: Error,Number(4). Argument is error (#N/A) -> #N/A. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(NA(),2,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(NA(),2,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(4). Argument is error (#N/A) -> #N/A. 5 of 5 arguments used.');
		// Case #8: Reference link(3). Reference to cell with text in A100 -> #VALUE!. 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(A105,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(A105,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(3). Reference to cell with text in A100 -> #VALUE!. 3 of 5 arguments used.');
		// Case #9: Area,Number(4). Area contains invalid probability (0 or >1) in one element -> that position -> #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(A106:A107,2,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(A106:A107,2,3,0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area,Number(4). Area contains invalid probability (0 or >1) in one element -> that position -> #NUM!. 5 of 5 arguments used.');
		// Case #10: Number(5). alpha < 0 -> #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.5,-1,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.5,-1,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). alpha < 0 -> #NUM!. 5 of 5 arguments used.');
		// Case #11: Number(5). beta < 0 -> #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.5,1,-3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.5,1,-3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). beta < 0 -> #NUM!. 5 of 5 arguments used.');
		// Case #12: Array,Number(4). Array element >1 -> that element returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV({1.5},2,3,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV({1.5},2,3,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array,Number(4). Array element >1 -> that element returns #NUM!. 5 of 5 arguments used.');
		// Case #13: String,Number(2). String with incorrect comma as decimal may not be parsed -> #VALUE!. 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV("0,5",2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV("0,5",2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Number(2). String with incorrect comma as decimal may not be parsed -> #VALUE!. 3 of 5 arguments used.');
		// Case #14: Table. Table contains text in Column6 -> #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(Table1[Column6],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(Table1[Column6],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table contains text in Column6 -> #VALUE!. 5 of 5 arguments used.');
		// Case #15: Ref3D(3). One of Sheet2!A6 contains text -> #VALUE!. 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(Sheet2!A6,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(Sheet2!A6,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(3). One of Sheet2!A6 contains text -> #VALUE!. 3 of 5 arguments used.');
		// Case #16: Formula. DATE serial is >>1 -> probability out of range -> #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(DATE(9999,1,1),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(DATE(9999,1,1),2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. DATE serial is >>1 -> probability out of range -> #NUM!. 3 of 5 arguments used.');
		// Case #17: Formula. TIME 00:00:00 = 0 -> probability 0 -> #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(TIME(0,0,0),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(TIME(0,0,0),2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. TIME 00:00:00 = 0 -> probability 0 -> #NUM!. 3 of 5 arguments used.');
		// Case #18: Formula,Number(2). Non-numeric intermediate (division by zero) -> error propagated (#DIV/0!). 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(1/0,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(1/0,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula,Number(2). Non-numeric intermediate (division by zero) -> error propagated (#DIV/0!). 3 of 5 arguments used.');
		// Case #19: Number(5). Probability accidentally >1 in first argument -> #NUM!. 3 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(2,0.5,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(2,0.5,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Probability accidentally >1 in first argument -> #NUM!. 3 of 5 arguments used.');

		// Bounded cases:

		// Case #1: Number(5). Large alpha/beta and probability near 1 — numeric stability upper bound test. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.999999999999,100000,100000,0,100000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.999999999999,100000,100000,0,100000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50786.43208373119, 'Test: Bounded case: Number(5). Large alpha/beta and probability near 1 — numeric stability upper bound test. 5 of 5 arguments used.');
		// Case #2: Number(5). Alpha=1 and Beta=1 -> uniform distribution; standard central-case stability test. 5 of 5 arguments used.
		oParser = new parserFormula('BETA.INV(0.5,1,1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETA.INV(0.5,1,1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number(5). Alpha=1 and Beta=1 -> uniform distribution; standard central-case stability test. 5 of 5 arguments used.');

		// Need to fix:
		// Case #9: Area,Number(4). Area contains invalid probability (0 or >1) in one element -> that position -> #NUM!. 5 of 5 arguments used.
		// Case #17: Formula. TIME 00:00:00 = 0 -> probability 0 -> #NUM!. 3 of 5 arguments used.	

		testArrayFormula2(assert, "BETA.INV", 3, 5);
	});

	QUnit.test("Test: \"BETAINV\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("0");
		ws.getRange2("A104").setValue("3");
		ws.getRange2("A105").setValue("");
		ws.getRange2("A2").setValue("0.685470581");
		ws.getRange2("A3").setValue("8");
		ws.getRange2("A4").setValue("10");
		ws.getRange2("A5").setValue("1");
		ws.getRange2("A6").setValue("3");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 4);
		ws.getRange2("A601").setValue("0.5"); // Column1
		ws.getRange2("B601").setValue("2"); // Column2
		ws.getRange2("C601").setValue("3"); // Column3
		ws.getRange2("D601").setValue("0"); // Column4
		ws.getRange2("E601").setValue("3"); // Column5
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("3");
		ws2.getRange2("A4").setValue("0");
		ws2.getRange2("A5").setValue("3");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.5"); // TestName
		ws.getRange2("A202").setValue("2"); // TestName1
		ws.getRange2("A203").setValue("3"); // TestName2
		ws.getRange2("A204").setValue("0"); // TestName3
		ws.getRange2("A205").setValue("3"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.5") // TestName3D
		ws2.getRange2("A12").setValue("2") // TestName3D1
		ws2.getRange2("A13").setValue("3") // TestName3D2
		ws2.getRange2("A14").setValue("0") // TestName3D3
		ws2.getRange2("A15").setValue("3") // TestName3D4


		// Positive cases:

		// Case #1: Reference link(5). Example from documentation. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(A2,A3,A4,A5,A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(A2,A3,A4,A5,A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 2, 'Test: Positive case: Reference link(5). Example from documentation. 5 of 5 arguments used.');
		// Case #1: Number(5). Basic valid input with all 5 arguments. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.385727568, 'Test: Positive case: Number(5). Basic valid input with all 5 arguments. 5 of 5 arguments used.');
		// Case #2: Number(3). Uses default A=0 and B=1. 3 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.385727568, 'Test: Positive case: Number(3). Uses default A=0 and B=1. 3 of 5 arguments used.');
		// Case #3: String(5). String arguments converted to numbers. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV("0.5", "2", "3", "0", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV("0.5", "2", "3", "0", "1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.385727568, 'Test: Positive case: String(5). String arguments converted to numbers. 5 of 5 arguments used.');
		// Case #4: Formula(5). Nested formulas as arguments. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(SQRT(0.25), 2*1, 3/1, 0+0, 1-0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(SQRT(0.25), 2*1, 3/1, 0+0, 1-0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.385727568, 'Test: Positive case: Formula(5). Nested formulas as arguments. 5 of 5 arguments used.');
		// Case #5: Reference link(5). Reference links to cells. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(A100, A101, A102, A103, A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(A100, A101, A102, A103, A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.157182704, 'Test: Positive case: Reference link(5). Reference links to cells. 5 of 5 arguments used.');
		// Case #6: Area(5). Single-cell areas. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(A100:A100, A101:A101, A102:A102, A103:A103, A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(A100:A100, A101:A101, A102:A102, A103:A103, A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.157182704, 'Test: Positive case: Area(5). Single-cell areas. 5 of 5 arguments used.');
		// Case #7: Array(5). Single-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV({0.5}, {2}, {3}, {0}, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV({0.5}, {2}, {3}, {0}, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.385727568, 'Test: Positive case: Array(5). Single-element arrays. 5 of 5 arguments used.');
		// Case #8: Name(5). Named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(TestName, TestName1, TestName2, TestName3, TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(TestName, TestName1, TestName2, TestName3, TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.157182704, 'Test: Positive case: Name(5). Named ranges. 5 of 5 arguments used.');
		// Case #9: Name3D(5). 3D named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(TestName3D, TestName3D1, TestName3D2, TestName3D3, TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(TestName3D, TestName3D1, TestName3D2, TestName3D3, TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.157182704, 'Test: Positive case: Name3D(5). 3D named ranges. 5 of 5 arguments used.');
		// Case #10: Ref3D(5). 3D references. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(Sheet2!A1, Sheet2!A2, Sheet2!A3, Sheet2!A4, Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(Sheet2!A1, Sheet2!A2, Sheet2!A3, Sheet2!A4, Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.157182704, 'Test: Positive case: Ref3D(5). 3D references. 5 of 5 arguments used.');
		// Case #11: Area3D(5). 3D single-cell areas. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(Sheet2!A1:A1, Sheet2!A2:A2, Sheet2!A3:A3, Sheet2!A4:A4, Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(Sheet2!A1:A1, Sheet2!A2:A2, Sheet2!A3:A3, Sheet2!A4:A4, Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.157182704, 'Test: Positive case: Area3D(5). 3D single-cell areas. 5 of 5 arguments used.');
		// Case #12: Table(5). Table references. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(Table1[Column1], Table1[Column2], Table1[Column3], Table1[Column4], Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(Table1[Column1], Table1[Column2], Table1[Column3], Table1[Column4], Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.157182704, 'Test: Positive case: Table(5). Table references. 5 of 5 arguments used.');
		// Case #13: Number, Boolean(4). Boolean values (TRUE=1, FALSE=0). 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, TRUE, TRUE, FALSE, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, TRUE, TRUE, FALSE, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Number, Boolean(4). Boolean values (TRUE=1, FALSE=0). 5 of 5 arguments used.');
		// Case #14: Number(5). Fractional numbers. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.123, 1.5, 2.5, 0.1, 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.123, 1.5, 2.5, 0.1, 0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.19422143, 'Test: Positive case: Number(5). Fractional numbers. 5 of 5 arguments used.');
		// Case #15: Number(5). Large alpha and beta. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 100, 200, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 100, 200, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.332962507, 'Test: Positive case: Number(5). Large alpha and beta. 5 of 5 arguments used.');
		// Case #16: Formula. Nested in another function. 5 of 5 arguments used for BETAINV.
		oParser = new parserFormula('SUM(BETAINV(0.5, 2, 3, 0, 1), 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BETAINV(0.5, 2, 3, 0, 1), 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 10.38572757, 'Test: Positive case: Formula. Nested in another function. 5 of 5 arguments used for BETAINV.');
		// Case #17: Array(5). Multi-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV({0.1,0.9}, {1,2}, {2,1}, {0,0}, {1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV({0.1,0.9}, {1,2}, {2,1}, {0,0}, {1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.051316702, 'Test: Positive case: Array(5). Multi-element arrays. 5 of 5 arguments used.');
		// Case #18: Formula(2), Number(2), Formula. Dates as serial numbers. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(DATE(1900,1,1) - TIME(0,30,0), DATE(2020,1,2), 2, 3, DATE(2020,1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(DATE(1900,1,1) - TIME(0,30,0), DATE(2020,1,2), 2, 3, DATE(2020,1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 43832.78054, 'Test: Positive case: Formula(2), Number(2), Formula. Dates as serial numbers. 5 of 5 arguments used.');
		// Case #19: Formula(2), Number(3). Times as serial numbers. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(TIME(0,30,0), TIME(12,0,0), 2, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(TIME(0,30,0), TIME(12,0,0), 2, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000192926, 'Test: Positive case: Formula(2), Number(3). Times as serial numbers. 5 of 5 arguments used.');
		// Case #20: Number(5). Negative A value. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, 3, -10, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, 3, -10, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -2.285448637, 'Test: Positive case: Number(5). Negative A value. 5 of 5 arguments used.');
		// Case #21: Number, Array, Number(3). Array of boolean for alpha. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, {TRUE}, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, {TRUE}, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.206299474, 'Test: Positive case: Number, Array, Number(3). Array of boolean for alpha. 5 of 5 arguments used.');

		// Negative cases:

		// Case #1: Number(5). Probability < 0. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(-0.1, 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(-0.1, 2, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Probability < 0. 5 of 5 arguments used.');
		// Case #2: Number(5). Probability > 1. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(1.1, 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(1.1, 2, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Probability > 1. 5 of 5 arguments used.');
		// Case #3: Number(5). Alpha <= 0. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 0, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 0, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Alpha <= 0. 5 of 5 arguments used.');
		// Case #4: Number(5). Beta <= 0. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, -1, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, -1, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Beta <= 0. 5 of 5 arguments used.');
		// Case #5: Number(5). A >= B. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, 3, 1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, 3, 1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). A >= B. 5 of 5 arguments used.');
		// Case #6: String, Number(4). Non-numeric string. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV("abc", 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV("abc", 2, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(4). Non-numeric string. 5 of 5 arguments used.');
		// Case #7: Error, Number(4). Error value. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(NA(), 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(NA(), 2, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(4). Error value. 5 of 5 arguments used.');
		// Case #8: Reference link, Number(4). Empty cell (treated as 0). 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(A105, 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(A105, 2, 3, 0, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Number(4). Empty cell (treated as 0). 5 of 5 arguments used.');
		// Case #9: Number, Boolean, Number(3). FALSE for alpha (0). 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, FALSE, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, FALSE, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Boolean, Number(3). FALSE for alpha (0). 5 of 5 arguments used.');
		// Case #10: Number(2), Boolean, Number(2). FALSE for beta (0). 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, FALSE, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, FALSE, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Boolean, Number(2). FALSE for beta (0). 5 of 5 arguments used.');
		// Case #11: Number, String, Number(3). Non-numeric string for alpha. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, "abc", 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, "abc", 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(3). Non-numeric string for alpha. 5 of 5 arguments used.');
		// Case #12: Number(2), String, Number(2). Non-numeric string for beta. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, "abc", 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, "abc", 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Number(2). Non-numeric string for beta. 5 of 5 arguments used.');
		// Case #13: Array, Number(4). Array with text. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV({"abc"}, 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV({"abc"}, 2, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Number(4). Array with text. 5 of 5 arguments used.');
		// Case #14: Number(3), String(2). Non-numeric strings for A and B. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, 3, "a", "b")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, 3, "a", "b") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String(2). Non-numeric strings for A and B. 5 of 5 arguments used.');
		// Case #15: Array, Number(4). Array of booleans for probability. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV({TRUE, FALSE}, 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV({TRUE, FALSE}, 2, 3, 0, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number(4). Array of booleans for probability. 5 of 5 arguments used.');
		// Case #16: Number(2), Array, Number(2). Array of boolean for beta. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, {FALSE}, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, {FALSE}, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Array, Number(2). Array of boolean for beta. 5 of 5 arguments used.');
		// Case #17: Number(3), Array(2). Arrays with text for A and B. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, 3, { "a"}, { "b"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, 3, { "a"}, { "b"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Array(2). Arrays with text for A and B. 5 of 5 arguments used.');
		// Case #18: Formula, Number(4). Division by zero in formula. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(1/0, 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(1/0, 2, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, Number(4). Division by zero in formula. 5 of 5 arguments used.');

		// Bounded cases:

		// Case #1: Number(5). Min probability (close to 0). 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(1E-307, 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(1E-307, 2, 3, 0, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 8.8138e-162, 'Test: Bounded case: Number(5). Min probability (close to 0). 5 of 5 arguments used.');
		// Case #2: Number(5). Max probability (close to 1). 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(1-1E-15, 2, 3, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(1-1E-15, 2, 3, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.999994, 'Test: Bounded case: Number(5). Max probability (close to 1). 5 of 5 arguments used.');
		// Case #3: Number(5). Min difference between A and B. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, 3, 0, 1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, 3, 0, 1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.857275681323895e-308, 'Test: Bounded case: Number(5). Min difference between A and B. 5 of 5 arguments used.');
		// Case #4: Number(5). Large alpha and beta. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 1E+10, 1E+10, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 1E+10, 1E+10, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Bounded case: Number(5). Large alpha and beta. 5 of 5 arguments used.');
		// Case #5: Number(5). Large interval [A, B]. 5 of 5 arguments used.
		oParser = new parserFormula('BETAINV(0.5, 2, 3, -1E+10, 1E+10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BETAINV(0.5, 2, 3, -1E+10, 1E+10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2285448637.35221, 'Test: Bounded case: Number(5). Large interval [A, B]. 5 of 5 arguments used.');

		// Need to fix: 
		// Case #8: Reference link, Number(4). Empty cell (treated as 0). 5 of 5 arguments used.
		// Case #15: Array, Number(4). Array of booleans for probability. 5 of 5 arguments used.
		// Case #1: Number(5). Min probability (close to 0). 5 of 5 arguments used.

		testArrayFormula2(assert, "BETAINV", 3, 5);
	});

	QUnit.test("Test: \"BINOMDIST\"", function (assert) {
		// OLD
		function binomdist(x, n, p) {
			x = parseInt(x);
			n = parseInt(n);
			return Math.binomCoeff(n, x) * Math.pow(p, x) * Math.pow(1 - p, n - x);
		}

		oParser = new parserFormula("BINOMDIST(6,10,0.5,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.ok(Math.abs(oParser.calculate().getValue() - binomdist(6, 10, 0.5)) < dif);

		oParser = new parserFormula("BINOMDIST(6,10,0.5,TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.ok(Math.abs(oParser.calculate().getValue() - (function () {
			var bm = 0;
			for (var y = 0; y <= 6; y++) {
				bm += binomdist(y, 10, 0.5)
			}
			return bm;
		})()) < dif);

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("6");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("FALSE");
		ws.getRange2("A104").setValue("test");
		ws.getRange2("A105").setValue("text");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("6"); // Column1
		ws.getRange2("B601").setValue("10"); // Column2
		ws.getRange2("C601").setValue("0.5"); // Column3
		ws.getRange2("D601").setValue("TRUE"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("6");
		ws2.getRange2("A2").setValue("10");
		ws2.getRange2("A3").setValue("0.5");
		ws2.getRange2("A4").setValue("FALSE");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("6"); // TestName
		ws.getRange2("A202").setValue("10"); // TestName1
		ws.getRange2("A203").setValue("0.5"); // TestName2
		ws.getRange2("A204").setValue("FALSE"); // TestName3
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("6") // TestName3D
		ws2.getRange2("A12").setValue("10") // TestName3D1
		ws2.getRange2("A13").setValue("0.5") // TestName3D2
		ws2.getRange2("A14").setValue("TRUE") // TestName3D3

		// Positive cases:

		// Case #1: Number(3), Boolean. Example from documentation.  Cumulative  - FALSE
		oParser = new parserFormula('BINOMDIST(6,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(6,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Number(3), Boolean. Example from documentation.  Cumulative  - FALSE');
		// Case #2: Number(3), Boolean. Example from documentation.  Cumulative  - TRUE
		oParser = new parserFormula('BINOMDIST(6,10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(6,10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Number(3), Boolean. Example from documentation.  Cumulative  - TRUE');
		// Case #1: Number(3), Boolean. Basic use: number of successes, trials, probability and cumulative distribution. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(6,10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(6,10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Number(3), Boolean. Basic use: number of successes, trials, probability and cumulative distribution. All parameters are in acceptable range.');
		// Case #2: Number(3), Boolean. Basic use: number of successes, trials, probability and probability mass function. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(6,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(6,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Number(3), Boolean. Basic use: number of successes, trials, probability and probability mass function. All parameters are in acceptable range.');
		// Case #3: Number(3), Boolean. Testing with 0 successes. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(0,10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(0,10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000976563, 'Test: Positive case: Number(3), Boolean. Testing with 0 successes. All parameters are in acceptable range.');
		// Case #4: Number(3), Boolean. Testing with number_s = trials (boundary case). All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(10,10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(10,10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3), Boolean. Testing with number_s = trials (boundary case). All parameters are in acceptable range.');
		// Case #5: Number(3), Boolean. Testing with 0 probability. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(5,10,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3), Boolean. Testing with 0 probability. All parameters are in acceptable range.');
		// Case #6: Number(3), Boolean. Testing with probability = 1. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(5,10,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(3), Boolean. Testing with probability = 1. All parameters are in acceptable range.');
		// Case #7: String(4). All parameters as strings convertible to appropriate types. Number_s and trials are truncated to integers.
		oParser = new parserFormula('BINOMDIST("6","10","0.5","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST("6","10","0.5","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.828125, 'Test: Positive case: String(4). All parameters as strings convertible to appropriate types. Number_s and trials are truncated to integers.');
		// Case #8: Formula(4). All parameters as formulas returning appropriate types.
		oParser = new parserFormula('BINOMDIST(ROUND(5.7,0),INT(10.2),ABS(-0.5),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(ROUND(5.7,0),INT(10.2),ABS(-0.5),IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Formula(4). All parameters as formulas returning appropriate types.');
		// Case #9: Number(4). Using 1 as equivalent to TRUE for cumulative parameter.
		oParser = new parserFormula('BINOMDIST(6,10,0.5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(6,10,0.5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Number(4). Using 1 as equivalent to TRUE for cumulative parameter.');
		// Case #10: Number(4). Using 0 as equivalent to FALSE for cumulative parameter.
		oParser = new parserFormula('BINOMDIST(6,10,0.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(6,10,0.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Number(4). Using 0 as equivalent to FALSE for cumulative parameter.');
		// Case #11: Reference link(4). All parameters as reference links to cells containing appropriate values.
		oParser = new parserFormula('BINOMDIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Reference link(4). All parameters as reference links to cells containing appropriate values.');
		// Case #12: Area(4). All parameters as single-cell ranges.
		oParser = new parserFormula('BINOMDIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Area(4). All parameters as single-cell ranges.');
		// Case #13: Array(4). All parameters as single-element arrays with appropriate values.
		oParser = new parserFormula('BINOMDIST({6},{10},{0.5},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST({6},{10},{0.5},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Array(4). All parameters as single-element arrays with appropriate values.');
		// Case #14: Name(4). All parameters as named ranges with appropriate values.
		oParser = new parserFormula('BINOMDIST(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Name(4). All parameters as named ranges with appropriate values.');
		// Case #15: Name3D(4). All parameters as 3D named ranges with appropriate values.
		oParser = new parserFormula('BINOMDIST(TestName3D,TestName3D1,TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Name3D(4). All parameters as 3D named ranges with appropriate values.');
		// Case #16: Ref3D(4). All parameters as 3D references to cells.
		oParser = new parserFormula('BINOMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Ref3D(4). All parameters as 3D references to cells.');
		// Case #17: Area3D(4). All parameters as 3D single-cell ranges.
		oParser = new parserFormula('BINOMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Area3D(4). All parameters as 3D single-cell ranges.');
		// Case #18: Table(4). All parameters as table references with appropriate values.
		oParser = new parserFormula('BINOMDIST(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Table(4). All parameters as table references with appropriate values.');
		// Case #19: Formula. BINOMDIST inside another formula.
		oParser = new parserFormula('SUM(BINOMDIST(6,10,0.5,TRUE),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BINOMDIST(6,10,0.5,TRUE),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 1.828125, 'Test: Positive case: Formula. BINOMDIST inside another formula.');
		// Case #20: Number(2), Formula(2). Using formulas with fixed results to generate probability and cumulative parameters.
		oParser = new parserFormula('BINOMDIST(6,10,SQRT(0.25),IF(SQRT(4)>1,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(6,10,SQRT(0.25),IF(SQRT(4)>1,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Number(2), Formula(2). Using formulas with fixed results to generate probability and cumulative parameters.');
		// Case #21: Number(3), Boolean. Testing with different probability value. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(3,10,0.3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(3,10,0.3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.649610718, 'Test: Positive case: Number(3), Boolean. Testing with different probability value. All parameters are in acceptable range.');
		// Case #22: Number(3), Boolean. Testing with different number of trials. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(8,15,0.6,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(8,15,0.6,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.177083662, 'Test: Positive case: Number(3), Boolean. Testing with different number of trials. All parameters are in acceptable range.');
		// Case #23: Number(3), Boolean. Testing with zero trials and zero successes. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(0,0,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(0,0,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3), Boolean. Testing with zero trials and zero successes. All parameters are in acceptable range.');
		// Case #24: Number, String(3). First parameter as number, others as strings.
		oParser = new parserFormula('BINOMDIST(5,"10","0.5","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,"10","0.5","FALSE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(8) - 0*/, 0.24609375, 'Test: Positive case: Number, String(3). First parameter as number, others as strings.');
		// Case #25: String, Number(3). First parameter as string, others as numbers.
		oParser = new parserFormula('BINOMDIST("5",10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST("5",10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: String, Number(3). First parameter as string, others as numbers.');
		// Case #26: Number(2), String(2). First two parameters as numbers, others as strings.
		oParser = new parserFormula('BINOMDIST(5,10,"0.5","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,"0.5","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.623046875, 'Test: Positive case: Number(2), String(2). First two parameters as numbers, others as strings.');
		// Case #27: Number(3), String. First three parameters as numbers, last as string.
		oParser = new parserFormula('BINOMDIST(5,10,0.5,"TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,0.5,"TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.623046875, 'Test: Positive case: Number(3), String. First three parameters as numbers, last as string.');
		// Case #28: Number(3), Boolean. First three parameters as numbers, last as boolean TRUE.
		oParser = new parserFormula('BINOMDIST(5,10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Number(3), Boolean. First three parameters as numbers, last as boolean TRUE.');
		// Case #29: Number(3), Formula. Last parameter as formula returning boolean.
		oParser = new parserFormula('BINOMDIST(5,10,0.5,IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,0.5,IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Number(3), Formula. Last parameter as formula returning boolean.');
		// Case #30: Formula, Number(3). First parameter as formula returning number.
		oParser = new parserFormula('BINOMDIST(ROUND(5.3,0),10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(ROUND(5.3,0),10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Formula, Number(3). First parameter as formula returning number.');
		// Case #31: Number, Formula, Number, Boolean. Second parameter as formula returning number.
		oParser = new parserFormula('BINOMDIST(5,INT(10.8),0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,INT(10.8),0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Number, Formula, Number, Boolean. Second parameter as formula returning number.');
		// Case #32: Number(2), Formula, Boolean. Third parameter as formula returning number.
		oParser = new parserFormula('BINOMDIST(5,10,ABS(-0.5),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,ABS(-0.5),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Number(2), Formula, Boolean. Third parameter as formula returning number.');
		// Case #33: Number(3), Boolean. Testing with float values for number_s and trials. Values will be truncated to integers.
		oParser = new parserFormula('BINOMDIST(5.7,10.3,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5.7,10.3,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Number(3), Boolean. Testing with float values for number_s and trials. Values will be truncated to integers.');
		// Case #34: Number(3), Boolean. Testing with float values for number_s and trials with mass function. Values will be truncated to integers.
		oParser = new parserFormula('BINOMDIST(5.1,10.9,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5.1,10.9,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.24609375, 'Test: Positive case: Number(3), Boolean. Testing with float values for number_s and trials with mass function. Values will be truncated to integers.');
		// Case #35: Formula(2), Number, Boolean. First two parameters as formulas returning appropriate values.
		oParser = new parserFormula('BINOMDIST(MIN(5,7),MAX(8,10),0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(MIN(5,7),MAX(8,10),0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Formula(2), Number, Boolean. First two parameters as formulas returning appropriate values.');
		// Case #36: Formula(2), String(2). Mixed parameter types.
		oParser = new parserFormula('BINOMDIST(ROUND(5.7,0),INT(10.2),"0.5","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(ROUND(5.7,0),INT(10.2),"0.5","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(6) - 0*/, 0.828125, 'Test: Positive case: Formula(2), String(2). Mixed parameter types.');
		// Case #37: Number(3), Boolean. Testing with one trial and zero successes. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(0,1,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(0,1,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Number(3), Boolean. Testing with one trial and zero successes. All parameters are in acceptable range.');
		// Case #38: Number(3), Boolean. Testing with one trial and one success. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(1,1,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(1,1,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3), Boolean. Testing with one trial and one success. All parameters are in acceptable range.');
		// Case #39: Number(3), Boolean. Testing with zero successes in many trials. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(0,100,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(0,100,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.888609052210118e-31, 'Test: Positive case: Number(3), Boolean. Testing with zero successes in many trials. All parameters are in acceptable range.');
		// Case #40: Number(3), Boolean. Testing with all successes in many trials. All parameters are in acceptable range.
		oParser = new parserFormula('BINOMDIST(100,100,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(100,100,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 1, 'Test: Positive case: Number(3), Boolean. Testing with all successes in many trials. All parameters are in acceptable range.');
		// Case #41: Formula(2), Number, Boolean. Using date formulas as number_s and trials. Will be converted to serial numbers and truncated to integers.
		oParser = new parserFormula('BINOMDIST(DATE(2023,1,1),DATE(2023,12,31),0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(DATE(2023,1,1),DATE(2023,12,31),0.5,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2), Number, Boolean. Using date formulas as number_s and trials. Will be converted to serial numbers and truncated to integers.');
		// Case #42: Formula(2), Number, Boolean. Using date formulas with smaller difference as number_s and trials with mass function.
		oParser = new parserFormula('BINOMDIST(DATE(2023,1,1),DATE(2023,1,10),0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(DATE(2023,1,1),DATE(2023,1,10),0.5,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula(2), Number, Boolean. Using date formulas with smaller difference as number_s and trials with mass function.');
		// Case #43: Formula(2), Number, Boolean. Using time formulas as number_s and trials. Will be converted to decimal fractions and truncated.
		oParser = new parserFormula('BINOMDIST(TIME(6,0,0),TIME(12,0,0),0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(TIME(6,0,0),TIME(12,0,0),0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2), Number, Boolean. Using time formulas as number_s and trials. Will be converted to decimal fractions and truncated.');
		// Case #44: Formula(2), Number, Boolean. Using time formulas plus days as number_s and trials with mass function.
		oParser = new parserFormula('BINOMDIST(TIME(12,0,0)+1,TIME(18,0,0)+2,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(TIME(12,0,0)+1,TIME(18,0,0)+2,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Formula(2), Number, Boolean. Using time formulas plus days as number_s and trials with mass function.');
		// Case #45: Formula(2), Number, Boolean. Using date functions to extract numerical values for parameters.
		oParser = new parserFormula('BINOMDIST(DAY("2023-09-15"),MONTH("2023-09-15")*10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(DAY("2023-09-15"),MONTH("2023-09-15")*10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.588242747857359e-11, 'Test: Positive case: Formula(2), Number, Boolean. Using date functions to extract numerical values for parameters.');
		// Case #46: Number(2), Formula, Boolean. Using date formula difference as probability (evaluates to 1).
		oParser = new parserFormula('BINOMDIST(5,10,DATE(2023,1,1)-DATE(2022,12,31),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,DATE(2023,1,1)-DATE(2022,12,31),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2), Formula, Boolean. Using date formula difference as probability (evaluates to 1).');
		// Case #47: Number(2), Formula, Boolean. Using time formula as probability (0.5 day = 0.5).
		oParser = new parserFormula('BINOMDIST(5,10,TIME(12,0,0),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,TIME(12,0,0),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Number(2), Formula, Boolean. Using time formula as probability (0.5 day = 0.5).');
		// Case #48: Empty(4). All parameters omitted
		oParser = new parserFormula('BINOMDIST(,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(,,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty(4). All parameters omitted');
		// Case #49: Number(2), Empty(2). Third and fourth parameters omitted. Third defaults to 0.5, fourth to TRUE.
		oParser = new parserFormula('BINOMDIST(5,10,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2), Empty(2). Third and fourth parameters omitted. Third defaults to 0.5, fourth to TRUE.');

		// Negative cases:

		// Case #0: Number(3), Boolean. Number of successes greater than trials returns #NUM!..
		oParser = new parserFormula("BINOMDIST(11,10,0.5,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(11,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Number of successes greater than trials returns #NUM!.');
		// Case #1: Number(3), Boolean. Negative number of successes returns #NUM!.
		oParser = new parserFormula('BINOMDIST(-1,10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(-1,10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Negative number of successes returns #NUM!.');
		// Case #2: Number(3), Boolean. Number of successes greater than trials returns #NUM!.
		oParser = new parserFormula('BINOMDIST(11,10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(11,10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Number of successes greater than trials returns #NUM!.');
		// Case #3: Number(3), Boolean. Negative number of trials returns #NUM!.
		oParser = new parserFormula('BINOMDIST(5,-1,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,-1,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Negative number of trials returns #NUM!.');
		// Case #4: Number(3), Boolean. Negative probability returns #NUM!.
		oParser = new parserFormula('BINOMDIST(5,10,-0.1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,-0.1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Negative probability returns #NUM!.');
		// Case #5: Number(3), Boolean. Probability greater than 1 returns #NUM!.
		oParser = new parserFormula('BINOMDIST(5,10,1.1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,1.1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Probability greater than 1 returns #NUM!.');
		// Case #6: String(4). Non-numeric string for number_s returns #VALUE!.
		oParser = new parserFormula('BINOMDIST("abc","10","0.5","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST("abc","10","0.5","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string for number_s returns #VALUE!.');
		// Case #7: String(4). Non-numeric string for trials returns #VALUE!.
		oParser = new parserFormula('BINOMDIST("5","abc","0.5","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST("5","abc","0.5","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string for trials returns #VALUE!.');
		// Case #8: String(4). Non-numeric string for probability returns #VALUE!.
		oParser = new parserFormula('BINOMDIST("5","10","abc","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST("5","10","abc","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string for probability returns #VALUE!.');
		// Case #9: String(4). Non-boolean string for cumulative returns #VALUE!.
		oParser = new parserFormula('BINOMDIST("5","10","0.5","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST("5","10","0.5","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-boolean string for cumulative returns #VALUE!.');
		// Case #10: Error, Number(2), Boolean. Error value for number_s propagates the error.
		oParser = new parserFormula('BINOMDIST(NA(),10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(NA(),10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(2), Boolean. Error value for number_s propagates the error.');
		// Case #11: Number, Error, Number, Boolean. Error value for trials propagates the error.
		oParser = new parserFormula('BINOMDIST(5,NA(),0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,NA(),0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number, Boolean. Error value for trials propagates the error.');
		// Case #12: Number(2), Error, Boolean. Error value for probability propagates the error.
		oParser = new parserFormula('BINOMDIST(5,10,NA(),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,NA(),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Boolean. Error value for probability propagates the error.');
		// Case #13: Number(3), Error. Error value for cumulative propagates the error.
		oParser = new parserFormula('BINOMDIST(5,10,0.5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,0.5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error. Error value for cumulative propagates the error.');
		// Case #14: Formula, Number(2), Boolean. Formula resulting in error for number_s propagates the error.
		oParser = new parserFormula('BINOMDIST(SQRT(-1),10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(SQRT(-1),10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number(2), Boolean. Formula resulting in error for number_s propagates the error.');
		// Case #15: Number, Formula, Number, Boolean. Formula resulting in error for trials propagates the error.
		oParser = new parserFormula('BINOMDIST(5,SQRT(-1),0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,SQRT(-1),0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula, Number, Boolean. Formula resulting in error for trials propagates the error.');
		// Case #16: Number(2), Formula, Boolean. Formula resulting in error for probability propagates the error.
		oParser = new parserFormula('BINOMDIST(5,10,SQRT(-1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,SQRT(-1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Formula, Boolean. Formula resulting in error for probability propagates the error.');
		// Case #17: Number(3), Formula. Formula resulting in error for cumulative propagates the error.
		oParser = new parserFormula('BINOMDIST(5,10,0.5,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,0.5,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Formula. Formula resulting in error for cumulative propagates the error.');
		// Case #18: Number, Empty, Number, Boolean. Second parameter omitted returns #VALUE!.
		oParser = new parserFormula('BINOMDIST(5,,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number, Boolean. Second parameter omitted returns #VALUE!.');
		// Case #19: String(4). Empty strings for all parameters returns #VALUE!.
		oParser = new parserFormula('BINOMDIST("","","","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST("","","","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Empty strings for all parameters returns #VALUE!.');
		// Case #20: Number(3), String. Non-boolean string for cumulative returns #VALUE!.
		oParser = new parserFormula('BINOMDIST(5,10,0.5,"5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,0.5,"5") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String. Non-boolean string for cumulative returns #VALUE!.');
		// Case #21: Formula, Number(2), Boolean. Date formula as number_s greater than trials date returns #NUM!.
		oParser = new parserFormula('BINOMDIST(DATE(2023,1,15),DATE(2023,1,1),0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(DATE(2023,1,15),DATE(2023,1,1),0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number(2), Boolean. Date formula as number_s greater than trials date returns #NUM!.');
		// Case #22: Number(2), Formula, Boolean. Date formula difference greater than 1 as probability returns #NUM!.
		oParser = new parserFormula('BINOMDIST(5,10,DATE(2023,12,31)-DATE(2023,1,1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(5,10,DATE(2023,12,31)-DATE(2023,1,1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Formula, Boolean. Date formula difference greater than 1 as probability returns #NUM!.');

		// Bounded cases:

		// Case #1: Number(3), Boolean. Minimum valid values: zero successes, zero trials, zero probability with cumulative TRUE.
		oParser = new parserFormula('BINOMDIST(0,0,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(0,0,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Minimum valid values: zero successes, zero trials, zero probability with cumulative TRUE.');
		// Case #2: Number(3), Boolean. Minimum valid values: zero successes, zero trials, zero probability with cumulative FALSE.
		oParser = new parserFormula('BINOMDIST(0,0,0,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(0,0,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Minimum valid values: zero successes, zero trials, zero probability with cumulative FALSE.');
		// Case #3: Number(3), Boolean. Edge case: zero successes, zero trials, probability of 1 with cumulative TRUE.
		oParser = new parserFormula('BINOMDIST(0,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(0,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Edge case: zero successes, zero trials, probability of 1 with cumulative TRUE.');
		// Case #4: Number(3), Boolean. Edge case: zero successes, zero trials, probability of 1 with cumulative FALSE.
		oParser = new parserFormula('BINOMDIST(0,0,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(0,0,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Edge case: zero successes, zero trials, probability of 1 with cumulative FALSE.');
		// Case #5: Number(3), Boolean. Large values: million successes, million trials with cumulative TRUE.
		oParser = new parserFormula('BINOMDIST(1000000,1000000,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(1000000,1000000,0.5,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Large values: million successes, million trials with cumulative TRUE.');
		// Case #6: Number(3), Boolean. Large values: million successes, million trials with probability mass function.
		oParser = new parserFormula('BINOMDIST(1000000,1000000,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(1000000,1000000,0.5,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3), Boolean. Large values: million successes, million trials with probability mass function.');
		// Case #7: Number(3), Boolean. Edge case: zero successes with very large number of trials.
		oParser = new parserFormula('BINOMDIST(0,1000000,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(0,1000000,0.5,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3), Boolean. Edge case: zero successes with very large number of trials.');
		// Case #8: Number(3), Boolean. Edge case: very small probability with large number of trials.
		oParser = new parserFormula('BINOMDIST(1000000,1000000,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(1000000,1000000,1E-307,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Edge case: very small probability with large number of trials.');
		// Case #9: Number(3), Boolean. Edge case: probability very close to 1 with large number of trials.
		oParser = new parserFormula('BINOMDIST(1000000,1000000,9.9E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(1000000,1000000,9.9E-307,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Edge case: probability very close to 1 with large number of trials.');
		// Case #10: Number(3), Boolean. Testing with extremely large numbers.
		oParser = new parserFormula('BINOMDIST(999999999,999999999,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOMDIST(999999999,999999999,0.5,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3), Boolean. Testing with extremely large numbers.');

		// Need to fix:
		// Case #7: String(4). All parameters as strings convertible to appropriate types. Number_s and trials are truncated to integers.
		// Case #24: Number, String(3). First parameter as number, others as strings.
		// Case #26: Number(2), String(2). First two parameters as numbers, others as strings.
		// Case #27: Number(3), String. First three parameters as numbers, last as string.
		// Case #36: Formula(2), String(2). Mixed parameter types.
		// Case #41: Formula(2), Number, Boolean. Using date formulas as number_s and trials. Will be converted to serial numbers and truncated to integers.
		// Case #42: Formula(2), Number, Boolean. Using date formulas with smaller difference as number_s and trials with mass function.
		// Case #20: Number(3), String. Non-boolean string for cumulative returns #VALUE!.
		// Case #5: Number(3), Boolean. Large values: million successes, million trials with cumulative TRUE.
		// Case #6: Number(3), Boolean. Large values: million successes, million trials with probability mass function.
		// Case #7: Number(3), Boolean. Edge case: zero successes with very large number of trials.
		// Case #8: Number(3), Boolean. Edge case: very small probability with large number of trials.
		// Case #9: Number(3), Boolean. Edge case: probability very close to 1 with large number of trials.
		// Case #10: Number(3), Boolean. Testing with extremely large numbers.


		testArrayFormula2(assert, "BINOMDIST", 4, 4);
	});

	QUnit.test("Test: \"BINOM.DIST\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A2").setValue("6");
		ws.getRange2("A3").setValue("10");
		ws.getRange2("A4").setValue("0.5");
		ws.getRange2("A100").setValue("4");
		ws.getRange2("A101").setValue("9");
		ws.getRange2("A102").setValue("0.4");
		ws.getRange2("A103").setValue("TRUE");
		ws.getRange2("A104").setValue("text");
		ws.getRange2("A105").setValue("test");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("4"); // Column1
		ws.getRange2("B601").setValue("9"); // Column2
		ws.getRange2("C601").setValue("0.4"); // Column3
		ws.getRange2("D601").setValue("TRUE"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("4");
		ws2.getRange2("A2").setValue("9");
		ws2.getRange2("A3").setValue("0.4");
		ws2.getRange2("A4").setValue("FALSE");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("4"); // TestName
		ws.getRange2("A202").setValue("9"); // TestName1
		ws.getRange2("A203").setValue("0.4"); // TestName2
		ws.getRange2("A204").setValue("TRUE"); // TestName3
		ws.getRange2("A206").setValue("text"); // TestNameArea
		ws.getRange2("A207").setValue("test"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("4") // TestName3D
		ws2.getRange2("A12").setValue("9") // TestName3D1
		ws2.getRange2("A13").setValue("0.4") // TestName3D2
		ws2.getRange2("A14").setValue("TRUE") // TestName3D3

		// Positive cases:

		// Case #1: Reference link(3), Boolean. Example from documentation
		oParser = new parserFormula('BINOM.DIST(A2,A3,A4,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(A2,A3,A4,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.2050781, 'Test: Positive case: Reference link(3), Boolean. Example from documentation');
		// Case #2: Number(3), Boolean. Basic test with number_s=6, trials=10, probability_s=0.5, cumulative=FALSE.
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Number(3), Boolean. Basic test with number_s=6, trials=10, probability_s=0.5, cumulative=FALSE.');
		// Case #3: Number(3), Boolean. Testing cumulative distribution (TRUE).
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Number(3), Boolean. Testing cumulative distribution (TRUE).');
		// Case #4: String(3), Boolean. All numeric arguments as strings. Strings convertible to numbers are valid.
		oParser = new parserFormula('BINOM.DIST("6","10","0.5",FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST("6","10","0.5",FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: String(3), Boolean. All numeric arguments as strings. Strings convertible to numbers are valid.');
		// Case #5: String(3), Number. Cumulative as number 1 (equivalent to TRUE).
		oParser = new parserFormula('BINOM.DIST("6","10","0.5",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST("6","10","0.5",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: String(3), Number. Cumulative as number 1 (equivalent to TRUE).');
		// Case #6: Number(3), String. Cumulative as string "FALSE".
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,"FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,"FALSE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.205078125, 'Test: Positive case: Number(3), String. Cumulative as string "FALSE".');
		// Case #7: Number(3), String. Cumulative as string "TRUE".
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,"TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,"TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(6) - 0, 0.828125*/, 'Positive case: Number(3), String. Cumulative as string "TRUE".');
		// Case #8: Formula(4). All arguments as formulas.
		oParser = new parserFormula('BINOM.DIST(ROUND(5.9,0),ROUND(10.2,0),ROUND(0.5,1),IF(TRUE,FALSE,TRUE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(ROUND(5.9,0),ROUND(10.2,0),ROUND(0.5,1),IF(TRUE,FALSE,TRUE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Formula(4). All arguments as formulas.');
		// Case #9: Formula, Number(3). Number_s as formula, others as direct values.
		oParser = new parserFormula('BINOM.DIST(INT(6.7),10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(INT(6.7),10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Formula, Number(3). Number_s as formula, others as direct values.');
		// Case #10: Number, Formula, Number(2). Trials as formula, others as direct values.
		oParser = new parserFormula('BINOM.DIST(6,CEILING(9.1,1),0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,CEILING(9.1,1),0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Number, Formula, Number(2). Trials as formula, others as direct values.');
		// Case #11: Number(2), Formula, Number. Probability_s as formula, others as direct values.
		oParser = new parserFormula('BINOM.DIST(6,10,ABS(-0.5),FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,ABS(-0.5),FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Number(2), Formula, Number. Probability_s as formula, others as direct values.');
		// Case #12: Number(3), Formula. Cumulative as formula, others as direct values.
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,NOT(FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,NOT(FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.828125, 'Test: Positive case: Number(3), Formula. Cumulative as formula, others as direct values.');
		// Case #13: Reference link(4). All arguments as cell references.
		oParser = new parserFormula('BINOM.DIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.73343232, 'Test: Positive case: Reference link(4). All arguments as cell references.');
		// Case #14: Area(4). All arguments as single-cell ranges.
		oParser = new parserFormula('BINOM.DIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.73343232, 'Test: Positive case: Area(4). All arguments as single-cell ranges.');
		// Case #15: Array(4). All arguments as single-element arrays.
		oParser = new parserFormula('BINOM.DIST({6},{10},{0.5},{FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST({6},{10},{0.5},{FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Array(4). All arguments as single-element arrays.');
		// Case #16: Number(3), Boolean. Testing with number_s = 0.
		oParser = new parserFormula('BINOM.DIST(0,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(0,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000976563, 'Test: Positive case: Number(3), Boolean. Testing with number_s = 0.');
		// Case #17: Number(3), Boolean. Testing with number_s = trials.
		oParser = new parserFormula('BINOM.DIST(10,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(10,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000976563, 'Test: Positive case: Number(3), Boolean. Testing with number_s = trials.');
		// Case #18: Number(3), Boolean. Testing cumulative with number_s = 0.
		oParser = new parserFormula('BINOM.DIST(0,10,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(0,10,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000976563, 'Test: Positive case: Number(3), Boolean. Testing cumulative with number_s = 0.');
		// Case #19: Name(4). All arguments as named ranges.
		oParser = new parserFormula('BINOM.DIST(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.73343232, 'Test: Positive case: Name(4). All arguments as named ranges.');
		// Case #20: Name3D(4). All arguments as 3D named ranges.
		oParser = new parserFormula('BINOM.DIST(TestName3D,TestName3D1,TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.73343232, 'Test: Positive case: Name3D(4). All arguments as 3D named ranges.');
		// Case #21: Ref3D(4). All arguments as 3D cell references.
		oParser = new parserFormula('BINOM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.250822656, 'Test: Positive case: Ref3D(4). All arguments as 3D cell references.');
		// Case #22: Area3D(4). All arguments as 3D single-cell ranges.
		oParser = new parserFormula('BINOM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.250822656, 'Test: Positive case: Area3D(4). All arguments as 3D single-cell ranges.');
		// Case #23: Table(4). All arguments as table references.
		oParser = new parserFormula('BINOM.DIST(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.73343232, 'Test: Positive case: Table(4). All arguments as table references.');
		// Case #24: Formula. BINOM.DIST nested in another formula.
		oParser = new parserFormula('SUM(BINOM.DIST(6,10,0.5,FALSE),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BINOM.DIST(6,10,0.5,FALSE),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.205078125, 'Test: Positive case: Formula. BINOM.DIST nested in another formula.');
		// Case #25: Number(3), Boolean. Testing with probability_s close to 1.
		oParser = new parserFormula('BINOM.DIST(6,10,0.999,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.999,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.0874314580314948e-10, 'Test: Positive case: Number(3), Boolean. Testing with probability_s close to 1.');
		// Case #26: Number(3), Boolean. Testing with probability_s close to 0.
		oParser = new parserFormula('BINOM.DIST(6,10,0.001,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.001,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.0916125916021001e-16, 'Test: Positive case: Number(3), Boolean. Testing with probability_s close to 0.');
		// Case #27: Number(3), Boolean. Testing with number_s = 0 and trials = 0.
		oParser = new parserFormula('BINOM.DIST(0,0,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(0,0,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3), Boolean. Testing with number_s = 0 and trials = 0.');
		// Case #28: Number(3), Empty. Testing with cumulative argument omitted (defaults to FALSE).
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Number(3), Empty. Testing with cumulative argument omitted (defaults to FALSE).');
		// Case #29: Number(3), Boolean. Testing with very small probability_s.
		oParser = new parserFormula('BINOM.DIST(0,1000,0.00001,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(0,1000,0.00001,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.990049784, 'Test: Positive case: Number(3), Boolean. Testing with very small probability_s.');
		// Case #30: Number(3), Boolean. Testing with very large probability_s.
		oParser = new parserFormula('BINOM.DIST(100,100,0.99999,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(100,100,0.99999,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.999000495, 'Test: Positive case: Number(3), Boolean. Testing with very large probability_s.');
		// Case #31: Formula, Number(2), Boolean. Number_s calculated as date difference (0).
		oParser = new parserFormula('BINOM.DIST(DATE(2025,1,1)-DATE(2025,1,1),10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(DATE(2025,1,1)-DATE(2025,1,1),10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000976563, 'Test: Positive case: Formula, Number(2), Boolean. Number_s calculated as date difference (0).');
		// Case #32: Number, Formula, Number, Boolean. Trials calculated as date difference (9).
		oParser = new parserFormula('BINOM.DIST(6,DATE(2025,1,10)-DATE(2025,1,1),0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,DATE(2025,1,10)-DATE(2025,1,1),0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.1640625, 'Test: Positive case: Number, Formula, Number, Boolean. Trials calculated as date difference (9).');
		// Case #33: Number(2), Formula, Boolean. Probability_s as time value (0.5).
		oParser = new parserFormula('BINOM.DIST(6,10,TIME(12,0,0),FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,TIME(12,0,0),FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Number(2), Formula, Boolean. Probability_s as time value (0.5).');
		// Case #34: Number(3), Number. Cumulative as 0 (equivalent to FALSE).
		oParser = new parserFormula('BINOM.DIST(2,5,0.4,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(2,5,0.4,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 0.3456, 'Test: Positive case: Number(3), Number. Cumulative as 0 (equivalent to FALSE).');
		// Case #35: Number(3), Boolean. Basic test with Boolean TRUE for cumulative.
		oParser = new parserFormula('BINOM.DIST(4,10,0.3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(4,10,0.3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.849731667, 'Test: Positive case: Number(3), Boolean. Basic test with Boolean TRUE for cumulative.');
		// Case #36: Number(3), Boolean. Basic test with Boolean FALSE for cumulative.
		oParser = new parserFormula('BINOM.DIST(4,10,0.3,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(4,10,0.3,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.200120949, 'Test: Positive case: Number(3), Boolean. Basic test with Boolean FALSE for cumulative.');
		// Case #37: Number(3), Formula. Cumulative as comparison expression (TRUE).
		oParser = new parserFormula('BINOM.DIST(5,10,0.5,2>1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(5,10,0.5,2>1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Number(3), Formula. Cumulative as comparison expression (TRUE).');
		// Case #38: Number(3), Formula. Cumulative as comparison expression (FALSE).
		oParser = new parserFormula('BINOM.DIST(5,10,0.5,2<1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(5,10,0.5,2<1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.24609375, 'Test: Positive case: Number(3), Formula. Cumulative as comparison expression (FALSE).');
		// Case #39: Number(3), Boolean. Testing with large trials and small probability_s.
		oParser = new parserFormula('BINOM.DIST(10,1000,0.01,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(10,1000,0.01,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.125740211, 'Test: Positive case: Number(3), Boolean. Testing with large trials and small probability_s.');
		// Case #40: Empty, Number(2), Boolean. Testing with empty number_s.
		oParser = new parserFormula('BINOM.DIST(,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000976563, 'Test: Positive case: Empty, Number(2), Boolean. Testing with empty number_s.');
		// Case #41: Number(2), Empty, Boolean. Testing with empty probability_s.
		oParser = new parserFormula('BINOM.DIST(6,10,,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2), Empty, Boolean. Testing with empty probability_s.');
		// Case #42: Number(3), Boolean. Testing with non-integer number_s.
		oParser = new parserFormula('BINOM.DIST(1.5,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(1.5,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.009765625, 'Test: Positive case: Number(3), Boolean. Testing with non-integer number_s.');
		// Case #43: Number(3), Boolean. Testing with non-integer trials.
		oParser = new parserFormula('BINOM.DIST(6,10.5,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10.5,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.205078125, 'Test: Positive case: Number(3), Boolean. Testing with non-integer trials.');

		// Negative cases:

		// Case #1: Number(3), Boolean. Testing with negative number_s. Returns #NUM! error.
		oParser = new parserFormula('BINOM.DIST(-1,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(-1,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Testing with negative number_s. Returns #NUM! error.');
		// Case #2: Number(3), Boolean. Testing with negative trials. Returns #NUM! error.
		oParser = new parserFormula('BINOM.DIST(6,-10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,-10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Testing with negative trials. Returns #NUM! error.');
		// Case #3: Number(3), Boolean. Testing with negative probability_s. Returns #NUM! error.
		oParser = new parserFormula('BINOM.DIST(6,10,-0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,-0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Testing with negative probability_s. Returns #NUM! error.');
		// Case #4: Number(3), Boolean. Testing with probability_s > 1. Returns #NUM! error.
		oParser = new parserFormula('BINOM.DIST(6,10,1.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,1.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Testing with probability_s > 1. Returns #NUM! error.');
		// Case #5: Number(3), Boolean. Testing with number_s > trials. Returns #NUM! error.
		oParser = new parserFormula('BINOM.DIST(11,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(11,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Testing with number_s > trials. Returns #NUM! error.');
		// Case #6: String, Number(2), Boolean. Testing with non-numeric string for number_s. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST("abc",10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST("abc",10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(2), Boolean. Testing with non-numeric string for number_s. Returns #VALUE! error.');
		// Case #7: Number, String, Number, Boolean. Testing with non-numeric string for trials. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,"abc",0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,"abc",0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number, Boolean. Testing with non-numeric string for trials. Returns #VALUE! error.');
		// Case #8: Number(2), String, Boolean. Testing with non-numeric string for probability_s. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,10,"abc",FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,"abc",FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Boolean. Testing with non-numeric string for probability_s. Returns #VALUE! error.');
		// Case #9: Number(3), String. Testing with non-boolean string for cumulative. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String. Testing with non-boolean string for cumulative. Returns #VALUE! error.');
		// Case #10: Number, Empty, Number, Boolean. Testing with empty trials. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number, Boolean. Testing with empty trials. Returns #VALUE! error.');
		// Case #11: Number, Empty(3). Testing with all optional arguments empty. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty(3). Testing with all optional arguments empty. Returns #VALUE! error.');
		// Case #12: Error, Number(2), Boolean. Testing with #N/A error for number_s. Propagates #N/A error.
		oParser = new parserFormula('BINOM.DIST(NA(),10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(NA(),10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(2), Boolean. Testing with #N/A error for number_s. Propagates #N/A error.');
		// Case #13: Number, Error, Number, Boolean. Testing with #N/A error for trials. Propagates #N/A error.
		oParser = new parserFormula('BINOM.DIST(6,NA(),0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,NA(),0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number, Boolean. Testing with #N/A error for trials. Propagates #N/A error.');
		// Case #14: Number(2), Error, Boolean. Testing with #N/A error for probability_s. Propagates #N/A error.
		oParser = new parserFormula('BINOM.DIST(6,10,NA(),FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,NA(),FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Boolean. Testing with #N/A error for probability_s. Propagates #N/A error.');
		// Case #15: Number(3), Error. Testing with #N/A error for cumulative. Propagates #N/A error.
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error. Testing with #N/A error for cumulative. Propagates #N/A error.');
		// Case #16: Number(3), Formula. Testing with division by zero for cumulative. Propagates #DIV/0! error.
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(3), Formula. Testing with division by zero for cumulative. Propagates #DIV/0! error.');
		// Case #17: Formula, Number(2), Boolean. Testing with division by zero for number_s. Propagates #DIV/0! error.
		oParser = new parserFormula('BINOM.DIST(1/0,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(1/0,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, Number(2), Boolean. Testing with division by zero for number_s. Propagates #DIV/0! error.');
		// Case #18: Number, Formula, Number, Boolean. Testing with division by zero for trials. Propagates #DIV/0! error.
		oParser = new parserFormula('BINOM.DIST(6,1/0,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,1/0,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Formula, Number, Boolean. Testing with division by zero for trials. Propagates #DIV/0! error.');
		// Case #19: Number(2), Formula, Boolean. Testing with division by zero for probability_s. Propagates #DIV/0! error.
		oParser = new parserFormula('BINOM.DIST(6,10,1/0,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,1/0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2), Formula, Boolean. Testing with division by zero for probability_s. Propagates #DIV/0! error.');
		// Case #20: Area, Number(2), Boolean. Testing with multi-cell range for number_s. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(A104:A105,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(A104:A105,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(2), Boolean. Testing with multi-cell range for number_s. Returns #VALUE! error.');
		// Case #21: Number, Area, Number, Boolean. Testing with multi-cell range for trials. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,A104:A105,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,A104:A105,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number, Boolean. Testing with multi-cell range for trials. Returns #VALUE! error.');
		// Case #22: Number(2), Area, Boolean. Testing with multi-cell range for probability_s. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,10,A104:A105,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,A104:A105,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Boolean. Testing with multi-cell range for probability_s. Returns #VALUE! error.');
		// Case #23: Number(3), Area. Testing with multi-cell range for cumulative. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Testing with multi-cell range for cumulative. Returns #VALUE! error.');
		// Case #24: String, Number(2), Boolean. Testing with empty string for number_s. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST("",10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST("",10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(2), Boolean. Testing with empty string for number_s. Returns #VALUE! error.');
		// Case #25: Number, String, Number, Boolean. Testing with empty string for trials. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,"",0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,"",0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number, Boolean. Testing with empty string for trials. Returns #VALUE! error.');
		// Case #26: Number(2), String, Boolean. Testing with empty string for probability_s. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,10,"",FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,"",FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Boolean. Testing with empty string for probability_s. Returns #VALUE! error.');
		// Case #27: Number(3), String. Testing with empty string for cumulative. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,"") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String. Testing with empty string for cumulative. Returns #VALUE! error.');
		// Case #28: Number(3), Boolean. Testing with number_s exceeding Excel\'s integer limits. Returns #NUM! error.
		oParser = new parserFormula('BINOM.DIST(2147483648,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(2147483648,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Testing with number_s exceeding Excel\'s integer limits. Returns #NUM! error.');
		// Case #29: Number(3), Boolean. Testing with trials exceeding Excel\'s integer limits. Returns #NUM! error.
		oParser = new parserFormula('BINOM.DIST(6,2147483648,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,2147483648,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean. Testing with trials exceeding Excel\'s integer limits. Returns #NUM! error.');
		// Case #30: Name, Number(2), Boolean. Testing with multi-cell named range for number_s. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(TestNameArea,10,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(TestNameArea,10,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number(2), Boolean. Testing with multi-cell named range for number_s. Returns #VALUE! error.');
		// Case #31: Number, Name, Number, Boolean. Testing with multi-cell named range for trials. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,TestNameArea,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,TestNameArea,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name, Number, Boolean. Testing with multi-cell named range for trials. Returns #VALUE! error.');
		// Case #32: Number(2), Name, Boolean. Testing with multi-cell named range for probability_s. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,10,TestNameArea,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,TestNameArea,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Name, Boolean. Testing with multi-cell named range for probability_s. Returns #VALUE! error.');
		// Case #33: Number(3), Name. Testing with multi-cell named range for cumulative. Returns #VALUE! error.
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Name. Testing with multi-cell named range for cumulative. Returns #VALUE! error.');
		// Case #34: Number(3), String. Cumulative as string "0" (equivalent to FALSE).
		oParser = new parserFormula('BINOM.DIST(6,10,0.5,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(6,10,0.5,"0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String. Cumulative as string "0" (equivalent to FALSE).');
		// Case #35: String(4). All arguments as strings, including cumulative as "1".
		oParser = new parserFormula('BINOM.DIST("0","10","0.5","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST("0","10","0.5","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). All arguments as strings, including cumulative as "1".');

		// Bounded cases:

		// Case #1: Number(3), Boolean. Testing with minimum valid values (number_s=0, trials=0, probability_s=0).
		oParser = new parserFormula('BINOM.DIST(0,0,0,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(0,0,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Testing with minimum valid values (number_s=0, trials=0, probability_s=0).');
		// Case #2: Number(3), Boolean. Testing with probability_s = 1 (maximum valid value).
		oParser = new parserFormula('BINOM.DIST(0,0,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(0,0,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Testing with probability_s = 1 (maximum valid value).');
		// Case #3: Number(3), Boolean. Testing with large number_s and trials values.
		oParser = new parserFormula('BINOM.DIST(100000,1000000,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(100000,1000000,0.5,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3), Boolean. Testing with large number_s and trials values.');
		// Case #4: Number(3), Boolean. Testing with very small probability_s (close to 0).
		oParser = new parserFormula('BINOM.DIST(0,1000,1E-307,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(0,1000,1E-307,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3), Boolean. Testing with very small probability_s (close to 0).');
		// Case #5: Number(3), Boolean. Testing with very large probability_s (close to 1).
		oParser = new parserFormula('BINOM.DIST(1000,1000,9E-307,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST(1000,1000,9E-307,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3), Boolean. Testing with very large probability_s (close to 1).');

		// Need to fix: results diff from MS
		// Case #29: Number(3), Boolean. Testing with very small probability_s.
		// Case #39: Number(3), Boolean. Testing with large trials and small probability_s.
		// Case #34: Number(3), String. Cumulative as string "0" (equivalent to FALSE).
		// Case #35: String(4). All arguments as strings, including cumulative as "1".
		// Case #3: Number(3), Boolean. Testing with large number_s and trials values.
		// Case #4: Number(3), Boolean. Testing with very small probability_s (close to 0).
		// Case #5: Number(3), Boolean. Testing with very large probability_s (close to 1).

	});

	QUnit.test("Test: \"BINOM.DIST.RANGE\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("60");
		ws.getRange2("A101").setValue("0.75");
		ws.getRange2("A102").setValue("45");
		ws.getRange2("A103").setValue("50");
		ws.getRange2("A104").setValue("48");
		ws.getRange2("A105").setValue("5");
		ws.getRange2("A106").setValue("test");
		ws.getRange2("A107").setValue("#NULL!");
		ws.getRange2("A108").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("60"); // Column1
		ws.getRange2("B601").setValue("0.75"); // Column2
		ws.getRange2("C601").setValue("45"); // Column3
		ws.getRange2("D601").setValue("50"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("60");
		ws2.getRange2("A2").setValue("0.75");
		ws2.getRange2("A3").setValue("45");
		ws2.getRange2("A4").setValue("50");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("60"); // TestName
		ws.getRange2("A202").setValue("0.75"); // TestName1
		ws.getRange2("A203").setValue("45"); // TestName2
		ws.getRange2("A204").setValue("50"); // TestName3
		ws.getRange2("A205").setValue("text"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("60") // TestName3D
		ws2.getRange2("A12").setValue("0.75") // TestName3D1
		ws2.getRange2("A13").setValue("45") // TestName3D2
		ws2.getRange2("A14").setValue("50") // TestName3D3

		// Positive cases:

		// Case #1: Number(3). Example from documentation. 3 of 4 arguments used.
		oParser = new parserFormula('BINOM.DIST.RANGE(60,0.75,48)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(60,0.75,48) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.084, 'Test: Positive case: Number(3). Example from documentation. 3 of 4 arguments used.');
		// Case #2: Number(4). Example from documentation. 4 of 4 arguments used.
		oParser = new parserFormula('BINOM.DIST.RANGE(60,0.75,45,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(60,0.75,45,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.524, 'Test: Positive case: Number(4). Example from documentation. 4 of 4 arguments used.');
		// Case #1: Number(3). All arguments are numbers. Optional number_s2 is omitted.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.1171875, 'Test: Positive case: Number(3). All arguments are numbers. Optional number_s2 is omitted.');
		// Case #2: Number(4). All arguments are numbers. Using optional number_s2.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,3,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,3,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.568359375, 'Test: Positive case: Number(4). All arguments are numbers. Using optional number_s2.');
		// Case #3: Number(2), String(2). number_s and number_s2 are numeric strings.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,"3","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,"3","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.568359375, 'Test: Positive case: Number(2), String(2). number_s and number_s2 are numeric strings.');
		// Case #4: Number, String, Number(2). probability_s is a numeric string.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,"0.5",3,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,"0.5",3,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.568359375, 'Test: Positive case: Number, String, Number(2). probability_s is a numeric string.');
		// Case #5: Formula(4). All arguments are formulas.
		oParser = new parserFormula('BINOM.DIST.RANGE(SUM(5,5),1/2,MIN(3,4),MAX(5,6))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(SUM(5,5),1/2,MIN(3,4),MAX(5,6)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.7734375, 'Test: Positive case: Formula(4). All arguments are formulas.');
		// Case #6: Reference link(4). All arguments are reference links.
		oParser = new parserFormula('BINOM.DIST.RANGE(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523629793, 'Test: Positive case: Reference link(4). All arguments are reference links.');
		// Case #7: Area(4). All arguments are single-cell Areas.
		oParser = new parserFormula('BINOM.DIST.RANGE(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523629793, 'Test: Positive case: Area(4). All arguments are single-cell Areas.');
		// Case #8: Number(2), Area(2). number_s and number_s2 are multi-cell Areas.
		oParser = new parserFormula('BINOM.DIST.RANGE(100,0.25,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(100,0.25,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10) - 0, 0.0000109001, 'Test: Positive case: Number(2), Area(2). number_s and number_s2 are multi-cell Areas.');
		// Case #9: Name(4). All arguments are Names.
		oParser = new parserFormula('BINOM.DIST.RANGE(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523629793, 'Test: Positive case: Name(4). All arguments are Names.');
		// Case #10: Ref3D(4). All arguments are Ref3D.
		oParser = new parserFormula('BINOM.DIST.RANGE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523629793, 'Test: Positive case: Ref3D(4). All arguments are Ref3D.');
		// Case #11: Area3D(4). All arguments are Area3D.
		oParser = new parserFormula('BINOM.DIST.RANGE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523629793, 'Test: Positive case: Area3D(4). All arguments are Area3D.');
		// Case #12: Name3D(4). All arguments are Name3D.
		oParser = new parserFormula('BINOM.DIST.RANGE(TestName3D,TestName3D1,TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523629793, 'Test: Positive case: Name3D(4). All arguments are Name3D.');
		// Case #13: Number(3). probability_s is 1.
		oParser = new parserFormula('BINOM.DIST.RANGE(100,1,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(100,1,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3). probability_s is 1.');
		// Case #14: Number(3). probability_s is 0.
		oParser = new parserFormula('BINOM.DIST.RANGE(100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3). probability_s is 0.');
		// Case #15: Number(4). number_s and number_s2 are equal.
		oParser = new parserFormula('BINOM.DIST.RANGE(50,0.5,25,25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(50,0.5,25,25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.112275173, 'Test: Positive case: Number(4). number_s and number_s2 are equal.');
		// Case #16: Formula, Number(3). trials argument is a formula that truncates a float.
		oParser = new parserFormula('BINOM.DIST.RANGE(INT(10.9),0.5,2,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(INT(10.9),0.5,2,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.978515625, 'Test: Positive case: Formula, Number(3). trials argument is a formula that truncates a float.');
		// Case #17: Number, Formula, Number(2). probability_s is a formula.
		oParser = new parserFormula('BINOM.DIST.RANGE(20,SUM(0.1,0.2),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(20,SUM(0.1,0.2),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.745347405, 'Test: Positive case: Number, Formula, Number(2). probability_s is a formula.');
		// Case #18: Formula. Formula is a part of another formula.
		oParser = new parserFormula('IF(BINOM.DIST.RANGE(10,0.5,5)>0.2,"High","Low")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(BINOM.DIST.RANGE(10,0.5,5)>0.2,"High","Low") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'High', 'Test: Positive case: Formula. Formula is a part of another formula.');
		// Case #19: Number, Boolean(3). Arguments are booleans (TRUE=1, FALSE=0).
		oParser = new parserFormula('BINOM.DIST.RANGE(2,TRUE,FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(2,TRUE,FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Boolean(3). Arguments are booleans (TRUE=1, FALSE=0).');
		// Case #20: Number(2), Empty, Number. number_s is empty, treated as 0.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.623046875, 'Test: Positive case: Number(2), Empty, Number. number_s is empty, treated as 0.');
		// Case #21: Number(2), Reference link. number_s2 is omitted.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.24609375, 'Test: Positive case: Number(2), Reference link. number_s2 is omitted.');
		// Case #22: Table(4). Arguments from Table reference.
		oParser = new parserFormula('BINOM.DIST.RANGE(Table1[Column1],Table1[Column2], Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(Table1[Column1],Table1[Column2], Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523629793, 'Test: Positive case: Table(4). Arguments from Table reference.');
		// Case #23: Formula, Number(3). trials is a date.
		oParser = new parserFormula('BINOM.DIST.RANGE(DATE(2025,1,1),0.5,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(DATE(2025,1,1),0.5,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula, Number(3). trials is a date.');
		// Case #24: Reference link(4). Reference to an empty cell for all arguments.
		oParser = new parserFormula('BINOM.DIST.RANGE(A108,A108,A108,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(A108,A108,A108,A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link(4). Reference to an empty cell for all arguments.');
		// Case #25: Number(2), Array. number_s is an array.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.009765625, 'Test: Positive case: Number(2), Array. number_s is an array.');
		// Case #26: Empty(4). All arguments are empty.
		oParser = new parserFormula('BINOM.DIST.RANGE(,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(,,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty(4). All arguments are empty.');
		// Case #27: Array(4). All arguments numbers in arrays
		oParser = new parserFormula('BINOM.DIST.RANGE({60},{0.75},{45},{50})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE({60},{0.75},{45},{50}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.523629793, 'Test: Positive case: Array(4). All arguments numbers in arrays');
		// Case #28: Number(4). Numeric arguments are truncated to integers.
		oParser = new parserFormula('BINOM.DIST.RANGE(10.9, 0.5, 2.1, 8.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10.9, 0.5, 2.1, 8.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.978515625, 'Test: Positive case: Number(4). Numeric arguments are truncated to integers.');

		// Negative cases:

		// Case #1: String, Number(3). trials is a non-numeric string.
		oParser = new parserFormula('BINOM.DIST.RANGE("text",0.5,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE("text",0.5,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(3). trials is a non-numeric string.');
		// Case #2: Number, String, Number(2). probability_s is a non-numeric string.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,"text",1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,"text",1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(2). probability_s is a non-numeric string.');
		// Case #3: Error, Number(3). trials is an error.
		oParser = new parserFormula('BINOM.DIST.RANGE(#N/A,0.5,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(#N/A,0.5,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(3). trials is an error.');
		// Case #4: Number, Error, Number(2). probability_s is an error.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,#VALUE!,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,#VALUE!,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Error, Number(2). probability_s is an error.');
		// Case #5: Number(2), Error, Number. number_s is an error.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,#REF!,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,#REF!,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Number(2), Error, Number. number_s is an error.');
		// Case #6: Number(3), Error. number_s2 is an error.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,1,#DIV/0!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,1,#DIV/0!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(3), Error. number_s2 is an error.');
		// Case #7: Number(4). trials < 0.
		oParser = new parserFormula('BINOM.DIST.RANGE(-10,0.5,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(-10,0.5,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). trials < 0.');
		// Case #8: Number(4). probability_s < 0.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,-0.5,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,-0.5,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). probability_s < 0.');
		// Case #9: Number(4). probability_s > 1.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,1.1,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,1.1,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). probability_s > 1.');
		// Case #10: Number(4). number_s < 0.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,-1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,-1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). number_s < 0.');
		// Case #11: Number(4). number_s > trials.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,11,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,11,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). number_s > trials.');
		// Case #12: Number(4). number_s2 < number_s.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,5,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,5,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). number_s2 < number_s.');
		// Case #13: Number(4). number_s2 > trials.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,0.5,1,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,0.5,1,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). number_s2 > trials.');
		// Case #14: Number, Formula, Number(2). probability_s is a date, which converts to a number > 1.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,DATE(2025,1,1),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,DATE(2025,1,1),1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula, Number(2). probability_s is a date, which converts to a number > 1.');
		// Case #15: Reference link, Number(3). Reference to a cell with text.
		oParser = new parserFormula('BINOM.DIST.RANGE(A106,0.5,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(A106,0.5,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number(3). Reference to a cell with text.');
		// Case #16: Number, Reference link, Number(2). Reference to a cell with an error.
		oParser = new parserFormula('BINOM.DIST.RANGE(10,A107,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(10,A107,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number, Reference link, Number(2). Reference to a cell with an error.');
		// Case #17: Area, Number(3). trials is a multi-cell range.
		oParser = new parserFormula('BINOM.DIST.RANGE(A106:A107,0.5,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(A106:A107,0.5,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(3). trials is a multi-cell range.');
		// Case #18: Name, Number(3). Name refers to a non-numeric string.
		oParser = new parserFormula('BINOM.DIST.RANGE(TestName4,0.5,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(TestName4,0.5,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number(3). Name refers to a non-numeric string.');

		// Bounded cases:

		// Case #1: Number(3). trials is at minimum (0).
		oParser = new parserFormula('BINOM.DIST.RANGE(0,0.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(0,0.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(3). trials is at minimum (0).');
		// Case #2: Number(4). probability_s is at minimum (0).
		oParser = new parserFormula('BINOM.DIST.RANGE(100,0,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(100,0,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(4). probability_s is at minimum (0).');
		// Case #3: Number(4). probability_s is at maximum (1).
		oParser = new parserFormula('BINOM.DIST.RANGE(100,1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(100,1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(4). probability_s is at maximum (1).');
		// Case #4: Number(4). number_s is at minimum (0).
		oParser = new parserFormula('BINOM.DIST.RANGE(100,0.5,0,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(100,0.5,0,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5316450877189938e-17, 'Test: Bounded case: Number(4). number_s is at minimum (0).');
		// Case #5: Number(4). number_s is at maximum (equal to trials).
		oParser = new parserFormula('BINOM.DIST.RANGE(1000000000,0.5,1000000000,1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BINOM.DIST.RANGE(1000000000,0.5,1000000000,1000000000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(4). number_s is at maximum (equal to trials).');

		// Need to fix: diff results from MS
		// Case #23: Formula, Number(3). trials is a date.
		// Case #5: Number(4). number_s is at maximum (equal to trials).


		testArrayFormula2(assert, "BINOM.DIST.RANGE", 3, 4);
	});

	QUnit.test("Test: \"CHIDIST\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A2").setValue("18.307");
		ws.getRange2("A3").setValue("10");
		ws.getRange2("A100").setValue("10");
		ws.getRange2("A101").setValue("5");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("text");
		ws.getRange2("A104").setValue("-1");
		ws.getRange2("A105").setValue("10.5");
		ws.getRange2("A106").setValue("5.5");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("18.307"); // Column1
		ws.getRange2("B601").setValue("10"); // Column2
		ws.getRange2("C601").setValue("0"); // Column3
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("7.5");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("0");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("15"); // TestName
		ws.getRange2("A202").setValue("8"); // TestName1
		ws.getRange2("A206").setValue("18.307"); // TestNameArea
		ws.getRange2("A207").setValue("10"); // TestNameArea
		ws.getRange2("A208").setValue("10"); // TestNameArea2
		ws.getRange2("B208").setValue("5"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("18.307") // TestName3D
		ws2.getRange2("A12").setValue("10") // TestName3D1
		ws2.getRange2("A13").setValue("-1") // TestName3D2
		ws2.getRange2("A14").setValue("-2") // TestName3D3

		// Positive cases:

		// Case #1: Reference link(2). One-tailed probability of the chi-squared distribution. A2 - 18.307, A3 - 10
		oParser = new parserFormula('CHIDIST(A2,A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(A2,A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Reference link(2). One-tailed probability of the chi-squared distribution. A2 - 18.307, A3 - 10');
		// Case #2: Number(2). Both arguments are positive integers.
		oParser = new parserFormula('CHIDIST(10,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.075235246, 'Test: Positive case: Number(2). Both arguments are positive integers.');
		// Case #3: Number(2). \'deg_freedom\' argument is a non-integer number, which will be truncated to an integer (7) according to documentation.
		oParser = new parserFormula('CHIDIST(12.5,7.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(12.5,7.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.085269275, 'Test: Positive case: Number(2). \'deg_freedom\' argument is a non-integer number, which will be truncated to an integer (7) according to documentation.');
		// Case #4: Number(2). Minimum valid positive integer arguments.
		oParser = new parserFormula('CHIDIST(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.317310508, 'Test: Positive case: Number(2). Minimum valid positive integer arguments.');
		// Case #5: String(2). Both arguments are numeric strings, which are automatically converted to numbers.
		oParser = new parserFormula('CHIDIST("15","8")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST("15","8") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.05914546, 'Test: Positive case: String(2). Both arguments are numeric strings, which are automatically converted to numbers.');
		// Case #6: String, Number. First argument is a numeric string, second is a number.
		oParser = new parserFormula('CHIDIST("7.5",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST("7.5",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.023517746, 'Test: Positive case: String, Number. First argument is a numeric string, second is a number.');
		// Case #7: Number, Boolean. Boolean value TRUE is converted to number 1.
		oParser = new parserFormula('CHIDIST(10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.001565402, 'Test: Positive case: Number, Boolean. Boolean value TRUE is converted to number 1.');
		// Case #8: Boolean, Number. Boolean value TRUE is converted to number 1.
		oParser = new parserFormula('CHIDIST(TRUE,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(TRUE,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.962565773, 'Test: Positive case: Boolean, Number. Boolean value TRUE is converted to number 1.');
		// Case #9: Number, Formula. \'deg_freedom\' is a nested formula returning an integer.
		oParser = new parserFormula('CHIDIST(20,ROUND(7.8,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(20,ROUND(7.8,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.010336051, 'Test: Positive case: Number, Formula. \'deg_freedom\' is a nested formula returning an integer.');
		// Case #10: Formula, Formula. Both arguments are nested formulas returning numbers.
		oParser = new parserFormula('CHIDIST(ABS(-12),INT(9.99))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(ABS(-12),INT(9.99)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.213309305, 'Test: Positive case: Formula, Formula. Both arguments are nested formulas returning numbers.');
		// Case #11: Reference link(2). Both arguments are reference links to cells containing positive numbers.
		oParser = new parserFormula('CHIDIST(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.075235246, 'Test: Positive case: Reference link(2). Both arguments are reference links to cells containing positive numbers.');
		// Case #12: Area(2). Both arguments are single-cell areas containing positive numbers.
		oParser = new parserFormula('CHIDIST(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.075235246, 'Test: Positive case: Area(2). Both arguments are single-cell areas containing positive numbers.');
		// Case #13: Name(2). Both arguments are named ranges containing positive numbers.
		oParser = new parserFormula('CHIDIST(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.05914546, 'Test: Positive case: Name(2). Both arguments are named ranges containing positive numbers.');
		// Case #14: Area(2). Both arguments are multi-cell named ranges, but only the first value is used.
		oParser = new parserFormula('CHIDIST(TestNameArea,TestNameArea2)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(TestNameArea,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.05000058909139812, 'Test: Positive case: Area(2). Both arguments are multi-cell named ranges, but only the first value is used.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0.075235, 'Test: Positive case: Area(2). Both arguments are multi-cell named ranges, but only the first value is used.');
		// Case #15: Table(2). Both arguments are table references with numerical data.
		oParser = new parserFormula('CHIDIST(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Table(2). Both arguments are table references with numerical data.');
		// Case #16: Array(2). Both arguments are single-element arrays with positive numbers.
		oParser = new parserFormula('CHIDIST({10},{5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST({10},{5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.075235246, 'Test: Positive case: Array(2). Both arguments are single-element arrays with positive numbers.');
		// Case #17: Array(2). Both arguments are multi-element arrays. The function spills the results.
		oParser = new parserFormula('CHIDIST({12,15},{6,8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST({12,15},{6,8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.061968804, 'Test: Positive case: Array(2). Both arguments are multi-element arrays. The function spills the results.');
		// Case #18: Ref3D(2). Both arguments are 3D references to cells on a different sheet containing positive numbers.
		oParser = new parserFormula('CHIDIST(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.023517746, 'Test: Positive case: Ref3D(2). Both arguments are 3D references to cells on a different sheet containing positive numbers.');
		// Case #19: Name3D(2). Both arguments are 3D named ranges with positive numbers.
		oParser = new parserFormula('CHIDIST(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Name3D(2). Both arguments are 3D named ranges with positive numbers.');
		// Case #20: Area3D(2). Both arguments are 3D single-cell areas with positive numbers.
		oParser = new parserFormula('CHIDIST(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.023517746, 'Test: Positive case: Area3D(2). Both arguments are 3D single-cell areas with positive numbers.');
		// Case #21: Formula, Number. CHIDIST formula is nested within another function. 2 of 2 arguments used for CHIDIST.
		oParser = new parserFormula('SUM(LEN(CHIDIST(5,1)),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(LEN(CHIDIST(5,1)),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 19, 'Test: Positive case: Formula, Number. CHIDIST formula is nested within another function. 2 of 2 arguments used for CHIDIST.');
		// Case #22: Number, Formula. \'deg_freedom\' is a formula returning a valid integer.
		oParser = new parserFormula('CHIDIST(20,MATCH(5,{1,2,5,8},0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(20,MATCH(5,{1,2,5,8},0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000169742, 'Test: Positive case: Number, Formula. \'deg_freedom\' is a formula returning a valid integer.');
		// Case #23: Number(2). \'x\' argument is a very large number in scientific notation.
		oParser = new parserFormula('CHIDIST(1E+10, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(1E+10, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). \'x\' argument is a very large number in scientific notation.');
		// Case #24: Number, Date. \'deg_freedom\' argument is a date which Excel stores as a number.
		oParser = new parserFormula('CHIDIST(10,DATE(2023,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,DATE(2023,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Date. \'deg_freedom\' argument is a date which Excel stores as a number.');
		// Case #25: Reference link(2). Both arguments are reference links to cells containing decimal numbers.
		oParser = new parserFormula('CHIDIST(A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.062245928, 'Test: Positive case: Reference link(2). Both arguments are reference links to cells containing decimal numbers.');
		// Case #26: Number, Area. \'deg_freedom\' is a multi-cell area. Only the first value is used.
		oParser = new parserFormula('CHIDIST(10,A101:A102)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,A101:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.0752352461465122, 'Test: Positive case: Number, Area. \'deg_freedom\' is a multi-cell area. Only the first value is used.');
		// Case #27: Empty, Number. First required argument \'x\' is missing.
		oParser = new parserFormula('CHIDIST(,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty, Number. First required argument \'x\' is missing.');

		// Negative cases:

		// Case #1: Number, Empty. Second required argument \'deg_freedom\' is missing. Returns #VALUE! error.
		oParser = new parserFormula('CHIDIST(10,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty. Second required argument \'deg_freedom\' is missing. Returns #VALUE! error.');
		// Case #2: Error, Number. x is argument is an error value. Returns #NA! error.
		oParser = new parserFormula('CHIDIST(NA(),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(NA(),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. x is argument is an error value. Returns #NA! error.');
		// Case #3: Empty(2). Both required arguments are missing. Returns #VALUE! error.
		oParser = new parserFormula('CHIDIST(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty(2). Both required arguments are missing. Returns #VALUE! error.');
		// Case #4: Number, String. \'deg_freedom\' is a non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CHIDIST(10,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. \'deg_freedom\' is a non-numeric string. Returns #VALUE! error.');
		// Case #5: String, Number. \'x\' is a non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CHIDIST("xyz",5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST("xyz",5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. \'x\' is a non-numeric string. Returns #VALUE! error.');
		// Case #6: Number, Error. deg_freedom\' argument is an error value. Returns #NA! error.
		oParser = new parserFormula('CHIDIST(10,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. deg_freedom\' argument is an error value. Returns #NA! error.');
		// Case #7: Error, Number. \'x\' argument is an error value. Returns #VALUE! error.
		oParser = new parserFormula('CHIDIST(#VALUE!,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(#VALUE!,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Number. \'x\' argument is an error value. Returns #VALUE! error.');
		// Case #8: Number(2). \'deg_freedom\' is a negative number, which is less than 1. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(5,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(5,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). \'deg_freedom\' is a negative number, which is less than 1. Returns #NUM! error.');
		// Case #9: Number(2). \'deg_freedom\' is 0, which is less than 1. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). \'deg_freedom\' is 0, which is less than 1. Returns #NUM! error.');
		// Case #10: Number(2). \'x\' is a negative number. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(-5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(-5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). \'x\' is a negative number. Returns #NUM! error.');
		// Case #11: Number(2). \'deg_freedom\' exceeds the maximum allowed value of 10^10. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(10,10^10+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,10^10+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). \'deg_freedom\' exceeds the maximum allowed value of 10^10. Returns #NUM! error.');
		// Case #12: Number, Formula. \'deg_freedom\' is a formula that returns a number that rounds down to 0, which is less than 1. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(10,ROUNDDOWN(0.99,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,ROUNDDOWN(0.99,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. \'deg_freedom\' is a formula that returns a number that rounds down to 0, which is less than 1. Returns #NUM! error.');
		// Case #13: Number, Reference link. \'deg_freedom\' is a reference link to a cell containing non-numeric text. Returns #VALUE! error.
		oParser = new parserFormula('CHIDIST(10,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. \'deg_freedom\' is a reference link to a cell containing non-numeric text. Returns #VALUE! error.');
		// Case #14: Reference link, Number. \'x\' is a reference link to a cell containing a negative number. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(A104,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(A104,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Number. \'x\' is a reference link to a cell containing a negative number. Returns #NUM! error.');
		// Case #15: Number, Area. \'deg_freedom\' is an area with non-numeric and negative values. Only the first cell is used, returning #VALUE! error.
		oParser = new parserFormula('CHIDIST(10,A103:A104)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: Number, Area. \'deg_freedom\' is an area with non-numeric and negative values. Only the first cell is used, returning #VALUE! error.');
		// Case #16: Number, Table. \'deg_freedom\' is a table column with values outside the valid range. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(10,Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Table. \'deg_freedom\' is a table column with values outside the valid range. Returns #NUM! error.');
		// Case #17: Array(2). \'x\' is a negative value inside an array. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST({-5},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST({-5},{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array(2). \'x\' is a negative value inside an array. Returns #NUM! error.');
		// Case #18: Array(2). \'deg_freedom\' is a zero value inside an array. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST({10},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST({10},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array(2). \'deg_freedom\' is a zero value inside an array. Returns #NUM! error.');
		// Case #19: Ref3D(2). \'deg_freedom\' is a 3D reference with a zero value. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D(2). \'deg_freedom\' is a 3D reference with a zero value. Returns #NUM! error.');
		// Case #20: Area3D(2). \'deg_freedom\' is a 3D area with a negative value. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D(2). \'deg_freedom\' is a 3D area with a negative value. Returns #NUM! error.');
		// Case #21: Name3D(2). \'x\' is a 3D named range with a negative value. Returns #NUM! error.
		oParser = new parserFormula('CHIDIST(TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D(2). \'x\' is a 3D named range with a negative value. Returns #NUM! error.');
		// Case #22: Number(2), Formula. CHIDIST function nested in a parent function. CHIDIST returns a #NUM! error because \'x\' is negative, and the parent function propagates the error. 2 of 2 arguments used for CHIDIST.
		oParser = new parserFormula('SUM(LEN(CHIDIST(-5,10)),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(LEN(CHIDIST(-5,10)),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Formula. CHIDIST function nested in a parent function. CHIDIST returns a #NUM! error because \'x\' is negative, and the parent function propagates the error. 2 of 2 arguments used for CHIDIST.');

		// Bounded cases:

		// Case #1: Number(2). Minimum valid \'x\' and \'deg_freedom\' arguments. Both at their respective boundaries.
		oParser = new parserFormula('CHIDIST(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Minimum valid \'x\' and \'deg_freedom\' arguments. Both at their respective boundaries.');
		// Case #2: Number(2). Maximum floating-point value for \'x\' and maximum integer value for \'deg_freedom\'.
		oParser = new parserFormula('CHIDIST(1E+307, 10^10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(1E+307, 10^10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Maximum floating-point value for \'x\' and maximum integer value for \'deg_freedom\'.');
		// Case #3: Number(2). \'deg_freedom\' is a number slightly above 1, which will be truncated to 1.
		oParser = new parserFormula('CHIDIST(10,1.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,1.000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0015654022580025477, 'Test: Bounded case: Number(2). \'deg_freedom\' is a number slightly above 1, which will be truncated to 1.');
		// Case #4: Number(2). \'deg_freedom\' is a large number slightly below 10^10, which will be truncated to the maximum valid value.
		oParser = new parserFormula('CHIDIST(10,9999999999.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10,9999999999.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). \'deg_freedom\' is a large number slightly below 10^10, which will be truncated to the maximum valid value.');
		// Case #5: Formula(2). Both arguments are formulas returning minimum valid integers.
		oParser = new parserFormula('CHIDIST(ROUND(0.001,0),ROUNDUP(0.5,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(ROUND(0.001,0),ROUNDUP(0.5,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula(2). Both arguments are formulas returning minimum valid integers.');
		// Case #6: Number(2). Minimum \'x\' and maximum \'deg_freedom\'.
		oParser = new parserFormula('CHIDIST(0,10^10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(0,10^10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Minimum \'x\' and maximum \'deg_freedom\'.');
		// Case #7: Number(2). Large \'x\' and minimum \'deg_freedom\'.
		oParser = new parserFormula('CHIDIST(10^10,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIDIST(10^10,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Large \'x\' and minimum \'deg_freedom\'.');


		testArrayFormula2(assert, "CHIDIST", 2, 2);
	});

	QUnit.test("Test: \"CHIINV\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A2").setValue("0.050001");
		ws.getRange2("A3").setValue("10");
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("0.1");
		ws.getRange2("A103").setValue("0.01");
		ws.getRange2("A104").setValue("2");
		ws.getRange2("A105").setValue("5");
		ws.getRange2("A106").setValue("-0.1");
		ws.getRange2("A107").setValue("0");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("0.050001"); // Column1
		ws.getRange2("B601").setValue("10"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1");
		ws2.getRange2("A3").setValue("-0.1");
		ws2.getRange2("A4").setValue("0");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.01"); // TestName
		ws.getRange2("A202").setValue("5"); // TestName1
		ws.getRange2("A206").setValue("-0.1"); // TestNameArea
		ws.getRange2("A207").setValue("0"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.05001") // TestName3D
		ws2.getRange2("A12").setValue("10") // TestName3D1
		ws2.getRange2("A13").setValue("-0.1") // TestName3D2
		ws2.getRange2("A14").setValue("0") // TestName3D3

		// Positive cases:

		// Case #1: Reference link(2). Inverse of the one-tailed probability of the chi-squared distribution. A2 - 0.050001, A3 - 10
		oParser = new parserFormula('CHIINV(A2,A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(A2,A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 18.306973, 'Test: Positive case: Reference link(2). Inverse of the one-tailed probability of the chi-squared distribution. A2 - 0.050001, A3 - 10');
		// Case #2: Number(2). Basic valid input: probability 0.5, deg_freedom 1.
		oParser = new parserFormula('CHIINV(0.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Positive case: Number(2). Basic valid input: probability 0.5, deg_freedom 1.');
		// Case #3: Number(2). Valid inputs: probability 0.1, deg_freedom 2.
		oParser = new parserFormula('CHIINV(0.1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.605170186, 'Test: Positive case: Number(2). Valid inputs: probability 0.1, deg_freedom 2.');
		// Case #4: Number(2). Valid inputs: low probability, higher deg_freedom.
		oParser = new parserFormula('CHIINV(0.01, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.01, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 15.08627247, 'Test: Positive case: Number(2). Valid inputs: low probability, higher deg_freedom.');
		// Case #5: String(2). String inputs convertible to numbers.
		oParser = new parserFormula('CHIINV("0.5", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV("0.5", "1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Positive case: String(2). String inputs convertible to numbers.');
		// Case #6: Formula(2). Nested formulas for both arguments.
		oParser = new parserFormula('CHIINV(1-0.5, SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(1-0.5, SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.386294361, 'Test: Positive case: Formula(2). Nested formulas for both arguments.');
		// Case #7: Reference link(2). References to cells with valid values.
		oParser = new parserFormula('CHIINV(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.605170186, 'Test: Positive case: Reference link(2). References to cells with valid values.');
		// Case #8: Area(2). Single-cell ranges with valid values.
		oParser = new parserFormula('CHIINV(A100:A100, A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(A100:A100, A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.605170186, 'Test: Positive case: Area(2). Single-cell ranges with valid values.');
		// Case #9: Array(2). Arrays with single elements.
		oParser = new parserFormula('CHIINV({0.5}, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV({0.5}, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Positive case: Array(2). Arrays with single elements.');
		// Case #10: Name(2). Named ranges with valid values.
		oParser = new parserFormula('CHIINV(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 15.08627247, 'Test: Positive case: Name(2). Named ranges with valid values.');
		// Case #11: Name3D(2). 3D named ranges with valid values.
		oParser = new parserFormula('CHIINV(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 18.30639214, 'Test: Positive case: Name3D(2). 3D named ranges with valid values.');
		// Case #12: Ref3D(2). 3D references to cells with valid values.
		oParser = new parserFormula('CHIINV(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Positive case: Ref3D(2). 3D references to cells with valid values.');
		// Case #13: Area3D(2). 3D single-cell ranges with valid values.
		oParser = new parserFormula('CHIINV(Sheet2!A1:A1, Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(Sheet2!A1:A1, Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Positive case: Area3D(2). 3D single-cell ranges with valid values.');
		// Case #14: Table(2). Table references with valid values.
		oParser = new parserFormula('CHIINV(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 18.30697346, 'Test: Positive case: Table(2). Table references with valid values.');
		// Case #15: Formula. CHIINV inside another formula.
		oParser = new parserFormula('SUM(CHIINV(0.5, 1), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CHIINV(0.5, 1), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.454936423, 'Test: Positive case: Formula. CHIINV inside another formula.');
		// Case #16: Formula(2). Nested IF formulas for both arguments.
		oParser = new parserFormula('CHIINV(IF(TRUE, 0.5, 0.1), IF(TRUE, 2, 1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(IF(TRUE, 0.5, 0.1), IF(TRUE, 2, 1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.386294361, 'Test: Positive case: Formula(2). Nested IF formulas for both arguments.');
		// Case #17: Number, Formula. Number and formula returning integer.
		oParser = new parserFormula('CHIINV(0.25, ROUND(2.4, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.25, ROUND(2.4, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.772588722, 'Test: Positive case: Number, Formula. Number and formula returning integer.');
		// Case #18: Formula, Number. Formula returning probability and integer deg_freedom.
		oParser = new parserFormula('CHIINV(ABS(-0.75), 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(ABS(-0.75), 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.212532903, 'Test: Positive case: Formula, Number. Formula returning probability and integer deg_freedom.');
		// Case #19: Number(2). Higher degrees of freedom (10).
		oParser = new parserFormula('CHIINV(0.5, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 9.341817766, 'Test: Positive case: Number(2). Higher degrees of freedom (10).');
		// Case #20: Number(2). Very high degrees of freedom (100).
		oParser = new parserFormula('CHIINV(0.5, 100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 99.33412924, 'Test: Positive case: Number(2). Very high degrees of freedom (100).');
		// Case #21: Number(2). Probability with many decimal places.
		oParser = new parserFormula('CHIINV(0.123456789, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.123456789, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 8.659144328, 'Test: Positive case: Number(2). Probability with many decimal places.');
		// Case #22: Number(2). Degrees of freedom as float (truncated to 2).
		oParser = new parserFormula('CHIINV(0.5, 2.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 2.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.386294361, 'Test: Positive case: Number(2). Degrees of freedom as float (truncated to 2).');
		// Case #23: String(2). Percentage string for probability, string for deg_freedom.
		oParser = new parserFormula('CHIINV("50%", "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV("50%", "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.365973884, 'Test: Positive case: String(2). Percentage string for probability, string for deg_freedom.');
		// Case #24: Formula, Number. Date formula returning 1 (converts to probability 1).
		oParser = new parserFormula('CHIINV(DATE(2023,1,1)-DATE(2022,12,31), 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(DATE(2023,1,1)-DATE(2022,12,31), 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula, Number. Date formula returning 1 (converts to probability 1).');
		// Case #25: Formula, Number. Time formula value (0.5) as probability.
		oParser = new parserFormula('CHIINV(TIME(12,0,0), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(TIME(12,0,0), 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.351460191, 'Test: Positive case: Formula, Number. Time formula value (0.5) as probability.');
		// Case #26: Boolean, Number. Boolean TRUE (1) as probability, integer deg_freedom.
		oParser = new parserFormula('CHIINV(TRUE, 6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(TRUE, 6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean, Number. Boolean TRUE (1) as probability, integer deg_freedom.');
		// Case #27: Number(2). Degrees of freedom as non-integer (truncated to 1).
		oParser = new parserFormula('CHIINV(0.5, 1.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 1.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Positive case: Number(2). Degrees of freedom as non-integer (truncated to 1).');
		// Case #28: Number, String. Number probability, string deg_freedom converted to number and truncated.
		oParser = new parserFormula('CHIINV(0.5, "7.8")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, "7.8") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 6.345811196, 'Test: Positive case: Number, String. Number probability, string deg_freedom converted to number and truncated.');
		// Case #29: Formula, String. Formula returning probability, string deg_freedom converted to number.
		oParser = new parserFormula('CHIINV(ROUND(0.123, 2), "15")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(ROUND(0.123, 2), "15") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 21.5554958, 'Test: Positive case: Formula, String. Formula returning probability, string deg_freedom converted to number.');
		// Case #30: Number(2). Degrees of freedom almost 2 but truncated to 1.
		oParser = new parserFormula('CHIINV(0.5, 1.9999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 1.9999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Positive case: Number(2). Degrees of freedom almost 2 but truncated to 1.');
		// Case #31: Number, Boolean. Boolean TRUE (1) as deg_freedom.
		oParser = new parserFormula('CHIINV(0.3, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.3, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.074194171, 'Test: Positive case: Number, Boolean. Boolean TRUE (1) as deg_freedom.');
		// Case #32: Number, Formula. Time formula returning 1 as deg_freedom.
		oParser = new parserFormula('CHIINV(0.3, TIME(12,0,0) + 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.3, TIME(12,0,0) + 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.074194171, 'Test: Positive case: Number, Formula. Time formula returning 1 as deg_freedom.');
		// Case #33: Array(2). Arrays with multiple valid elements.
		oParser = new parserFormula('CHIINV({0.3, 0.4}, {2, 3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV({0.3, 0.4}, {2, 3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.407945609, 'Test: Positive case: Array(2). Arrays with multiple valid elements.');
		// Case #34: Area(2). Multi-cell ranges with valid values.
		oParser = new parserFormula('CHIINV(A102:A103, A104:A105)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(A102:A103, A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(9) - 0, 4.605170186, 'Test: Positive case: Area(2). Multi-cell ranges with valid values.');

		// Negative cases:

		// Case #1: Number(2). Probability < 0 returns #NUM! error.
		oParser = new parserFormula('CHIINV(-0.1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(-0.1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Probability < 0 returns #NUM! error.');
		// Case #2: Number(2). Probability > 1 returns #NUM! error.
		oParser = new parserFormula('CHIINV(1.1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(1.1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Probability > 1 returns #NUM! error.');
		// Case #3: Number(2). Degrees of freedom = 0 returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Degrees of freedom = 0 returns #NUM! error.');
		// Case #4: Number(2). Negative degrees of freedom returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative degrees of freedom returns #NUM! error.');
		// Case #5: String(2). Non-numeric string for probability returns #VALUE! error.
		oParser = new parserFormula('CHIINV("abc", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV("abc", "1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric string for probability returns #VALUE! error.');
		// Case #6: String(2). Non-numeric string for deg_freedom returns #VALUE! error.
		oParser = new parserFormula('CHIINV("0.5", "xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV("0.5", "xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric string for deg_freedom returns #VALUE! error.');
		// Case #7: Error, Number. #N/A error as probability propagates the error.
		oParser = new parserFormula('CHIINV(NA(), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(NA(), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. #N/A error as probability propagates the error.');
		// Case #8: Number, Error. #N/A error as deg_freedom propagates the error.
		oParser = new parserFormula('CHIINV(0.5, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. #N/A error as deg_freedom propagates the error.');
		// Case #9: Empty, Number. Empty probability cell returns #VALUE! error.
		oParser = new parserFormula('CHIINV(, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty probability cell returns #VALUE! error.');
		// Case #10: Number, Empty. Empty deg_freedom cell returns #VALUE! error.
		oParser = new parserFormula('CHIINV(0.5, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty. Empty deg_freedom cell returns #VALUE! error.');
		// Case #11: Array, Number. Array with invalid probability element returns #NUM! error.
		oParser = new parserFormula('CHIINV({-0.1, 0.5}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV({-0.1, 0.5}, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Array with invalid probability element returns #NUM! error.');
		// Case #12: Number, Array. Array with invalid deg_freedom element returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, {0, 2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, {0, 2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Array. Array with invalid deg_freedom element returns #NUM! error.');
		// Case #13: Formula, Number. Formula returning #NUM! error propagates the error.
		oParser = new parserFormula('CHIINV(SQRT(-1), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(SQRT(-1), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula returning #NUM! error propagates the error.');
		// Case #14: Number, Formula. Formula returning #NUM! error propagates the error.
		oParser = new parserFormula('CHIINV(0.5, SQRT(-4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, SQRT(-4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Formula returning #NUM! error propagates the error.');
		// Case #15: String, Number. Empty string for probability returns #VALUE! error.
		oParser = new parserFormula('CHIINV("", 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV("", 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Empty string for probability returns #VALUE! error.');
		// Case #16: Number, String. Empty string for deg_freedom returns #VALUE! error.
		oParser = new parserFormula('CHIINV(0.5, "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Empty string for deg_freedom returns #VALUE! error.');
		// Case #17: Area, Number. Area with invalid probability element returns #NUM! error.
		oParser = new parserFormula('CHIINV(A106:A107, 1)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(A106:A107, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Area, Number. Area with invalid probability element returns #NUM! error.');
		// Case #18: Number, Area. Area with invalid deg_freedom element returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, A106:A107)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Number, Area. Area with invalid deg_freedom element returns #NUM! error.');
		// Case #19: Area3D, Number. 3D area with invalid values returns error.
		oParser = new parserFormula('CHIINV(Sheet2!A3:A4, 5)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(Sheet2!A3:A4, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D area with invalid values returns error.');
		// Case #20: Number, Area3D. 3D area with invalid values returns error.
		oParser = new parserFormula('CHIINV(0.5, Sheet2!A3:A4)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Number, Area3D. 3D area with invalid values returns error.');
		// Case #21: Name, Number. Named range with invalid values returns error.
		oParser = new parserFormula('CHIINV(TestNameArea, 6)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(TestNameArea, 6) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Name, Number. Named range with invalid values returns error.');
		// Case #22: Number, Name. Named range with invalid values returns error.
		oParser = new parserFormula('CHIINV(0.5, TestNameArea)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Number, Name. Named range with invalid values returns error.');
		// Case #23: Formula(2). Both formulas return #NUM! errors which propagate.
		oParser = new parserFormula('CHIINV(LOG(-1), FACT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(LOG(-1), FACT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). Both formulas return #NUM! errors which propagate.');
		// Case #24: Number, Formula. Formula returning 0 for deg_freedom returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, INT(0.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, INT(0.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Formula returning 0 for deg_freedom returns #NUM! error.');
		// Case #25: Number, String. String converted to number < 1 for deg_freedom returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, "0.9")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, "0.9") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, String. String converted to number < 1 for deg_freedom returns #NUM! error.');
		// Case #26: Number, Formula. Date formula returning 0 for deg_freedom returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, DATE(2023,1,1)-DATE(2023,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, DATE(2023,1,1)-DATE(2023,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Date formula returning 0 for deg_freedom returns #NUM! error.');
		// Case #27: String, Number. Negative percentage string for probability returns #NUM! error.
		oParser = new parserFormula('CHIINV("-50%", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV("-50%", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Negative percentage string for probability returns #NUM! error.');
		// Case #28: String, Number. Percentage string > 100% for probability returns #NUM! error.
		oParser = new parserFormula('CHIINV("150%", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV("150%", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Percentage string > 100% for probability returns #NUM! error.');
		// Case #29: Formula, Number. Time formula > 1 for probability returns #NUM! error.
		oParser = new parserFormula('CHIINV(TIME(12,0,0)+1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(TIME(12,0,0)+1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Time formula > 1 for probability returns #NUM! error.');
		// Case #30: Number, Formula. Time formula = 0 for deg_freedom returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Time formula = 0 for deg_freedom returns #NUM! error.');
		// Case #31: Reference link, Number. Reference link to cell with invalid probability (<0) returns #NUM! error.
		oParser = new parserFormula('CHIINV(A106, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(A106, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Number. Reference link to cell with invalid probability (<0) returns #NUM! error.');
		// Case #32: Number, Reference link. Reference link to cell with invalid deg_freedom (0) returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Reference link. Reference link to cell with invalid deg_freedom (0) returns #NUM! error.');
		// Case #33: Name3D, Number. 3D named range with invalid probability (<0) returns #NUM! error.
		oParser = new parserFormula('CHIINV(TestName3D2, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(TestName3D2, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D, Number. 3D named range with invalid probability (<0) returns #NUM! error.');
		// Case #34: Number, Name3D. 3D named range with invalid deg_freedom (<1) returns #NUM! error.
		oParser = new parserFormula('CHIINV(0.5, TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Name3D. 3D named range with invalid deg_freedom (<1) returns #NUM! error.');
		// Case #35: Boolean, Formula. Boolean FALSE (0) as probability, formula returning deg_freedom.
		oParser = new parserFormula('CHIINV(FALSE, SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(FALSE, SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Formula. Boolean FALSE (0) as probability, formula returning deg_freedom.');

		// Bounded cases:

		// Case #1: Number(2). Minimum valid probability (very close to 0).
		oParser = new parserFormula('CHIINV(0.0000000001, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.0000000001, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 41.821456364761296, 'Test: Bounded case: Number(2). Minimum valid probability (very close to 0).');
		// Case #2: Number(2). Maximum valid probability (very close to 1).
		oParser = new parserFormula('CHIINV(0.9999999999, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.9999999999, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707966176409497e-20, 'Test: Bounded case: Number(2). Maximum valid probability (very close to 1).');
		// Case #3: Number(2). Minimum valid degrees of freedom (1).
		oParser = new parserFormula('CHIINV(0.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4549364231195724, 'Test: Bounded case: Number(2). Minimum valid degrees of freedom (1).');
		// Case #4: Number(2). Very large valid degrees of freedom.
		oParser = new parserFormula('CHIINV(0.5, 1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 999999.333333458, 'Test: Bounded case: Number(2). Very large valid degrees of freedom.');
		// Case #5: Number(2). Degrees of freedom slightly above minimum (truncated to 1).
		oParser = new parserFormula('CHIINV(0.5, 1.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.5, 1.000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4549364231195724, 'Test: Bounded case: Number(2). Degrees of freedom slightly above minimum (truncated to 1).');
		// Case #6: Number(2). Combination of minimum probability and large deg_freedom.
		oParser = new parserFormula('CHIINV(0.0000000001, 1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.0000000001, 1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1009022.6223852477, 'Test: Bounded case: Number(2). Combination of minimum probability and large deg_freedom.');
		// Case #7: Number(2). Combination of maximum probability and large deg_freedom.
		oParser = new parserFormula('CHIINV(0.9999999999, 1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.9999999999, 1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 991029.9998514776, 'Test: Bounded case: Number(2). Combination of maximum probability and large deg_freedom.');
		// Case #8: Number(2). Combination of minimum probability and minimum deg_freedom.
		oParser = new parserFormula('CHIINV(0.0000000001, 1.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHIINV(0.0000000001, 1.000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 41.821456364761296, 'Test: Bounded case: Number(2). Combination of minimum probability and minimum deg_freedom.');

		// Need to fix: all formulas under "?" mark

		testArrayFormula2(assert, "CHIINV", 2, 2);
	});

	QUnit.test("Test: \"CHISQ.DIST\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A102").setValue("TRUE");
		ws.getRange2("A103").setValue("2");
		ws.getRange2("A104").setValue("3");
		ws.getRange2("A105").setValue("FALSE");
		ws.getRange2("A106").setValue("text");
		ws.getRange2("A107").setValue("#N/A");
		ws.getRange2("A108").setValue("-1");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("0.5"); // Column1
		ws.getRange2("B601").setValue("1"); // Column2
		ws.getRange2("C601").setValue("TRUE"); // Column3
		ws.getRange2("D601").setValue("text"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1");
		ws2.getRange2("A3").setValue("TRUE");
		ws2.getRange2("A4").setValue("text");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.5"); // TestName
		ws.getRange2("A202").setValue("1"); // TestName1
		ws.getRange2("A203").setValue("TRUE"); // TestName2
		ws.getRange2("A204").setValue("text"); // TestName3
		ws.getRange2("A206").setValue("test"); // TestNameArea
		ws.getRange2("A207").setValue("text"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("2") // TestName3D
		ws2.getRange2("A12").setValue("3") // TestName3D1
		ws2.getRange2("A13").setValue("FALSE") // TestName3D2
		ws2.getRange2("A14").setValue("text") // TestName3D3

		// Positive cases:

		// Case #1: Number(2), Boolean. The chi-squared distribution for 0.5, returned as the cumulative distribution function, using 1 degree of freedom.
		oParser = new parserFormula('CHISQ.DIST(0.5,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(0.5,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.52049988, 'Test: Positive case: Number(2), Boolean. The chi-squared distribution for 0.5, returned as the cumulative distribution function, using 1 degree of freedom.');
		// Case #2: Number(2), Boolean. The chi-squared distribution for 2, returned as the probability density function, using 3 degrees of freedom.
		oParser = new parserFormula('CHISQ.DIST(2,3,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.20755375, 'Test: Positive case: Number(2), Boolean. The chi-squared distribution for 2, returned as the probability density function, using 3 degrees of freedom.');
		// Case #3: Number(3). Basic valid input with all numeric arguments. Returns cumulative distribution function. Example from documentation.
		oParser = new parserFormula('CHISQ.DIST(0.5,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(0.5,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.520499878, 'Test: Positive case: Number(3). Basic valid input with all numeric arguments. Returns cumulative distribution function. Example from documentation.');
		// Case #4: Number(3). Basic valid input with all numeric arguments. Returns probability density function. Example from documentation.
		oParser = new parserFormula('CHISQ.DIST(2,3,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.207553749, 'Test: Positive case: Number(3). Basic valid input with all numeric arguments. Returns probability density function. Example from documentation.');
		// Case #5: Number(3). Float values for x and deg_freedom. deg_freedom will be truncated to 2.
		oParser = new parserFormula('CHISQ.DIST(3.5,2.8,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(3.5,2.8,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.826226057, 'Test: Positive case: Number(3). Float values for x and deg_freedom. deg_freedom will be truncated to 2.');
		// Case #6: String(3). All arguments as strings convertible to proper types.
		oParser = new parserFormula('CHISQ.DIST("2","3","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST("2","3","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.427593296, 'Test: Positive case: String(3). All arguments as strings convertible to proper types.');
		// Case #7: Formula(3). All arguments are formulas returning valid values.
		oParser = new parserFormula('CHISQ.DIST(SQRT(16),ABS(-2),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(SQRT(16),ABS(-2),IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.864664717, 'Test: Positive case: Formula(3). All arguments are formulas returning valid values.');
		// Case #8: Reference link(3). All arguments as cell references.
		oParser = new parserFormula('CHISQ.DIST(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.520499878, 'Test: Positive case: Reference link(3). All arguments as cell references.');
		// Case #9: Area(3). All arguments as single-cell ranges.
		oParser = new parserFormula('CHISQ.DIST(A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.207553749, 'Test: Positive case: Area(3). All arguments as single-cell ranges.');
		// Case #10: Array(3). All arguments as arrays with single elements.
		oParser = new parserFormula('CHISQ.DIST({2},{3},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST({2},{3},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.427593296, 'Test: Positive case: Array(3). All arguments as arrays with single elements.');
		// Case #11: Name(3). All arguments as named ranges.
		oParser = new parserFormula('CHISQ.DIST(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.520499878, 'Test: Positive case: Name(3). All arguments as named ranges.');
		// Case #12: Name3D(3). All arguments as 3D named ranges.
		oParser = new parserFormula('CHISQ.DIST(TestName3D,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(TestName3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.207553749, 'Test: Positive case: Name3D(3). All arguments as 3D named ranges.');
		// Case #13: Ref3D(3). All arguments as 3D references.
		oParser = new parserFormula('CHISQ.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.520499878, 'Test: Positive case: Ref3D(3). All arguments as 3D references.');
		// Case #14: Area3D(3). All arguments as 3D single-cell ranges.
		oParser = new parserFormula('CHISQ.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.520499878, 'Test: Positive case: Area3D(3). All arguments as 3D single-cell ranges.');
		// Case #15: Table(3). All arguments as table references.
		oParser = new parserFormula('CHISQ.DIST(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.520499878, 'Test: Positive case: Table(3). All arguments as table references.');
		// Case #16: String, Number, Boolean. X as string convertible to number.
		oParser = new parserFormula('CHISQ.DIST("1.5",2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST("1.5",2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.236183276, 'Test: Positive case: String, Number, Boolean. X as string convertible to number.');
		// Case #17: Number, String, String. deg_freedom and cumulative as strings convertible to proper types.
		oParser = new parserFormula('CHISQ.DIST(3,"4","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(3,"4","FALSE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.16734762, 'Test: Positive case: Number, String, String. deg_freedom and cumulative as strings convertible to proper types.');
		// Case #18: Formula, Number, Boolean. X as a formula returning a valid number.
		oParser = new parserFormula('CHISQ.DIST(SQRT(25),5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(SQRT(25),5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.584119813, 'Test: Positive case: Formula, Number, Boolean. X as a formula returning a valid number.');
		// Case #19: Number, Formula, Formula. deg_freedom and cumulative as formulas returning valid values.
		oParser = new parserFormula('CHISQ.DIST(7,ROUNDDOWN(3.9,0),NOT(FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(7,ROUNDDOWN(3.9,0),NOT(FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.928102228, 'Test: Positive case: Number, Formula, Formula. deg_freedom and cumulative as formulas returning valid values.');
		// Case #20: Formula. CHISQ.DIST used inside another formula (SUM).
		oParser = new parserFormula('SUM(CHISQ.DIST(2,3,FALSE),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CHISQ.DIST(2,3,FALSE),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.207553749, 'Test: Positive case: Formula. CHISQ.DIST used inside another formula (SUM).');
		// Case #21: Number, Number, Boolean. Equal values for x and deg_freedom, returns probability density function.
		oParser = new parserFormula('CHISQ.DIST(5,5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(5,5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.122041521, 'Test: Positive case: Number, Number, Boolean. Equal values for x and deg_freedom, returns probability density function.');
		// Case #22: Formula, Number, Boolean. X as time formula (converted to decimal, 0.5 for noon).
		oParser = new parserFormula('CHISQ.DIST(TIME(12,0,0),2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(TIME(12,0,0),2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.389400392, 'Test: Positive case: Formula, Number, Boolean. X as time formula (converted to decimal, 0.5 for noon).');
		// Case #23: Number, Number, Number. Cumulative as number 1 (converted to TRUE).
		oParser = new parserFormula('CHISQ.DIST(3,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(3,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.77686984, 'Test: Positive case: Number, Number, Number. Cumulative as number 1 (converted to TRUE).');
		// Case #24: Number, Number, Number. Cumulative as number 0 (converted to FALSE).
		oParser = new parserFormula('CHISQ.DIST(3,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(3,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.11156508, 'Test: Positive case: Number, Number, Number. Cumulative as number 0 (converted to FALSE).');
		// Case #25: Boolean, Number, Boolean. X as boolean TRUE (converted to 1).
		oParser = new parserFormula('CHISQ.DIST(TRUE,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(TRUE,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.30326533, 'Test: Positive case: Boolean, Number, Boolean. X as boolean TRUE (converted to 1).');
		// Case #26: Number, Boolean, Boolean. deg_freedom as boolean TRUE (converted to 1).
		oParser = new parserFormula('CHISQ.DIST(2,TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,TRUE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.842700793, 'Test: Positive case: Number, Boolean, Boolean. deg_freedom as boolean TRUE (converted to 1).');
		// Case #27: Number, Boolean, Number. deg_freedom as boolean TRUE and cumulative as number 1 (both valid).
		oParser = new parserFormula('CHISQ.DIST(5,TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(5,TRUE,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.974652681, 'Test: Positive case: Number, Boolean, Number. deg_freedom as boolean TRUE and cumulative as number 1 (both valid).');
		// Case #28: Empty, Number, Boolean. X is empty
		oParser = new parserFormula('CHISQ.DIST(,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number, Boolean. X is empty');
		// Case #29: Number, Number, Empty. cumulative is empty
		oParser = new parserFormula('CHISQ.DIST(2,3,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.207553749, 'Test: Positive case: Number, Number, Empty. cumulative is empty');
		// Case #30: Boolean, Number, Boolean. X as boolean FALSE (converted to 0) is valid.
		oParser = new parserFormula('CHISQ.DIST(FALSE,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(FALSE,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean, Number, Boolean. X as boolean FALSE (converted to 0) is valid.');

		// Negative cases:

		// Case #1: Number, Number, Boolean. X is negative, returns #NUM! error.
		oParser = new parserFormula('CHISQ.DIST(-1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(-1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Boolean. X is negative, returns #NUM! error.');
		// Case #2: Number, Number, Boolean. deg_freedom is 0, returns #NUM! error.
		oParser = new parserFormula('CHISQ.DIST(2,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Boolean. deg_freedom is 0, returns #NUM! error.');
		// Case #3: Number, Number, Boolean. deg_freedom is negative, returns #NUM! error.
		oParser = new parserFormula('CHISQ.DIST(2,-1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,-1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Boolean. deg_freedom is negative, returns #NUM! error.');
		// Case #4: String, Number, Boolean. X is non-numeric string, returns #VALUE! error.
		oParser = new parserFormula('CHISQ.DIST("text",3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST("text",3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Boolean. X is non-numeric string, returns #VALUE! error.');
		// Case #5: Number, String, Boolean. deg_freedom is non-numeric string, returns #VALUE! error.
		oParser = new parserFormula('CHISQ.DIST(2,"text",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,"text",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Boolean. deg_freedom is non-numeric string, returns #VALUE! error.');
		// Case #6: Number, Number, String. cumulative is non-convertible to boolean, returns #VALUE! error.
		oParser = new parserFormula('CHISQ.DIST(2,3,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String. cumulative is non-convertible to boolean, returns #VALUE! error.');
		// Case #7: Number, Empty, Boolean. deg_freedom is empty, treated as 0, returns #NUM! error.
		oParser = new parserFormula('CHISQ.DIST(2,,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Boolean. deg_freedom is empty, treated as 0, returns #NUM! error.');
		// Case #8: Error, Number, Boolean. X is an error value, error propagates.
		oParser = new parserFormula('CHISQ.DIST(NA(),3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(NA(),3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Boolean. X is an error value, error propagates.');
		// Case #9: Number, Error, Boolean. deg_freedom is an error value, error propagates.
		oParser = new parserFormula('CHISQ.DIST(2,NA(),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,NA(),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Boolean. deg_freedom is an error value, error propagates.');
		// Case #10: Number, Number, Error. cumulative is an error value, error propagates.
		oParser = new parserFormula('CHISQ.DIST(2,3,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Number, Error. cumulative is an error value, error propagates.');
		// Case #11: Area, Number, Boolean. X is multi-cell range with invalid values, returns #VALUE! error.
		oParser = new parserFormula('CHISQ.DIST(A106:A107,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(A106:A107,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number, Boolean. X is multi-cell range with invalid values, returns #VALUE! error.');
		// Case #12: Number, Area, Boolean. deg_freedom is multi-cell range with invalid values, returns #VALUE! error.
		oParser = new parserFormula('CHISQ.DIST(2,A106:A107,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,A106:A107,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Boolean. deg_freedom is multi-cell range with invalid values, returns #VALUE! error.');
		// Case #13: Number, Number, Area. cumulative is multi-cell range with invalid values, returns #VALUE! error.
		oParser = new parserFormula('CHISQ.DIST(2,3,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Area. cumulative is multi-cell range with invalid values, returns #VALUE! error.');
		// Case #14: Array, Number, Boolean. X is multi-element array with invalid values, returns #VALUE! error.
		oParser = new parserFormula('CHISQ.DIST({-1,2},3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST({-1,2},3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number, Boolean. X is multi-element array with invalid values, returns #VALUE! error.');
		// Case #15: Formula, Number, Boolean. X formula results in error, error propagates.
		oParser = new parserFormula('CHISQ.DIST(SQRT(-1),3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(SQRT(-1),3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number, Boolean. X formula results in error, error propagates.');
		// Case #16: Number, Formula, Boolean. deg_freedom formula results in error, error propagates.
		oParser = new parserFormula('CHISQ.DIST(2,LOG(-1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,LOG(-1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula, Boolean. deg_freedom formula results in error, error propagates.');
		// Case #17: Number, Number, Formula. cumulative formula results in error, error propagates.
		oParser = new parserFormula('CHISQ.DIST(2,3,1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Number, Formula. cumulative formula results in error, error propagates.');
		// Case #18: Number, Number, Boolean. deg_freedom exceeds maximum (10^10), returns #NUM! error.
		oParser = new parserFormula('CHISQ.DIST(2,10^11,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,10^11,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Boolean. deg_freedom exceeds maximum (10^10), returns #NUM! error.');
		// Case #19: Number, Boolean, Boolean. deg_freedom as boolean FALSE (converted to 0), returns #NUM! error.
		oParser = new parserFormula('CHISQ.DIST(2,FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Boolean, Boolean. deg_freedom as boolean FALSE (converted to 0), returns #NUM! error.');
		// Case #20: Reference link, Number, Boolean. X as reference link with invalid value (negative number).
		oParser = new parserFormula('CHISQ.DIST(A108,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(A108,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Number, Boolean. X as reference link with invalid value (negative number).');
		// Case #21: Number, Reference link, Boolean. deg_freedom as reference link with invalid value (0).
		oParser = new parserFormula('CHISQ.DIST(2,A106,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,A106,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link, Boolean. deg_freedom as reference link with invalid value (0).');
		// Case #22: Number, Number, Reference link. cumulative as reference link with invalid value (text).
		oParser = new parserFormula('CHISQ.DIST(2,3,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Reference link. cumulative as reference link with invalid value (text).');
		// Case #23: Ref3D, Number, Boolean. X as 3D reference with invalid value.
		oParser = new parserFormula('CHISQ.DIST(Sheet2!A4,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(Sheet2!A4,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Number, Boolean. X as 3D reference with invalid value.');
		// Case #24: Name, Number, Boolean. X as named range with invalid value.
		oParser = new parserFormula('CHISQ.DIST(TestName3,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(TestName3,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number, Boolean. X as named range with invalid value.');
		// Case #25: Number, Name, Boolean. deg_freedom as named range with invalid value.
		oParser = new parserFormula('CHISQ.DIST(2,TestName3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,TestName3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name, Boolean. deg_freedom as named range with invalid value.');
		// Case #26: Number, Number, Name. cumulative is named range with invalid values.
		oParser = new parserFormula('CHISQ.DIST(2,3,TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Name. cumulative is named range with invalid values.');
		// Case #27: Name3D, Number, Boolean. X as 3D named range with invalid value.
		oParser = new parserFormula('CHISQ.DIST(TestName3D3,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(TestName3D3,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D, Number, Boolean. X as 3D named range with invalid value.');
		// Case #28: Number, Name3D, Boolean. deg_freedom as 3D named range with invalid value.
		oParser = new parserFormula('CHISQ.DIST(2,TestName3D3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,TestName3D3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name3D, Boolean. deg_freedom as 3D named range with invalid value.');
		// Case #29: Number, Number, Name3D. cumulative as 3D named range with invalid value (text).
		oParser = new parserFormula('CHISQ.DIST(2,3,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Name3D. cumulative as 3D named range with invalid value (text).');
		// Case #30: Area3D, Number, Boolean. X as 3D area with invalid value.
		oParser = new parserFormula('CHISQ.DIST(Sheet2!A4:A4,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(Sheet2!A4:A4,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number, Boolean. X as 3D area with invalid value.');
		// Case #31: Number, Area3D, Boolean. deg_freedom as 3D area with invalid value.
		oParser = new parserFormula('CHISQ.DIST(2,Sheet2!A4:A4,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,Sheet2!A4:A4,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D, Boolean. deg_freedom as 3D area with invalid value.');
		// Case #32: Number, Number, Area3D. cumulative as 3D area with invalid value (text).
		oParser = new parserFormula('CHISQ.DIST(2,3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Area3D. cumulative as 3D area with invalid value (text).');
		// Case #33: Table, Number, Boolean. X as table reference with invalid value .
		oParser = new parserFormula('CHISQ.DIST(Table1[Column4],3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(Table1[Column4],3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table, Number, Boolean. X as table reference with invalid value .');
		// Case #34: Number, Table, Boolean. deg_freedom as table reference with invalid value.
		oParser = new parserFormula('CHISQ.DIST(2,Table1[Column4],TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,Table1[Column4],TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Table, Boolean. deg_freedom as table reference with invalid value.');
		// Case #35: Number, Number, Table. cumulative as table reference with invalid value.
		oParser = new parserFormula('CHISQ.DIST(2,3,Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,3,Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Table. cumulative as table reference with invalid value.');

		// Bounded cases:

		// Case #1: Number, Number, Boolean. Minimum valid x value (1) with minimum valid deg_freedom (1), probability density function.
		oParser = new parserFormula('CHISQ.DIST(1,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(1,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24197072451914337, 'Test: Bounded case: Number, Number, Boolean. Minimum valid x value (1) with minimum valid deg_freedom (1), probability density function.');
		// Case #2: Number, Number, Boolean. Minimum valid x value (0) with minimum valid deg_freedom (1), cumulative distribution function.
		oParser = new parserFormula('CHISQ.DIST(0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number, Boolean. Minimum valid x value (0) with minimum valid deg_freedom (1), cumulative distribution function.');
		// Case #3: Number, Number, Boolean. Very small positive x value with minimum valid deg_freedom.
		oParser = new parserFormula('CHISQ.DIST(1E-10,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(1E-10,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 39894.228038148554, 'Test: Bounded case: Number, Number, Boolean. Very small positive x value with minimum valid deg_freedom.');
		// Case #4: Number, Number, Boolean. Very large x value with minimum valid deg_freedom.
		oParser = new parserFormula('CHISQ.DIST(1E+307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(1E+307,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number, Boolean. Very large x value with minimum valid deg_freedom.');
		// Case #5: Number, Number, Boolean. Typical x value with maximum valid deg_freedom (10^10).
		oParser = new parserFormula('CHISQ.DIST(2,10^10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(2,10^10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number, Boolean. Typical x value with maximum valid deg_freedom (10^10).');
		// Case #6: Number, Number, Boolean. Maximum valid x value with maximum valid deg_freedom.
		oParser = new parserFormula('CHISQ.DIST(9.99999999999999E+307,10^10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST(9.99999999999999E+307,10^10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number, Boolean. Maximum valid x value with maximum valid deg_freedom.');


		testArrayFormula2(assert, "CHISQ.DIST", 3, 3);
	});

	QUnit.test("Test: \"CHISQ.DIST.RT\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A2").setValue("18.307");
		ws.getRange2("A3").setValue("10");
		ws.getRange2("A100").setValue("18.307");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("3.841");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A104").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("5.991"); // Column1
		ws.getRange2("B601").setValue("2"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("18.307");
		ws2.getRange2("A2").setValue("10");
		ws2.getRange2("A3").setValue("test");
		ws2.getRange2("A4").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("18.307"); // TestName
		ws.getRange2("A202").setValue("10"); // TestName1
		ws.getRange2("A206").setValue("test"); // TestNameArea
		ws.getRange2("A207").setValue("#N/A"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("5.991") // TestName3D
		ws2.getRange2("A12").setValue("2") // TestName3D1

		// Positive cases:

		// Case #1: Reference link(2). One-tailed probability of the chi-squared distribution, for the arguments specified in A2 and A3.
		oParser = new parserFormula('CHISQ.DIST.RT(A2,A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(A2,A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0500006, 'Test: Positive case: Reference link(2). One-tailed probability of the chi-squared distribution, for the arguments specified in A2 and A3.');
		// Case #2: Number(2). Basic case with standard values. Both arguments are numbers. Example from documentation.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Number(2). Basic case with standard values. Both arguments are numbers. Example from documentation.');
		// Case #3: Number(2). Common chi-square critical value for 1 degree of freedom.
		oParser = new parserFormula('CHISQ.DIST.RT(3.841,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(3.841,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050013684, 'Test: Positive case: Number(2). Common chi-square critical value for 1 degree of freedom.');
		// Case #4: Number(2). Common chi-square critical value for 2 degrees of freedom.
		oParser = new parserFormula('CHISQ.DIST.RT(5.991,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(5.991,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050011615, 'Test: Positive case: Number(2). Common chi-square critical value for 2 degrees of freedom.');
		// Case #5: Number(2). Small x value with moderate degrees of freedom.
		oParser = new parserFormula('CHISQ.DIST.RT(0.5,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(0.5,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.992123293, 'Test: Positive case: Number(2). Small x value with moderate degrees of freedom.');
		// Case #6: Number(2). Large x value with large degrees of freedom.
		oParser = new parserFormula('CHISQ.DIST.RT(100,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(100,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10) - 0, 0.0000345493, 'Test: Positive case: Number(2). Large x value with large degrees of freedom.');
		// Case #7: String(2). Both arguments as strings that can be converted to numbers.
		oParser = new parserFormula('CHISQ.DIST.RT("18.307","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT("18.307","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: String(2). Both arguments as strings that can be converted to numbers.');
		// Case #8: Formula(2). Both arguments as results of formulas.
		oParser = new parserFormula('CHISQ.DIST.RT(SQRT(336),ROUND(9.6,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(SQRT(336),ROUND(9.6,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.049641025, 'Test: Positive case: Formula(2). Both arguments as results of formulas.');
		// Case #9: Reference link(2). Both arguments as cell references.
		oParser = new parserFormula('CHISQ.DIST.RT(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Reference link(2). Both arguments as cell references.');
		// Case #10: Area(2). Both arguments as single-cell ranges.
		oParser = new parserFormula('CHISQ.DIST.RT(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050013684, 'Test: Positive case: Area(2). Both arguments as single-cell ranges.');
		// Case #11: Array(2). Both arguments as single-element arrays.
		oParser = new parserFormula('CHISQ.DIST.RT({18.307},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT({18.307},{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Array(2). Both arguments as single-element arrays.');
		// Case #12: Name(2). Both arguments as named ranges.
		oParser = new parserFormula('CHISQ.DIST.RT(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Name(2). Both arguments as named ranges.');
		// Case #13: Name3D(2). Both arguments as 3D named ranges.
		oParser = new parserFormula('CHISQ.DIST.RT(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050011615, 'Test: Positive case: Name3D(2). Both arguments as 3D named ranges.');
		// Case #14: Ref3D(2). Both arguments as 3D references.
		oParser = new parserFormula('CHISQ.DIST.RT(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Ref3D(2). Both arguments as 3D references.');
		// Case #15: Area3D(2). Both arguments as 3D single-cell ranges.
		oParser = new parserFormula('CHISQ.DIST.RT(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Area3D(2). Both arguments as 3D single-cell ranges.');
		// Case #16: Table(2). Both arguments from table references.
		oParser = new parserFormula('CHISQ.DIST.RT(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050011615, 'Test: Positive case: Table(2). Both arguments from table references.');
		// Case #17: Formula. Function used inside another function.
		oParser = new parserFormula('SUM(CHISQ.DIST.RT(18.307,10),0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CHISQ.DIST.RT(18.307,10),0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.100000589, 'Test: Positive case: Formula. Function used inside another function.');
		// Case #18: Number(2). Second argument with decimal (should be truncated to 10).
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,10.6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,10.6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Number(2). Second argument with decimal (should be truncated to 10).');
		// Case #19: Number, Formula. First argument as number, second as result of IF formula.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,IF(TRUE,10,5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,IF(TRUE,10,5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Number, Formula. First argument as number, second as result of IF formula.');
		// Case #20: Formula, Number. First argument as date serial number, second as number.
		oParser = new parserFormula('CHISQ.DIST.RT(DATE(2023,1,1),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(DATE(2023,1,1),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula, Number. First argument as date serial number, second as number.');
		// Case #21: Number, Formula. First argument as number, second as date difference (4 days).
		oParser = new parserFormula('CHISQ.DIST.RT(20,DATE(2000,1,5)-DATE(2000,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(20,DATE(2000,1,5)-DATE(2000,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000499399, 'Test: Positive case: Number, Formula. First argument as number, second as date difference (4 days).');
		// Case #22: Formula, Number. First argument as time value * 2 (0.5*2=1), second as number.
		oParser = new parserFormula('CHISQ.DIST.RT(TIME(12,0,0)*2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(TIME(12,0,0)*2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.962565773, 'Test: Positive case: Formula, Number. First argument as time value * 2 (0.5*2=1), second as number.');
		// Case #23: Number, Formula. First argument as number, second as time that equals 1 day (1).
		oParser = new parserFormula('CHISQ.DIST.RT(20,TIME(24,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(20,TIME(24,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(11) - 0, 0.00000774422, 'Test: Positive case: Number, Formula. First argument as number, second as time that equals 1 day (1).');
		// Case #24: Formula. Both arguments as results of statistical functions.
		oParser = new parserFormula('CHISQ.DIST.RT(AVERAGE(10,20,30),COUNT(10,20,30))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(AVERAGE(10,20,30),COUNT(10,20,30)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.000169742, 'Test: Positive case: Formula. Both arguments as results of statistical functions.');
		// Case #25: Number, Formula. First argument as number, second as ABS formula result.
		oParser = new parserFormula('CHISQ.DIST.RT(20,ABS(-5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(20,ABS(-5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.001249731, 'Test: Positive case: Number, Formula. First argument as number, second as ABS formula result.');
		// Case #26: Formula, Number. First argument as POWER formula result, second as number.
		oParser = new parserFormula('CHISQ.DIST.RT(POWER(2,3),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(POWER(2,3),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.156235628, 'Test: Positive case: Formula, Number. First argument as POWER formula result, second as number.');
		// Case #27: Number(2). Very large x value with moderate degrees of freedom.
		oParser = new parserFormula('CHISQ.DIST.RT(1E+10,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(1E+10,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Very large x value with moderate degrees of freedom.');
		// Case #28: Number(2). Very small x value with minimal degrees of freedom.
		oParser = new parserFormula('CHISQ.DIST.RT(0.0001,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(0.0001,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.992021287, 'Test: Positive case: Number(2). Very small x value with minimal degrees of freedom.');
		// Case #29: String(2). Scientific notation in string for first argument.
		oParser = new parserFormula('CHISQ.DIST.RT("2.5E+5","15")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT("2.5E+5","15") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String(2). Scientific notation in string for first argument.');
		// Case #30: Reference link, Number. First argument as column reference.
		oParser = new parserFormula('CHISQ.DIST.RT(A100,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(A100,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.050000589, 'Test: Positive case: Reference link, Number. First argument as column reference.');
		// Case #31: Area, Number. First argument as row range reference, using first cell only.
		// Different result with MS
		oParser = new parserFormula('CHISQ.DIST.RT(A100:A101,5)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(A100:A101,5) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(7) - 0, 0.0025853, 'Test: Positive case: Area, Number. First argument as row range reference, using first cell only.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue().toFixed(7) - 0, 0.0752352, 'Test: Positive case: Area, Number. First argument as row range reference, using first cell only.');
		// Case #32: Empty, Number. First argument is empty, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT(,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty, Number. First argument is empty, should return #VALUE!.');
		// Case #33: Reference link. First argument is entire column reference, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT(M:M,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(M:M,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. First argument is entire column reference, should return #VALUE!.');
		// Case #34: Boolean, Number. First argument is boolean (converted to 1), valid calculation.
		oParser = new parserFormula('CHISQ.DIST.RT(TRUE,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(TRUE,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.999827884, 'Test: Positive case: Boolean, Number. First argument is boolean (converted to 1), valid calculation.');
		// Case #35: Number, Boolean. Second argument is boolean (converted to 1), valid calculation.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10) - 0, 0.0000188015, 'Test: Positive case: Number, Boolean. Second argument is boolean (converted to 1), valid calculation.');

		// Negative cases:

		// Case #1: Number, String. Second argument is non-numeric string, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Second argument is non-numeric string, should return #VALUE!.');
		// Case #2: String, Number. First argument is non-numeric string, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT("abc",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT("abc",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. First argument is non-numeric string, should return #VALUE!.');
		// Case #3: Number, Empty. Second argument is empty, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty. Second argument is empty, should return #VALUE!.');
		// Case #4: Error, Number. First argument is #N/A error, should propagate the error.
		oParser = new parserFormula('CHISQ.DIST.RT(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. First argument is #N/A error, should propagate the error.');
		// Case #5: Number, Error. Second argument is #N/A error, should propagate the error.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Second argument is #N/A error, should propagate the error.');
		// Case #6: Number(2). Second argument is 0 (below minimum of 1), should return #NUM!.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Second argument is 0 (below minimum of 1), should return #NUM!.');
		// Case #7: Number(2). Second argument is negative, should return #NUM!.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Second argument is negative, should return #NUM!.');
		// Case #8: Number(2). Second argument exceeds maximum (10^10), should return #NUM!.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,1E+11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,1E+11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Second argument exceeds maximum (10^10), should return #NUM!.');
		// Case #9: Array, Number. First argument is multi-element array, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT({"test",#N/A},10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT({"test",#N/A},10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Number. First argument is multi-element array, should return #VALUE!.');
		// Case #10: Number, Array. Second argument is multi-element array, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,{"test",#N/A})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,{"test",#N/A}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Array. Second argument is multi-element array, should return #VALUE!.');
		// Case #11: Name, Number. First argument is multi-cell named range, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT(TestNameArea,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(TestNameArea,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number. First argument is multi-cell named range, should return #VALUE!.');
		// Case #12: Number, Name. Second argument is multi-cell named range, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name. Second argument is multi-cell named range, should return #VALUE!.');
		// Case #13: Area3D, Number. First argument is multi-cell 3D range, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT(Sheet2!A3:A4,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(Sheet2!A3:A4,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number. First argument is multi-cell 3D range, should return #VALUE!.');
		// Case #14: Number, Area3D. Second argument is multi-cell 3D range, should return #VALUE!.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D. Second argument is multi-cell 3D range, should return #VALUE!.');
		// Case #15: Reference link, Number. First argument is reference to cell with error value.
		oParser = new parserFormula('CHISQ.DIST.RT(A104,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(A104,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number. First argument is reference to cell with error value.');
		// Case #16: Number, Reference link. Second argument is reference to cell with error value.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number, Reference link. Second argument is reference to cell with error value.');
		// Case #17: Number(2). Negative x value, should calculate but result is likely to be near 1.
		oParser = new parserFormula('CHISQ.DIST.RT(-10,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(-10,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative x value, should calculate but result is likely to be near 1.');
		// Case #18: Formula, Number. First argument is formula returning #NUM! error, should propagate the error.
		oParser = new parserFormula('CHISQ.DIST.RT(SQRT(-1),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(SQRT(-1),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. First argument is formula returning #NUM! error, should propagate the error.');
		// Case #19: Number, Formula. Second argument is formula returning #NUM! error, should propagate the error.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Second argument is formula returning #NUM! error, should propagate the error.');
		// Case #20: Formula(2). First arg returns #N/A error, second returns 0 (invalid). Should propagate #N/A.
		oParser = new parserFormula('CHISQ.DIST.RT(IF(TRUE,NA(),10),IF(FALSE,5,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(IF(TRUE,NA(),10),IF(FALSE,5,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula(2). First arg returns #N/A error, second returns 0 (invalid). Should propagate #N/A.');
		// Case #21: Reference link. Second argument is entire row reference.
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4356072837486846, 'Test: Negative case: Reference link. Second argument is entire row reference.');

		// Bounded cases:

		// Case #1: Number(2). Minimum practical x value with minimum valid degrees of freedom.
		// Different result with MS
		oParser = new parserFormula('CHISQ.DIST.RT(0.0000000001,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(0.0000000001,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.999992, 'Test: Bounded case: Number(2). Minimum practical x value with minimum valid degrees of freedom.');
		// Case #2: Number(2). Maximum practical x value with minimum valid degrees of freedom.
		// Different result with MS
		oParser = new parserFormula('CHISQ.DIST.RT(1E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(1E+307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Maximum practical x value with minimum valid degrees of freedom.');
		// Case #3: Number(2). Standard x value with minimum valid degrees of freedom (1).
		// Different result with MS
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10) - 0, 1.88015E-05, 'Test: Bounded case: Number(2). Standard x value with minimum valid degrees of freedom (1).');
		// Case #4: Number(2). Standard x value with maximum valid degrees of freedom (10^10).
		oParser = new parserFormula('CHISQ.DIST.RT(18.307,1E+10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(18.307,1E+10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Standard x value with maximum valid degrees of freedom (10^10).');
		// Case #5: Number(2). Zero x value with minimum valid degrees of freedom, should return 1.
		oParser = new parserFormula('CHISQ.DIST.RT(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.DIST.RT(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Zero x value with minimum valid degrees of freedom, should return 1.');

		testArrayFormula2(assert, "CHISQ.INV.RT", 2, 2);
	});

	QUnit.test("Test: \"CHISQ.INV\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.93");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A102").setValue("0.6");
		ws.getRange2("A103").setValue("2");
		ws.getRange2("A104").setValue("text");
		ws.getRange2("A105").setValue("#N/A");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("0.5"); // Column1
		ws.getRange2("B601").setValue("10"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.93");
		ws2.getRange2("A2").setValue("1");
		ws2.getRange2("A3").setValue("0.6");
		ws2.getRange2("A4").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.93"); // TestName
		ws.getRange2("A202").setValue("4"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.75") // TestName3D
		ws2.getRange2("A12").setValue("3") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Inverse of the left-tailed probability of the chi-squared distribution for 0.93, using 1 degree of freedom.
		oParser = new parserFormula('CHISQ.INV(0.93,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.93,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.283020287, 'Test: Positive case: Number(2). Inverse of the left-tailed probability of the chi-squared distribution for 0.93, using 1 degree of freedom.');
		// Case #2: Number(2). Inverse of the left-tailed probability of the chi-squared distribution for 0.6, using 2 degrees of freedom.
		oParser = new parserFormula('CHISQ.INV(0.6,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.6,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.832581464, 'Test: Positive case: Number(2). Inverse of the left-tailed probability of the chi-squared distribution for 0.6, using 2 degrees of freedom.');
		// Case #3: String, String. String arguments are converted to numbers.
		oParser = new parserFormula('CHISQ.INV("0.5", "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV("0.5", "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.365973884, 'Test: Positive case: String, String. String arguments are converted to numbers.');
		// Case #4: Number, Formula. deg_freedom is a nested formula.
		oParser = new parserFormula('CHISQ.INV(0.75, SQRT(16))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.75, SQRT(16)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 5.385269058, 'Test: Positive case: Number, Formula. deg_freedom is a nested formula.');
		// Case #5: Formula, Number. Probability is a nested formula.
		oParser = new parserFormula('CHISQ.INV(1-0.1, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(1-0.1, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 9.2363569, 'Test: Positive case: Formula, Number. Probability is a nested formula.');
		// Case #6: Number, Number. CHISQ.INV is a part of another formula.
		oParser = new parserFormula('ROUND(CHISQ.INV(0.25,2), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ROUND(CHISQ.INV(0.25,2), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.58, 'Test: Positive case: Number, Number. CHISQ.INV is a part of another formula.');
		// Case #7: Number, Boolean. deg_freedom is a Boolean TRUE, converted to 1.
		oParser = new parserFormula('CHISQ.INV(0.8, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.8, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.642374415, 'Test: Positive case: Number, Boolean. deg_freedom is a Boolean TRUE, converted to 1.');
		// Case #8: Number, Number. deg_freedom is a float, which should be truncated to 5.
		oParser = new parserFormula('CHISQ.INV(0.1, 5.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.1, 5.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.610307987, 'Test: Positive case: Number, Number. deg_freedom is a float, which should be truncated to 5.');
		// Case #9: Reference link, Number. Probability is a reference to a cell.
		oParser = new parserFormula('CHISQ.INV(A100, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(A100, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 5.318520074, 'Test: Positive case: Reference link, Number. Probability is a reference to a cell.');
		// Case #10: Number, Reference link. deg_freedom is a reference to a cell.
		oParser = new parserFormula('CHISQ.INV(0.95, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.95, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.841458821, 'Test: Positive case: Number, Reference link. deg_freedom is a reference to a cell.');
		// Case #11: Area, Number. Probability is a single-cell area.
		oParser = new parserFormula('CHISQ.INV(A102:A102, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(A102:A102, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.946166073, 'Test: Positive case: Area, Number. Probability is a single-cell area.');
		// Case #12: Number, Area. deg_freedom is a single-cell area.
		oParser = new parserFormula('CHISQ.INV(0.5, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.386294361, 'Test: Positive case: Number, Area. deg_freedom is a single-cell area.');
		// Case #13: Name, Number. Probability is a named range.
		oParser = new parserFormula('CHISQ.INV(TestName, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(TestName, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 8.666428234, 'Test: Positive case: Name, Number. Probability is a named range.');
		// Case #14: Number, Name. deg_freedom is a named range.
		oParser = new parserFormula('CHISQ.INV(0.75, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.75, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 5.385269058, 'Test: Positive case: Number, Name. deg_freedom is a named range.');
		// Case #15: Ref3D, Number. Probability is a 3D reference.
		oParser = new parserFormula('CHISQ.INV(Sheet2!A1, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(Sheet2!A1, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 10.19102791, 'Test: Positive case: Ref3D, Number. Probability is a 3D reference.');
		// Case #16: Number, Ref3D. deg_freedom is a 3D reference.
		oParser = new parserFormula('CHISQ.INV(0.25, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.25, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.101531044, 'Test: Positive case: Number, Ref3D. deg_freedom is a 3D reference.');
		// Case #17: Area3D, Number. Probability is a 3D single-cell area.
		oParser = new parserFormula('CHISQ.INV(Sheet2!A3:A3, 6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(Sheet2!A3:A3, 6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 6.210757195, 'Test: Positive case: Area3D, Number. Probability is a 3D single-cell area.');
		// Case #18: Number, Area3D. deg_freedom is a 3D single-cell area.
		oParser = new parserFormula('CHISQ.INV(0.8, Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.8, Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.218875825, 'Test: Positive case: Number, Area3D. deg_freedom is a 3D single-cell area.');
		// Case #19: Name3D, Number. Probability is a 3D named range.
		oParser = new parserFormula('CHISQ.INV(TestName3D, 7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(TestName3D, 7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 9.037147548, 'Test: Positive case: Name3D, Number. Probability is a 3D named range.');
		// Case #20: Number, Name3D. deg_freedom is a 3D named range.
		oParser = new parserFormula('CHISQ.INV(0.99, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.99, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 11.34486673, 'Test: Positive case: Number, Name3D. deg_freedom is a 3D named range.');
		// Case #21: Array, Array. Both arguments are arrays.
		oParser = new parserFormula('CHISQ.INV({0.5,0.6},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV({0.5,0.6},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.386294361, 'Test: Positive case: Array, Array. Both arguments are arrays.');
		// Case #22: Table, Number. Probability is a reference to a table column.
		oParser = new parserFormula('CHISQ.INV(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 9.341817766, 'Test: Positive case: Table, Number. Probability is a reference to a table column.');
		// Case #23: Number, Area. deg_freedom is a whole row reference.
		oParser = new parserFormula('CHISQ.INV(100:100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(100:100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.283020286759537, 'Test: Positive case: Number, Area. deg_freedom is a whole row reference.');
		// Case #24: Empty, Number. Empty probability
		oParser = new parserFormula('CHISQ.INV(, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number. Empty probability');

		// Negative cases:

		// Case #1: Number, Number. Probability < 0 returns #NUM!.
		oParser = new parserFormula('CHISQ.INV(-0.1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(-0.1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Probability < 0 returns #NUM!.');
		// Case #2: Number, Number. Probability > 1 returns #NUM!.
		oParser = new parserFormula('CHISQ.INV(1.1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(1.1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Probability > 1 returns #NUM!.');
		// Case #3: Number, Number. deg_freedom < 1 returns #NUM!.
		oParser = new parserFormula('CHISQ.INV(0.5, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. deg_freedom < 1 returns #NUM!.');
		// Case #4: Number, Number. deg_freedom < 1 (after truncation) returns #NUM!.
		oParser = new parserFormula('CHISQ.INV(0.5, 0.99)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, 0.99) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. deg_freedom < 1 (after truncation) returns #NUM!.');
		// Case #5: Number, Number. deg_freedom is negative, returns #NUM!.
		oParser = new parserFormula('CHISQ.INV(0.5, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. deg_freedom is negative, returns #NUM!.');
		// Case #6: String, Number. Non-numeric probability returns #VALUE!.
		oParser = new parserFormula('CHISQ.INV("text", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV("text", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric probability returns #VALUE!.');
		// Case #7: Number, String. Non-numeric deg_freedom returns #VALUE!.
		oParser = new parserFormula('CHISQ.INV(0.5, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric deg_freedom returns #VALUE!.');
		// Case #8: Error, Number. Probability is an error, returns #N/A.
		oParser = new parserFormula('CHISQ.INV(#N/A, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(#N/A, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Probability is an error, returns #N/A.');
		// Case #9: Number, Error. deg_freedom is an error, returns #N/A.
		oParser = new parserFormula('CHISQ.INV(0.5, #N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, #N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. deg_freedom is an error, returns #N/A.');
		// Case #10: Number, Empty. Empty deg_freedom argument returns #NUM!.
		oParser = new parserFormula('CHISQ.INV(0.5, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty. Empty deg_freedom argument returns #NUM!.');
		// Case #11: Formula, Number. Nested formula results in #NUM!, which propagates.
		oParser = new parserFormula('CHISQ.INV(SQRT(-1), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(SQRT(-1), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Nested formula results in #NUM!, which propagates.');
		// Case #12: Number, Formula. Nested formula results in #NUM!, which propagates.
		oParser = new parserFormula('CHISQ.INV(0.5, LOG(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, LOG(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Nested formula results in #NUM!, which propagates.');
		// Case #13: Reference link, Number. Reference to a cell with text.
		oParser = new parserFormula('CHISQ.INV(A104, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(A104, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to a cell with text.');
		// Case #14: Number, Reference link. Reference to a cell with an error.
		oParser = new parserFormula('CHISQ.INV(0.5, A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Reference link. Reference to a cell with an error.');
		// Case #15: Area, Number. Multi-cell area for probability returns #VALUE!.
		oParser = new parserFormula('CHISQ.INV(A104:A105, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(A104:A105, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell area for probability returns #VALUE!.');
		// Case #16: Number, Area. Multi-cell area for deg_freedom returns #VALUE!.
		oParser = new parserFormula('CHISQ.INV(0.5, A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Multi-cell area for deg_freedom returns #VALUE!.');
		// Case #17: Number, Boolean. deg_freedom is FALSE (0), returns #NUM!.
		oParser = new parserFormula('CHISQ.INV(0.5, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Boolean. deg_freedom is FALSE (0), returns #NUM!.');
		// Case #22: Number, Area. deg_freedom is a whole column reference.
		oParser = new parserFormula('CHISQ.INV(0.5, M:M)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, M:M) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area. deg_freedom is a whole column reference.');

		// Bounded cases:

		// Case #1: Number, Number. Probability at minimum valid value (0).
		oParser = new parserFormula('CHISQ.INV(0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number. Probability at minimum valid value (0).');
		// Case #2: Number, Number. Probability at maximum valid value (1).
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV(9E-307, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(9E-307, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number. Probability at maximum valid value (1).');
		// Case #3: Number, Number. deg_freedom at minimum valid value (1).
		oParser = new parserFormula('CHISQ.INV(0.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Bounded case: Number, Number. deg_freedom at minimum valid value (1).');
		// Case #4: Number, Number. deg_freedom at maximum valid value (10^10).
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV(0.5, 10^10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, 10^10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 9999999999, 'Test: Bounded case: Number, Number. deg_freedom at maximum valid value (10^10).');
		// Case #5: Formula, Number. Probability approaching maximum value.
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV(1-1E-15, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(1-1E-15, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 64.43203897, 'Test: Bounded case: Formula, Number. Probability approaching maximum value.');
		// Case #6: Number, Formula. deg_freedom approaching minimum value (will be truncated to 1).
		oParser = new parserFormula('CHISQ.INV(0.5, 1+1E-9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV(0.5, 1+1E-9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Bounded case: Number, Formula. deg_freedom approaching minimum value (will be truncated to 1).');

		testArrayFormula2(assert, "CHISQ.INV", 2, 2);
	});

	QUnit.test("Test: \"CHISQ.INV.RT\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A2").setValue("0.050001");
		ws.getRange2("A3").setValue("10");
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("5");
		ws.getRange2("A102").setValue("0.05");
		ws.getRange2("A103").setValue("10");
		ws.getRange2("A104").setValue("text");
		ws.getRange2("A105").setValue("#N/A");
		ws.getRange2("A106").setValue("0.5");
		ws.getRange2("A107").setValue("0.05");
		ws.getRange2("A108").setValue("5");
		ws.getRange2("A109").setValue("10");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("0.05"); // Column1
		ws.getRange2("B601").setValue("10"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("5");
		ws2.getRange2("A3").setValue("0.05");
		ws2.getRange2("A4").setValue("10");
		ws2.getRange2("A5").setValue("text");
		ws2.getRange2("A6").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.5"); // TestName
		ws.getRange2("A202").setValue("5"); // TestName1
		ws.getRange2("A206").setValue("test"); // TestNameArea
		ws.getRange2("A207").setValue("#N/A"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.05") // TestName3D
		ws2.getRange2("A12").setValue("10") // TestName3D1

		// Positive cases:

		// Case #1: Reference link(2). Inverse of the one-tailed probability of the chi-squared distribution
		oParser = new parserFormula('CHISQ.INV.RT(A2,A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(A2,A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 18.306973, 'Test: Positive case: Reference link(2). Inverse of the one-tailed probability of the chi-squared distribution');
		// Case #2: Number(2). Basic test with example values from documentation.
		oParser = new parserFormula('CHISQ.INV.RT(0.050001,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.050001,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 18.30697346, 'Test: Positive case: Number(2). Basic test with example values from documentation.');
		// Case #3: Number(2). Probability 0.5 and degrees of freedom 5.
		oParser = new parserFormula('CHISQ.INV.RT(0.5,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.5,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.351460191, 'Test: Positive case: Number(2). Probability 0.5 and degrees of freedom 5.');
		// Case #4: String(2). Strings that can be converted to numbers.
		oParser = new parserFormula('CHISQ.INV.RT("0.05","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT("0.05","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 18.30703805, 'Test: Positive case: String(2). Strings that can be converted to numbers.');
		// Case #5: Formula(2). Formulas returning numeric values.
		oParser = new parserFormula('CHISQ.INV.RT(1-0.95,2*5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(1-0.95,2*5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 18.30703805, 'Test: Positive case: Formula(2). Formulas returning numeric values.');
		// Case #6: Reference link(2). Reference links to cells with valid values.
		oParser = new parserFormula('CHISQ.INV.RT(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.351460191, 'Test: Positive case: Reference link(2). Reference links to cells with valid values.');
		// Case #7: Area(2). Single-cell ranges with valid values.
		oParser = new parserFormula('CHISQ.INV.RT(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 18.30703805, 'Test: Positive case: Area(2). Single-cell ranges with valid values.');
		// Case #8: Array(2). Arrays with single valid elements.
		oParser = new parserFormula('CHISQ.INV.RT({0.01},{15})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT({0.01},{15}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 30.57791417, 'Test: Positive case: Array(2). Arrays with single valid elements.');
		// Case #9: Name(2). Named ranges with valid values.
		oParser = new parserFormula('CHISQ.INV.RT(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.351460191, 'Test: Positive case: Name(2). Named ranges with valid values.');
		// Case #10: Name3D(2). 3D named ranges with valid values.
		oParser = new parserFormula('CHISQ.INV.RT(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 18.30703805, 'Test: Positive case: Name3D(2). 3D named ranges with valid values.');
		// Case #11: Ref3D(2). 3D references to cells with valid values.
		oParser = new parserFormula('CHISQ.INV.RT(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.351460191, 'Test: Positive case: Ref3D(2). 3D references to cells with valid values.');
		// Case #12: Area3D(2). 3D single-cell ranges with valid values.
		oParser = new parserFormula('CHISQ.INV.RT(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4.35146019, 'Test: Positive case: Area3D(2). 3D single-cell ranges with valid values.');
		// Case #13: Table(2). Structured references to table with valid values.
		oParser = new parserFormula('CHISQ.INV.RT(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 18.30703805, 'Test: Positive case: Table(2). Structured references to table with valid values.');
		// Case #14: Formula. CHISQ.INV.RT as part of another formula.
		oParser = new parserFormula('SUM(CHISQ.INV.RT(0.05,10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CHISQ.INV.RT(0.05,10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 19.30703805, 'Test: Positive case: Formula. CHISQ.INV.RT as part of another formula.');
		// Case #15: Number(2). Probability close to 0.
		oParser = new parserFormula('CHISQ.INV.RT(0.000001,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.000001,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 65.42068104, 'Test: Positive case: Number(2). Probability close to 0.');
		// Case #16: Number(2). Probability close to 1.
		oParser = new parserFormula('CHISQ.INV.RT(0.999999,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.999999,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 6.200293738, 'Test: Positive case: Number(2). Probability close to 1.');
		// Case #17: Number(2). Fractional degrees of freedom (should be truncated to 2).
		oParser = new parserFormula('CHISQ.INV.RT(0.1,2.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,2.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.605170186, 'Test: Positive case: Number(2). Fractional degrees of freedom (should be truncated to 2).');
		// Case #18: Number(2). Large degrees of freedom value.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 1057.723901, 'Test: Positive case: Number(2). Large degrees of freedom value.');
		// Case #19: Formula(2). Nested formulas for both arguments.
		oParser = new parserFormula('CHISQ.INV.RT(SQRT(0.01),ABS(10))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(SQRT(0.01),ABS(10)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 15.98717917, 'Test: Positive case: Formula(2). Nested formulas for both arguments.');
		// Case #20: Number, Formula. Numeric probability and formula for degrees of freedom.
		oParser = new parserFormula('CHISQ.INV.RT(0.05,INT(2.7))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.05,INT(2.7)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 5.991464547, 'Test: Positive case: Number, Formula. Numeric probability and formula for degrees of freedom.');
		// Case #21: Formula, Number. Formula for probability and numeric degrees of freedom.
		oParser = new parserFormula('CHISQ.INV.RT(ROUND(0.045,2),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(ROUND(0.045,2),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 18.30703805, 'Test: Positive case: Formula, Number. Formula for probability and numeric degrees of freedom.');
		// Case #22: Number(2). Minimum allowed degrees of freedom.
		oParser = new parserFormula('CHISQ.INV.RT(0.05,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.05,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.841458821, 'Test: Positive case: Number(2). Minimum allowed degrees of freedom.');
		// Case #23: Formula, Number. DATE formula converted to number for probability.
		oParser = new parserFormula('CHISQ.INV.RT(DATE(2025,1,1)/1000000,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(DATE(2025,1,1)/1000000,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 11.30494775, 'Test: Positive case: Formula, Number. DATE formula converted to number for probability.');
		// Case #24: Number, Formula. TIME formula converted to number for degrees of freedom.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,TIME(12,0,0)*100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,TIME(12,0,0)*100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 63.16712101, 'Test: Positive case: Number, Formula. TIME formula converted to number for degrees of freedom.');
		// Case #25: Number(2). Degrees of freedom as fractional number (should be truncated to 100).
		oParser = new parserFormula('CHISQ.INV.RT(0.05,100.9999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.05,100.9999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 124.3421134, 'Test: Positive case: Number(2). Degrees of freedom as fractional number (should be truncated to 100).');
		// Case #26: Number(2). Degrees of freedom slightly above 1 (should be truncated to 1).
		oParser = new parserFormula('CHISQ.INV.RT(0.5,1.00001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.5,1.00001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Positive case: Number(2). Degrees of freedom slightly above 1 (should be truncated to 1).');
		// Case #27: Number, Boolean. Boolean TRUE (1) for degrees of freedom.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.705543454, 'Test: Positive case: Number, Boolean. Boolean TRUE (1) for degrees of freedom.');
		// Case #28: Number, Formula. Conditional formula for degrees of freedom.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,IF(TRUE,5,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,IF(TRUE,5,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 9.2363569, 'Test: Positive case: Number, Formula. Conditional formula for degrees of freedom.');
		// Case #29: Formula, Number. Conditional formula for probability.
		oParser = new parserFormula('CHISQ.INV.RT(IF(TRUE,0.1,0.9),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(IF(TRUE,0.1,0.9),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 9.2363569, 'Test: Positive case: Formula, Number. Conditional formula for probability.');
		// Case #30: Array(2). Arrays with multiple valid elements.
		oParser = new parserFormula('CHISQ.INV.RT({0.1,0.2},{5,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT({0.1,0.2},{5,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 9.2363569, 'Test: Positive case: Array(2). Arrays with multiple valid elements.');
		// Case #31: Area(2). Multi-cell ranges with valid values.
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV.RT(A106:A107,A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(A106:A107,A108:A109) is parsed.');
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 4.351460191095526, 'Test: Positive case: Area(2). Multi-cell ranges with valid values.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 18.30703805327515, 'Test: Positive case: Area(2). Multi-cell ranges with valid values.');
		// Case #32: Area3D(2). 3D multi-cell ranges with valid values.
		oParser = new parserFormula('CHISQ.INV.RT(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(2). 3D multi-cell ranges with valid values.');
		// Case #33: Boolean, Number. Boolean TRUE (1) for probability is equal to maximum allowed value (may return very small number).
		oParser = new parserFormula('CHISQ.INV.RT(TRUE,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(TRUE,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean, Number. Boolean TRUE (1) for probability is equal to maximum allowed value (may return very small number).');
		// Case #34: Number(2). Probability equal to 1 returns 0 or very small value.
		oParser = new parserFormula('CHISQ.INV.RT(1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Probability equal to 1 returns 0 or very small value.');

		// Negative cases:

		// Case #1: Number(2). Negative probability returns #NUM! error.
		oParser = new parserFormula('CHISQ.INV.RT(-0.1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(-0.1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative probability returns #NUM! error.');
		// Case #2: Number(2). Probability greater than 1 returns #NUM! error.
		oParser = new parserFormula('CHISQ.INV.RT(1.1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(1.1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Probability greater than 1 returns #NUM! error.');
		// Case #3: Number(2). Degrees of freedom less than 1 returns #NUM! error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Degrees of freedom less than 1 returns #NUM! error.');
		// Case #4: Number(2). Degrees of freedom equal to 0 returns #NUM! error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Degrees of freedom equal to 0 returns #NUM! error.');
		// Case #5: String, Number. Non-numeric string for probability returns #VALUE! error.
		oParser = new parserFormula('CHISQ.INV.RT("abc",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT("abc",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string for probability returns #VALUE! error.');
		// Case #6: Number, String. Non-numeric string for degrees of freedom returns #VALUE! error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for degrees of freedom returns #VALUE! error.');
		// Case #7: Empty, Number. Empty cell for probability returns #VALUE! error.
		oParser = new parserFormula('CHISQ.INV.RT(,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty cell for probability returns #VALUE! error.');
		// Case #8: Number, Empty. Empty cell for degrees of freedom returns #VALUE! error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty. Empty cell for degrees of freedom returns #VALUE! error.');
		// Case #9: Error, Number. #N/A error for probability propagates the error.
		oParser = new parserFormula('CHISQ.INV.RT(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. #N/A error for probability propagates the error.');
		// Case #10: Number, Error. #N/A error for degrees of freedom propagates the error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. #N/A error for degrees of freedom propagates the error.');
		// Case #11: Number, Boolean. Boolean FALSE (0) for degrees of freedom returns #NUM! error (less than minimum 1).
		oParser = new parserFormula('CHISQ.INV.RT(0.1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Boolean. Boolean FALSE (0) for degrees of freedom returns #NUM! error (less than minimum 1).');
		// Case #12: Area, Number. Multi-cell range containing invalid data for probability (text or error) returns #VALUE! error.
		oParser = new parserFormula('CHISQ.INV.RT(A104:A105,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(A104:A105,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell range containing invalid data for probability (text or error) returns #VALUE! error.');
		// Case #13: Number, Area. Multi-cell range containing invalid data for degrees of freedom (text or error) returns #VALUE! error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Multi-cell range containing invalid data for degrees of freedom (text or error) returns #VALUE! error.');
		// Case #14: Array, Number. Array with out-of-range probability values returns #NUM! error.
		oParser = new parserFormula('CHISQ.INV.RT({-0.1,1.1},10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT({-0.1,1.1},10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Array with out-of-range probability values returns #NUM! error.');
		// Case #15: Number, Array. Array with invalid degrees of freedom values (less than 1) returns #NUM! error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,{0,-5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,{0,-5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Array. Array with invalid degrees of freedom values (less than 1) returns #NUM! error.');
		// Case #16: Name, Number. Named range containing invalid data for probability (mixed or text values) returns #VALUE! error.
		oParser = new parserFormula('CHISQ.INV.RT(TestNameArea,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(TestNameArea,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number. Named range containing invalid data for probability (mixed or text values) returns #VALUE! error.');
		// Case #17: Number, Name. Named range containing invalid data for degrees of freedom (mixed or text values) returns #VALUE! error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name. Named range containing invalid data for degrees of freedom (mixed or text values) returns #VALUE! error.');
		// Case #18: Area3D, Number. 3D range containing invalid data for probability (text or error) returns #VALUE! error.
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV.RT(Sheet2!A5:A6,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(Sheet2!A5:A6,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D range containing invalid data for probability (text or error) returns #VALUE! error.');
		// Case #19: Number, Area3D. 3D range containing invalid data for degrees of freedom (text or error) returns #VALUE! error.
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV.RT(0.1,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,Sheet2!A5:A6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area3D. 3D range containing invalid data for degrees of freedom (text or error) returns #VALUE! error.');
		// Case #20: Number(2). Probability equal to 0 returns #NUM! error or infinity.
		oParser = new parserFormula('CHISQ.INV.RT(0,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Probability equal to 0 returns #NUM! error or infinity.');
		// Case #21: Formula(2). Formula returning #NUM! error for probability propagates the error.
		oParser = new parserFormula('CHISQ.INV.RT(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). Formula returning #NUM! error for probability propagates the error.');
		// Case #22: Number, Formula. Formula returning #NUM! error for degrees of freedom propagates the error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Formula returning #NUM! error for degrees of freedom propagates the error.');
		// Case #23: Number(2). Negative degrees of freedom returns #NUM! error.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,-10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,-10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative degrees of freedom returns #NUM! error.');
		// Case #24: Number, Formula. Testing entire column as an argument.
		oParser = new parserFormula('CHISQ.INV.RT(MAX(M:M),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(MAX(M:M),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Testing entire column as an argument.');
		// Case #25: Number, Formula. Testing entire row as an argument.
		oParser = new parserFormula('CHISQ.INV.RT(0.1,MAX(100:100))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.1,MAX(100:100)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6.251388631170324, 'Test: Negative case: Number, Formula. Testing entire row as an argument.');

		// Bounded cases:

		// Case #1: Number(2). Minimum probability close to 0 and minimum degrees of freedom.
		oParser = new parserFormula('CHISQ.INV.RT(1E-10,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(1E-10,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 41.821456, 'Test: Bounded case: Number(2). Minimum probability close to 0 and minimum degrees of freedom.');
		// Case #2: Number(2). Maximum probability close to 1 and minimum degrees of freedom.
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV.RT(0.999999999999999,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.999999999999999,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.56829e-30, 'Test: Bounded case: Number(2). Maximum probability close to 1 and minimum degrees of freedom.');
		// Case #3: Number(2). Minimum probability close to 0 and maximum degrees of freedom.
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV.RT(1E-10,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(1E-10,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.0003e+307, 'Test: Bounded case: Number(2). Minimum probability close to 0 and maximum degrees of freedom.');
		// Case #4: Number(2). Maximum probability close to 1 and maximum degrees of freedom.
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV.RT(0.999999999999999,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.999999999999999,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.0003e+307, 'Test: Bounded case: Number(2). Maximum probability close to 1 and maximum degrees of freedom.');
		// Case #5: Number(2). Probability 0.5 and minimum degrees of freedom.
		oParser = new parserFormula('CHISQ.INV.RT(0.5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.454936423, 'Test: Bounded case: Number(2). Probability 0.5 and minimum degrees of freedom.');
		// Case #6: Number(2). Probability 0.5 and maximum degrees of freedom.
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV.RT(0.5,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.5,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.0003e+307, 'Test: Bounded case: Number(2). Probability 0.5 and maximum degrees of freedom.');
		// Case #7: Number(2). Probability close to minimum allowed value and average degrees of freedom.
		oParser = new parserFormula('CHISQ.INV.RT(0.000000000000001,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.000000000000001,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 93.66879161, 'Test: Bounded case: Number(2). Probability close to minimum allowed value and average degrees of freedom.');
		// Case #8: Number(2). Probability and degrees of freedom close to minimum allowed values.
		// Different result with MS
		oParser = new parserFormula('CHISQ.INV.RT(0.000000000000001,1.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.INV.RT(0.000000000000001,1.000000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 64.43203897, 'Test: Bounded case: Number(2). Probability and degrees of freedom close to minimum allowed values.');

		// Need to fix: all tests under "?" mark

		testArrayFormula2(assert, "CHISQ.INV.RT", 2, 2);
	});

	QUnit.test("Test: \"CHISQ.TEST\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A2").setValue("58");
		ws.getRange2("A3").setValue("11");
		ws.getRange2("A4").setValue("10");
		ws.getRange2("A5").setValue("x");
		ws.getRange2("A6").setValue("45.35");
		ws.getRange2("A7").setValue("17.56");
		ws.getRange2("A8").setValue("16.09");

		ws.getRange2("B2").setValue("35");
		ws.getRange2("B3").setValue("25");
		ws.getRange2("B4").setValue("23");
		ws.getRange2("B5").setValue("x");
		ws.getRange2("B6").setValue("47.65");
		ws.getRange2("B7").setValue("18.44");
		ws.getRange2("B8").setValue("16.91");
		ws.getRange2("A100").setValue("5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("B100").setValue("50");
		ws.getRange2("B101").setValue("30");
		ws.getRange2("A102").setValue("35");
		ws.getRange2("A103").setValue("25");
		ws.getRange2("A104").setValue("23");
		ws.getRange2("A105").setValue("45.35");
		ws.getRange2("A106").setValue("17.56");
		ws.getRange2("A107").setValue("16.09");
		ws.getRange2("A108").setValue("47.65");
		ws.getRange2("A109").setValue("18.44");
		ws.getRange2("A110").setValue("16.91");
		ws.getRange2("B102").setValue("text");
		ws.getRange2("B103").setValue("test");
		ws.getRange2("B104").setValue("test");
		ws.getRange2("B105").setValue("text");
		ws.getRange2("B106").setValue("TRUE");
		ws.getRange2("B107").setValue("FALSE");
		ws.getRange2("B108").setValue("0");
		ws.getRange2("B109").setValue("0");
		// Table type. Use A601:L6**
		getTableType(599, 0, 601, 1);
		ws.getRange2("A601").setValue("45.35"); // Column1
		ws.getRange2("A602").setValue("17.56"); // Column1
		ws.getRange2("B601").setValue("47.65"); // Column2
		ws.getRange2("B602").setValue("18.44"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("35");
		ws2.getRange2("A2").setValue("25");
		ws2.getRange2("A3").setValue("23");
		ws2.getRange2("A4").setValue("10");
		ws2.getRange2("B1").setValue("58");
		ws2.getRange2("B2").setValue("11");
		ws2.getRange2("B3").setValue("35");
		ws2.getRange2("B4").setValue("25");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("-1"); // TestName
		ws.getRange2("A202").setValue("-2"); // TestName1
		ws.getRange2("A206").setValue("58"); // TestNameArea
		ws.getRange2("A207").setValue("11"); // TestNameArea
		ws.getRange2("A208").setValue("35"); // TestNameArea2
		ws.getRange2("B208").setValue("25"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("50") // TestName3D
		ws2.getRange2("A12").setValue("30") // TestName3D1
		ws2.getRange2("A16").setValue("58"); // TestNameArea3D
		ws2.getRange2("A17").setValue("11"); // TestNameArea3D
		ws2.getRange2("A18").setValue("35"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("25"); // TestNameArea3D2


		// Positive cases:

		// Case #1: Area(2). The χ2 statistic for the data above is 16.16957 with 2 degrees of freedom.
		oParser = new parserFormula('CHISQ.TEST(A2:B4,A6:B8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A2:B4,A6:B8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0003082, 'Test: Positive case: Area(2). The χ2 statistic for the data above is 16.16957 with 2 degrees of freedom.');
		// Case #2: Area(2). Basic positive case with 1x1 ranges of numbers.
		oParser = new parserFormula('CHISQ.TEST(A100:A101,B100:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A101,B100:B101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.18239e-13, 'Test: Positive case: Area(2). Basic positive case with 1x1 ranges of numbers.');
		// Case #3: Area(2). Basic positive case with 1D ranges (vector).
		oParser = new parserFormula('CHISQ.TEST(A102:A104,A105:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A102:A104,A105:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.014393575, 'Test: Positive case: Area(2). Basic positive case with 1D ranges (vector).');
		// Case #4: Area(2). Basic positive case with 1-row ranges.
		oParser = new parserFormula('CHISQ.TEST(A100:B100,A101:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:B100,A101:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10) - 0, 0.0000691731, 'Test: Positive case: Area(2). Basic positive case with 1-row ranges.');
		// Case #5: Area(2). Ranges with float numbers.
		oParser = new parserFormula('CHISQ.TEST(A100:A103,A104:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A103,A104:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.93376e-15, 'Test: Positive case: Area(2). Ranges with float numbers.');
		// Case #6: Area,Array. Expected_range is an array of numeric strings.
		oParser = new parserFormula('CHISQ.TEST(A100:B101,{45.35,47.65;17.56,18.44})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:B101,{45.35,47.65;17.56,18.44}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.33059e-28, 'Test: Positive case: Area,Array. Expected_range is an array of numeric strings.');
		// Case #7: Name(2). Both arguments are named ranges (area).
		oParser = new parserFormula('CHISQ.TEST(TestNameArea,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(TestNameArea,TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.000001659, 'Test: Positive case: Name(2). Both arguments are named ranges (area).');
		// Case #8: Formula, Area. First argument is a nested formula with ABS function.
		oParser = new parserFormula('CHISQ.TEST(ABS(A100:A101),A102:A103)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(ABS(A100:A101),A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/*.toFixed(8) - 0*/, 3.8181940490842206e-9, 'Test: Positive case: Formula, Area. First argument is a nested formula with ABS function.');
		// Case #9: Area, Formula. Second argument is a nested formula with ROUND function.
		oParser = new parserFormula('CHISQ.TEST(A100:A101,ROUND(A104:A105,0))', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:A3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A101,ROUND(A104:A105,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 1.2995722274033905e-10, 'Test: Positive case: Area, Formula. Second argument is a nested formula with ROUND function.');
		// Case #10: Area(2). Both arguments are arrays of numbers.
		oParser = new parserFormula('CHISQ.TEST({58;11;10},{45.35;17.56;16.09})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST({58;11;10},{45.35;17.56;16.09}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.01588856, 'Test: Positive case: Area(2). Both arguments are arrays of numbers.');
		// Case #11: Table(2). Arguments are references to Table columns.
		oParser = new parserFormula('CHISQ.TEST(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.695672025, 'Test: Positive case: Table(2). Arguments are references to Table columns.');
		// Case #12: Formula. CHISQ.TEST is a part of another formula (IF).
		oParser = new parserFormula('IF(CHISQ.TEST(A100:B100,A101:B101)>0.05,"OK","FAIL")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(CHISQ.TEST(A100:B100,A101:B101)>0.05,"OK","FAIL") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FAIL', 'Test: Positive case: Formula. CHISQ.TEST is a part of another formula (IF).');
		// Case #13: Area3D(2). Both arguments are vertical 3D ranges.
		oParser = new parserFormula('CHISQ.TEST(Sheet2!A1:A4, Sheet2!B1:B4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(Sheet2!A1:A4, Sheet2!B1:B4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 1e-8, 'Test: Positive case: Area3D(2). Both arguments are vertical 3D ranges.');
		// Case #14: Area3D(2). Arguments are 3D references to columns.
		oParser = new parserFormula('CHISQ.TEST(Sheet2!A1:A3,Sheet2!B1:B3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(Sheet2!A1:A3,Sheet2!B1:B3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 1.8e-7, 'Test: Positive case: Area3D(2). Arguments are 3D references to columns.');
		// Case #15: Name3D(2). Second argument is a vertical 3D Name with area.
		oParser = new parserFormula('CHISQ.TEST(TestNameArea3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(TestNameArea3D,TestNameArea3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.000001659, 'Test: Positive case: Name3D(2). Second argument is a vertical 3D Name with area.');

		// Negative cases:
		// Case #1: Area(2). Actual range contains text, expecting error.
		oParser = new parserFormula('CHISQ.TEST(B102:B103,B100:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(B102:B103,B100:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Actual range contains text, expecting error.');
		// Case #2: Area(2). Expected range contains text, expecting error.
		oParser = new parserFormula('CHISQ.TEST(A100:A101,B104:B105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A101,B104:B105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Expected range contains text, expecting error.');
		// Case #3: Area(2). Actual range contains boolean, expecting error.
		oParser = new parserFormula('CHISQ.TEST(B106:B107,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(B106:B107,A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Actual range contains boolean, expecting error.');
		// Case #4: Area(2). Expected range contains boolean, expecting error.
		oParser = new parserFormula('CHISQ.TEST(A100:A101,B106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A101,B106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Expected range contains boolean, expecting error.');
		// Case #5: Area(2). Expected range contains zero, expecting #DIV/0! error.
		oParser = new parserFormula('CHISQ.TEST(B108:B109,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(B108:B109,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.000108, 'Test: Negative case: Area(2). Expected range contains zero, expecting #DIV/0! error.');
		// Case #6: Area(2). Expected range contains a negative number, expecting #DIV/0! error.
		oParser = new parserFormula('CHISQ.TEST(A100:A101,B108:B109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A101,B108:B109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Expected range contains a negative number, expecting #DIV/0! error.');
		// Case #7: Area(2). Ranges have different dimensions, expecting #N/A error.
		oParser = new parserFormula('CHISQ.TEST(A100:B100,A101:B102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:B100,A101:B102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area(2). Ranges have different dimensions, expecting #N/A error.');
		// Case #8: Area(2). Ranges have different number of data points, expecting #N/A error.
		oParser = new parserFormula('CHISQ.TEST(A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A102,A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area(2). Ranges have different number of data points, expecting #N/A error.');
		// Case #9: Name(2). Named ranges are single cells (r=1, c=1), expecting #N/A error.
		oParser = new parserFormula('CHISQ.TEST(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name(2). Named ranges are single cells (r=1, c=1), expecting #N/A error.');
		// Case #10: Area, Empty. Missing second argument, expecting error.
		oParser = new parserFormula('CHISQ.TEST(A100:A101,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A101,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Empty. Missing second argument, expecting error.');
		// Case #11: Empty, Area. Missing first argument, expecting error.
		oParser = new parserFormula('CHISQ.TEST(,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(,A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty, Area. Missing first argument, expecting error.');
		// Case #12: Array, Area. Actual range contains an error, expecting propagated error.
		oParser = new parserFormula('CHISQ.TEST({#N/A, #NULL!},A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST({#N/A, #NULL!},A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Area. Actual range contains an error, expecting propagated error.');
		// Case #13: Area, Array. Expected range contains an error, expecting propagated error.
		oParser = new parserFormula('CHISQ.TEST(A100:A101,{#N/A, #NULL!})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A101,{#N/A, #NULL!}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area, Array. Expected range contains an error, expecting propagated error.');
		// Case #14: Formula, Area. First argument is a formula that returns an error.
		oParser = new parserFormula('CHISQ.TEST(SQRT(-1),A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(SQRT(-1),A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Area. First argument is a formula that returns an error.');
		// Case #15: Number(2). Arguments are not ranges, expecting #VALUE! error.
		oParser = new parserFormula('CHISQ.TEST(1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2). Arguments are not ranges, expecting #VALUE! error.');
		// Case #16: String(2). Arguments are text strings, expecting #VALUE! error.
		oParser = new parserFormula('CHISQ.TEST("text","text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST("text","text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String(2). Arguments are text strings, expecting #VALUE! error.');
		// Case #17: Area, Formula. Second argument is a single value (date) not a range, expecting #VALUE! error.
		oParser = new parserFormula('CHISQ.TEST(A100:A101,DATE(2020,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:A101,DATE(2020,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area, Formula. Second argument is a single value (date) not a range, expecting #VALUE! error.');
		// Case #18: Formula, Area. First argument is a single value (time) not a range, expecting #VALUE! error.
		oParser = new parserFormula('CHISQ.TEST(TIME(12,0,0),A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(TIME(12,0,0),A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula, Area. First argument is a single value (time) not a range, expecting #VALUE! error.');
		// Case #19: Area(2). Ranges have different number of columns, expecting #N/A error.
		oParser = new parserFormula('CHISQ.TEST(A100:B101,A102:C103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100:B101,A102:C103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area(2). Ranges have different number of columns, expecting #N/A error.');
		// Case #20: Area(2). Arguments are entire columns, which may contain non-numeric headers or empty cells leading to errors.
		oParser = new parserFormula('CHISQ.TEST(A:A,B:B)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A:A,B:B) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Arguments are entire columns, which may contain non-numeric headers or empty cells leading to errors.');
		// Case #21: Area(2). Arguments are entire rows. Similar to columns, this is not a valid use case for statistical comparison.
		oParser = new parserFormula('CHISQ.TEST(100:100,101:101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(100:100,101:101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.0000018833218276141848, 'Test: Negative case: Area(2). Arguments are entire rows. Similar to columns, this is not a valid use case for statistical comparison.');
		// Case #22: Area, Array. Second argument is an array of numeric strings.
		oParser = new parserFormula('CHISQ.TEST(A104:A106,{"45.35";"17.56";"16.09"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A104:A106,{"45.35";"17.56";"16.09"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Array. Second argument is an array of numeric strings.');
		// Case #23: Reference link. Using single cell reference links within ranges (implicitly).
		oParser = new parserFormula('CHISQ.TEST(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(A100, A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link. Using single cell reference links within ranges (implicitly).');
		// Case #24: Name3D. Single cell  c = 1 r =1.
		oParser = new parserFormula('CHISQ.TEST(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST(TestName3D,TestName3D1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name3D. Single cell  c = 1 r =1.');

		// Bounded cases:

		// Case #1: Array(2). Maximum valid number for calculation. Expected result is 0 because Aij=Eij.
		oParser = new parserFormula('CHISQ.TEST({1E+307,1E+307},{1E+307,1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST({1E+307,1E+307},{1E+307,1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array(2). Maximum valid number for calculation. Expected result is 0 because Aij=Eij.');
		// Case #2: Array(2). Minimum valid positive number. Expected result is 0 because Aij=Eij.
		oParser = new parserFormula('CHISQ.TEST({2.225E-307,1},{2.225E-307,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHISQ.TEST({2.225E-307,1},{2.225E-307,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array(2). Minimum valid positive number. Expected result is 0 because Aij=Eij.');

		// Need to fix: all tests under "?" mark 

	});

	QUnit.test("Test: \"CHITEST\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A2").setValue("58");
		ws.getRange2("A3").setValue("11");
		ws.getRange2("A4").setValue("10");
		ws.getRange2("A5").setValue("x");
		ws.getRange2("A6").setValue("45.35");
		ws.getRange2("A7").setValue("17.56");
		ws.getRange2("A8").setValue("16.09");

		ws.getRange2("B2").setValue("35");
		ws.getRange2("B3").setValue("25");
		ws.getRange2("B4").setValue("23");
		ws.getRange2("B5").setValue("x");
		ws.getRange2("B6").setValue("47.65");
		ws.getRange2("B7").setValue("18.44");
		ws.getRange2("B8").setValue("16.91");
		ws.getRange2("A100").setValue("5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("B100").setValue("50");
		ws.getRange2("B101").setValue("30");
		ws.getRange2("A102").setValue("35");
		ws.getRange2("A103").setValue("25");
		ws.getRange2("A104").setValue("23");
		ws.getRange2("A105").setValue("45.35");
		ws.getRange2("A106").setValue("17.56");
		ws.getRange2("A107").setValue("16.09");
		ws.getRange2("A108").setValue("47.65");
		ws.getRange2("A109").setValue("18.44");
		ws.getRange2("A110").setValue("16.91");
		ws.getRange2("B102").setValue("text");
		ws.getRange2("B103").setValue("test");
		ws.getRange2("B104").setValue("test");
		ws.getRange2("B105").setValue("text");
		ws.getRange2("B106").setValue("TRUE");
		ws.getRange2("B107").setValue("FALSE");
		ws.getRange2("B108").setValue("0");
		ws.getRange2("B109").setValue("0");
		// Table type. Use A601:L6**
		getTableType(599, 0, 601, 1);
		ws.getRange2("A601").setValue("45.35"); // Column1
		ws.getRange2("A602").setValue("17.56"); // Column1
		ws.getRange2("B601").setValue("47.65"); // Column2
		ws.getRange2("B602").setValue("18.44"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("35");
		ws2.getRange2("A2").setValue("25");
		ws2.getRange2("A3").setValue("23");
		ws2.getRange2("A4").setValue("10");
		ws2.getRange2("B1").setValue("58");
		ws2.getRange2("B2").setValue("11");
		ws2.getRange2("B3").setValue("35");
		ws2.getRange2("B4").setValue("25");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("-1"); // TestName
		ws.getRange2("A202").setValue("-2"); // TestName1
		ws.getRange2("A206").setValue("58"); // TestNameArea
		ws.getRange2("A207").setValue("11"); // TestNameArea
		ws.getRange2("A208").setValue("35"); // TestNameArea2
		ws.getRange2("B208").setValue("25"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("50") // TestName3D
		ws2.getRange2("A12").setValue("30") // TestName3D1
		ws2.getRange2("A16").setValue("58"); // TestNameArea3D
		ws2.getRange2("A17").setValue("11"); // TestNameArea3D
		ws2.getRange2("A18").setValue("35"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("25"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Area(2). The χ2 statistic for the data above is 16.16957 with 2 degrees of freedom.
		oParser = new parserFormula('CHITEST(A2:B4,A6:B8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A2:B4,A6:B8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0003082, 'Test: Positive case: Area(2). The χ2 statistic for the data above is 16.16957 with 2 degrees of freedom.');
		// Case #2: Area(2). Basic positive case with 1x1 ranges of numbers.
		oParser = new parserFormula('CHITEST(A100:A101,B100:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A101,B100:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.1823854459807877e-13, 'Test: Positive case: Area(2). Basic positive case with 1x1 ranges of numbers.');
		// Case #3: Area(2). Basic positive case with 1D ranges (vector).
		oParser = new parserFormula('CHITEST(A102:A104,A105:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A102:A104,A105:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.014393575, 'Test: Positive case: Area(2). Basic positive case with 1D ranges (vector).');
		// Case #4: Area(2). Basic positive case with 1-row ranges.
		oParser = new parserFormula('CHITEST(A100:B100,A101:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:B100,A101:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10) - 0, 0.0000691731, 'Test: Positive case: Area(2). Basic positive case with 1-row ranges.');
		// Case #5: Area(2). Ranges with float numbers.
		oParser = new parserFormula('CHITEST(A100:A103,A104:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A103,A104:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.93376e-15, 'Test: Positive case: Area(2). Ranges with float numbers.');
		// Case #6: Area,Array. Expected_range is an array of numeric strings.
		oParser = new parserFormula('CHITEST(A100:B101,{45.35,47.65;17.56,18.44})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:B101,{45.35,47.65;17.56,18.44}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.33059e-28, 'Test: Positive case: Area,Array. Expected_range is an array of numeric strings.');
		// Case #7: Name(2). Both arguments are named ranges (area).
		oParser = new parserFormula('CHITEST(TestNameArea,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(TestNameArea,TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.000001659, 'Test: Positive case: Name(2). Both arguments are named ranges (area).');
		// Case #8: Formula, Area. First argument is a nested formula with ABS function.
		oParser = new parserFormula('CHITEST(ABS(A100:A101),A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(ABS(A100:A101),A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(8) - 0*/, 3.81819e-9, 'Test: Positive case: Formula, Area. First argument is a nested formula with ABS function.');
		// Case #9: Area, Formula. Second argument is a nested formula with ROUND function.
		oParser = new parserFormula('CHITEST(A100:A101,ROUND(A104:A105,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A101,ROUND(A104:A105,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 1.29957e-10, 'Test: Positive case: Area, Formula. Second argument is a nested formula with ROUND function.');
		// Case #10: Area(2). Both arguments are arrays of numbers.
		oParser = new parserFormula('CHITEST({58;11;10},{45.35;17.56;16.09})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST({58;11;10},{45.35;17.56;16.09}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.01588856, 'Test: Positive case: Area(2). Both arguments are arrays of numbers.');
		// Case #11: Table(2). Arguments are references to Table columns.
		oParser = new parserFormula('CHITEST(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.695672025, 'Test: Positive case: Table(2). Arguments are references to Table columns.');
		// Case #12: Formula. CHITEST is a part of another formula (IF).
		oParser = new parserFormula('IF(CHITEST(A100:B100,A101:B101)>0.05,"OK","FAIL")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(CHITEST(A100:B100,A101:B101)>0.05,"OK","FAIL") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FAIL', 'Test: Positive case: Formula. CHITEST is a part of another formula (IF).');
		// Case #13: Area3D(2). Both arguments are vertical 3D ranges.
		oParser = new parserFormula('CHITEST(Sheet2!A1:A4, Sheet2!B1:B4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(Sheet2!A1:A4, Sheet2!B1:B4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0382194236153072e-8, 'Test: Positive case: Area3D(2). Both arguments are vertical 3D ranges.');
		// Case #14: Area3D(2). Arguments are 3D references to columns.
		oParser = new parserFormula('CHITEST(Sheet2!A1:A3,Sheet2!B1:B3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(Sheet2!A1:A3,Sheet2!B1:B3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8067272458568037e-7, 'Test: Positive case: Area3D(2). Arguments are 3D references to columns.');
		// Case #15: Name3D(2). Second argument is a vertical 3D Name with area.
		oParser = new parserFormula('CHITEST(TestNameArea3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(TestNameArea3D,TestNameArea3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(9) - 0*/, 0.000001659, 'Test: Positive case: Name3D(2). Second argument is a vertical 3D Name with area.');

		// Negative cases:

		// Case #1: Area(2). Actual range contains text, expecting error.
		oParser = new parserFormula('CHITEST(B102:B103,B100:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(B102:B103,B100:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Actual range contains text, expecting error.');
		// Case #2: Area(2). Expected range contains text, expecting error.
		oParser = new parserFormula('CHITEST(A100:A101,B103:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A101,B103:B104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Expected range contains text, expecting error.');
		// Case #3: Area(2). Actual range contains boolean, expecting error.
		oParser = new parserFormula('CHITEST(B106:B107,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(B106:B107,A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Actual range contains boolean, expecting error.');
		// Case #4: Area(2). Expected range contains boolean, expecting error.
		oParser = new parserFormula('CHITEST(A100:A101,B106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A101,B106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Expected range contains boolean, expecting error.');
		// Case #5: Area(2). Expected range contains zero, expecting #DIV/0! error.
		oParser = new parserFormula('CHITEST(B108:B109,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(B108:B109,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Expected range contains zero, expecting #DIV/0! error.');
		// Case #6: Area(2). Expected range contains a negative number, expecting #DIV/0! error.
		oParser = new parserFormula('CHITEST(A100:A101,B108:B109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A101,B108:B109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Expected range contains a negative number, expecting #DIV/0! error.');
		// Case #7: Area(2). Ranges have different dimensions, expecting #N/A error.
		oParser = new parserFormula('CHITEST(A100:B100,A101:B102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:B100,A101:B102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area(2). Ranges have different dimensions, expecting #N/A error.');
		// Case #8: Area(2). Ranges have different number of data points, expecting #N/A error.
		oParser = new parserFormula('CHITEST(A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A102,A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area(2). Ranges have different number of data points, expecting #N/A error.');
		// Case #9: Name(2). Named ranges are single cells (r=1, c=1), expecting #N/A error.
		oParser = new parserFormula('CHITEST(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name(2). Named ranges are single cells (r=1, c=1), expecting #N/A error.');
		// Case #10: Area, Empty. Missing second argument, expecting error.
		oParser = new parserFormula('CHITEST(A100:A101,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A101,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Empty. Missing second argument, expecting error.');
		// Case #11: Empty, Area. Missing first argument, expecting error.
		oParser = new parserFormula('CHITEST(,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(,A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty, Area. Missing first argument, expecting error.');
		// Case #12: Array, Area. Actual range contains an error, expecting propagated error.
		oParser = new parserFormula('CHITEST({#N/A, #NULL!},A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST({#N/A, #NULL!},A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Area. Actual range contains an error, expecting propagated error.');
		// Case #13: Area, Array. Expected range contains an error, expecting propagated error.
		oParser = new parserFormula('CHITEST(A100:A101,{#N/A, #NULL!})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A101,{#N/A, #NULL!}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area, Array. Expected range contains an error, expecting propagated error.');
		// Case #14: Formula, Area. First argument is a formula that returns an error.
		oParser = new parserFormula('CHITEST(SQRT(-1),A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(SQRT(-1),A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Area. First argument is a formula that returns an error.');
		// Case #15: Number(2). Arguments are not ranges, expecting #VALUE! error.
		oParser = new parserFormula('CHITEST(1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2). Arguments are not ranges, expecting #VALUE! error.');
		// Case #16: String(2). Arguments are text strings, expecting #VALUE! error.
		oParser = new parserFormula('CHITEST("text","text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST("text","text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String(2). Arguments are text strings, expecting #VALUE! error.');
		// Case #17: Area, Formula. Second argument is a single value (date) not a range, expecting #VALUE! error.
		oParser = new parserFormula('CHITEST(A100:A101,DATE(2020,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:A101,DATE(2020,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area, Formula. Second argument is a single value (date) not a range, expecting #VALUE! error.');
		// Case #18: Formula, Area. First argument is a single value (time) not a range, expecting #VALUE! error.
		oParser = new parserFormula('CHITEST(TIME(12,0,0),A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(TIME(12,0,0),A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula, Area. First argument is a single value (time) not a range, expecting #VALUE! error.');
		// Case #19: Area(2). Ranges have different number of columns, expecting #N/A error.
		oParser = new parserFormula('CHITEST(A100:B101,A102:C103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100:B101,A102:C103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area(2). Ranges have different number of columns, expecting #N/A error.');
		// Case #20: Area(2). Arguments are entire columns, which may contain non-numeric headers or empty cells leading to errors.
		oParser = new parserFormula('CHITEST(A:A,B:B)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A:A,B:B) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). Arguments are entire columns, which may contain non-numeric headers or empty cells leading to errors.');
		// Case #21: Area(2). Arguments are entire rows. Similar to columns, this is not a valid use case for statistical comparison.
		oParser = new parserFormula('CHITEST(100:100,101:101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(100:100,101:101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.0000018833218276141848, 'Test: Negative case: Area(2). Arguments are entire rows. Similar to columns, this is not a valid use case for statistical comparison.');
		// Case #22: Area, Array. Second argument is an array of numeric strings.
		oParser = new parserFormula('CHITEST(A104:A106,{"45.35";"17.56";"16.09"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A104:A106,{"45.35";"17.56";"16.09"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Array. Second argument is an array of numeric strings.');
		// Case #23: Reference link. Using single cell reference links within ranges (implicitly).
		oParser = new parserFormula('CHITEST(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(A100, A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link. Using single cell reference links within ranges (implicitly).');
		// Case #24: Name3D. Single cell  c = 1 r =1.
		oParser = new parserFormula('CHITEST(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST(TestName3D,TestName3D1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name3D. Single cell  c = 1 r =1.');

		// Bounded cases:

		// Case #1: Array(2). Maximum valid number for calculation. Expected result is 0 because Aij=Eij.
		oParser = new parserFormula('CHITEST({1E+307,1E+307},{1E+307,1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST({1E+307,1E+307},{1E+307,1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array(2). Maximum valid number for calculation. Expected result is 0 because Aij=Eij.');
		// Case #2: Array(2). Minimum valid positive number. Expected result is 0 because Aij=Eij.
		oParser = new parserFormula('CHITEST({2.225E-307,1},{2.225E-307,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CHITEST({2.225E-307,1},{2.225E-307,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array(2). Minimum valid positive number. Expected result is 0 because Aij=Eij.');

		// Need to fix: error types diff, results diff from MS
		// Case #5: Area(2). Ranges with float numbers.
		// Case #6: Area,Array. Expected_range is an array of numeric strings.
		// Case #7: Name(2). Both arguments are named ranges (area).
		// Case #8: Formula, Area. First argument is a nested formula with ABS function.
		// Case #9: Area, Formula. Second argument is a nested formula with ROUND function.
		// Case #15: Name3D(2). Second argument is a vertical 3D Name with area.
		// Case #2: Area(2). Expected range contains text, expecting error.
		// Case #3: Area(2). Actual range contains boolean, expecting error.
		// Case #4: Area(2). Expected range contains boolean, expecting error.
		// Case #5: Area(2). Expected range contains zero, expecting #DIV/0! error.
		// Case #9: Name(2). Named ranges are single cells (r=1, c=1), expecting #N/A error.
		// Case #10: Area, Empty. Missing second argument, expecting error.
		// Case #11: Empty, Area. Missing first argument, expecting error.
		// Case #16: String(2). Arguments are text strings, expecting #VALUE! error.
		// Case #21: Area(2). Arguments are entire rows. Similar to columns, this is not a valid use case for statistical comparison
		// Case #22: Area, Array. Second argument is an array of numeric strings.
		// Case #23: Reference link. Using single cell reference links within ranges (implicitly).
		// Case #24: Name3D. Single cell  c = 1 r =1.

		testArrayFormula2(assert, "CHITEST", 2, 2, null, true);
	});

	QUnit.test("Test: \"CONFIDENCE\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.05");
		ws.getRange2("A101").setValue("2.5");
		ws.getRange2("A102").setValue("50");
		ws.getRange2("A103").setValue("2.5");
		ws.getRange2("A104").setValue("1");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("0.05"); // Column1
		ws.getRange2("B601").setValue("2.5"); // Column2
		ws.getRange2("C601").setValue("50"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.05");
		ws2.getRange2("A2").setValue("2.5");
		ws2.getRange2("A3").setValue("50");
		ws2.getRange2("A4").setValue("test");
		ws2.getRange2("A5").setValue("text");
		ws2.getRange2("A6").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.05"); // TestName
		ws.getRange2("A202").setValue("2.5"); // TestName1
		ws.getRange2("A203").setValue("50"); // TestName2
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.05") // TestName3D
		ws2.getRange2("A12").setValue("2.5") // TestName3D1
		ws2.getRange2("A13").setValue("50") // TestName3D2

		// Positive cases:

		// Case #1: Number(3). Alpha - 0.4, standart_dev - 5, size - 12
		oParser = new parserFormula('CONFIDENCE(0.4,5,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.4,5,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.214775614, 'Test: Positive case: Number(3). Alpha - 0.4, standart_dev - 5, size - 12');
		// Case #2: Number(3). Alpha - 0.75, standart_dev - 9, size - 7
		oParser = new parserFormula('CONFIDENCE(0.75,9,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.75,9,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.083909234, 'Test: Positive case: Number(3). Alpha - 0.75, standart_dev - 9, size - 7');
		// Case #3: Number(3). Basic valid numeric arguments. 3 of 3 arguments used.
		oParser = new parserFormula('CONFIDENCE(0.05,2,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.55436153, 'Test: Positive case: Number(3). Basic valid numeric arguments. 3 of 3 arguments used.');
		// Case #4: String, Number, Number. Alpha as numeric string converted to number.
		oParser = new parserFormula('CONFIDENCE("0.05",2.5,50.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE("0.05",2.5,50.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: String, Number, Number. Alpha as numeric string converted to number.');
		// Case #5: Number, String, Number. Std_dev as numeric string converted to number.
		oParser = new parserFormula('CONFIDENCE(0.05,"2.5",50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,"2.5",50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, String, Number. Std_dev as numeric string converted to number.');
		// Case #6: Number, Number, String. Size as numeric string converted to number.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,"50")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,"50") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, Number, String. Size as numeric string converted to number.');
		// Case #7: Formula. CONFIDENCE nested inside SUM (parent formula).
		oParser = new parserFormula('SUM(CONFIDENCE(0.05,2.5,50),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CONFIDENCE(0.05,2.5,50),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.692951912, 'Test: Positive case: Formula. CONFIDENCE nested inside SUM (parent formula).');
		// Case #8: Formula, Number, Number. Alpha produced by IF formula.
		oParser = new parserFormula('CONFIDENCE(IF(TRUE,0.05,0.1),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(IF(TRUE,0.05,0.1),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Formula, Number, Number. Alpha produced by IF formula.');
		// Case #9: Number, Formula, Number. Std_dev produced by ABS formula.
		oParser = new parserFormula('CONFIDENCE(0.05,ABS(-2.5),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,ABS(-2.5),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, Formula, Number. Std_dev produced by ABS formula.');
		// Case #10: Number, Number, Formula. Size produced by ROUND formula.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,ROUND(49.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,ROUND(49.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, Number, Formula. Size produced by ROUND formula.');
		// Case #11: Reference link(3). All arguments by single-cell references.
		oParser = new parserFormula('CONFIDENCE(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Reference link(3). All arguments by single-cell references.');
		// Case #12: Area(3). All arguments as single-cell areas.
		oParser = new parserFormula('CONFIDENCE(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Area(3). All arguments as single-cell areas.');
		// Case #13: Array(3). All arguments as single-element arrays.
		oParser = new parserFormula('CONFIDENCE({0.05},{2.5},{50})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE({0.05},{2.5},{50}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Array(3). All arguments as single-element arrays.');
		// Case #14: Name(3). All arguments via defined names.
		oParser = new parserFormula('CONFIDENCE(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Name(3). All arguments via defined names.');
		// Case #15: Name3D(3). All arguments via 3D defined names.
		oParser = new parserFormula('CONFIDENCE(TestName3D,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(TestName3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Name3D(3). All arguments via 3D defined names.');
		// Case #16: Ref3D(3). All arguments via 3D references.
		oParser = new parserFormula('CONFIDENCE(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Ref3D(3). All arguments via 3D references.');
		// Case #17: Area3D(3). All arguments as 3D single-cell areas.
		oParser = new parserFormula('CONFIDENCE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Area3D(3). All arguments as 3D single-cell areas.');
		// Case #18: Table(3). All arguments as structured table refs.
		oParser = new parserFormula('CONFIDENCE(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Table(3). All arguments as structured table refs.');
		// Case #19: Time, Number, Number. Alpha from Time fraction (0.5).
		oParser = new parserFormula('CONFIDENCE(TIME(12,0,0),2.5,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(TIME(12,0,0),2.5,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.307861042, 'Test: Positive case: Time, Number, Number. Alpha from Time fraction (0.5).');
		// Case #20: Number, Time, Number. Std_dev as Time fraction (>0).
		oParser = new parserFormula('CONFIDENCE(0.05,TIME(6,0,0),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,TIME(6,0,0),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.069295191, 'Test: Positive case: Number, Time, Number. Std_dev as Time fraction (>0).');
		// Case #21: Number, Time(2). Std_dev as Time fraction (>0).
		oParser = new parserFormula('CONFIDENCE(0.05,TIME(6,0,0),50+TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,TIME(6,0,0),50+TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.069295191, 'Test: Positive case: Number, Time(2). Std_dev as Time fraction (>0).');
		// Case #22: Number, Date, Number. Std_dev supplied as Date serial (>0).
		oParser = new parserFormula('CONFIDENCE(0.05,DATE(2025,1,1),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,DATE(2025,1,1),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 8948.803561, 'Test: Positive case: Number, Date, Number. Std_dev supplied as Date serial (>0).');
		// Case #23: Number, Number, Date. Size as Date serial (integer).
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.022931352, 'Test: Positive case: Number, Number, Date. Size as Date serial (integer).');
		// Case #24: Number, Boolean, Number. Std_dev using boolean arithmetic (TRUE->1).
		oParser = new parserFormula('CONFIDENCE(0.05,TRUE,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,TRUE,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.277180765, 'Test: Positive case: Number, Boolean, Number. Std_dev using boolean arithmetic (TRUE->1).');
		// Case #25: Number, Number, Boolean. Size using boolean arithmetic (TRUE->1).
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.899909961, 'Test: Positive case: Number, Number, Boolean. Size using boolean arithmetic (TRUE->1).');
		// Case #26: String, Formula, Reference link. Mixed: alpha string, std_dev formula, size ref.
		oParser = new parserFormula('CONFIDENCE("0.05",ABS(-2.5),A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE("0.05",ABS(-2.5),A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: String, Formula, Reference link. Mixed: alpha string, std_dev formula, size ref.');
		// Case #27: Reference link, String, Formula. Mixed: alpha ref, std_dev string, size formula.
		oParser = new parserFormula('CONFIDENCE(A100,"2.5",ROUND(49.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(A100,"2.5",ROUND(49.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Reference link, String, Formula. Mixed: alpha ref, std_dev string, size formula.');
		// Case #28: Number, Array, Number. Std_dev multi-element array
		oParser = new parserFormula('CONFIDENCE(0.05,{2.5,3.5},50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,{2.5,3.5},50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, Array, Number. Std_dev multi-element array');
		// Case #29: Array, Number, Number. Alpha multi-element array
		oParser = new parserFormula('CONFIDENCE({0.05,0.5},2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE({0.05,0.5},2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Array, Number, Number. Alpha multi-element array');
		// Case #30: Number(2), Array. Size multi-element array
		oParser = new parserFormula('CONFIDENCE(0.05, 2.5, {50,500})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05, 2.5, {50,500}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number(2), Array. Size multi-element array');

		// Negative cases:

		// Case #1: Number(3). Alpha = 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha = 0 => #NUM!.');
		// Case #2: Number(3). Alpha = 1 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(1,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(1,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha = 1 => #NUM!.');
		// Case #3: Number(3). Alpha <0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(-0.1,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(-0.1,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha <0 => #NUM!.');
		// Case #4: Number(3). Alpha >1 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(1.5,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(1.5,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha >1 => #NUM!.');
		// Case #5: Number(3). Std_dev =0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0.05,0,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,0,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Std_dev =0 => #NUM!.');
		// Case #6: Number(3). Std_dev <0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0.05,-2,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,-2,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Std_dev <0 => #NUM!.');
		// Case #7: Number(3). Size =0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Size =0 => #NUM!.');
		// Case #8: Number(3). Size <0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,-10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,-10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Size <0 => #NUM!.');
		// Case #9: String, Number, Number. Alpha non-numeric => #VALUE!.
		oParser = new parserFormula('CONFIDENCE("abc",2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE("abc",2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Number. Alpha non-numeric => #VALUE!.');
		// Case #10: Number, String, Number. Std_dev non-numeric => #VALUE!.
		oParser = new parserFormula('CONFIDENCE(0.05,"xyz",50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,"xyz",50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number. Std_dev non-numeric => #VALUE!.');
		// Case #11: Number, Number, String. Size non-numeric => #VALUE!.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,"size")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,"size") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String. Size non-numeric => #VALUE!.');
		// Case #12: Boolean, Number, Number. Alpha TRUE ->1 invalid => #NUM!.
		oParser = new parserFormula('CONFIDENCE(TRUE,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(TRUE,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number, Number. Alpha TRUE ->1 invalid => #NUM!.');
		// Case #13: Boolean, Number, Number. Alpha FALSE ->0 invalid => #NUM!.
		oParser = new parserFormula('CONFIDENCE(FALSE,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(FALSE,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number, Number. Alpha FALSE ->0 invalid => #NUM!.');
		// Case #14: Error, Number, Number. Alpha error propagates.
		oParser = new parserFormula('CONFIDENCE(NA(),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(NA(),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Number. Alpha error propagates.');
		// Case #15: Number, Error, Number. Std_dev error propagates.
		oParser = new parserFormula('CONFIDENCE(0.05,NA(),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,NA(),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number. Std_dev error propagates.');
		// Case #16: Number, Number, Error. Size error propagates.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Number, Error. Size error propagates.');
		// Case #17: Area, Number, Number. Alpha multi-cell area => #NUM!.
		// Different result with MS
		oParser = new parserFormula('CONFIDENCE(A103:A104,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(A103:A104,2.5,50) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number, Number. Alpha multi-cell area => #NUM!.');
		// Case #18: Name, Number, Number. Alpha named 2-cell area => #NUM!.
		// Different result with MS
		oParser = new parserFormula('CONFIDENCE(TestNameArea,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(TestNameArea,2.5,50) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name, Number, Number. Alpha named 2-cell area => #NUM!.');
		// Case #19: Number, Number, Area3D. Size multi-cell 3D area => #VALUE!.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Area3D. Size multi-cell 3D area => #VALUE!.');
		// Case #20: Time, Number, Number. Alpha =0 (midnight) => #NUM!.
		oParser = new parserFormula('CONFIDENCE(TIME(0,0,0),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(TIME(0,0,0),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time, Number, Number. Alpha =0 (midnight) => #NUM!.');
		// Case #21: Number, Formula, Number. Std_dev formula negative => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0.05,-ABS(-2.5),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,-ABS(-2.5),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula, Number. Std_dev formula negative => #NUM!.');
		// Case #22: Formula. Parent formula; inner alpha invalid => #NUM!.
		oParser = new parserFormula('ROUND(CONFIDENCE(0,2.5,50),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ROUND(CONFIDENCE(0,2.5,50),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Parent formula; inner alpha invalid => #NUM!.');
		// Case #23: Ref3D, Number, Number. Alpha 3D ref to error cell => error.
		oParser = new parserFormula('CONFIDENCE(Sheet2!A6,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(Sheet2!A5,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D, Number, Number. Alpha 3D ref to error cell => error.');
		// Case #24: Table, Number, Number. Invalid table column => #VALUE!.
		oParser = new parserFormula('CONFIDENCE(Table1[Column4],2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(Table1[Column4],2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table, Number, Number. Invalid table column => #VALUE!.');
		// Case #25: Number, Boolean, Number. Std_dev FALSE ->0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0.05,FALSE,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,FALSE,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Boolean, Number. Std_dev FALSE ->0 => #NUM!.');
		// Case #26: Date, Number, Number. Alpha date serial >=1 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(DATE(2025,1,1),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(DATE(2025,1,1),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Number, Number. Alpha date serial >=1 => #NUM!.');
		// Case #27: Number, Number, Time. Size fractional (non-integer) => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Time. Size fractional (non-integer) => #NUM!.');
		// Case #28: Empty, Number, Number. Alpha empty coerces to 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number, Number. Alpha empty coerces to 0 => #NUM!.');
		// Case #29: Number, Empty, Number. Std_dev empty coerces to 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0.05,,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number. Std_dev empty coerces to 0 => #NUM!.');
		// Case #30: Number, Number, Empty. Size empty coerces to 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Empty. Size empty coerces to 0 => #NUM!.');
		// Case #31: Empty(3). All arguments empty => #NUM!.
		oParser = new parserFormula('CONFIDENCE(,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty(3). All arguments empty => #NUM!.');
		// Case #32: String, Number, Number. Alpha empty string => #VALUE!.
		oParser = new parserFormula('CONFIDENCE("",2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE("",2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Number. Alpha empty string => #VALUE!.');
		// Case #33: Number, String, Number. Std_dev empty string => #VALUE!.
		oParser = new parserFormula('CONFIDENCE(0.05,"",50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,"",50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number. Std_dev empty string => #VALUE!.');
		// Case #34: Number, Number, String. Size empty string => #VALUE!.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,"") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String. Size empty string => #VALUE!.');

		// Bounded cases:

		// Case #1: Number(3). Min valid alpha>0, min positive std_dev, min size.
		oParser = new parserFormula('CONFIDENCE(0.000000000000001,1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.000000000000001,1E-307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.014015948775543e-307, 'Test: Bounded case: Number(3). Min valid alpha>0, min positive std_dev, min size.');
		// Case #2: Number(3). Alpha just below 1 with normal std_dev & size.
		oParser = new parserFormula('CONFIDENCE(0.999999999999999,2.5,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.999999999999999,2.5,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.080887004814512e-16, 'Test: Bounded case: Number(3). Alpha just below 1 with normal std_dev & size.');
		// Case #4: Number(3). Near maximum std_dev magnitude.
		oParser = new parserFormula('CONFIDENCE(0.05,1E+307,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,1E+307,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.771807648699355e+306, 'Test: Bounded case: Number(3). Near maximum std_dev magnitude.');
		// Case #5: Number(3). Maximum tested integer size.
		oParser = new parserFormula('CONFIDENCE(0.05,2.5,2147483647)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,2.5,2147483647) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0001057360706079375, 'Test: Bounded case: Number(3). Maximum tested integer size.');
		// Case #6: Number(3). Min alpha with extreme std_dev & size.
		oParser = new parserFormula('CONFIDENCE(0.000000000000001,1E+307,2147483647)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.000000000000001,1E+307,2147483647) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7293594431261375e+303, 'Test: Bounded case: Number(3). Min alpha with extreme std_dev & size.');
		// Case #7: Number(3). Max alpha with smallest std_dev & size.
		oParser = new parserFormula('CONFIDENCE(0.999999999999999,1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.999999999999999,1E-307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 0, 'Test: Bounded case: Number(3). Max alpha with smallest std_dev & size.');
		// Case #8: Number,Area(2). Whole row reference as size.
		oParser = new parserFormula('CONFIDENCE(0.05,A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE(0.05,A:A,100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number,Area(2). Whole row reference as size.');

		// Need to fix: error types diff

		testArrayFormula2(assert, "CONFIDENCE", 3, 3);
	});

	QUnit.test("Test: \"CONFIDENCE.NORM\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A2").setValue("0.05");
		ws.getRange2("A3").setValue("2.5");
		ws.getRange2("A4").setValue("50");
		ws.getRange2("A100").setValue("0.05");
		ws.getRange2("A101").setValue("2.5");
		ws.getRange2("A102").setValue("50");
		ws.getRange2("A103").setValue("2.5");
		ws.getRange2("A104").setValue("1");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("0.05"); // Column1
		ws.getRange2("B601").setValue("2.5"); // Column2
		ws.getRange2("C601").setValue("50"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.05");
		ws2.getRange2("A2").setValue("2.5");
		ws2.getRange2("A3").setValue("50");
		ws2.getRange2("A4").setValue("test");
		ws2.getRange2("A5").setValue("text");
		ws2.getRange2("A6").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.05"); // TestName
		ws.getRange2("A202").setValue("2.5"); // TestName1
		ws.getRange2("A203").setValue("50"); // TestName2
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.05") // TestName3D
		ws2.getRange2("A12").setValue("2.5") // TestName3D1
		ws2.getRange2("A13").setValue("50") // TestName3D2


		// Positive cases:

		// Case #1: Reference link(3). CONFIDENCE.NORM interval for a population mean.
		oParser = new parserFormula('CONFIDENCE.NORM(A2,A3,A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(A2,A3,A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.692952, 'Test: Positive case: Reference link(3). CONFIDENCE.NORM interval for a population mean.');
		// Case #2: Number(3). Alpha - 0.4, standart_dev - 5, size - 12
		oParser = new parserFormula('CONFIDENCE.NORM(0.4,5,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.4,5,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.214775614, 'Test: Positive case: Number(3). Alpha - 0.4, standart_dev - 5, size - 12');
		// Case #3: Number(3). Alpha - 0.75, standart_dev - 9, size - 7
		oParser = new parserFormula('CONFIDENCE.NORM(0.75,9,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.75,9,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.083909234, 'Test: Positive case: Number(3). Alpha - 0.75, standart_dev - 9, size - 7');
		// Case #4: Number(3). Basic valid numeric arguments. 3 of 3 arguments used.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.55436153, 'Test: Positive case: Number(3). Basic valid numeric arguments. 3 of 3 arguments used.');
		// Case #5: String, Number, Number. Alpha as numeric string converted to number.
		oParser = new parserFormula('CONFIDENCE.NORM("0.05",2.5,50.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM("0.05",2.5,50.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: String, Number, Number. Alpha as numeric string converted to number.');
		// Case #6: Number, String, Number. Std_dev as numeric string converted to number.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,"2.5",50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,"2.5",50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, String, Number. Std_dev as numeric string converted to number.');
		// Case #7: Number, Number, String. Size as numeric string converted to number.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,"50")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,"50") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, Number, String. Size as numeric string converted to number.');
		// Case #8: Formula. CONFIDENCE.NORM nested inside SUM (parent formula).
		oParser = new parserFormula('SUM(CONFIDENCE.NORM(0.05,2.5,50),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CONFIDENCE.NORM(0.05,2.5,50),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.692951912, 'Test: Positive case: Formula. CONFIDENCE.NORM nested inside SUM (parent formula).');
		// Case #9: Formula, Number, Number. Alpha produced by IF formula.
		oParser = new parserFormula('CONFIDENCE.NORM(IF(TRUE,0.05,0.1),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(IF(TRUE,0.05,0.1),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Formula, Number, Number. Alpha produced by IF formula.');
		// Case #10: Number, Formula, Number. Std_dev produced by ABS formula.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,ABS(-2.5),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,ABS(-2.5),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, Formula, Number. Std_dev produced by ABS formula.');
		// Case #11: Number, Number, Formula. Size produced by ROUND formula.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,ROUND(49.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,ROUND(49.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, Number, Formula. Size produced by ROUND formula.');
		// Case #12: Reference link(3). All arguments by single-cell references.
		oParser = new parserFormula('CONFIDENCE.NORM(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Reference link(3). All arguments by single-cell references.');
		// Case #13: Area(3). All arguments as single-cell areas.
		oParser = new parserFormula('CONFIDENCE.NORM(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Area(3). All arguments as single-cell areas.');
		// Case #14: Array(3). All arguments as single-element arrays.
		oParser = new parserFormula('CONFIDENCE.NORM({0.05},{2.5},{50})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM({0.05},{2.5},{50}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Array(3). All arguments as single-element arrays.');
		// Case #15: Name(3). All arguments via defined names.
		oParser = new parserFormula('CONFIDENCE.NORM(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Name(3). All arguments via defined names.');
		// Case #16: Name3D(3). All arguments via 3D defined names.
		oParser = new parserFormula('CONFIDENCE.NORM(TestName3D,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(TestName3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Name3D(3). All arguments via 3D defined names.');
		// Case #17: Ref3D(3). All arguments via 3D references.
		oParser = new parserFormula('CONFIDENCE.NORM(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Ref3D(3). All arguments via 3D references.');
		// Case #18: Area3D(3). All arguments as 3D single-cell areas.
		oParser = new parserFormula('CONFIDENCE.NORM(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Area3D(3). All arguments as 3D single-cell areas.');
		// Case #19: Table(3). All arguments as structured table refs.
		oParser = new parserFormula('CONFIDENCE.NORM(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Table(3). All arguments as structured table refs.');
		// Case #20: Time, Number, Number. Alpha from Time fraction (0.5).
		oParser = new parserFormula('CONFIDENCE.NORM(TIME(12,0,0),2.5,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(TIME(12,0,0),2.5,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.307861042, 'Test: Positive case: Time, Number, Number. Alpha from Time fraction (0.5).');
		// Case #21: Number, Time, Number. Std_dev as Time fraction (>0).
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,TIME(6,0,0),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,TIME(6,0,0),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.069295191, 'Test: Positive case: Number, Time, Number. Std_dev as Time fraction (>0).');
		// Case #22: Number, Time(2). Std_dev as Time fraction (>0).
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,TIME(6,0,0),50+TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,TIME(6,0,0),50+TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.069295191, 'Test: Positive case: Number, Time(2). Std_dev as Time fraction (>0).');
		// Case #23: Number, Date, Number. Std_dev supplied as Date serial (>0).
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,DATE(2025,1,1),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,DATE(2025,1,1),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 8948.803561, 'Test: Positive case: Number, Date, Number. Std_dev supplied as Date serial (>0).');
		// Case #24: Number, Number, Date. Size as Date serial (integer).
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.022931352, 'Test: Positive case: Number, Number, Date. Size as Date serial (integer).');
		// Case #25: Number, Boolean, Number. Std_dev using boolean arithmetic (TRUE->1).
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,TRUE,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,TRUE,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.277180765, 'Test: Positive case: Number, Boolean, Number. Std_dev using boolean arithmetic (TRUE->1).');
		// Case #26: Number, Number, Boolean. Size using boolean arithmetic (TRUE->1).
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.899909961, 'Test: Positive case: Number, Number, Boolean. Size using boolean arithmetic (TRUE->1).');
		// Case #27: String, Formula, Reference link. Mixed: alpha string, std_dev formula, size ref.
		oParser = new parserFormula('CONFIDENCE.NORM("0.05",ABS(-2.5),A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM("0.05",ABS(-2.5),A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: String, Formula, Reference link. Mixed: alpha string, std_dev formula, size ref.');
		// Case #28: Reference link, String, Formula. Mixed: alpha ref, std_dev string, size formula.
		oParser = new parserFormula('CONFIDENCE.NORM(A100,"2.5",ROUND(49.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(A100,"2.5",ROUND(49.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6929519121748386, 'Test: Positive case: Reference link, String, Formula. Mixed: alpha ref, std_dev string, size formula.');
		// Case #29: Number, Array, Number. Std_dev multi-element array
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,{2.5,3.5},50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,{2.5,3.5},50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number, Array, Number. Std_dev multi-element array');
		// Case #30: Array, Number, Number. Alpha multi-element array
		oParser = new parserFormula('CONFIDENCE.NORM({0.05,0.5},2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM({0.05,0.5},2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Array, Number, Number. Alpha multi-element array');
		// Case #31: Number(2), Array. Size multi-element array
		oParser = new parserFormula('CONFIDENCE.NORM(0.05, 2.5, {50,500})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05, 2.5, {50,500}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.692951912, 'Test: Positive case: Number(2), Array. Size multi-element array');

		// Negative cases:

		// Case #1: Number(3). Alpha = 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha = 0 => #NUM!.');
		// Case #2: Number(3). Alpha = 1 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(1,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(1,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha = 1 => #NUM!.');
		// Case #3: Number(3). Alpha <0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(-0.1,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(-0.1,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha <0 => #NUM!.');
		// Case #4: Number(3). Alpha >1 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(1.5,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(1.5,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha >1 => #NUM!.');
		// Case #5: Number(3). Std_dev =0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,0,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,0,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Std_dev =0 => #NUM!.');
		// Case #6: Number(3). Std_dev <0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,-2,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,-2,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Std_dev <0 => #NUM!.');
		// Case #7: Number(3). Size =0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Size =0 => #NUM!.');
		// Case #8: Number(3). Size <0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,-10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,-10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Size <0 => #NUM!.');
		// Case #9: String, Number, Number. Alpha non-numeric => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM("abc",2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM("abc",2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Number. Alpha non-numeric => #VALUE!.');
		// Case #10: Number, String, Number. Std_dev non-numeric => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,"xyz",50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,"xyz",50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number. Std_dev non-numeric => #VALUE!.');
		// Case #11: Number, Number, String. Size non-numeric => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,"size")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,"size") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String. Size non-numeric => #VALUE!.');
		// Case #12: Boolean, Number, Number. Alpha TRUE ->1 invalid => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(TRUE,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(TRUE,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number, Number. Alpha TRUE ->1 invalid => #NUM!.');
		// Case #13: Boolean, Number, Number. Alpha FALSE ->0 invalid => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(FALSE,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(FALSE,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number, Number. Alpha FALSE ->0 invalid => #NUM!.');
		// Case #14: Error, Number, Number. Alpha error propagates.
		oParser = new parserFormula('CONFIDENCE.NORM(NA(),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(NA(),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Number. Alpha error propagates.');
		// Case #15: Number, Error, Number. Std_dev error propagates.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,NA(),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,NA(),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number. Std_dev error propagates.');
		// Case #16: Number, Number, Error. Size error propagates.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Number, Error. Size error propagates.');
		// Case #17: Area, Number, Number. Alpha multi-cell area => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM(A103:A104,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(A103:A104,2.5,50) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number, Number. Alpha multi-cell area => #VALUE!.');
		// Case #18: Name, Number, Number. Alpha named 2-cell area => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM(TestNameArea,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(TestNameArea,2.5,50) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name, Number, Number. Alpha named 2-cell area => #VALUE!.');
		// Case #19: Number, Number, Area3D. Size multi-cell 3D area => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Area3D. Size multi-cell 3D area => #VALUE!.');
		// Case #20: Time, Number, Number. Alpha =0 (midnight) => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(TIME(0,0,0),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(TIME(0,0,0),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time, Number, Number. Alpha =0 (midnight) => #NUM!.');
		// Case #21: Number, Formula, Number. Std_dev formula negative => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,-ABS(-2.5),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,-ABS(-2.5),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula, Number. Std_dev formula negative => #NUM!.');
		// Case #22: Formula. Parent formula; inner alpha invalid => #NUM!.
		oParser = new parserFormula('ROUND(CONFIDENCE.NORM(0,2.5,50),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ROUND(CONFIDENCE.NORM(0,2.5,50),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Parent formula; inner alpha invalid => #NUM!.');
		// Case #23: Ref3D, Number, Number. Alpha 3D ref to error cell => error.
		oParser = new parserFormula('CONFIDENCE.NORM(Sheet2!A6,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(Sheet2!A6,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D, Number, Number. Alpha 3D ref to error cell => error.');
		// Case #24: Table, Number, Number. Invalid table column => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM(Table1[Column4],2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(Table1[Column4],2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table, Number, Number. Invalid table column => #VALUE!.');
		// Case #25: Number, Boolean, Number. Std_dev FALSE ->0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,FALSE,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,FALSE,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Boolean, Number. Std_dev FALSE ->0 => #NUM!.');
		// Case #26: Date, Number, Number. Alpha date serial >=1 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(DATE(2025,1,1),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(DATE(2025,1,1),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Number, Number. Alpha date serial >=1 => #NUM!.');
		// Case #27: Number, Number, Time. Size fractional (non-integer) => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Time. Size fractional (non-integer) => #NUM!.');
		// Case #28: Empty, Number, Number. Alpha empty coerces to 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number, Number. Alpha empty coerces to 0 => #NUM!.');
		// Case #29: Number, Empty, Number. Std_dev empty coerces to 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number. Std_dev empty coerces to 0 => #NUM!.');
		// Case #30: Number, Number, Empty. Size empty coerces to 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Empty. Size empty coerces to 0 => #NUM!.');
		// Case #31: Empty(3). All arguments empty => #NUM!.
		oParser = new parserFormula('CONFIDENCE.NORM(,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty(3). All arguments empty => #NUM!.');
		// Case #32: String, Number, Number. Alpha empty string => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM("",2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM("",2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Number. Alpha empty string => #VALUE!.');
		// Case #33: Number, String, Number. Std_dev empty string => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,"",50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,"",50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number. Std_dev empty string => #VALUE!.');
		// Case #34: Number, Number, String. Size empty string => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,"") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String. Size empty string => #VALUE!.');

		// Bounded cases:

		// Case #1: Number(3). Min valid alpha>0, min positive std_dev, min size.
		oParser = new parserFormula('CONFIDENCE.NORM(0.000000000000001,1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.000000000000001,1E-307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.014015948775543e-307, 'Test: Bounded case: Number(3). Min valid alpha>0, min positive std_dev, min size.');
		// Case #2: Number(3). Alpha just below 1 with normal std_dev & size.
		oParser = new parserFormula('CONFIDENCE.NORM(0.999999999999999,2.5,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.999999999999999,2.5,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.080887004814512e-16, 'Test: Bounded case: Number(3). Alpha just below 1 with normal std_dev & size.');
		// Case #4: Number(3). Near maximum std_dev magnitude.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,1E+307,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,1E+307,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.771807648699355e+306, 'Test: Bounded case: Number(3). Near maximum std_dev magnitude.');
		// Case #5: Number(3). Maximum tested integer size.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,2.5,2147483647)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,2.5,2147483647) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0001057360706079375, 'Test: Bounded case: Number(3). Maximum tested integer size.');
		// Case #6: Number(3). Min alpha with extreme std_dev & size.
		oParser = new parserFormula('CONFIDENCE.NORM(0.000000000000001,1E+307,2147483647)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.000000000000001,1E+307,2147483647) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7293594431261375e+303, 'Test: Bounded case: Number(3). Min alpha with extreme std_dev & size.');
		// Case #7: Number(3). Max alpha with smallest std_dev & size.
		oParser = new parserFormula('CONFIDENCE.NORM(0.999999999999999,1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.999999999999999,1E-307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '0', 'Test: Bounded case: Number(3). Max alpha with smallest std_dev & size.');
		// Case #8: Number,Area(2). Whole row reference as size.
		oParser = new parserFormula('CONFIDENCE.NORM(0.05,A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.NORM(0.05,A:A,100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number,Area(2). Whole row reference as size.');

		// Need to fix: error types diff

	});

	QUnit.test("Test: \"CONFIDENCE.T\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.05");
		ws.getRange2("A101").setValue("2.5");
		ws.getRange2("A102").setValue("50");
		ws.getRange2("A103").setValue("2.5");
		ws.getRange2("A104").setValue("1");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("0.05"); // Column1
		ws.getRange2("B601").setValue("2.5"); // Column2
		ws.getRange2("C601").setValue("50"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.05");
		ws2.getRange2("A2").setValue("2.5");
		ws2.getRange2("A3").setValue("50");
		ws2.getRange2("A4").setValue("test");
		ws2.getRange2("A5").setValue("text");
		ws2.getRange2("A6").setValue("#N/A");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.05"); // TestName
		ws.getRange2("A202").setValue("2.5"); // TestName1
		ws.getRange2("A203").setValue("50"); // TestName2
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.05") // TestName3D
		ws2.getRange2("A12").setValue("2.5") // TestName3D1
		ws2.getRange2("A13").setValue("50") // TestName3D2

		// Positive cases:

		// Case #1: Number(3). Сonfidence interval for the mean of a population based on a sample size of 50, with a 5% significance level and a standard deviation of 1.
		oParser = new parserFormula('CONFIDENCE.T(0.05,1,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,1,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.284196855, 'Test: Positive case: Number(3). Сonfidence interval for the mean of a population based on a sample size of 50, with a 5% significance level and a standard deviation of 1.');
		// Case #2: Number(3). Alpha - 0.4, standart_dev - 5, size - 12
		oParser = new parserFormula('CONFIDENCE.T(0.4,5,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.4,5,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.263718671, 'Test: Positive case: Number(3). Alpha - 0.4, standart_dev - 5, size - 12');
		// Case #3: Number(3). Alpha - 0.75, standart_dev - 9, size - 7
		oParser = new parserFormula('CONFIDENCE.T(0.75,9,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.75,9,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.134949646, 'Test: Positive case: Number(3). Alpha - 0.75, standart_dev - 9, size - 7');
		// Case #4: Number(3). Basic valid numeric arguments. 3 of 3 arguments used.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.568393711, 'Test: Positive case: Number(3). Basic valid numeric arguments. 3 of 3 arguments used.');
		// Case #5: String, Number, Number. Alpha as numeric string converted to number.
		oParser = new parserFormula('CONFIDENCE.T("0.05",2.5,50.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T("0.05",2.5,50.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: String, Number, Number. Alpha as numeric string converted to number.');
		// Case #6: Number, String, Number. Std_dev as numeric string converted to number.
		oParser = new parserFormula('CONFIDENCE.T(0.05,"2.5",50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,"2.5",50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Number, String, Number. Std_dev as numeric string converted to number.');
		// Case #7: Number, Number, String. Size as numeric string converted to number.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,"50")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,"50") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Number, Number, String. Size as numeric string converted to number.');
		// Case #8: Formula. CONFIDENCE.T nested inside SUM (parent formula).
		oParser = new parserFormula('SUM(CONFIDENCE.T(0.05,2.5,50),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CONFIDENCE.T(0.05,2.5,50),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.710492139, 'Test: Positive case: Formula. CONFIDENCE.T nested inside SUM (parent formula).');
		// Case #9: Formula, Number, Number. Alpha produced by IF formula.
		oParser = new parserFormula('CONFIDENCE.T(IF(TRUE,0.05,0.1),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(IF(TRUE,0.05,0.1),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Formula, Number, Number. Alpha produced by IF formula.');
		// Case #10: Number, Formula, Number. Std_dev produced by ABS formula.
		oParser = new parserFormula('CONFIDENCE.T(0.05,ABS(-2.5),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,ABS(-2.5),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Number, Formula, Number. Std_dev produced by ABS formula.');
		// Case #11: Number, Number, Formula. Size produced by ROUND formula.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,ROUND(49.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,ROUND(49.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Number, Number, Formula. Size produced by ROUND formula.');
		// Case #12: Reference link(3). All arguments by single-cell references.
		oParser = new parserFormula('CONFIDENCE.T(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Reference link(3). All arguments by single-cell references.');
		// Case #13: Area(3). All arguments as single-cell areas.
		oParser = new parserFormula('CONFIDENCE.T(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Area(3). All arguments as single-cell areas.');
		// Case #14: Array(3). All arguments as single-element arrays.
		oParser = new parserFormula('CONFIDENCE.T({0.05},{2.5},{50})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T({0.05},{2.5},{50}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Array(3). All arguments as single-element arrays.');
		// Case #15: Name(3). All arguments via defined names.
		oParser = new parserFormula('CONFIDENCE.T(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Name(3). All arguments via defined names.');
		// Case #16: Name3D(3). All arguments via 3D defined names.
		oParser = new parserFormula('CONFIDENCE.T(TestName3D,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(TestName3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Name3D(3). All arguments via 3D defined names.');
		// Case #17: Ref3D(3). All arguments via 3D references.
		oParser = new parserFormula('CONFIDENCE.T(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Ref3D(3). All arguments via 3D references.');
		// Case #18: Area3D(3). All arguments as 3D single-cell areas.
		oParser = new parserFormula('CONFIDENCE.T(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Area3D(3). All arguments as 3D single-cell areas.');
		// Case #19: Table(3). All arguments as structured table refs.
		oParser = new parserFormula('CONFIDENCE.T(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Table(3). All arguments as structured table refs.');
		// Case #20: Time, Number, Number. Alpha from Time fraction (0.5).
		oParser = new parserFormula('CONFIDENCE.T(TIME(12,0,0),2.5,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(TIME(12,0,0),2.5,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.311765442, 'Test: Positive case: Time, Number, Number. Alpha from Time fraction (0.5).');
		// Case #21: Number, Time, Number. Std_dev as Time fraction (>0).
		oParser = new parserFormula('CONFIDENCE.T(0.05,TIME(6,0,0),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,TIME(6,0,0),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.071049214, 'Test: Positive case: Number, Time, Number. Std_dev as Time fraction (>0).');
		// Case #22: Number, Time(2). Std_dev as Time fraction (>0).
		oParser = new parserFormula('CONFIDENCE.T(0.05,TIME(6,0,0),50+TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,TIME(6,0,0),50+TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.071049214, 'Test: Positive case: Number, Time(2). Std_dev as Time fraction (>0).');
		// Case #23: Number, Date, Number. Std_dev supplied as Date serial (>0).
		oParser = new parserFormula('CONFIDENCE.T(0.05,DATE(2025,1,1),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,DATE(2025,1,1),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 9059.537758, 'Test: Positive case: Number, Date, Number. Std_dev supplied as Date serial (>0).');
		// Case #24: Number, Number, Date. Size as Date serial (integer).
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.02293196, 'Test: Positive case: Number, Number, Date. Size as Date serial (integer).');
		// Case #25: Number, Boolean, Number. Std_dev using boolean arithmetic (TRUE->1).
		oParser = new parserFormula('CONFIDENCE.T(0.05,TRUE,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,TRUE,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.284196855, 'Test: Positive case: Number, Boolean, Number. Std_dev using boolean arithmetic (TRUE->1).');
		// Case #26: String, Formula, Reference link. Mixed: alpha string, std_dev formula, size ref.
		oParser = new parserFormula('CONFIDENCE.T("0.05",ABS(-2.5),A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T("0.05",ABS(-2.5),A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: String, Formula, Reference link. Mixed: alpha string, std_dev formula, size ref.');
		// Case #27: Reference link, String, Formula. Mixed: alpha ref, std_dev string, size formula.
		oParser = new parserFormula('CONFIDENCE.T(A100,"2.5",ROUND(49.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(A100,"2.5",ROUND(49.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Reference link, String, Formula. Mixed: alpha ref, std_dev string, size formula.');
		// Case #28: Number, Array, Number. Std_dev multi-element array
		oParser = new parserFormula('CONFIDENCE.T(0.05,{2.5,3.5},50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,{2.5,3.5},50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Number, Array, Number. Std_dev multi-element array');
		// Case #29: Array, Number, Number. Alpha multi-element array
		oParser = new parserFormula('CONFIDENCE.T({0.05,0.5},2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T({0.05,0.5},2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Array, Number, Number. Alpha multi-element array');
		// Case #30: Number(2), Array. Size multi-element array
		oParser = new parserFormula('CONFIDENCE.T(0.05, 2.5, {50,500})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05, 2.5, {50,500}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.710492139, 'Test: Positive case: Number(2), Array. Size multi-element array');

		// Negative cases:

		// Case #1: Number(3). Alpha = 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha = 0 => #NUM!.');
		// Case #2: Number(3). Alpha = 1 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(1,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(1,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha = 1 => #NUM!.');
		// Case #3: Number(3). Alpha <0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(-0.1,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(-0.1,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha <0 => #NUM!.');
		// Case #4: Number(3). Alpha >1 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(1.5,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(1.5,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha >1 => #NUM!.');
		// Case #5: Number(3). Std_dev =0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,0,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,0,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Std_dev =0 => #NUM!.');
		// Case #6: Number(3). Std_dev <0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,-2,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,-2,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Std_dev <0 => #NUM!.');
		// Case #7: Number(3). Size =0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Size =0 => #NUM!.');
		// Case #8: Number(3). Size <0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,-10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,-10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Size <0 => #NUM!.');
		// Case #9: String, Number, Number. Alpha non-numeric => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T("abc",2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T("abc",2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Number. Alpha non-numeric => #VALUE!.');
		// Case #10: Number, String, Number. Std_dev non-numeric => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,"xyz",50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,"xyz",50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number. Std_dev non-numeric => #VALUE!.');
		// Case #11: Number, Number, String. Size non-numeric => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,"size")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,"size") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String. Size non-numeric => #VALUE!.');
		// Case #12: Boolean, Number, Number. Alpha TRUE ->1 invalid => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(TRUE,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(TRUE,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number, Number. Alpha TRUE ->1 invalid => #NUM!.');
		// Case #13: Boolean, Number, Number. Alpha FALSE ->0 invalid => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(FALSE,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(FALSE,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number, Number. Alpha FALSE ->0 invalid => #NUM!.');
		// Case #14: Error, Number, Number. Alpha error propagates.
		oParser = new parserFormula('CONFIDENCE.T(NA(),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(NA(),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Number. Alpha error propagates.');
		// Case #15: Number, Error, Number. Std_dev error propagates.
		oParser = new parserFormula('CONFIDENCE.T(0.05,NA(),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,NA(),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number. Std_dev error propagates.');
		// Case #16: Number, Number, Error. Size error propagates.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Number, Error. Size error propagates.');
		// Case #17: Area, Number, Number. Alpha multi-cell area => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T(A103:A104,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(A103:A104,2.5,50) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number, Number. Alpha multi-cell area => #VALUE!.');
		// Case #18: Name, Number, Number. Alpha named 2-cell area => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T(TestNameArea,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(TestNameArea,2.5,50) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name, Number, Number. Alpha named 2-cell area => #VALUE!.');
		// Case #19: Number, Number, Area3D. Size multi-cell 3D area => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Area3D. Size multi-cell 3D area => #VALUE!.');
		// Case #20: Time, Number, Number. Alpha =0 (midnight) => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(TIME(0,0,0),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(TIME(0,0,0),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time, Number, Number. Alpha =0 (midnight) => #NUM!.');
		// Case #21: Number, Formula, Number. Std_dev formula negative => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,-ABS(-2.5),50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,-ABS(-2.5),50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula, Number. Std_dev formula negative => #NUM!.');
		// Case #22: Formula. Parent formula; inner alpha invalid => #NUM!.
		oParser = new parserFormula('ROUND(CONFIDENCE.T(0,2.5,50),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ROUND(CONFIDENCE.T(0,2.5,50),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Parent formula; inner alpha invalid => #NUM!.');
		// Case #23: Ref3D, Number, Number. Alpha 3D ref to error cell => error.
		oParser = new parserFormula('CONFIDENCE.T(Sheet2!A6,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(Sheet2!A6,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D, Number, Number. Alpha 3D ref to error cell => error.');
		// Case #24: Table, Number, Number. Invalid table column => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T(Table1[Column4],2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(Table1[Column4],2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table, Number, Number. Invalid table column => #VALUE!.');
		// Case #25: Number, Boolean, Number. Std_dev FALSE ->0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,FALSE,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,FALSE,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Boolean, Number. Std_dev FALSE ->0 => #NUM!.');
		// Case #26: Date, Number, Number. Alpha date serial >=1 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(DATE(2025,1,1),2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(DATE(2025,1,1),2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Number, Number. Alpha date serial >=1 => #NUM!.');
		// Case #27: Number, Number, Time. Size fractional (non-integer) => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Time. Size fractional (non-integer) => #NUM!.');
		// Case #28: Empty, Number, Number. Alpha empty coerces to 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(,2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(,2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number, Number. Alpha empty coerces to 0 => #NUM!.');
		// Case #29: Number, Empty, Number. Std_dev empty coerces to 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number. Std_dev empty coerces to 0 => #NUM!.');
		// Case #30: Number, Number, Empty. Size empty coerces to 0 => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Empty. Size empty coerces to 0 => #NUM!.');
		// Case #31: Empty(3). All arguments empty => #NUM!.
		oParser = new parserFormula('CONFIDENCE.T(,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty(3). All arguments empty => #NUM!.');
		// Case #32: String, Number, Number. Alpha empty string => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T("",2.5,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T("",2.5,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Number. Alpha empty string => #VALUE!.');
		// Case #33: Number, String, Number. Std_dev empty string => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,"",50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,"",50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number. Std_dev empty string => #VALUE!.');
		// Case #34: Number, Number, String. Size empty string => #VALUE!.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,"") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String. Size empty string => #VALUE!.');
		// Case #35: Number, Number, Boolean. Size using boolean arithmetic (TRUE->1).
		// Different result with MS
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Number, Boolean. Size using boolean arithmetic (TRUE->1).');

		// Bounded cases:

		// Case #1: Number(3). Min valid alpha>0, min positive std_dev, min size.
		oParser = new parserFormula('CONFIDENCE.T(0.000000000000001,1E-307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.000000000000001,1E-307,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.5015815807855133e-293, 'Test: Bounded case: Number(3). Min valid alpha>0, min positive std_dev, min size.');
		// Case #2: Number(3). Alpha just below 1 with normal std_dev & size.
		// Different result with MS
		oParser = new parserFormula('CONFIDENCE.T(0.999999999999999,2.5,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.999999999999999,2.5,30) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5.76548e-16, 'Test: Bounded case: Number(3). Alpha just below 1 with normal std_dev & size.');
		// Case #4: Number(3). Near maximum std_dev magnitude.
		oParser = new parserFormula('CONFIDENCE.T(0.05,1E+307,50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,1E+307,50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.8419685549572977e+306, 'Test: Bounded case: Number(3). Near maximum std_dev magnitude.');
		// Case #5: Number(3). Maximum tested integer size.
		oParser = new parserFormula('CONFIDENCE.T(0.05,2.5,2147483647)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,2.5,2147483647) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.00010573607356934008, 'Test: Bounded case: Number(3). Maximum tested integer size.');
		// Case #6: Number(3). Min alpha with extreme std_dev & size.
		oParser = new parserFormula('CONFIDENCE.T(0.000000000000001,1E+307,2147483647)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.000000000000001,1E+307,2147483647) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.732130857000712e+303, 'Test: Bounded case: Number(3). Min alpha with extreme std_dev & size.');
		// Case #7: Number(3). Max alpha with smallest std_dev & size.
		oParser = new parserFormula('CONFIDENCE.T(0.999999999999999,1E-307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.999999999999999,1E-307,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '0', 'Test: Bounded case: Number(3). Max alpha with smallest std_dev & size.');
		// Case #8: Number,Area(2). Whole row reference as size.
		oParser = new parserFormula('CONFIDENCE.T(0.05,A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONFIDENCE.T(0.05,A:A,100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number,Area(2). Whole row reference as size.');

		// Need to fix: error types diff, diff result from MS

		testArrayFormula2(assert, "CONFIDENCE.T", 3, 3);
	});

	QUnit.test("Test: \"CORREL\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("3");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("4");
		ws.getRange2("A103").setValue("5");
		ws.getRange2("A104").setValue("6");
		ws.getRange2("A105").setValue("2.532");
		ws.getRange2("A106").setValue("5.621");
		ws.getRange2("A107").setValue("2.1");
		ws.getRange2("A108").setValue("3.4");
		ws.getRange2("B100").setValue("9");
		ws.getRange2("B101").setValue("7");
		ws.getRange2("B102").setValue("12");
		ws.getRange2("B103").setValue("15");
		ws.getRange2("B104").setValue("17");
		ws.getRange2("B105").setValue("5.32");
		ws.getRange2("B106").setValue("2.765");
		ws.getRange2("B107").setValue("5.2");
		ws.getRange2("B108").setValue("f");
		ws.getRange2("A109").setValue("-2");
		ws.getRange2("A110").setValue("0");
		ws.getRange2("A111").setValue("2");
		ws.getRange2("B109").setValue("-1");
		ws.getRange2("B110").setValue("1");
		ws.getRange2("B111").setValue("0");
		ws.getRange2("B112").setValue("text");
		ws.getRange2("B113").setValue("text1");
		// Table type. Use A601:L6**
		getTableType(599, 0, 604, 1);
		ws.getRange2("A601").setValue("3"); // Column1
		ws.getRange2("A602").setValue("2"); // Column1
		ws.getRange2("A603").setValue("4"); // Column1
		ws.getRange2("A604").setValue("5"); // Column1
		ws.getRange2("A605").setValue("6"); // Column1
		ws.getRange2("B601").setValue("9"); // Column2
		ws.getRange2("B602").setValue("7"); // Column2
		ws.getRange2("B603").setValue("12"); // Column2
		ws.getRange2("B604").setValue("15"); // Column2
		ws.getRange2("B605").setValue("17"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("3");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("4");
		ws2.getRange2("A4").setValue("5");
		ws2.getRange2("A5").setValue("6");
		ws2.getRange2("A6").setValue("2.532");
		ws2.getRange2("A7").setValue("5.621");
		ws2.getRange2("A8").setValue("2.1");
		ws2.getRange2("A9").setValue("3.4");
		ws2.getRange2("B1").setValue("9");
		ws2.getRange2("B2").setValue("7");
		ws2.getRange2("B3").setValue("12");
		ws2.getRange2("B4").setValue("15");
		ws2.getRange2("B5").setValue("17");
		ws2.getRange2("B6").setValue("5.32");
		ws2.getRange2("B7").setValue("2.765");
		ws2.getRange2("B8").setValue("5.2");
		ws2.getRange2("B9").setValue("f");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1"); // TestName
		ws.getRange2("A202").setValue("2"); // TestName1
		ws.getRange2("A206").setValue("3"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		ws.getRange2("A208").setValue("4"); // TestNameArea2
		ws.getRange2("B208").setValue("5"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A16").setValue("3"); // TestNameArea3D
		ws2.getRange2("A17").setValue("2"); // TestNameArea3D
		ws2.getRange2("A18").setValue("4"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("5"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Array(2). Arrays with float number 4 elements (2 row, 2 col)
		oParser = new parserFormula('CORREL({2.532,5.621;2.1,3.4},{5.32,2.765;5.2,"f"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({2.532,5.621;2.1,3.4},{5.32,2.765;5.2,"f"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.9881120200322111, 'Test: Positive case: Array(2). Arrays with float number 4 elements (2 row, 2 col)');
		// Case #2: Array(2). Arrays with int numbers 3 elements
		oParser = new parserFormula('CORREL({1;2;3},{4;5;"E"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1;2;3},{4;5;"E"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(2). Arrays with int numbers 3 elements');
		// Case #3: Area(2). Basic usage with two numeric arrays of equal size. 2 arguments used.
		oParser = new parserFormula('CORREL(A100:A104,B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(A100:A104,B100:B104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.997054486, 'Test: Positive case: Area(2). Basic usage with two numeric arrays of equal size. 2 arguments used.');
		// Case #4: Area(2). Arrays with mix of numbers, text. Text are ignored. 2 arguments used.
		oParser = new parserFormula('CORREL(A105:A108,B105:B108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(A105:A108,B105:B108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -0.98811202, 'Test: Positive case: Area(2). Arrays with mix of numbers, text. Text are ignored. 2 arguments used.');
		// Case #5: Area(2). Arrays with mix of positive/negative values including zeros. 2 arguments used.
		oParser = new parserFormula('CORREL(A109:A111,B109:B111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(A109:A111,B109:B111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.5, 'Test: Positive case: Area(2). Arrays with mix of positive/negative values including zeros. 2 arguments used.');
		// Case #6: Array(2). Array constants with perfect positive correlation. 2 arguments used.
		oParser = new parserFormula('CORREL({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(2). Array constants with perfect positive correlation. 2 arguments used.');
		// Case #7: Array(2). Array constants with perfect negative correlation. 2 arguments used.
		oParser = new parserFormula('CORREL({1,2,3},{6,5,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1,2,3},{6,5,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Array(2). Array constants with perfect negative correlation. 2 arguments used.');
		// Case #8: Formula(2). Formulas that return arrays of equal size. 2 arguments used.
		oParser = new parserFormula('CORREL(ROW(A1:A5),COLUMN(A1:E1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(ROW(A1:A5),COLUMN(A1:E1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2). Formulas that return arrays of equal size. 2 arguments used.');
		// Case #9: Formula. CORREL nested inside another formula. 2 arguments used.
		oParser = new parserFormula('SUM(1,CORREL({1,2,3},{4,5,6}))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(1,CORREL({1,2,3},{4,5,6})) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. CORREL nested inside another formula. 2 arguments used.');
		// Case #10: Formula(2). Nested formulas inside CORREL. 2 arguments used.
		oParser = new parserFormula('CORREL(ABS({-1,-2,-3}),SQRT({4,9,16}))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(ABS({-1,-2,-3}),SQRT({4,9,16})) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2). Nested formulas inside CORREL. 2 arguments used.');
		// Case #11: Name(2). Named ranges with numeric values. 2 arguments used.
		oParser = new parserFormula('CORREL(TestNameArea,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(TestNameArea,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name(2). Named ranges with numeric values. 2 arguments used.');
		// Case #12: Name3D(2). 3D named ranges with numeric values. 2 arguments used.
		oParser = new parserFormula('CORREL(TestNameArea3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(TestNameArea3D,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name3D(2). 3D named ranges with numeric values. 2 arguments used.');
		// Case #13: Ref3D(2). 3D references to ranges with numeric values. 2 arguments used.
		oParser = new parserFormula('CORREL(Sheet2!A1:A5,Sheet2!B1:B5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(Sheet2!A1:A5,Sheet2!B1:B5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.997054486, 'Test: Positive case: Ref3D(2). 3D references to ranges with numeric values. 2 arguments used.');
		// Case #14: Area3D(2). 3D areas with numeric values. 2 arguments used.
		oParser = new parserFormula('CORREL(Sheet2!A6:A9,Sheet2!B6:B9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(Sheet2!A6:A9,Sheet2!B6:B9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -0.98811202, 'Test: Positive case: Area3D(2). 3D areas with numeric values. 2 arguments used.');
		// Case #15: Table(2). Table structured references with numeric values. 2 arguments used.
		oParser = new parserFormula('CORREL(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.997054486, 'Test: Positive case: Table(2). Table structured references with numeric values. 2 arguments used.');
		// Case #16: Area, Array. Mix of area and array constant of same size. 2 arguments used.
		oParser = new parserFormula('CORREL(A100:A104,{1,2,3,4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(A100:A104,{1,2,3,4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 0.9, 'Test: Positive case: Area, Array. Mix of area and array constant of same size. 2 arguments used.');

		// Negative cases:

		// Case #1: Array(2). Arrays with int numbers 2 elements. Return #DIV/0! error
		oParser = new parserFormula('CORREL({1,2},{1,"e"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1,2},{1,"e"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). Arrays with int numbers 2 elements. Return #DIV/0! error');
		// Case #1: Area(2). Arrays of different sizes return #N/A error. 2 arguments used.
		oParser = new parserFormula('CORREL(A100:A104,B100:B106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(A100:A104,B100:B106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area(2). Arrays of different sizes return #N/A error. 2 arguments used.');
		// Case #2: Number(2). Single numbers as arrays. 2 arguments used.
		oParser = new parserFormula('CORREL(1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Single numbers as arrays. 2 arguments used.');
		// Case #3: Number(2). Two zero values return #DIV/0! error due to zero standard deviation. 2 arguments used.
		oParser = new parserFormula('CORREL(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Two zero values return #DIV/0! error due to zero standard deviation. 2 arguments used.');
		// Case #4: String(2). Non-numeric strings return #VALUE! error. 2 arguments used.
		oParser = new parserFormula('CORREL("text","more text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL("text","more text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String(2). Non-numeric strings return #VALUE! error. 2 arguments used.');
		// Case #5: String(2). Strings convertible to numbers return #DIV/0! error due to zero standard deviation. 2 arguments used.
		oParser = new parserFormula('CORREL("5","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL("5","10") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String(2). Strings convertible to numbers return #DIV/0! error due to zero standard deviation. 2 arguments used.');
		// Case #6: Boolean(2). Boolean values (converted to 1 and 0) return #DIV/0! error due to zero standard deviation. 2 arguments used.
		oParser = new parserFormula('CORREL(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean(2). Boolean values (converted to 1 and 0) return #DIV/0! error due to zero standard deviation. 2 arguments used.');
		// Case #7: Empty(2). Empty arguments return #DIV/0! error. 2 arguments used.
		oParser = new parserFormula('CORREL(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty(2). Empty arguments return #DIV/0! error. 2 arguments used.');
		// Case #8: Date(2). Dates as serial numbers return #DIV/0! error due to zero standard deviation. 2 arguments used.
		oParser = new parserFormula('CORREL(DATE(2023,1,1),DATE(2023,6,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(DATE(2023,1,1),DATE(2023,6,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Date(2). Dates as serial numbers return #DIV/0! error due to zero standard deviation. 2 arguments used.');
		// Case #9: Time(2). Time values as serial numbers return #DIV/0! error due to zero standard deviation. 2 arguments used.
		oParser = new parserFormula('CORREL(TIME(1,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(TIME(1,0,0),TIME(13,0,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time(2). Time values as serial numbers return #DIV/0! error due to zero standard deviation. 2 arguments used.');
		// Case #10: Reference link(2). References to cells with text only returns #DIV/0! because all values are ignored. 2 arguments used.
		oParser = new parserFormula('CORREL(B112,B113)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(B112,B113) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link(2). References to cells with text only returns #DIV/0! because all values are ignored. 2 arguments used.');
		// Case #11: Error(2). Error values as arguments propagate the first error. 2 arguments used.
		oParser = new parserFormula('CORREL(#DIV/0!,#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(#DIV/0!,#VALUE!) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error(2). Error values as arguments propagate the first error. 2 arguments used.');
		// Case #12: Error, Number. Error value in first argument is propagated. 2 arguments used.
		oParser = new parserFormula('CORREL(#N/A,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(#N/A,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error value in first argument is propagated. 2 arguments used.');
		// Case #13: Number, Error. Error value in second argument is propagated. 2 arguments used.
		oParser = new parserFormula('CORREL(5,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(5,#N/A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error value in second argument is propagated. 2 arguments used.');
		// Case #14: Formula(2). Formulas resulting in errors propagate the errors. 2 arguments used.
		oParser = new parserFormula('CORREL(SQRT(-1),LOG(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(SQRT(-1),LOG(0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). Formulas resulting in errors propagate the errors. 2 arguments used.');
		// Case #15: Array(2). Arrays with constant values return #DIV/0! error due to zero standard deviation. 2 arguments used.
		oParser = new parserFormula('CORREL({1,1,1},{1,1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1,1,1},{1,1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). Arrays with constant values return #DIV/0! error due to zero standard deviation. 2 arguments used.');
		// Case #17: Name(2). Named range with non-numeric values with numeric named range. 2 arguments used.
		oParser = new parserFormula('CORREL(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name(2). Named range with non-numeric values with numeric named range. 2 arguments used.');
		// Case #18: Array(2). Arrays of different lengths return #N/A error. 2 arguments used.
		oParser = new parserFormula('CORREL({1,2,3,4,5},{10,20,30,40})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1,2,3,4,5},{10,20,30,40}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array(2). Arrays of different lengths return #N/A error. 2 arguments used.');
		// Case #19: Formula. CORREL with only one valid point pair inside a conditional formula returns #DIV/0! error. 2 arguments used.
		oParser = new parserFormula('IF(CORREL({1,#N/A},{1,#N/A})>0,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(CORREL({1,#N/A},{1,#N/A})>0,TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. CORREL with only one valid point pair inside a conditional formula returns #DIV/0! error. 2 arguments used.');
		// Case #20: Reference link(2). Reference to same cell returns #DIV/0! error due to zero standard deviation. 2 arguments used.
		oParser = new parserFormula('CORREL(A100,A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(A100,A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link(2). Reference to same cell returns #DIV/0! error due to zero standard deviation. 2 arguments used.');
		// Case #21: Area, Formula. Mix of area and formula returning array. 2 arguments used.
		oParser = new parserFormula('CORREL(A100:A105,ROW(A1:A6))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(A100:A105,ROW(A1:A6)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area, Formula. Mix of area and formula returning array. 2 arguments used.');
		// Case #22: Array(2). No correlation due to constant values (returns #DIV/0! error). 2 arguments used.
		oParser = new parserFormula('CORREL({1,1,1},{0,0,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1,1,1},{0,0,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). No correlation due to constant values (returns #DIV/0! error). 2 arguments used.');

		// Bounded cases:

		// Case #1: Array(2). Perfect negative correlation (result = -1). 2 arguments used.
		oParser = new parserFormula('CORREL({1,2,3},{6,5,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1,2,3},{6,5,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Array(2). Perfect negative correlation (result = -1). 2 arguments used.');
		// Case #3: Area(2). Entire columns as arguments. 2 arguments used.
		oParser = new parserFormula('CORREL(A:A,B:B)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(A:A,B:B) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", 'Test: Bounded case: Area(2). Entire columns as arguments. 2 arguments used.');
		// Case #4: Area(2). Entire rows as arguments. 2 arguments used.
		oParser = new parserFormula('CORREL(100:100,101:101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL(100:100,101:101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.3562537034219062, 'Test: Bounded case: Area(2). Entire rows as arguments. 2 arguments used.');
		// Case #5: Array(2). Arrays with near-maximum Excel values. 2 arguments used.
		oParser = new parserFormula('CORREL({1E+307,1E+306,1E+305},{1E+307,1E+306,1E+305})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1E+307,1E+306,1E+305},{1E+307,1E+306,1E+305}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array(2). Arrays with near-maximum Excel values. 2 arguments used.');
		// Case #6: Array(2). Arrays with near-minimum Excel values. 2 arguments used.
		oParser = new parserFormula('CORREL({1E-307,1E-306,1E-305},{1E-307,1E-306,1E-305})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1E-307,1E-306,1E-305},{1E-307,1E-306,1E-305}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Array(2). Arrays with near-minimum Excel values. 2 arguments used.');
		// Case #7: Array(2). Minimum number of points required (2) for valid correlation. 2 arguments used.
		oParser = new parserFormula('CORREL({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array(2). Minimum number of points required (2) for valid correlation. 2 arguments used.');
		// Case #8: Array(2). Perfect negative correlation with 10 data points. 2 arguments used.
		oParser = new parserFormula('CORREL({1,2,3,4,5,6,7,8,9,10},{10,9,8,7,6,5,4,3,2,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CORREL({1,2,3,4,5,6,7,8,9,10},{10,9,8,7,6,5,4,3,2,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Array(2). Perfect negative correlation with 10 data points. 2 arguments used.');

		// Need to fix: error types diff in results

		testArrayFormula2(assert, "CORREL", 2, 2, null, true)
	});

	QUnit.test("Test: \"COUNT\"", function (assert) {

		ws.getRange2("A1:S210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("E2").setValue("TRUE");

		ws.getRange2("S5").setValue("#DIV/0!");
		ws.getRange2("S6").setValue("TRUE");
		ws.getRange2("S7").setValue("qwe");
		ws.getRange2("S8").setValue("");
		ws.getRange2("S9").setValue("2");

		ws.getRange2("A100").setValue("42");
		ws.getRange2("A101").setValue("Text");
		ws.getRange2("A102").setValue("");
		ws.getRange2("A103").setValue("TRUE");
		ws.getRange2("A104").setValue("#DIV/0");
		// Table type. Use A601:L6**
		getTableType(599, 0, 604, 0);
		ws.getRange2("A601").setValue("42"); // Column1
		ws.getRange2("A602").setValue("Text"); // Column1
		ws.getRange2("A603").setValue(""); // Column1
		ws.getRange2("A604").setValue("TRUE"); // Column1
		ws.getRange2("A605").setValue("#DIV/0!"); // Column1
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("42");
		ws2.getRange2("A2").setValue("Text");
		ws2.getRange2("A3").setValue("");
		ws2.getRange2("A4").setValue("TRUE");
		ws2.getRange2("A5").setValue("#DIV/0");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("42"); // TestName
		ws.getRange2("A202").setValue("Text"); // TestName1
		ws.getRange2("A206").setValue("42"); // TestNameArea
		ws.getRange2("A207").setValue("Text"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("42") // TestName3D
		ws2.getRange2("A12").setValue("Text") // TestName3D1
		ws2.getRange2("A16").setValue("42"); // TestNameArea3D
		ws2.getRange2("A17").setValue("Text"); // TestNameArea3D

		// Positive cases:

		// Case #1: Array. Return 5
		oParser = new parserFormula('COUNT({1,2,3,4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT({1,2,3,4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Return 5');
		// Case #2: Array. Return 5
		oParser = new parserFormula('COUNT(1,2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(1,2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Return 5');
		// Case #3: Array, Number, String. Return 7
		oParser = new parserFormula('COUNT({1,2,3,4,5},6,"7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT({1,2,3,4,5},6,"7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Array, Number, String. Return 7');
		// Case #4: Number(2). Return 1
		oParser = new parserFormula('COUNT(10,E150)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(10,E150) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Return 1');
		// Case #5: Number, Reference link. Return 1
		oParser = new parserFormula('COUNT(10,E2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(10,E2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Reference link. Return 1');
		// Case #6: Reference link. Return 0
		oParser = new parserFormula('COUNT(S5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(S5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Return 0');
		// Case #7: Reference link. Return 0
		oParser = new parserFormula('COUNT(S6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(S6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Return 0');
		// Case #8: Reference link. Return 0
		oParser = new parserFormula('COUNT(S7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(S7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Return 0');
		// Case #9: Reference link. Return 0
		oParser = new parserFormula('COUNT(S8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(S8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Return 0');
		// Case #10: Area. Return 1
		oParser = new parserFormula('COUNT(S5:S9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(S5:S9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Return 1');
		// Case #11: Area. Return 1
		oParser = new parserFormula('COUNT(S6:S9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(S6:S9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Return 1');
		// Case #12: Array. Return 2
		oParser = new parserFormula('COUNT({"7",true,false,4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT({"7",true,false,4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array. Return 2');
		// Case #13: Array. Return 0
		oParser = new parserFormula('COUNT({"7", true, false, false})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT({"7", true, false, false}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Return 0');
		// Case #14: Array. Return 1
		oParser = new parserFormula('COUNT({"7", true, false, false;"7", true, false, 2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT({"7", true, false, false;"7", true, false, 2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Return 1');
		// Case #15: Number. Single numeric argument counted
		oParser = new parserFormula('COUNT(42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Single numeric argument counted');
		// Case #16: Number(2). Two numeric arguments counted
		oParser = new parserFormula('COUNT(42,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(42,15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(2). Two numeric arguments counted');
		// Case #17: Number(3). Three numeric arguments counted
		oParser = new parserFormula('COUNT(42.5,15,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(42.5,15,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(3). Three numeric arguments counted');
		// Case #18: String,Number. Text string ignored, number counted
		oParser = new parserFormula('COUNT("Text",42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT("Text",42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String,Number. Text string ignored, number counted');
		// Case #19: String(2),Number. Text strings ignored, number counted
		oParser = new parserFormula('COUNT("Hello","World",42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT("Hello","World",42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String(2),Number. Text strings ignored, number counted');
		// Case #20: Boolean,Number. Boolean TRUE counted as number when direct argument
		oParser = new parserFormula('COUNT(TRUE,42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(TRUE,42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Boolean,Number. Boolean TRUE counted as number when direct argument');
		// Case #21: Boolean,Number. Boolean FALSE counted as number when direct argument
		oParser = new parserFormula('COUNT(FALSE,42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(FALSE,42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Boolean,Number. Boolean FALSE counted as number when direct argument');
		// Case #22: String(3). Numeric strings counted as numbers
		oParser = new parserFormula('COUNT("1","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT("1","2","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String(3). Numeric strings counted as numbers');
		// Case #23: Formula,Number. Formula result and number counted
		oParser = new parserFormula('COUNT(SQRT(16),42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(SQRT(16),42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula,Number. Formula result and number counted');
		// Case #24: Formula(2),Number. Multiple formulas and number counted
		oParser = new parserFormula('COUNT(ABS(-5),ROUND(3.7,0),42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(ABS(-5),ROUND(3.7,0),42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula(2),Number. Multiple formulas and number counted');
		// Case #25: Formula,Number. Date formula and number counted
		oParser = new parserFormula('COUNT(DATE(2024,12,8),42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(DATE(2024,12,8),42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula,Number. Date formula and number counted');
		// Case #26: Formula,Number. Time formula and number counted
		oParser = new parserFormula('COUNT(TIME(15,30,45),42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(TIME(15,30,45),42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula,Number. Time formula and number counted');
		// Case #27: Reference link. Single reference to number counted
		oParser = new parserFormula('COUNT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Single reference to number counted');
		// Case #28: Reference link(2). Two references counted
		oParser = new parserFormula('COUNT(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link(2). Two references counted');
		// Case #29: Area. Area with mixed data types - only numbers counted
		oParser = new parserFormula('COUNT(A100:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(A100:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Area with mixed data types - only numbers counted');
		// Case #30: Array. Array with numbers counted
		oParser = new parserFormula('COUNT({42,15,100})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT({42,15,100}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array. Array with numbers counted');
		// Case #31: Array. Array with mixed types - number and boolean counted
		oParser = new parserFormula('COUNT({42,"Text",TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT({42,"Text",TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Array with mixed types - number and boolean counted');
		// Case #32: Name. Named range with number counted
		oParser = new parserFormula('COUNT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name. Named range with number counted');
		// Case #33: Name3D. 3D named range with number counted
		oParser = new parserFormula('COUNT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name3D. 3D named range with number counted');
		// Case #34: Ref3D. 3D reference to number counted
		oParser = new parserFormula('COUNT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to number counted');
		// Case #35: Area3D. 3D area with mixed data counted
		oParser = new parserFormula('COUNT(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D area with mixed data counted');
		// Case #36: Table. Table reference counted
		oParser = new parserFormula('COUNT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table reference counted');
		// Case #37: Empty,Number. Empty argument convert to number counted, number counted
		oParser = new parserFormula('COUNT(,42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(,42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Empty,Number. Empty argument convert to number counted, number counted');
		// Case #38: Number,Empty,Number. Empty middle argument counted
		oParser = new parserFormula('COUNT(42,,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(42,,15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number,Empty,Number. Empty middle argument counted');
		// Case #39: Formula. COUNT as part of parent formula
		oParser = new parserFormula('SUM(COUNT(42,15),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COUNT(42,15),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Formula. COUNT as part of parent formula');
		// Case #40: Number,Formula. Number with date formula
		oParser = new parserFormula('COUNT(42,DATE(2024,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(42,DATE(2024,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number,Formula. Number with date formula');
		// Case #41: Formula(2). Multiple static date and time formulas
		oParser = new parserFormula('COUNT(DATE(2024,5,15),TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(DATE(2024,5,15),TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(2). Multiple static date and time formulas');

		// Negative cases:

		// Case #1: String. Text string not counted as number
		oParser = new parserFormula('COUNT("Text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT("Text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String. Text string not counted as number');
		// Case #2: String(2). Multiple text strings not counted
		oParser = new parserFormula('COUNT("Hello","World")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT("Hello","World") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String(2). Multiple text strings not counted');
		// Case #3: Error. Error value not counted
		oParser = new parserFormula('COUNT(#DIV/0!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(#DIV/0!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Error. Error value not counted');
		// Case #4: Error(2). Multiple error values not counted
		oParser = new parserFormula('COUNT(#N/A,#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(#N/A,#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Error(2). Multiple error values not counted');
		// Case #5: String,Error. Text and error not counted
		oParser = new parserFormula('COUNT("Text",#DIV/0!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT("Text",#DIV/0!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String,Error. Text and error not counted');
		// Case #6: Reference link. Reference to text not counted
		oParser = new parserFormula('COUNT(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to text not counted');
		// Case #7: Area. Area with text and empty - nothing counted
		oParser = new parserFormula('COUNT(A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(A101:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Area with text and empty - nothing counted');
		// Case #8: Array. Array with only text strings not counted
		oParser = new parserFormula('COUNT({"Text","Hello"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT({"Text","Hello"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with only text strings not counted');
		// Case #9: Array. Array with only errors not counted
		oParser = new parserFormula('COUNT({#DIV/0!,#N/A})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT({#DIV/0!,#N/A}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with only errors not counted');
		// Case #10: Name. Named range with text not counted
		oParser = new parserFormula('COUNT(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with text not counted');
		// Case #11: Name3D. 3D named range with text not counted
		oParser = new parserFormula('COUNT(TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with text not counted');
		// Case #12: Ref3D. 3D reference to text not counted
		oParser = new parserFormula('COUNT(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to text not counted');
		// Case #13: Area3D. 3D area with text and empty
		oParser = new parserFormula('COUNT(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D area with text and empty');
		// Case #14: String(3). Empty strings not counted
		oParser = new parserFormula('COUNT("","","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT("","","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String(3). Empty strings not counted');
		// Case #15: Formula. Formula returning text not counted
		oParser = new parserFormula('COUNT(CONCATENATE("A","B"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(CONCATENATE("A","B")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Formula. Formula returning text not counted');
		// Case #16: Formula,String. Text formulas and strings not counted
		oParser = new parserFormula('COUNT(UPPER("text"),"Hello")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(UPPER("text"),"Hello") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Formula,String. Text formulas and strings not counted');
		// Case #17: Area. Area with empty, boolean, error - nothing counted
		oParser = new parserFormula('COUNT(A102:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(A102:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Area with empty, boolean, error - nothing counted');
		// Case #18: Name. Named area range with mixed data
		oParser = new parserFormula('COUNT(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named area range with mixed data');
		// Case #19: Name3D. 3D named area range with mixed data
		oParser = new parserFormula('COUNT(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name3D. 3D named area range with mixed data');
		// Case #20: Formula. IF formula returning text not counted
		oParser = new parserFormula('COUNT(IF(TRUE,"Text","Number"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(IF(TRUE,"Text","Number")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Formula. IF formula returning text not counted');

		// Bounded cases:

		// Case #1: Area. Entire column reference
		oParser = new parserFormula('COUNT(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(A:A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 21, 'Test: Bounded case: Area. Entire column reference');
		// Case #2: Area. Entire row reference
		oParser = new parserFormula('COUNT(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Bounded case: Area. Entire row reference');
		// Case #3: Number. Maximum positive number
		oParser = new parserFormula('COUNT(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum positive number');
		// Case #4: Number. Maximum negative number
		oParser = new parserFormula('COUNT(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum negative number');
		// Case #5: Number. Minimum positive number
		oParser = new parserFormula('COUNT(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum positive number');
		// Case #6: Number. Minimum negative number
		oParser = new parserFormula('COUNT(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum negative number');
		// Case #7: Formula. Minimum Excel date
		oParser = new parserFormula('COUNT(DATE(1900,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(DATE(1900,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula. Minimum Excel date');
		// Case #8: Formula. Maximum Excel date
		oParser = new parserFormula('COUNT(DATE(9999,12,31))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNT(DATE(9999,12,31)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula. Maximum Excel date');

		testArrayFormula2(assert, "COUNT", 2, 2, null, true);
	});

	QUnit.test("Test: \"COUNTA\"", function (assert) {

		ws.getRange2("A1:S210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("E2").setValue("TRUE");

		ws.getRange2("S5").setValue("#DIV/0!");
		ws.getRange2("S6").setValue("TRUE");
		ws.getRange2("S7").setValue("qwe");
		ws.getRange2("S8").setValue("");
		ws.getRange2("S9").setValue("2");

		ws.getRange2("A100").setValue("42");
		ws.getRange2("A101").setValue("Text");
		ws.getRange2("A102").setValue("");
		ws.getRange2("A103").setValue("TRUE");
		ws.getRange2("A104").setValue("#DIV/0");
		// Table type. Use A601:L6**
		getTableType(599, 0, 604, 0);
		ws.getRange2("A601").setValue("42"); // Column1
		ws.getRange2("A602").setValue("Text"); // Column1
		ws.getRange2("A603").setValue(""); // Column1
		ws.getRange2("A604").setValue("TRUE"); // Column1
		ws.getRange2("A605").setValue("#DIV/0!"); // Column1
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("42");
		ws2.getRange2("A2").setValue("Text");
		ws2.getRange2("A3").setValue("");
		ws2.getRange2("A4").setValue("TRUE");
		ws2.getRange2("A5").setValue("#DIV/0");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("Text"); // TestName
		ws.getRange2("A206").setValue(""); // TestNameArea
		ws.getRange2("A207").setValue(""); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("Text") // TestName3D
		ws2.getRange2("A16").setValue(""); // TestNameArea3D
		ws2.getRange2("A17").setValue(""); // TestNameArea3D

		// Positive cases:

		// Case #1: Array. Return 5
		oParser = new parserFormula('COUNTA({1,2,3,4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA({1,2,3,4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Return 5');
		// Case #2: Number(5). Return 5
		oParser = new parserFormula('COUNTA(1,2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(1,2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number(5). Return 5');
		// Case #3: Array, Number, String. Return 7
		oParser = new parserFormula('COUNTA({1,2,3,4,5},6,"7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA({1,2,3,4,5},6,"7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: Array, Number, String. Return 7');
		// Case #4: Number, Reference link. Return 1
		oParser = new parserFormula('COUNTA(10,E150)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(10,E150) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Reference link. Return 1');
		// Case #5: Number, Reference link. Return 2
		oParser = new parserFormula('COUNTA(10,E2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(10,E2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, Reference link. Return 2');
		// Case #6: Reference link. Return 1
		oParser = new parserFormula('COUNTA(S5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(S5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Return 1');
		// Case #7: Reference link. Return 1
		oParser = new parserFormula('COUNTA(S6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(S6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Return 1');
		// Case #8: Reference link. Return 1
		oParser = new parserFormula('COUNTA(S7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(S7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Return 1');
		// Case #9: Reference link. Return 4
		oParser = new parserFormula('COUNTA(S5:S9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(S5:S9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Reference link. Return 4');
		// Case #10: Reference link. Return 3
		oParser = new parserFormula('COUNTA(S6:S9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(S6:S9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Reference link. Return 3');
		// Case #11: Number. Single numeric argument counted
		oParser = new parserFormula('COUNTA(42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Single numeric argument counted');
		// Case #12: Number(2). Two numeric arguments counted
		oParser = new parserFormula('COUNTA(42,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(42,15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(2). Two numeric arguments counted');
		// Case #13: Number(3). Three numeric arguments counted
		oParser = new parserFormula('COUNTA(42.5,15,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(42.5,15,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(3). Three numeric arguments counted');
		// Case #14: String,Number. Text string and number both counted
		oParser = new parserFormula('COUNTA("Text",42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA("Text",42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String,Number. Text string and number both counted');
		// Case #15: String(2),Number. Text strings and number all counted
		oParser = new parserFormula('COUNTA("Hello","World",42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA("Hello","World",42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String(2),Number. Text strings and number all counted');
		// Case #16: Boolean,Number. Boolean TRUE and number both counted
		oParser = new parserFormula('COUNTA(TRUE,42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(TRUE,42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Boolean,Number. Boolean TRUE and number both counted');
		// Case #17: Boolean,Number. Boolean FALSE and number both counted
		oParser = new parserFormula('COUNTA(FALSE,42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(FALSE,42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Boolean,Number. Boolean FALSE and number both counted');
		// Case #18: String(3). All string arguments counted
		oParser = new parserFormula('COUNTA("1","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA("1","2","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String(3). All string arguments counted');
		// Case #19: Formula,Number. Formula result and number counted
		oParser = new parserFormula('COUNTA(SQRT(16),42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(SQRT(16),42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula,Number. Formula result and number counted');
		// Case #20: Formula(2),Number. Multiple formulas and number counted
		oParser = new parserFormula('COUNTA(ABS(-5),ROUND(3.7,0),42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(ABS(-5),ROUND(3.7,0),42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula(2),Number. Multiple formulas and number counted');
		// Case #21: Formula,Number. Date formula and number counted
		oParser = new parserFormula('COUNTA(DATE(2024,12,8),42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(DATE(2024,12,8),42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula,Number. Date formula and number counted');
		// Case #22: Formula,Number. Time formula and number counted
		oParser = new parserFormula('COUNTA(TIME(15,30,45),42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(TIME(15,30,45),42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula,Number. Time formula and number counted');
		// Case #23: Error,Number. Error value and number both counted
		oParser = new parserFormula('COUNTA(#DIV/0!,42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(#DIV/0!,42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Error,Number. Error value and number both counted');
		// Case #24: Error(2),String. Multiple errors and text all counted
		oParser = new parserFormula('COUNTA(#N/A,#VALUE!,"Text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(#N/A,#VALUE!,"Text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Error(2),String. Multiple errors and text all counted');
		// Case #25: String,Error,Boolean. Mixed types with error all counted
		oParser = new parserFormula('COUNTA("Text",#DIV/0!,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA("Text",#DIV/0!,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String,Error,Boolean. Mixed types with error all counted');
		// Case #26: String. Empty string counted as non-empty
		oParser = new parserFormula('COUNTA("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. Empty string counted as non-empty');
		// Case #27: String(2). Empty string and text both counted
		oParser = new parserFormula('COUNTA("","Text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA("","Text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String(2). Empty string and text both counted');
		// Case #28: Formula. Formula returning empty string counted
		oParser = new parserFormula('COUNTA(CONCATENATE("",""))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(CONCATENATE("","")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Formula returning empty string counted');
		// Case #29: Reference link. Single reference to number counted
		oParser = new parserFormula('COUNTA(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Single reference to number counted');
		// Case #30: Reference link(2). Two references counted
		oParser = new parserFormula('COUNTA(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Reference link(2). Two references counted');
		// Case #31: Area. Area with mixed data types - all non-empty counted
		oParser = new parserFormula('COUNTA(A100:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(A100:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Area. Area with mixed data types - all non-empty counted');
		// Case #32: Array. Array with numbers counted
		oParser = new parserFormula('COUNTA({42,15,100})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA({42,15,100}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array. Array with numbers counted');
		// Case #33: Array. Array with mixed types all counted
		oParser = new parserFormula('COUNTA({42,"Text",TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA({42,"Text",TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array. Array with mixed types all counted');
		// Case #34: Array. Array with text, error, boolean all counted
		oParser = new parserFormula('COUNTA({"Text",#DIV/0!,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA({"Text",#DIV/0!,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array. Array with text, error, boolean all counted');
		// Case #35: Name. Named range with number counted
		oParser = new parserFormula('COUNTA(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name. Named range with number counted');
		// Case #36: Name3D. 3D named range with number counted
		oParser = new parserFormula('COUNTA(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name3D. 3D named range with number counted');
		// Case #37: Ref3D. 3D reference to number counted
		oParser = new parserFormula('COUNTA(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to number counted');
		// Case #38: Area3D. 3D area with mixed data counted
		oParser = new parserFormula('COUNTA(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D area with mixed data counted');
		// Case #39: Table. Table reference counted
		oParser = new parserFormula('COUNTA(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Table. Table reference counted');
		// Case #40: Empty,Number. Empty argument counted, number counted
		// Different result with MS
		oParser = new parserFormula('COUNTA(,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(,"") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Empty,Number. Empty argument counted, number counted');
		// Case #41: Number,Empty,Number. Empty middle argument  counted
		// Different result with MS
		oParser = new parserFormula('COUNTA(42,,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(42,,15) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number,Empty,Number. Empty middle argument  counted');
		// Case #42: Formula. COUNTA as part of parent formula
		oParser = new parserFormula('SUM(COUNTA(42,"Text"),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COUNTA(42,"Text"),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Formula. COUNTA as part of parent formula');
		// Case #43: String,Boolean,Error. String, boolean, error all counted
		oParser = new parserFormula('COUNTA("Test",TRUE,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA("Test",TRUE,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String,Boolean,Error. String, boolean, error all counted');
		// Case #44: Formula(2). Multiple static date and time formulas
		oParser = new parserFormula('COUNTA(DATE(2024,5,15),TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(DATE(2024,5,15),TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(2). Multiple static date and time formulas');
		// Case #45: Boolean(2),Error. Multiple booleans and error counted
		oParser = new parserFormula('COUNTA(TRUE,FALSE,#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(TRUE,FALSE,#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Boolean(2),Error. Multiple booleans and error counted');
		// Case #46: String,Formula. Empty string and text formula counted
		oParser = new parserFormula('COUNTA("",CONCATENATE("A","B"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA("",CONCATENATE("A","B")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String,Formula. Empty string and text formula counted');
		// Case #47: Error(3). Multiple error values all counted
		oParser = new parserFormula('COUNTA(#DIV/0!,#N/A,#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(#DIV/0!,#N/A,#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Error(3). Multiple error values all counted');

		// Negative cases:

		// Case #1: Reference link. Reference to empty cell not counted
		oParser = new parserFormula('COUNTA(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to empty cell not counted');
		// Case #2: Area. Area with single empty cell not counted
		oParser = new parserFormula('COUNTA(A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Area with single empty cell not counted');
		// Case #3: Name. Named area with empty cells
		oParser = new parserFormula('COUNTA(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named area with empty cells');
		// Case #4: Name3D. 3D named area with empty cells
		oParser = new parserFormula('COUNTA(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named area with empty cells');
		// Case #5: Ref3D. 3D reference to empty cell
		oParser = new parserFormula('COUNTA(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to empty cell');
		// Case #6: Area3D. 3D area with empty cells
		oParser = new parserFormula('COUNTA(Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D area with empty cells');
		// Case #7: Reference link. Return 0
		oParser = new parserFormula('COUNTA(S8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(S8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Return 0');

		// Bounded cases:

		// Case #1: Area. Entire column reference
		oParser = new parserFormula('COUNTA(M:M)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(M:M) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Area. Entire column reference');
		// Case #2: Area. Entire row reference
		oParser = new parserFormula('COUNTA(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Bounded case: Area. Entire row reference');
		// Case #3: Number. Maximum positive number
		oParser = new parserFormula('COUNTA(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum positive number');
		// Case #4: Number. Maximum negative number
		oParser = new parserFormula('COUNTA(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum negative number');
		// Case #5: Number. Minimum positive number
		oParser = new parserFormula('COUNTA(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum positive number');
		// Case #6: Number. Minimum negative number
		oParser = new parserFormula('COUNTA(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum negative number');
		// Case #7: Formula. Minimum Excel date
		oParser = new parserFormula('COUNTA(DATE(1900,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(DATE(1900,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula. Minimum Excel date');
		// Case #8: Formula. Maximum Excel date
		oParser = new parserFormula('COUNTA(DATE(9999,12,31))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTA(DATE(9999,12,31)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula. Maximum Excel date');

		// Need to fix: empty handle
		// Case #40: Empty,Number. Empty argument counted, number counted
		// Case #41: Number,Empty,Number. Empty middle argument  counted
		// Case #2: Area. Entire row reference

	});

	QUnit.test("Test: \"COUNTIFS\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();

		ws.getRange2("A15").setValue("Yes");
		ws.getRange2("A16").setValue("Yes");
		ws.getRange2("A17").setValue("Yes");
		ws.getRange2("A18").setValue("No");

		ws.getRange2("B15").setValue("No");
		ws.getRange2("B16").setValue("Yes");
		ws.getRange2("B17").setValue("Yes");
		ws.getRange2("B18").setValue("Yes");

		ws.getRange2("C15").setValue("No");
		ws.getRange2("C16").setValue("No");
		ws.getRange2("C17").setValue("Yes");
		ws.getRange2("C18").setValue("Yes");

		oParser = new parserFormula("COUNTIFS(A15:C15,\"=Yes\")", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("COUNTIFS(A15:A18,\"=Yes\",B15:B18,\"=Yes\")", "B1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula("COUNTIFS(A18:C18,\"=Yes\",A16:C16,\"=Yes\")", "C1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		ws.getRange2("D15").setValue("1");
		ws.getRange2("D16").setValue("2");
		ws.getRange2("D17").setValue("3");
		ws.getRange2("D18").setValue("4");
		ws.getRange2("D19").setValue("5");
		ws.getRange2("D20").setValue("6");

		ws.getRange2("E15").setValue("5/1/2011");
		ws.getRange2("E16").setValue("5/2/2011");
		ws.getRange2("E17").setValue("5/3/2011");
		ws.getRange2("E18").setValue("5/4/2011");
		ws.getRange2("E19").setValue("5/5/2011");
		ws.getRange2("E20").setValue("5/6/2011");

		oParser = new parserFormula("COUNTIFS(D15:D20,\"<6\",D15:D20,\">1\")", "D1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		oParser = new parserFormula("COUNTIFS(D15:D20,\"<5\",E15:E20,\"<5/3/2011\")", "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula("COUNTIFS(D15:D20,\"<\" & D19,E15:E20,\"<\" & E17)", "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);


		testArrayFormulaEqualsValues(assert, "1,1,1,#N/A;1,1,1,#N/A;#N/A,#N/A,#N/A,#N/A", "COUNTIFS(A1:C2,A1:C2,A1:C2,A1:C2, A1:C2,A1:C2)");
		testArrayFormulaEqualsValues(assert, "1,0,0,#N/A;1,0,0,#N/A;#N/A,#N/A,#N/A,#N/A", "COUNTIFS(A1:C2,A1:A2,A1:C2,A1:C2,A1:C2,A1:C2)");
		testArrayFormulaEqualsValues(assert, "#VALUE!,#VALUE!,#VALUE!,#N/A;#VALUE!,#VALUE!,#VALUE!,#N/A;#N/A,#N/A,#N/A,#N/A", "COUNTIFS(A1:C2,A1:C2,A1:A2,A1:C2,A1:A2,A1:C2)");


		ws.getRange2("DS2").setValue("12");
		ws.getRange2("DS3").setValue("2");
		ws.getRange2("DS4").setValue("3");
		ws.getRange2("DS5").setValue("4");
		ws.getRange2("DS6").setValue("e");
		ws.getRange2("DS10").setValue("12");

		ws.getRange2("DU2").setValue("1");
		ws.getRange2("DU3").setValue("2");
		ws.getRange2("DU4").setValue("11");
		ws.getRange2("DU5").setValue("11");
		ws.getRange2("DU6").setValue("w");
		ws.getRange2("DU9").setValue("12");
		ws.getRange2("DU10").setValue("12");

		oParser = new parserFormula('COUNTIFS(DS:DS,">3",DU:DU,">10")', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(DS:DS,">3",DU1:DU2,">10")', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('COUNTIFS(DS2:DS3,">3",DU:DU,">10")', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('COUNTIFS(DS:DS,"e",DU:DU,"w")', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula('COUNTIFS(DS1:DS10,"<5",DU1:DU10,">2")', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(DS1:DS11,"<5",DU1:DU10,">2")', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula('COUNTIFS(DS1:DS10,"<5",DU1:DU11,">2")', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// bool, ref, num, string, err
		ws.getRange2("A88").setValue("#DIV/0!");
		ws.getRange2("A89").setValue("#NUM!");
		ws.getRange2("A90").setValue("TRUE");
		ws.getRange2("A91").setValue("TRUE");
		ws.getRange2("A92").setValue("FALSE");
		ws.getRange2("A93").setValue("FALSE");
		ws.getRange2("A94").setValue("1");
		ws.getRange2("A95").setValue("0");
		ws.getRange2("A96").setValue("1s");
		ws.getRange2("A97").setValue("1");
		ws.getRange2("A97").setNumFormat("@");
		ws.getRange2("A98").setValue("");
		ws.getRange2("A99").setValue("0");

		oParser = new parserFormula('COUNTIFS(A90:A99,TRUE)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,A90)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,FALSE)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,A92)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,1)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,A94)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,A97)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,0)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,A95)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,"")', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula('COUNTIFS(A90:A99,A98)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(A90:A99,A88)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula('COUNTIFS(A90:A99,#DIV/0!)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula('COUNTIFS(A90:A99,#NUM!)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula('COUNTIFS(A90:A99,A89)', "E1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		// arg0 = #DIV/0!
		oParser = new parserFormula('COUNTIFS(A88,A88:A99)', "E1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Result of COUNTIFS(A88,A88:A99)[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Result of COUNTIFS(A88,A88:A99)[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 0, 'Result of COUNTIFS(A88,A88:A99)[2,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(3,0).getValue(), 0, 'Result of COUNTIFS(A88,A88:A99)[3,0]');

		// arg0 = TRUE
		oParser = new parserFormula('COUNTIFS(A90,A88:A99)', "E1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Result of COUNTIFS(A90,A88:A99)[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Result of COUNTIFS(A90,A88:A99)[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 1, 'Result of COUNTIFS(A90,A88:A99)[2,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(3,0).getValue(), 1, 'Result of COUNTIFS(A90,A88:A99)[3,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(4,0).getValue(), 0, 'Result of COUNTIFS(A90,A88:A99)[4,0]');

		// arg0 = 0
		oParser = new parserFormula('COUNTIFS(A95,A88:A99)', "E1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(4,0).getValue(), 0, 'Result of COUNTIFS(A95,A88:A99)[4,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(5,0).getValue(), 0, 'Result of COUNTIFS(A95,A88:A99)[5,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(6,0).getValue(), 0, 'Result of COUNTIFS(A95,A88:A99)[6,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(7,0).getValue(), 1, 'Result of COUNTIFS(A95,A88:A99)[7,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(8,0).getValue(), 0, 'Result of COUNTIFS(A95,A88:A99)[8,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(9,0).getValue(), 0, 'Result of COUNTIFS(A95,A88:A99)[9,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(10,0).getValue(), 1, 'Result of COUNTIFS(A95,A88:A99)[10,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(11,0).getValue(), 1, 'Result of COUNTIFS(A95,A88:A99)[11,0]');

		// arg0 = cEmpty
		oParser = new parserFormula('COUNTIFS(A98,A88:A99)', "E1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(4,0).getValue(), 0, 'Result of COUNTIFS(A98,A88:A99)[4,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(5,0).getValue(), 0, 'Result of COUNTIFS(A98,A88:A99)[5,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(6,0).getValue(), 0, 'Result of COUNTIFS(A98,A88:A99)[6,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(7,0).getValue(), 0, 'Result of COUNTIFS(A98,A88:A99)[7,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(8,0).getValue(), 0, 'Result of COUNTIFS(A98,A88:A99)[8,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(9,0).getValue(), 0, 'Result of COUNTIFS(A98,A88:A99)[9,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(10,0).getValue(), 0, 'Result of COUNTIFS(A98,A88:A99)[10,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(11,0).getValue(), 0, 'Result of COUNTIFS(A98,A88:A99)[11,0]');


		// bug 58497
		ws.getRange2("A100:Z300").cleanAll();
		ws.getRange2("A101").setValue("str1");
		ws.getRange2("A102").setValue("str2");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A104").setValue("");

		oParser = new parserFormula('COUNTIFS(A101:A104,A101:A104)', "E1", ws);
		assert.ok(oParser.parse(), "COUNTIFS(A101:A104,A101:A104)");
		// without setArrayFormulaRef executed as .cross and as result and as a result, #VALUE comes into the second argument
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of COUNTIFS(A101:A104,A101:A104)");

		oParser = new parserFormula('COUNTIFS(A101:A104,A101:A104&"")', "E1", ws);
		assert.ok(oParser.parse(), 'COUNTIFS(A101:A104,A101:A104&"")');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Result of COUNTIFS(A101:A104,A101:A104&"")[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Result of COUNTIFS(A101:A104,A101:A104&"")[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 2, 'Result of COUNTIFS(A101:A104,A101:A104&"")[2,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(3,0).getValue(), 2, 'Result of COUNTIFS(A101:A104,A101:A104&"")[3,0]');

		oParser = new parserFormula('COUNTIFS(A101:A104,A101:A104)', "E1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse(), "COUNTIFS(A101:A104,A101:A104)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, "Result of COUNTIFS(A101:A104,A101:A104)[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, "Result of COUNTIFS(A101:A104,A101:A104)[1,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 0, "Result of COUNTIFS(A101:A104,A101:A104)[2,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(3,0).getValue(), 0, "Result of COUNTIFS(A101:A104,A101:A104)[3,0]");

		oParser = new parserFormula('COUNTIFS(A101:A104,A101:A104&"")', "E1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("AD6:AF8").bbox);
		assert.ok(oParser.parse(), 'COUNTIFS(A101:A104,A101:A104&"")');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Result of COUNTIFS(A101:A104,A101:A104&"")[0,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Result of COUNTIFS(A101:A104,A101:A104&"")[1,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 2, 'Result of COUNTIFS(A101:A104,A101:A104&"")[2,0]');
		assert.strictEqual(oParser.calculate().getElementRowCol(3,0).getValue(), 2, 'Result of COUNTIFS(A101:A104,A101:A104&"")[3,0]');

		// for bug 64880
		ws.getRange2("B:B").cleanAll();
		ws.getRange2("B101").setValue("22");
		ws.getRange2("B102").setValue("35");
		ws.getRange2("B103").setValue("1");
		ws.getRange2("B104").setValue("55");
		ws.getRange2("B105").setValue("1");
		ws.getRange2("B106").setValue("10");

		ws.getRange2("C:C").cleanAll();
		ws.getRange2("C101").setValue("3");
		ws.getRange2("C102").setValue("0");
		ws.getRange2("C103").setValue("6");
		ws.getRange2("C104").setValue("5");
		ws.getRange2("C105").setValue("2");
		ws.getRange2("C106").setValue("1");

		oParser = new parserFormula('COUNTIFS(B101:B106,">0",C101:C106,"=0")', "E1", ws);
		assert.ok(oParser.parse(), 'COUNTIFS(B101:B106,">0",C101:C106,"=0")');
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula('COUNTIFS(B:B,">0",C:C,"=0")', "E1", ws);
		assert.ok(oParser.parse(), 'COUNTIFS(B:B,">0",C:C,"=0")');
		assert.strictEqual(oParser.calculate().getValue(), 1);

		ws.getRange2("C106").setValue("0");

		oParser = new parserFormula('COUNTIFS(B101:B106,">0",C101:C106,"=0")', "E1", ws);
		assert.ok(oParser.parse(), 'COUNTIFS(B101:B106,">0",C101:C106,"=0")');
		assert.strictEqual(oParser.calculate().getValue(), 2);

		oParser = new parserFormula('COUNTIFS(B:B,">0",C:C,"=0")', "E1", ws);
		assert.ok(oParser.parse(), 'COUNTIFS(B:B,">0",C:C,"=0")');
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// for bug 66654
		ws.getRange2("C200:C220").cleanAll();
		ws.getRange2("C200:C210").setValue("externe");
		ws.getRange2("C212:C215").setValue("interne");
		ws.getRange2("C217:C220").setValue("externe");

		ws.getRange2("D200:D220").cleanAll();
		ws.getRange2("D200:D204").setValue("1")

		ws.getRange2("F200:F220").cleanAll();
		ws.getRange2("F200:F202").setValue("1");
		ws.getRange2("F205:F215").setValue("1");
		ws.getRange2("F219:F220").setValue("1");

		oParser = new parserFormula('COUNTIFS(C200:C220,"=externe")', "E1", ws);
		assert.ok(oParser.parse(), 'COUNTIFS(C200:C220,"=externe")',);
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Result of COUNTIFS(C200:C220,"=externe")');

		oParser = new parserFormula('COUNTIFS(C200:C220,"=externe", D200:D220, "=1")', "E1", ws);
		assert.ok(oParser.parse(), 'COUNTIFS(C200:C220,"=externe", D200:D220, "=1")',);
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Result of COUNTIFS(C200:C220,"=externe", D200:D220, "=1")');

		oParser = new parserFormula('COUNTIFS(C200:C220,"=externe", D200:D220, "=1", F200:F220, "=1")', "E1", ws);
		assert.ok(oParser.parse(), 'COUNTIFS(C200:C220,"=externe", D200:D220, "=1", F200:F220, "=1")',);
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Result of COUNTIFS(C200:C220,"=externe", D200:D220, "=1", F200:F220, "=1")');

	});

	QUnit.test("Test: \"COUNTIFS with multiple criteria ranges\"", function (assert) {
        // Setup test data with 5 columns for testing
        ws.getRange2("E2").setValue("10");
        ws.getRange2("E3").setValue("20");
        ws.getRange2("E4").setValue("30");
        ws.getRange2("E5").setValue("40");
        ws.getRange2("E6").setValue("50");
        ws.getRange2("E7").setValue("60");

        ws.getRange2("F2").setValue("Red");
        ws.getRange2("F3").setValue("Blue");
        ws.getRange2("F4").setValue("Green");
        ws.getRange2("F5").setValue("Red");
        ws.getRange2("F6").setValue("Blue");
        ws.getRange2("F7").setValue("Green");

        ws.getRange2("G2").setValue("Small");
        ws.getRange2("G3").setValue("Medium");
        ws.getRange2("G4").setValue("Large");
        ws.getRange2("G5").setValue("Large");
        ws.getRange2("G6").setValue("Medium");
        ws.getRange2("G7").setValue("Small");

        ws.getRange2("H2").setValue("2023");
        ws.getRange2("H3").setValue("2023");
        ws.getRange2("H4").setValue("2024");
        ws.getRange2("H5").setValue("2024");
        ws.getRange2("H6").setValue("2025");
        ws.getRange2("H7").setValue("2025");

        ws.getRange2("I2").setValue("A");
        ws.getRange2("I3").setValue("B");
        ws.getRange2("I4").setValue("C");
        ws.getRange2("I5").setValue("A");
        ws.getRange2("I6").setValue("B");
        ws.getRange2("I7").setValue("C");

        // Test with 10 arguments (5 criteria pairs)
        oParser = new parserFormula("COUNTIFS(F2:F7, \"Red\", G2:G7, \"Large\", H2:H7, 2024, I2:I7, \"A\", I2:I7, \"*\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with 5 criteria pairs");
        assert.strictEqual(oParser.calculate().getValue(), 1, "COUNTIFS with 5 criteria pairs"); // Only one row matches all criteria

        // Test with 10 arguments where none match all criteria
        oParser = new parserFormula("COUNTIFS(F2:F7, \"Red\", G2:G7, \"Small\", H2:H7, 2024, I2:I7, \"A\", I2:I7, \"Z\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with 5 criteria pairs - no match");
        assert.strictEqual(oParser.calculate().getValue(), 0, "COUNTIFS with 5 criteria pairs - no match");

        // Test with numeric criteria and comparison operators
        oParser = new parserFormula("COUNTIFS(E2:E7, \">20\", H2:H7, \">=2024\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with numeric criteria");
        assert.strictEqual(oParser.calculate().getValue(), 4, "COUNTIFS with numeric criteria"); // Count values >20 in years >=2024

        // Test with cell references for criteria
        ws.getRange2("J2").setValue("Red");
        ws.getRange2("J3").setValue("Large");
        ws.getRange2("J4").setValue("2024");
        ws.getRange2("J5").setValue("A");
        oParser = new parserFormula("COUNTIFS(F2:F7, J2, G2:G7, J3, H2:H7, J4, I2:I7, J5, I2:I7, \"*\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with cell references for criteria");
        assert.strictEqual(oParser.calculate().getValue(), 1, "COUNTIFS with cell references for criteria");

        // Test with wildcard criteria
        oParser = new parserFormula("COUNTIFS(F2:F7, \"*e*\", G2:G7, \"*arge\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with wildcard criteria");
        assert.strictEqual(oParser.calculate().getValue(), 2, "COUNTIFS with wildcard criteria"); // Red/Green with Large

        // Test with multiple criteria for same range
        oParser = new parserFormula("COUNTIFS(H2:H7, \">2023\", H2:H7, \"<=2024\", G2:G7, \"Large\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with multiple criteria for same range");
        assert.strictEqual(oParser.calculate().getValue(), 2, "COUNTIFS with multiple criteria for same range");

        // Test with blank criteria
        ws.getRange2("F4").setValue("");
        oParser = new parserFormula("COUNTIFS(F2:F7, \"\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with blank criteria");
        assert.strictEqual(oParser.calculate().getValue(), 1, "COUNTIFS with blank criteria");

        // Test with error handling - mismatched ranges
        oParser = new parserFormula("COUNTIFS(F2:F7, \"Red\", G2:G6, \"Large\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with mismatched ranges");
        assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "COUNTIFS with mismatched ranges should return #VALUE!");

        // Test counting specific patterns
        oParser = new parserFormula("COUNTIFS(G2:G7, \"*\", F2:F7, \"=Red\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with pattern matching");
        assert.strictEqual(oParser.calculate().getValue(), 2, "COUNTIFS with pattern matching"); // Count all Red entries

        // Test with complex criteria combinations
        oParser = new parserFormula("COUNTIFS(E2:E7, \">30\", F2:F7, \"<>Red\", G2:G7, \"=Medium\", H2:H7, \">=2024\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with complex criteria combinations");
        assert.strictEqual(oParser.calculate().getValue(), 1, "COUNTIFS with complex criteria combinations");

        // Test with range of numbers
        oParser = new parserFormula("COUNTIFS(E2:E7, \">=20\", E2:E7, \"<=40\", H2:H7, \"2024\")", "A1", ws);
        assert.ok(oParser.parse(), "COUNTIFS with number range");
        assert.strictEqual(oParser.calculate().getValue(), 2, "COUNTIFS with number range");

        // Cleanup
        ws.getRange2("F4").setValue("Green"); // Restore original value
    });

	QUnit.test("Test: \"COUNTIF\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();

		ws.getRange2("A7").setValue("3");
		ws.getRange2("B7").setValue("10");
		ws.getRange2("C7").setValue("7");
		ws.getRange2("D7").setValue("10");

		ws.getRange2("A8").setValue("apples");
		ws.getRange2("B8").setValue("oranges");
		ws.getRange2("C8").setValue("grapes");
		ws.getRange2("D8").setValue("melons");

		// Positive Cases:
		// Case #1: Area, String. Find equal number in Area
		oParser = new parserFormula("COUNTIF(A7:D7,\"=10\")", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #2: Area, String. Find numbers greater than value in Area
		oParser = new parserFormula("COUNTIF(A7:D7,\">5\")", "B1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		// Case #3: Area, String. Find numbers not equal to value in Area
		oParser = new parserFormula("COUNTIF(A7:D7,\"<>10\")", "C1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #4: Area, String. Find text ending with pattern using wildcard
		oParser = new parserFormula("COUNTIF(A8:D8,\"*es\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		// Case #5: Area, String. Find text matching pattern with question marks and wildcard
		oParser = new parserFormula("COUNTIF(A8:D8,\"??a*\")", "B2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #6: Area, String. Find text containing letter using wildcards
		oParser = new parserFormula("COUNTIF(A8:D8,\"*l*\")", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		wb.dependencyFormulas.unlockRecal();

		ws.getRange2("CC1").setValue("1");
		ws.getRange2("CC2").setValue("0");
		ws.getRange2("CC3").setValue("1");
		ws.getRange2("CC4").setValue("true");
		ws.getRange2("CC5").setValue("=true");
		ws.getRange2("CC6").setValue("=true()");
		ws.getRange2("CC7").setValue("'true'");
		ws.getRange2("CC8").setValue("");

		// Case #7: Area, Formula. Count TRUE values using TRUE() function
		oParser = new parserFormula("COUNTIF(CC1:CC7, TRUE())", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		// Case #8: Area, Boolean. Count TRUE values using boolean literal
		oParser = new parserFormula("COUNTIF(CC1:CC7, TRUE)", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		// Case #9: Area, Number. Count cells equal to 1
		oParser = new parserFormula("COUNTIF(CC1:CC7, 1)", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #10: Area, Number. Count cells equal to 0
		oParser = new parserFormula("COUNTIF(CC1:CC7, 0)", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		// Case #11: Ref, String. Count text criteria in single cell (no match)
		ws.getRange2("CC8").setValue(">3");
		oParser = new parserFormula("COUNTIF(CC8,\">3\")", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		// Case #12: Ref, String. Count text criteria in single cell with equals prefix
		ws.getRange2("CC8").setValue(">3");
		oParser = new parserFormula("COUNTIF(CC8,\"=>3\")", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		// Case #13: Area, String. Count error values using string representation
		ws.getRange2("CC9").setValue("=NA()");
		ws.getRange2("CC10").setValue("#N/A");
		oParser = new parserFormula("COUNTIF(CC9:CC10,\"#N/A\")", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #14: Area, Formula. Count error values using NA() function
		oParser = new parserFormula("COUNTIF(CC9:CC10, NA())", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #15: Area, String. Count formula text (no match for function call)
		oParser = new parserFormula("COUNTIF(CC9:CC10,\"=NA()\")", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		// Case #16: Area, String. Count numbers greater than or equal to 1
		oParser = new parserFormula("COUNTIF(CC1:CC8,\">=1\")", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #17: Area, String. Count numbers equal to 1
		oParser = new parserFormula("COUNTIF(CC1:CC8,\"=1\")", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #18: Area, String. Count numbers less than 1
		oParser = new parserFormula("COUNTIF(CC1:CC8,\"<1\")", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		// Case #19: Area, String. Count numbers greater than 1
		oParser = new parserFormula("COUNTIF(CC1:CC8,\">1\")", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		// Case #20: Area, String. Count using dynamic criteria with cell reference
		oParser = new parserFormula("COUNTIF(CC1:CC8,\"=\"&CC8)", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		wb.dependencyFormulas.lockRecal();

		ws.getRange2("A22").setValue("apples");
		ws.getRange2("A23").setValue("");
		ws.getRange2("A24").setValue("oranges");
		ws.getRange2("A25").setValue("peaches");
		ws.getRange2("A26").setValue("");
		ws.getRange2("A27").setValue("apples");

		// Case #21: Area, String. Count text ending with pattern using wildcard
		oParser = new parserFormula('COUNTIF(A22:A27,"*es")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		// Case #22: Area, String. Count text with exact length ending with pattern
		oParser = new parserFormula('COUNTIF(A22:A27,"?????es")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #23: Area, String. Count all non-empty text cells using wildcard
		oParser = new parserFormula('COUNTIF(A22:A27,"*")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		// Case #24: Area, String. Count cells not equal to literal asterisks
		oParser = new parserFormula('COUNTIF(A22:A27,"<>"&"***")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #25: Area, String. Count cells not equal to single asterisk
		oParser = new parserFormula('COUNTIF(A22:A27,"<>"&"*")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #26: Area, String. Count cells not equal to single question mark
		oParser = new parserFormula('COUNTIF(A22:A27,"<>"&"?")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 6);

		// Case #27: Area, String. Count exact date string match
		ws.getRange2("A1").setValue("12/1");
		ws.getRange2("A2").setValue("12/1");
		oParser = new parserFormula('COUNTIF(A1:A2,"12/1")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #28: Area, String. Count date string with no match
		oParser = new parserFormula('COUNTIF(A1:A2,"12/1/1")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		ws.getRange2("A100").setValue("Math");
		ws.getRange2("A101").setValue("87");
		ws.getRange2("A102").setValue("99");
		ws.getRange2("A103").setValue("21");
		ws.getRange2("A104").setValue("72");
		ws.getRange2("A105").setValue("68");
		ws.getRange2("B100").setValue("Physics");
		ws.getRange2("B101").setValue("91");
		ws.getRange2("B102").setValue("78");
		ws.getRange2("B103").setValue("12");
		ws.getRange2("B104").setValue("23");
		ws.getRange2("B105").setValue("55");

		// Case #32: Formula, String. Count values greater than 80 in XLOOKUP result (Math). For bug 62491
		oParser = new parserFormula('COUNTIF(XLOOKUP(A100,A100:B100,A101:B105),">80")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #33: Formula, String. Count values greater than 80 in XLOOKUP result (Physics)
		oParser = new parserFormula('COUNTIF(XLOOKUP(B100,A100:B100,A101:B105),">80")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		ws.getRange2("A100:D320").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("Math");
		ws.getRange2("A101").setValue("87");
		ws.getRange2("A102").setValue("99");
		ws.getRange2("A103").setValue("21");
		ws.getRange2("A104").setValue("72");
		ws.getRange2("A105").setValue("68");

		ws.getRange2("B100").setValue("Physics");
		ws.getRange2("B101").setValue("91");
		ws.getRange2("B102").setValue("78");
		ws.getRange2("B103").setValue("12");
		ws.getRange2("B104").setValue("23");
		ws.getRange2("B105").setValue("55");

		ws.getRange2("A201").setValue("123");
		ws.getRange2("A204").setValue("#N/A");
		ws.getRange2("B205").setValue("asd");
		ws.getRange2("B206").setValue("123");
		ws.getRange2("B207").setValue("ASD");

		ws.getRange2("A300").setValue("a*c");
		ws.getRange2("A301").setValue("aac");
		ws.getRange2("A302").setValue("a123c");
		ws.getRange2("A303").setValue("a**c");
		ws.getRange2("A304").setValue("");
		ws.getRange2("A305").setValue("");
		ws.getRange2("A306").setValue("a*c");
		ws.getRange2("A307").setValue("aac");
		ws.getRange2("A308").setValue("a123c");
		ws.getRange2("A309").setValue("a**c");
		ws.getRange2("A310").setValue("a*c");
		ws.getRange2("A311").setValue("aac");
		ws.getRange2("A312").setValue("a123c");
		ws.getRange2("A313").setValue("a**c");
		ws.getRange2("A314").setValue("a*c");
		ws.getRange2("A315").setValue("aac");
		ws.getRange2("A316").setValue("a123c");
		ws.getRange2("A317").setValue("a**c");
		ws.getRange2("A318").setValue("a*c");
		ws.getRange2("A319").setValue("aac");
		ws.getRange2("A320").setValue("a123c");

		ws.getRange2("A700:D800").cleanAll();
		ws.getRange2("A700").setValue("3");
		ws.getRange2("B700").setValue("10");
		ws.getRange2("C700").setValue("7");
		ws.getRange2("D700").setValue("10");

		ws.getRange2("A800").setValue("apples");
		ws.getRange2("B800").setValue("oranges");
		ws.getRange2("C800").setValue("grapes");
		ws.getRange2("D800").setValue("melons");

		ws.getRange2("AB1:AF4").cleanAll();
		ws.getRange2("AB1").setValue("#N/A");
		ws.getRange2("AB2").setValue("#DIV/0!");
		ws.getRange2("AB3").setValue("#VALUE!");
		ws.getRange2("AB4").setValue("5");
		ws.getRange2("AD1").setValue("#N/A");
		ws.getRange2("AD2").setValue("10");
		ws.getRange2("AD3").setValue("20");
		ws.getRange2("AD4").setValue("text");
		ws.getRange2("AE1").setValue("#N/A");
		ws.getRange2("AE2").setValue("#DIV/0!");
		ws.getRange2("AE3").setValue("#N/A");
		ws.getRange2("AE4").setValue("42");
		ws.getRange2("AF1").setValue("#VALUE!");
		ws.getRange2("AF2").setValue("#DIV/0!");
		ws.getRange2("AF3").setValue("#VALUE!");
		ws.getRange2("AF4").setValue("42");

		ws.getRange2("CC1:CC12").cleanAll();
		ws.getRange2("CC1").setValue("1");
		ws.getRange2("CC2").setValue("0");
		ws.getRange2("CC3").setValue("1");
		ws.getRange2("CC4").setValue("TRUE");
		ws.getRange2("CC5").setValue("TRUE");
		ws.getRange2("CC6").setValue("TRUE");
		ws.getRange2("CC7").setValue("'true'");
		ws.getRange2("CC8").setValue("");
		ws.getRange2("CC9").setValue(">3");
		ws.getRange2("CC10").setValue(">3");
		ws.getRange2("CC11").setValue("#N/A");
		ws.getRange2("CC12").setValue("#N/A");

		ws.getRange2("A1001").setValue("12/1/2025");
		ws.getRange2("A1002").setValue("12/1/2025");

		ws.getRange2("A2002").setValue("apples");
		ws.getRange2("A2004").setValue("oranges");
		ws.getRange2("A2005").setValue("peaches");
		ws.getRange2("A2007").setValue("apples");


		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		ws2.getRange2("A311").setValue("aac");
		ws2.getRange2("A312").setValue("a123c");
		ws2.getRange2("A313").setValue("a**c");
		ws2.getRange2("A314").setValue("a*c");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Area, String. Find equal number in Area
		oParser = new parserFormula('COUNTIF(A700:D700,"=10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A700:D700,"=10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Find equal number in Area');
		// Case #2: Area, String. Find numbers greater than value in Area
		oParser = new parserFormula('COUNTIF(A700:D700,">5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A700:D700,">5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area, String. Find numbers greater than value in Area');
		// Case #3: Area, String. Find numbers not equal to value in Area
		oParser = new parserFormula('COUNTIF(A700:D700,"<>10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A700:D700,"<>10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Find numbers not equal to value in Area');
		// Case #4: Area, String. Find text ending with pattern using wildcard
		oParser = new parserFormula('COUNTIF(A800:D800,"*es")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A800:D800,"*es") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area, String. Find text ending with pattern using wildcard');
		// Case #5: Area, String. Find text matching pattern with question marks and wildcard
		oParser = new parserFormula('COUNTIF(A800:D800,"??a*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A800:D800,"??a*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Find text matching pattern with question marks and wildcard');
		// Case #6: Area, String. Find text containing letter using wildcards
		oParser = new parserFormula('COUNTIF(A800:D800,"*l*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A800:D800,"*l*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Find text containing letter using wildcards');
		// Case #7: Area, Formula. Count TRUE values using TRUE() function
		oParser = new parserFormula('COUNTIF(CC1:CC7, TRUE())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC1:CC7, TRUE()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area, Formula. Count TRUE values using TRUE() function');
		// Case #8: Area, Boolean. Count TRUE values using boolean literal
		oParser = new parserFormula('COUNTIF(CC1:CC7, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC1:CC7, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Area, Boolean. Count TRUE values using boolean literal');
		// Case #9: Area, Number. Count cells equal to 1
		oParser = new parserFormula('COUNTIF(CC1:CC7, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC1:CC7, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, Number. Count cells equal to 1');
		// Case #10: Area, Number. Count cells equal to 0
		oParser = new parserFormula('COUNTIF(CC1:CC7, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC1:CC7, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Number. Count cells equal to 0');
		// Case #11: Ref, String. Count text criteria in single cell (no match)
		oParser = new parserFormula('COUNTIF(CC9,">3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC9,">3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref, String. Count text criteria in single cell (no match)');
		// Case #12: Ref, String. Count text criteria in single cell with equals prefix
		oParser = new parserFormula('COUNTIF(CC10,"=>3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC10,"=>3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref, String. Count text criteria in single cell with equals prefix');
		// Case #13: Area, String. Count error values using string representation
		oParser = new parserFormula('COUNTIF(CC11:CC12,"#N/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC11:CC12,"#N/A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Count error values using string representation');
		// Case #14: Area, Formula. Count error values using NA() function
		oParser = new parserFormula('COUNTIF(CC11:CC12, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC11:CC12, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, Formula. Count error values using NA() function');
		// Case #15: Area, String. Count formula text (no match for function call)
		oParser = new parserFormula('COUNTIF(CC11:CC12,"=NA()")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC11:CC12,"=NA()") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, String. Count formula text (no match for function call)');
		// Case #16: Area, String. Count numbers greater than or equal to 1
		oParser = new parserFormula('COUNTIF(CC1:CC8,">=1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC1:CC8,">=1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Count numbers greater than or equal to 1');
		// Case #17: Area, String. Count numbers equal to 1
		oParser = new parserFormula('COUNTIF(CC1:CC8,"=1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC1:CC8,"=1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Count numbers equal to 1');
		// Case #18: Area, String. Count numbers less than 1
		oParser = new parserFormula('COUNTIF(CC1:CC8,"<1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC1:CC8,"<1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, String. Count numbers less than 1');
		// Case #19: Area, String. Count numbers greater than 1
		oParser = new parserFormula('COUNTIF(CC1:CC8,">1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC1:CC8,">1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, String. Count numbers greater than 1');
		// Case #20: Area, String. Count using dynamic criteria with cell reference
		oParser = new parserFormula('COUNTIF(CC1:CC8,"="&CC8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(CC1:CC8,"="&CC8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, String. Count using dynamic criteria with cell reference');
		// Case #21: Area, String. Count text ending with pattern using wildcard
		oParser = new parserFormula('COUNTIF(A2002:A2007,"*es")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A2002:A2007,"*es") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Area, String. Count text ending with pattern using wildcard');
		// Case #22: Area, String. Count text with exact length ending with pattern
		oParser = new parserFormula('COUNTIF(A2002:A2007,"?????es")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A2002:A2007,"?????es") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Count text with exact length ending with pattern');
		// Case #23: Area, String. Count all non-empty text cells using wildcard
		oParser = new parserFormula('COUNTIF(A2002:A2007,"*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A2002:A2007,"*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Area, String. Count all non-empty text cells using wildcard');
		// Case #24: Area, String. Count cells not equal to literal asterisks
		oParser = new parserFormula('COUNTIF(A2002:A2007,"<>"&"***")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A2002:A2007,"<>"&"***") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Count cells not equal to literal asterisks');
		// Case #25: Area, String. Count cells not equal to single asterisk
		oParser = new parserFormula('COUNTIF(A2002:A2007,"<>"&"*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A2002:A2007,"<>"&"*") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Count cells not equal to single asterisk');
		// Case #26: Area, String. Count cells not equal to single question mark
		oParser = new parserFormula('COUNTIF(A2002:A2007,"<>"&"?")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A2002:A2007,"<>"&"?") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Area, String. Count cells not equal to single question mark');
		// Case #27: Area, String. Count exact date string match
		oParser = new parserFormula('COUNTIF(A1001:A1002,"12/1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A1001:A1002,"12/1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, String. Count exact date string match');
		// Case #28: Area, String. Count date string with no match
		oParser = new parserFormula('COUNTIF(A1001:A1002,"12/1/1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A1001:A1002,"12/1/1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, String. Count date string with no match');
		// Case #32: Formula, String. Count values greater than 80 in XLOOKUP result (Math). For bug 62491
		oParser = new parserFormula('COUNTIF(XLOOKUP(A100,A100:B100,A101:B105),">80")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(XLOOKUP(A100,A100:B100,A101:B105),">80") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula, String. Count values greater than 80 in XLOOKUP result (Math). For bug 62491');
		// Case #33: Formula, String. Count values greater than 80 in XLOOKUP result (Physics)
		oParser = new parserFormula('COUNTIF(XLOOKUP(B100,A100:B100,A101:B105),">80")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(XLOOKUP(B100,A100:B100,A101:B105),">80") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula, String. Count values greater than 80 in XLOOKUP result (Physics)');
		// Case #40: Area, String. Empty cells check
		oParser = new parserFormula('COUNTIF(A200:B205,"<>"&"*")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A200:B205,"<>"&"*") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Area, String. Empty cells check');
		// Case #41: Area, String. Find empty cells check
		oParser = new parserFormula('COUNTIF(A200:B205,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A200:B205,"") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Area, String. Find empty cells check');
		// Case #42: Area, Ref. second arg as cell
		oParser = new parserFormula('COUNTIF(A200:B205,B206)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A200:B205,B206) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Ref. second arg as cell');
		// Case #43: Area, Ref. second arg as cell, case-sens test
		oParser = new parserFormula('COUNTIF(A200:B205,B207)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A200:B205,B207) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Ref. second arg as cell, case-sens test');
		// Case #44: Area, String. second arg as cell, case-sens test
		oParser = new parserFormula('COUNTIF(A200:B205,"#n/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A200:B205,"#n/A") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, String. second arg as cell, case-sens test');
		// Case #45: Area, String. wildcard test with ~
		oParser = new parserFormula('COUNTIF(A300:A305,"a~*c")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A300:A305,"a~*c") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, String. wildcard test with ~');
		// Case #46: Area3D, Ref3D. Ref3D and Area3D test
		oParser = new parserFormula('COUNTIF(Sheet2!A311:A314,Sheet2!A315)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(Sheet2!A311:A314,Sheet2!A315) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D, Ref3D. Ref3D and Area3D test');
		// Case #47: Area, Ref. diacritic signs tests
		oParser = new parserFormula('COUNTIF(A306:A309,A310)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A306:A309,A310) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area, Ref. diacritic signs tests');
		// Case #48: Area, Ref. Hieroglyphs test
		oParser = new parserFormula('COUNTIF(A316:A319,A320)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A316:A319,A320) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Ref. Hieroglyphs test');
		// Case #49: Area, Formula. Formula test
		oParser = new parserFormula('COUNTIF(A311:A314,2+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A311:A314,2+1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Formula. Formula test');
		// Case #50: Name3D, Name3D. DefName test
		oParser = new parserFormula('COUNTIF(TestNameArea3D2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(TestNameArea3D2,TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Name3D, Name3D. DefName test');
		// Case #51: Area, Area.
		oParser = new parserFormula('COUNTIF(A311:A314,A311:A314)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A311:A314,A311:A314) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Area, Area. ');
		// Case #52: Area, Array.
		oParser = new parserFormula('COUNTIF(A311:A314,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A311:A314,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Array. ');

		// Negative cases:
		// Case #1: Error, Number. Handle reference error in range
		oParser = new parserFormula('COUNTIF(#REF!, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(#REF!, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Error, Number. Handle reference error in range');
		// Case #2: Array, Number.
		oParser = new parserFormula('COUNTIF({1,2,3}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF({1,2,3}, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Number. ');
		// Case #3: Array, Number.
		oParser = new parserFormula('COUNTIF({"a","a","a"}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF({"a","a","a"}, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Number. ');
		// Case #4: String, Number.
		oParser = new parserFormula('COUNTIF("a", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF("a", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. ');
		// Case #5: String, String.
		oParser = new parserFormula('COUNTIF("a", "a")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF("a", "a") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. ');
		// Case #6: Number, String.
		oParser = new parserFormula('COUNTIF(1, "a")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(1, "a") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. ');
		// Case #7: Number, Number.
		oParser = new parserFormula('COUNTIF(1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number. ');

		// Bounded cases:
		// Case #1: Area, String. Count errors greater than #N/A
		oParser = new parserFormula('COUNTIF(AB1:AB4,">#N/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(AB1:AB4,">#N/A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Area, String. Count errors greater than #N/A');
		// Case #2: Area, String. Count errors less than #DIV/0!
		oParser = new parserFormula('COUNTIF(AB1:AB4,"<#DIV/0!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(AB1:AB4,"<#DIV/0!") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Area, String. Count errors less than #DIV/0!');
		// Case #3: Area, String. Count errors not equal to #N/A
		oParser = new parserFormula('COUNTIF(AB1:AB4,"<>#N/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(AB1:AB4,"<>#N/A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Bounded case: Area, String. Count errors not equal to #N/A');
		// Case #4: Area, String. Count errors greater than or equal to #VALUE!
		oParser = new parserFormula('COUNTIF(AB1:AB4,">=#VALUE!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(AB1:AB4,">=#VALUE!") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Area, String. Count errors greater than or equal to #VALUE!');
		// Case #5: Area, String. Count values greater than error boundary
		oParser = new parserFormula('COUNTIF(AD1:AD4,"<#N/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(AD1:AD4,"<#N/A") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Area, String. Count values greater than error boundary');
		// Case #6: Area, String. Count specific error type in mixed range
		oParser = new parserFormula('COUNTIF(AE1:AE4,"=#N/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(AE1:AE4,"=#N/A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Area, String. Count specific error type in mixed range');
		// Case #7: Area, String. Count specific error type in mixed range
		oParser = new parserFormula('COUNTIF(AF1:AF4,"<#N/A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(AF1:AF4,"<#N/A") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Bounded case: Area, String. Count specific error type in mixed range');
		// Case #8: Area, String. Count empty values. \' as Empty. Different with Ms
		oParser = new parserFormula('COUNTIF(A321:A323,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: COUNTIF(A321:A323,"") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Bounded case: Area, String. Count empty values. \' as Empty. Different with Ms');

		// TODO 3D args handle
		// Need to fix: ms result diff, array handle, cache res diff in webapp and in tests
		// Case #20: Area, String. Count using dynamic criteria with cell reference - ok in app, diff res in tests(cache diff?)
		// Case #40: Area, String. Empty cells check
		// Case #41: Area, String. Find empty cells check
		// Case #42: Area, Ref. second arg as cell
		// Case #44: Area, String. second arg as cell, case-sens test
		// Case #46: Area3D, Ref3D. Ref3D and Area3D test - diff res
		// Case #1: Area, String. Count errors greater than #N/A
		// Case #4: Area, String. Count errors greater than or equal to #VALUE!
		// Case #5: Area, String. Count values greater than error boundary
		// Case #7: Area, String. Count specific error type in mixed range
		// Case #52: Area, Array.
		// Case #2: Array, Number.
		// Case #3: Array, Number.
		// Case #47: Area, Ref. diacritic signs tests
		// Case #49: Area, Formula. Formula test
		// Case #50: Name3D, Name3D. DefName test
		// Case #51: Area, Area.

		ws.getRange2("A200").setValue("");
		ws.getRange2("A201").setValue("123");
		ws.getRange2("A202").setValue("");
		ws.getRange2("A203").setValue("");
		ws.getRange2("A204").setValue("#N/A");
		ws.getRange2("A205").setValue("");
		ws.getRange2("B200").setValue("");
		ws.getRange2("B201").setValue(" ");
		ws.getRange2("B202").setValue("");
		ws.getRange2("B203").setValue("");
		ws.getRange2("B204").setValue("");
		ws.getRange2("B205").setValue("asd");
		ws.getRange2("B206").setValue('123');
		ws.getRange2("B207").setValue('ASD');

		// Case #40: Area, String. Empty cells check
		oParser = new parserFormula('COUNTIF(A200:B205,"<>"&"*")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 11);

		// Case #41: Area, String. Find empty cells check
		oParser = new parserFormula('COUNTIF(A200:B205,"")', "C2", ws);
		assert.ok(oParser.parse());
		//? assert.strictEqual(oParser.calculate().getValue(), 9);

		// Case #42: Area, Ref. second arg as cell
		oParser = new parserFormula('COUNTIF(A200:B205,B206)', "C2", ws);
		assert.ok(oParser.parse());
		//? assert.strictEqual(oParser.calculate().getValue(), 1);

		// Case #43: Area, Ref. second arg as cell, case-sens test
		oParser = new parserFormula('COUNTIF(A200:B205,B207)', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		// Case #44: Area, String. second arg as cell, case-sens test
		oParser = new parserFormula('COUNTIF(A200:B205,"#n/A")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		ws.getRange2("A300").setValue("a*c");
		ws.getRange2("A301").setValue("aac");
		ws.getRange2("A302").setValue("a123c");
		ws.getRange2("A303").setValue("a**c");
		ws.getRange2("A304").setValue("");
		ws.getRange2("A305").setValue("");

		// Case #45: Area, String. wildcard test with ~
		oParser = new parserFormula('COUNTIF(A300:A305,"a~*c")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		ws.getRange2("A311").setValue("1");
		ws.getRange2("A312").setValue("2");
		ws.getRange2("A313").setValue("3");
		ws.getRange2("A314").setValue("4");
		ws.getRange2("A315").setValue(">3");

		const currentSheet = ws.getName();
		// Case #46: Area3D, Ref3D. Ref3D and Ared3D test
		oParser = new parserFormula('COUNTIF(' + currentSheet + '!A311:A314,' + currentSheet + '!A315)', "C2", ws);
		assert.ok(oParser.parse());
		//? assert.strictEqual(oParser.calculate().getValue(), 1);

		ws.getRange2("A306").setValue("Á");
		ws.getRange2("A307").setValue("a");
		ws.getRange2("A308").setValue("A");
		ws.getRange2("A309").setValue("b");
		ws.getRange2("A310").setValue(">a");

		// Case #47: Area, Ref. diactric signs tests
		oParser = new parserFormula('COUNTIF(A306:A309,A310)', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		ws.getRange2("A316").setValue("a");
		ws.getRange2("A317").setValue("a");
		ws.getRange2("A318").setValue("a");
		ws.getRange2("A319").setValue("あ");
		ws.getRange2("A320").setValue(">a");

		// Case #48: Area, Ref. Hieroglyphs test
		oParser = new parserFormula('COUNTIF(A316:A319,A320)', "C2", ws);
		assert.ok(oParser.parse());
		//? assert.strictEqual(oParser.calculate().getValue(), 1);

		// Case #49: Area, Formula. Formula test
		oParser = new parserFormula('COUNTIF(A311:A314,2+1)', "C2", ws);
		assert.ok(oParser.parse());
		//? assert.strictEqual(oParser.calculate().getValue(), 1);

		const defName3D = new Asc.asc_CDefName('COUNTIFTestName3D', ws.getName() + '!$A$315');
		const defNameArea3D = new Asc.asc_CDefName('COUNTIFTestNameArea3D', ws.getName() + '!$A$311:$A$314');

		wb.editDefinesNames(null, defName3D);
		wb.editDefinesNames(null, defNameArea3D);

		// Case #50: Name3D, Name3D. DefName test
		oParser = new parserFormula('COUNTIF(COUNTIFTestNameArea3D,COUNTIFTestName3D)', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		wb.delDefinesNames(defName3D);
		wb.delDefinesNames(defNameArea3D);

		// Case #51: Area, Area.
		oParser = new parserFormula('COUNTIF(A311:A314,A311:A314)', "C2", ws);
		assert.ok(oParser.parse());
		array = oParser.calculate();
		//? assert.strictEqual(array.getElementRowCol(0,0).getValue(), 1, "Result of COUNTIF(A311:A314,A311:A314)[0,0]");
		//? assert.strictEqual(array.getElementRowCol(1,0).getValue(), 1, "Result of COUNTIF(A311:A314,A311:A314)[1,0]");
		//? assert.strictEqual(array.getElementRowCol(1,0).getValue(), 1, "Result of COUNTIF(A311:A314,A311:A314)[1,0]");

		// Case #52: Area, Array.
		oParser = new parserFormula('COUNTIF(A311:A314,{1,2,3})', "C2", ws);
		assert.ok(oParser.parse());
		array = oParser.calculate();
		//? assert.strictEqual(array.getElementRowCol(0,0).getValue(), 1, "Result of COUNTIF(A311:A314,A311:A314)[0,0]");
		//? assert.strictEqual(array.getElementRowCol(0,1).getValue(), 1, "Result of COUNTIF(A311:A314,A311:A314)[0,1]");
		//? assert.strictEqual(array.getElementRowCol(0,2).getValue(), 1, "Result of COUNTIF(A311:A314,A311:A314)[0,2]");

		// TODO Tables

		// Negative Cases:
		// Case #1: Error, Number. Handle reference error in range
		oParser = new parserFormula("COUNTIF(#REF!, 1)", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#REF!");

		// Case #2: Array, Number.
		oParser = new parserFormula("COUNTIF({1,2,3}, 1)", "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Case #3: Array, Number.
		oParser = new parserFormula('COUNTIF({"a","a","a"}, 1)', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Case #4: String, Number.
		oParser = new parserFormula('COUNTIF("a", 1)', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Case #5: String, String.
		oParser = new parserFormula('COUNTIF("a", "a")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Case #6: Number, String.
		oParser = new parserFormula('COUNTIF(1, "a")', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Case #7: Number, Number.
		oParser = new parserFormula('COUNTIF(1, 1)', "C2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Bounded Cases:
		// Case #1: Area, String. Count errors greater than #N/A
		ws.getRange2("AB1").setValue("#N/A");
		ws.getRange2("AB2").setValue("#DIV/0!");
		ws.getRange2("AB3").setValue("#VALUE!");
		ws.getRange2("AB4").setValue("5");
		oParser = new parserFormula('COUNTIF(AB1:AB4,">#N/A")', "AC1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		// Case #2: Area, String. Count errors less than #DIV/0!
		oParser = new parserFormula('COUNTIF(AB1:AB4,"<#DIV/0!")', "AC2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		// Case #3: Area, String. Count errors not equal to #N/A
		oParser = new parserFormula('COUNTIF(AB1:AB4,"<>#N/A")', "AC3", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		// Case #4: Area, String. Count errors greater than or equal to #VALUE!
		oParser = new parserFormula('COUNTIF(AB1:AB4,">=#VALUE!")', "AC4", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #5: Area, String. Count values greater than error boundary
		ws.getRange2("AD1").setValue("#N/A");
		ws.getRange2("AD2").setValue("10");
		ws.getRange2("AD3").setValue("20");
		ws.getRange2("AD4").setValue("text");
		oParser = new parserFormula('COUNTIF(AD1:AD4,"<#N/A")', "AC6", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		// Case #6: Area, String. Count specific error type in mixed range
		ws.getRange2("AE1").setValue("#N/A");
		ws.getRange2("AE2").setValue("#DIV/0!");
		ws.getRange2("AE3").setValue("#N/A");
		ws.getRange2("AE4").setValue("42");
		oParser = new parserFormula('COUNTIF(AE1:AE4,"=#N/A")', "AC7", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);

		// Case #7: Area, String. Count specific error type in mixed range
		ws.getRange2("AF1").setValue("#VALUE!");
		ws.getRange2("AF2").setValue("#DIV/0!");
		ws.getRange2("AF3").setValue("#VALUE!");
		ws.getRange2("AF4").setValue("42");
		oParser = new parserFormula('COUNTIF(AF1:AF4,"<#N/A")', "AC7", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		// Case #8: Area, String. Count empty values. ' as Empty. Different with Ms
		// ws.getRange2("A321").setValue("");
		// ws.getRange2("A322").setValue("");
		// ws.getRange2("A323").setValue("'");
		// oParser = new parserFormula('COUNTIF(A321:A323,"")', "C2", ws);
		// assert.ok(oParser.parse());
		// assert.strictEqual(oParser.calculate().getValue(), 3);

		// testArrayFormula2(assert, "COUNTIF", 2, 2)
	});

	QUnit.test("Test: \"COUNTBLANK\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A22").setValue("6");
		ws.getRange2("A23").setValue("");
		ws.getRange2("A24").setValue("4");

		ws.getRange2("B22").setValue("");
		ws.getRange2("B23").setValue("27");
		ws.getRange2("B24").setValue("34");

		ws.getRange2("A100").setValue("42");
		ws.getRange2("A101").setValue("Text");
		ws.getRange2("A102").setValue("");
		ws.getRange2("A103").setValue("TRUE");
		ws.getRange2("A104").setValue("#DIV/0");
		ws.getRange2("A105").setValue('""');
		// Table type. Use A601:L6**
		getTableType(599, 0, 604, 0);
		ws.getRange2("A601").setValue("42"); // Column1
		ws.getRange2("A602").setValue("Text"); // Column1
		ws.getRange2("A603").setValue(""); // Column1
		ws.getRange2("A604").setValue("TRUE"); // Column1
		ws.getRange2("A605").setValue("#DIV/0!"); // Column1
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("42");
		ws2.getRange2("A2").setValue("Text");
		ws2.getRange2("A3").setValue("");
		ws2.getRange2("A4").setValue("TRUE");
		ws2.getRange2("A5").setValue("#DIV/0");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("42"); // TestName
		ws.getRange2("A206").setValue("42"); // TestNameArea
		ws.getRange2("A207").setValue(""); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("42") // TestName3D
		ws2.getRange2("A16").setValue("Text"); // TestNameArea3D
		ws2.getRange2("A17").setValue(""); // TestNameArea3D

		// Positive cases:

		// Case #1: Area. Return 2
		oParser = new parserFormula('COUNTBLANK(A22:B24)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A22:B24) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area. Return 2');
		// Case #2: Reference link. Return 0
		oParser = new parserFormula('COUNTBLANK(A22)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A22) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Return 0');
		// Case #3: Reference link. Return 1
		oParser = new parserFormula('COUNTBLANK(A23)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A23) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Return 1');
		// Case #4: Reference link. Single reference to empty cell counted
		oParser = new parserFormula('COUNTBLANK(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Single reference to empty cell counted');
		// Case #5: Area. Area with single empty cell counted
		oParser = new parserFormula('COUNTBLANK(A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Area with single empty cell counted');
		// Case #6: Area. Area with multiple empty cells counted
		oParser = new parserFormula('COUNTBLANK(A102:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A102:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Area with multiple empty cells counted');
		// Case #7: Area. Mixed area - only empty cells counted
		oParser = new parserFormula('COUNTBLANK(A100:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A100:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Mixed area - only empty cells counted');
		// Case #8: Formula. COUNTBLANK as part of parent formula
		oParser = new parserFormula('SUM(COUNTBLANK(A102:A104),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COUNTBLANK(A102:A104),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Formula. COUNTBLANK as part of parent formula');
		// Case #9: Area. Empty string argument and area with empty cells
		oParser = new parserFormula('COUNTBLANK(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Empty string argument and area with empty cells');
		// Case #10: Name. Named area with empty cells counted
		oParser = new parserFormula('COUNTBLANK(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name. Named area with empty cells counted');
		// Case #11: Name3D. 3D named area with empty cells counted
		oParser = new parserFormula('COUNTBLANK(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name3D. 3D named area with empty cells counted');
		// Case #12: Ref3D. 3D reference to empty cell counted
		oParser = new parserFormula('COUNTBLANK(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to empty cell counted');
		// Case #13: Area3D. 3D area with empty cells counted
		oParser = new parserFormula('COUNTBLANK(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D area with empty cells counted');
		// Case #14: Table. Table with empty cells counted
		oParser = new parserFormula('COUNTBLANK(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table with empty cells counted');
		// Case #15: Area. Area with formulas returning empty strings
		oParser = new parserFormula('COUNTBLANK(A102:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A102:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Area with formulas returning empty strings');
		// Case #16: Formula. Formula returning empty string counted
		oParser = new parserFormula('COUNTBLANK(IF(TRUE,A102,"Text"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(IF(TRUE,A102,"Text")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Formula returning empty string counted');

		// Negative cases:
		// Different result with MS TODO: Need to fix:  Cases #1-#4, #8, #13 must be return parsed result - false.
		/*// Case #1: Number. Single number not counted as blank
		oParser = new parserFormula('COUNTBLANK(42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '=COUNTBLANK(42)', 'Test: Negative case: Number. Single number not counted as blank');
		// Case #2: String. Text string not counted as blank
		oParser = new parserFormula('COUNTBLANK("Text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK("Text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '=COUNTBLANK("Text")', 'Test: Negative case: String. Text string not counted as blank');
		// Case #3: Boolean. Boolean TRUE not counted as blank
		oParser = new parserFormula('COUNTBLANK(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '=COUNTBLANK(TRUE)', 'Test: Negative case: Boolean. Boolean TRUE not counted as blank');
		// Case #4: Error. Error value not counted as blank
		oParser = new parserFormula('COUNTBLANK(#DIV/0!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(#DIV/0!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '=COUNTBLANK(#DIV/0!)', 'Test: Negative case: Error. Error value not counted as blank');*/
		// Case #5: Reference link. Reference to number not counted
		oParser = new parserFormula('COUNTBLANK(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to number not counted');
		// Case #6: Reference link. Reference to text not counted
		oParser = new parserFormula('COUNTBLANK(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to text not counted');
		// Case #7: Area. Area with non-empty values not counted
		oParser = new parserFormula('COUNTBLANK(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Area with non-empty values not counted');
		/*// Case #8: Array. Array with non-empty values not counted
		oParser = new parserFormula('COUNTBLANK({42,"Text"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK({42,"Text"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '=COUNTBLANK({42;"Text"})', 'Test: Negative case: Array. Array with non-empty values not counted');
		*/// Case #9: Name. Named range with number not counted
		oParser = new parserFormula('COUNTBLANK(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with number not counted');
		// Case #10: Name3D. 3D named range with number not counted
		oParser = new parserFormula('COUNTBLANK(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with number not counted');
		// Case #11: Ref3D. 3D reference to number not counted
		oParser = new parserFormula('COUNTBLANK(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to number not counted');
		// Case #12: Area3D. 3D area with non-empty values not counted
		oParser = new parserFormula('COUNTBLANK(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D area with non-empty values not counted');
		// Case #13: Formula. Formula returning number not counted
		/*oParser = new parserFormula('COUNTBLANK(SQRT(16))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(SQRT(16)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '=COUNTBLANK(SQRT(16))', 'Test: Negative case: Formula. Formula returning number not counted');
		*/
		// Bounded cases:

		// Case #1: Area. Entire column reference
		oParser = new parserFormula('COUNTBLANK(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(A:A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1048539, 'Test: Bounded case: Area. Entire column reference');
		// Case #2: Area. Entire row reference
		oParser = new parserFormula('COUNTBLANK(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUNTBLANK(100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 16379, 'Test: Bounded case: Area. Entire row reference');

		// Need to fix: entire column tests
	});

	QUnit.test("Test: \"COVAR\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("3");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("4");
		ws.getRange2("A103").setValue("5");
		ws.getRange2("A104").setValue("6");
		ws.getRange2("B100").setValue("9");
		ws.getRange2("B101").setValue("7");
		ws.getRange2("B102").setValue("12");
		ws.getRange2("B103").setValue("15");
		ws.getRange2("B104").setValue("17");
		// Table type. Use A601:L6**
		getTableType(599, 0, 604, 1);
		ws.getRange2("A601").setValue("3"); // Column1
		ws.getRange2("A602").setValue("2"); // Column1
		ws.getRange2("A603").setValue("4"); // Column1
		ws.getRange2("A604").setValue("5"); // Column1
		ws.getRange2("A605").setValue("6"); // Column1
		ws.getRange2("B601").setValue("9"); // Column2
		ws.getRange2("B602").setValue("7"); // Column2
		ws.getRange2("B603").setValue("12"); // Column2
		ws.getRange2("B604").setValue("15"); // Column2
		ws.getRange2("B605").setValue("17"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("3");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("4");
		ws2.getRange2("A4").setValue("5");
		ws2.getRange2("A5").setValue("6");
		ws2.getRange2("B1").setValue("9");
		ws2.getRange2("B2").setValue("7");
		ws2.getRange2("B3").setValue("12");
		ws2.getRange2("B4").setValue("15");
		ws2.getRange2("B5").setValue("17");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("3"); // TestName
		ws.getRange2("A202").setValue("9"); // TestName1
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		ws.getRange2("A208").setValue("4"); // TestNameArea2
		ws.getRange2("B208").setValue("5"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("3") // TestName3D
		ws2.getRange2("A12").setValue("9") // TestName3D1
		ws2.getRange2("A16").setValue("1"); // TestNameArea3D
		ws2.getRange2("A17").setValue("2"); // TestNameArea3D
		ws2.getRange2("A18").setValue("4"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("5"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Array(2). Return -1.3753740625
		oParser = new parserFormula('COVAR({2.532,5.621;2.1,3.4},{5.32,2.765;5.2,6.7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({2.532,5.621;2.1,3.4},{5.32,2.765;5.2,6.7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.375374063', 'Test: Positive case: Array(2). Return -1.3753740625');
		// Case #2: Array(2). Return 0.25
		oParser = new parserFormula('COVAR({1,2},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1,2},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.25', 'Test: Positive case: Array(2). Return 0.25');
		// Case #3: Array, Array. Basic numeric arrays with positive covariance from example data
		oParser = new parserFormula('COVAR({3,2,4,5,6},{9,7,12,15,17})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({3,2,4,5,6},{9,7,12,15,17}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '5.2', 'Test: Positive case: Array, Array. Basic numeric arrays with positive covariance from example data');
		// Case #4: Array, Array. Simple three-element arrays with perfect correlation
		oParser = new parserFormula('COVAR({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.666666667', 'Test: Positive case: Array, Array. Simple three-element arrays with perfect correlation');
		// Case #5: Array, Array. Arrays with negative numbers mixed correlation
		oParser = new parserFormula('COVAR({-5,-2,0},{3,-10,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({-5,-2,0},{3,-10,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.666666667', 'Test: Positive case: Array, Array. Arrays with negative numbers mixed correlation');
		// Case #6: Array, Array. Arrays with decimal values
		oParser = new parserFormula('COVAR({1.5,2.3,3.7},{4.2,5.8,6.1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1.5,2.3,3.7},{4.2,5.8,6.1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.653333333', 'Test: Positive case: Array, Array. Arrays with decimal values');
		// Case #7: Array, Array. Arrays including zero values
		oParser = new parserFormula('COVAR({0,5,10},{15,0,25})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({0,5,10},{15,0,25}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '16.66666667', 'Test: Positive case: Array, Array. Arrays including zero values');
		// Case #8: Area, Area. Range references using example data
		oParser = new parserFormula('COVAR(A100:A104,B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(A100:A104,B100:B104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '5.2', 'Test: Positive case: Area, Area. Range references using example data');
		// Case #9: Array, Array. Large round numbers correlation
		oParser = new parserFormula('COVAR({100,200,300},{400,500,600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({100,200,300},{400,500,600}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '6666.666667', 'Test: Positive case: Array, Array. Large round numbers correlation');
		// Case #10: Array, Array. Decimal sequence correlation
		oParser = new parserFormula('COVAR({0.1,0.2,0.3},{0.4,0.5,0.6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({0.1,0.2,0.3},{0.4,0.5,0.6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.006666667', 'Test: Positive case: Array, Array. Decimal sequence correlation');
		// Case #11: Reference link, Reference link. Single cell references from example data
		oParser = new parserFormula('COVAR(A100,B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(A100,B100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link, Reference link. Single cell references from example data');
		// Case #12: Area, Area. Three element references from example
		oParser = new parserFormula('COVAR(A100:A102,B100:B102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(A100:A102,B100:B102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.666666667', 'Test: Positive case: Area, Area. Three element references from example');
		// Case #13: Array, Array. Zero values included in calculation
		oParser = new parserFormula('COVAR({1,2,3,0,5},{2,4,6,8,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1,2,3,0,5},{2,4,6,8,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '2.4', 'Test: Positive case: Array, Array. Zero values included in calculation');
		// Case #14: Array, Array. Array constants with round numbers
		oParser = new parserFormula('COVAR({10,20,30},{40,50,60})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({10,20,30},{40,50,60}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '66.66666667', 'Test: Positive case: Array, Array. Array constants with round numbers');
		// Case #15: Array, Array. Array constants with scientific notation
		oParser = new parserFormula('COVAR({1.2E+02,2.5E+02},{5.1E+02,6.4E+02})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1.2E+02,2.5E+02},{5.1E+02,6.4E+02}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4225, 'Test: Positive case: Array, Array. Array constants with scientific notation');
		// Case #16: Array, Array. Perfect positive correlation arrays
		oParser = new parserFormula('COVAR({2,4,6},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({2,4,6},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.333333333', 'Test: Positive case: Array, Array. Perfect positive correlation arrays');
		// Case #17: Array, Array. Decreasing sequence correlation
		oParser = new parserFormula('COVAR({10,5,0},{15,10,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({10,5,0},{15,10,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '16.66666667', 'Test: Positive case: Array, Array. Decreasing sequence correlation');
		// Case #18: Formula, Formula. Formula results as single values
		oParser = new parserFormula('COVAR(SUM(3,0),SUM(9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(SUM(3,0),SUM(9,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula, Formula. Formula results as single values');
		// Case #19: Array, Array. Small decimal precision values
		oParser = new parserFormula('COVAR({0.001,0.002},{0.004,0.005})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({0.001,0.002},{0.004,0.005}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5000000000000004e-7, 'Test: Positive case: Array, Array. Small decimal precision values');
		// Case #20: Array, Array. Single element arrays
		oParser = new parserFormula('COVAR({25},{75})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({25},{75}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array, Array. Single element arrays');
		// Case #21: Array, Array. Simple two-element correlation
		oParser = new parserFormula('COVAR({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.25', 'Test: Positive case: Array, Array. Simple two-element correlation');
		// Case #22: Array, Array. Negative correlation arrays
		oParser = new parserFormula('COVAR({-1,-2,-3},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({-1,-2,-3},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.666666667', 'Test: Positive case: Array, Array. Negative correlation arrays');
		// Case #23: Name, Name. Named range references
		oParser = new parserFormula('COVAR(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name, Name. Named range references');
		// Case #24: Name, Name. Named range references
		oParser = new parserFormula('COVAR(TestNameArea,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(TestNameArea,TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Name, Name. Named range references');
		// Case #25: Name3D, Name3D. Named 3D range references
		oParser = new parserFormula('COVAR(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(TestName3D,TestName3D1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D, Name3D. Named 3D range references');
		// Case #26: Name3D, Name3D. Named 3D range references
		oParser = new parserFormula('COVAR(TestNameArea3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(TestNameArea3D,TestNameArea3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Name3D, Name3D. Named 3D range references');
		// Case #27: Ref3D, Ref3D. 3D reference with sheet qualification
		oParser = new parserFormula('COVAR(Sheet2!A1,Sheet2!B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(Sheet2!A1,Sheet2!B1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D, Ref3D. 3D reference with sheet qualification');
		// Case #28: Area3D, Area3D. 3D area reference across sheets
		oParser = new parserFormula('COVAR(Sheet2!A1:A5,Sheet2!B1:B5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(Sheet2!A1:A5,Sheet2!B1:B5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5.2, 'Test: Positive case: Area3D, Area3D. 3D area reference across sheets');
		// Case #29: Table, Table. Table column references
		oParser = new parserFormula('COVAR(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(Table1[Column1],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5.2, 'Test: Positive case: Table, Table. Table column references');
		// Case #30: Array, Array. All identical values in first array
		oParser = new parserFormula('COVAR({5,5,5},{10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({5,5,5},{10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array, Array. All identical values in first array');
		// Case #31: Date, Date. Date formulas return 0
		oParser = new parserFormula('COVAR(DATE(2025,1,1),DATE(2025,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(DATE(2025,1,1),DATE(2025,1,2)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date, Date. Date formulas return 0');
		// Case #32: Time, Time. Time formulas return 0
		oParser = new parserFormula('COVAR(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time, Time. Time formulas return 0');

		// Negative cases:

		// Case #1: Array, Array. Different array sizes returns #N/A
		oParser = new parserFormula('COVAR({1,2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1,2,3},{4,5}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Array. Different array sizes returns #N/A');
		// Case #2: Array, Array. Empty first array
		oParser = new parserFormula('COVAR({},{5,10,15})', 'A2', ws);
		assert.strictEqual(oParser.parse(), false, 'Test: Formula COVAR({},{5,10,15}) isn\'t parsed.');
		//assert.strictEqual(oParser.calculate().getValue(), '=COVAR({};{5;10;15})', 'Test: Negative case: Array, Array. Empty first array');
		// Case #3: Array, Array. Empty second array
		oParser = new parserFormula('COVAR({1,2,3},{})', 'A2', ws);
		assert.strictEqual(oParser.parse(), false, 'Test: Formula COVAR({1,2,3},{}) isn\'t parsed.');
		//assert.strictEqual(oParser.calculate().getValue(), '=COVAR({1;2;3};{})', 'Test: Negative case: Array, Array. Empty second array');
		// Case #4: String, String. String literals return #DIV/0!
		oParser = new parserFormula('COVAR("text","string")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR("text","string") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String, String. String literals return #DIV/0!');
		// Case #5: Number, String. Number with string literal returns #DIV/0!
		oParser = new parserFormula('COVAR(5,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(5,"text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, String. Number with string literal returns #DIV/0!');
		// Case #6: Boolean, Boolean. Boolean literals return #DIV/0!
		oParser = new parserFormula('COVAR(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean, Boolean. Boolean literals return #DIV/0!');
		// Case #7: Error, Number. Error with number returns error
		oParser = new parserFormula('COVAR(#VALUE!,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(#VALUE!,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Number. Error with number returns error');
		// Case #8: Number, Error. Number with error returns error
		oParser = new parserFormula('COVAR(10,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(10,#N/A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Number with error returns error');
		// Case #9: Empty, Empty. Both arguments empty returns #VALUE!
		oParser = new parserFormula('COVAR(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty, Empty. Both arguments empty returns #VALUE!');
		// Case #10: Date, String. Date with string returns #DIV/0!
		oParser = new parserFormula('COVAR(DATE(2025,1,1),"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(DATE(2025,1,1),"text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Date, String. Date with string returns #DIV/0!');
		// Case #11: Time, Boolean. Time with boolean returns#DIV/0!
		oParser = new parserFormula('COVAR(TIME(12,0,0),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(TIME(12,0,0),TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time, Boolean. Time with boolean returns#DIV/0!');
		// Case #12: Formula, String. Formula result with string returns #VALUE!
		oParser = new parserFormula('COVAR(SUM(1,2,3),"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(SUM(1,2,3),"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, String. Formula result with string returns #VALUE!');
		// Case #13: Array, Array. Both arrays only text returns #DIV/0!
		oParser = new parserFormula('COVAR({"text","string"},{"abc","def"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({"text","string"},{"abc","def"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array, Array. Both arrays only text returns #DIV/0!');
		// Case #14: Array, Array. Both arrays only booleans returns #DIV/0!
		oParser = new parserFormula('COVAR({TRUE,FALSE},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({TRUE,FALSE},{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array, Array. Both arrays only booleans returns #DIV/0!');
		// Case #15: Array, Array. Error values in first array propagate
		oParser = new parserFormula('COVAR({#VALUE!,#DIV/0!},{5,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({#VALUE!,#DIV/0!},{5,10}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Array. Error values in first array propagate');
		// Case #16: Array, Array. Error values in second array propagate
		oParser = new parserFormula('COVAR({1,2},{#N/A,#REF!})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1,2},{#N/A,#REF!}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Array. Error values in second array propagate');

		// Bounded cases:

		// Case #1: Array, Array. Maximum positive numbers
		oParser = new parserFormula('COVAR({1.79E+154,1.79E+153},{1.78E+154,1.78E+153})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1.79E+154,1.79E+153},{1.78E+154,1.78E+153}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.452055e+307, 'Test: Bounded case: Array, Array. Maximum positive numbers');
		// Case #2: Array, Array. Maximum negative numbers
		oParser = new parserFormula('COVAR({-1.79E+154,-1.79E+153},{-1.78E+154,-1.78E+153})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({-1.79E+154,-1.79E+153},{-1.78E+154,-1.78E+153}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.452055e+307, 'Test: Bounded case: Array, Array. Maximum negative numbers');
		// Case #3: Array, Array. Smallest positive numbers
		oParser = new parserFormula('COVAR({2.23E-307,2.23E-306},{3.23E-307,3.23E-306})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({2.23E-307,2.23E-306},{3.23E-307,3.23E-306}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array, Array. Smallest positive numbers');
		// Case #4: Array, Array. Mixed extreme values
		oParser = new parserFormula('COVAR({1.79E+308,-1.79E+308},{-1.79E+308,1.79E+308})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR({1.79E+308,-1.79E+308},{-1.79E+308,1.79E+308}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -3.2041e+306, 'Test: Bounded case: Array, Array. Mixed extreme values');
		// Case #5: Area, Area. Entire column references
		oParser = new parserFormula('COVAR(A:A,B:B)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(A:A,B:B) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 35.40398230555556, 'Test: Bounded case: Area, Area. Entire column references');
		// Case #6: Area, Area. Entire row references
		oParser = new parserFormula('COVAR(100:100,101:101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVAR(100:100,101:101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3.8888888888888893, 'Test: Bounded case: Area, Area. Entire row references');

		// Need to fix: error types diff, diff results from MS in boundary cases

		testArrayFormula2(assert, "COVAR", 2, 2, null, true)
	});

	QUnit.test("Test: \"COVARIANCE.P\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("3");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("4");
		ws.getRange2("A103").setValue("5");
		ws.getRange2("A104").setValue("6");
		ws.getRange2("B100").setValue("9");
		ws.getRange2("B101").setValue("7");
		ws.getRange2("B102").setValue("12");
		ws.getRange2("B103").setValue("15");
		ws.getRange2("B104").setValue("17");
		// Table type. Use A601:L6**
		getTableType(599, 0, 604, 1);
		ws.getRange2("A601").setValue("3"); // Column1
		ws.getRange2("A602").setValue("2"); // Column1
		ws.getRange2("A603").setValue("4"); // Column1
		ws.getRange2("A604").setValue("5"); // Column1
		ws.getRange2("A605").setValue("6"); // Column1
		ws.getRange2("B601").setValue("9"); // Column2
		ws.getRange2("B602").setValue("7"); // Column2
		ws.getRange2("B603").setValue("12"); // Column2
		ws.getRange2("B604").setValue("15"); // Column2
		ws.getRange2("B605").setValue("17"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("3");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("4");
		ws2.getRange2("A4").setValue("5");
		ws2.getRange2("A5").setValue("6");
		ws2.getRange2("B1").setValue("9");
		ws2.getRange2("B2").setValue("7");
		ws2.getRange2("B3").setValue("12");
		ws2.getRange2("B4").setValue("15");
		ws2.getRange2("B5").setValue("17");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("3"); // TestName
		ws.getRange2("A202").setValue("9"); // TestName1
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		ws.getRange2("A208").setValue("4"); // TestNameArea2
		ws.getRange2("B208").setValue("5"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("3") // TestName3D
		ws2.getRange2("A12").setValue("9") // TestName3D1
		ws2.getRange2("A16").setValue("1"); // TestNameArea3D
		ws2.getRange2("A17").setValue("2"); // TestNameArea3D
		ws2.getRange2("A18").setValue("4"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("5"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Area(2). Return 5.2
		oParser = new parserFormula('COVARIANCE.P(A100:A104, B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(A100:A104, B100:B104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '5.2', 'Test: Positive case: Area(2). Return 5.2');
		// Case #2: Array(2). Return -1.3753740625
		oParser = new parserFormula('COVARIANCE.P({2.532,5.621;2.1,3.4},{5.32,2.765;5.2,6.7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({2.532,5.621;2.1,3.4},{5.32,2.765;5.2,6.7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.375374063', 'Test: Positive case: Array(2). Return -1.3753740625');
		// Case #3: Array(2). Return 0.25
		oParser = new parserFormula('COVARIANCE.P({1,2},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1,2},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.25', 'Test: Positive case: Array(2). Return 0.25');
		// Case #4: Array, Array. Basic numeric arrays with positive COVARIANCE.Piance from example data
		oParser = new parserFormula('COVARIANCE.P({3,2,4,5,6},{9,7,12,15,17})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({3,2,4,5,6},{9,7,12,15,17}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '5.2', 'Test: Positive case: Array, Array. Basic numeric arrays with positive COVARIANCE.Piance from example data');
		// Case #5: Array, Array. Simple three-element arrays with perfect correlation
		oParser = new parserFormula('COVARIANCE.P({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.666666667', 'Test: Positive case: Array, Array. Simple three-element arrays with perfect correlation');
		// Case #6: Array, Array. Arrays with negative numbers mixed correlation
		oParser = new parserFormula('COVARIANCE.P({-5,-2,0},{3,-10,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({-5,-2,0},{3,-10,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.666666667', 'Test: Positive case: Array, Array. Arrays with negative numbers mixed correlation');
		// Case #7: Array, Array. Arrays with decimal values
		oParser = new parserFormula('COVARIANCE.P({1.5,2.3,3.7},{4.2,5.8,6.1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1.5,2.3,3.7},{4.2,5.8,6.1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.653333333', 'Test: Positive case: Array, Array. Arrays with decimal values');
		// Case #8: Array, Array. Arrays including zero values
		oParser = new parserFormula('COVARIANCE.P({0,5,10},{15,0,25})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({0,5,10},{15,0,25}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '16.66666667', 'Test: Positive case: Array, Array. Arrays including zero values');
		// Case #9: Area, Area. Range references using example data
		oParser = new parserFormula('COVARIANCE.P(A100:A104,B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(A100:A104,B100:B104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '5.2', 'Test: Positive case: Area, Area. Range references using example data');
		// Case #10: Array, Array. Large round numbers correlation
		oParser = new parserFormula('COVARIANCE.P({100,200,300},{400,500,600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({100,200,300},{400,500,600}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '6666.666667', 'Test: Positive case: Array, Array. Large round numbers correlation');
		// Case #11: Array, Array. Decimal sequence correlation
		oParser = new parserFormula('COVARIANCE.P({0.1,0.2,0.3},{0.4,0.5,0.6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({0.1,0.2,0.3},{0.4,0.5,0.6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.006666667', 'Test: Positive case: Array, Array. Decimal sequence correlation');
		// Case #12: Reference link, Reference link. Single cell references from example data
		oParser = new parserFormula('COVARIANCE.P(A100,B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(A100,B100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link, Reference link. Single cell references from example data');
		// Case #13: Area, Area. Three element references from example
		oParser = new parserFormula('COVARIANCE.P(A100:A102,B100:B102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(A100:A102,B100:B102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.666666667', 'Test: Positive case: Area, Area. Three element references from example');
		// Case #14: Array, Array. Zero values included in calculation
		oParser = new parserFormula('COVARIANCE.P({1,2,3,0,5},{2,4,6,8,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1,2,3,0,5},{2,4,6,8,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '2.4', 'Test: Positive case: Array, Array. Zero values included in calculation');
		// Case #15: Array, Array. Array constants with round numbers
		oParser = new parserFormula('COVARIANCE.P({10,20,30},{40,50,60})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({10,20,30},{40,50,60}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '66.66666667', 'Test: Positive case: Array, Array. Array constants with round numbers');
		// Case #16: Array, Array. Array constants with scientific notation
		oParser = new parserFormula('COVARIANCE.P({1.2E+02,2.5E+02},{5.1E+02,6.4E+02})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1.2E+02,2.5E+02},{5.1E+02,6.4E+02}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4225, 'Test: Positive case: Array, Array. Array constants with scientific notation');
		// Case #17: Array, Array. Perfect positive correlation arrays
		oParser = new parserFormula('COVARIANCE.P({2,4,6},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({2,4,6},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.333333333', 'Test: Positive case: Array, Array. Perfect positive correlation arrays');
		// Case #18: Array, Array. Decreasing sequence correlation
		oParser = new parserFormula('COVARIANCE.P({10,5,0},{15,10,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({10,5,0},{15,10,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '16.66666667', 'Test: Positive case: Array, Array. Decreasing sequence correlation');
		// Case #19: Formula, Formula. Formula results as single values
		oParser = new parserFormula('COVARIANCE.P(SUM(3,0),SUM(9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(SUM(3,0),SUM(9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula, Formula. Formula results as single values');
		// Case #20: Array, Array. Small decimal precision values
		oParser = new parserFormula('COVARIANCE.P({0.001,0.002},{0.004,0.005})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({0.001,0.002},{0.004,0.005}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5000000000000004e-7, 'Test: Positive case: Array, Array. Small decimal precision values');
		// Case #21: Array, Array. Single element arrays
		oParser = new parserFormula('COVARIANCE.P({25},{75})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({25},{75}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array, Array. Single element arrays');
		// Case #22: Array, Array. Simple two-element correlation
		oParser = new parserFormula('COVARIANCE.P({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.25', 'Test: Positive case: Array, Array. Simple two-element correlation');
		// Case #23: Array, Array. Negative correlation arrays
		oParser = new parserFormula('COVARIANCE.P({-1,-2,-3},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({-1,-2,-3},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.666666667', 'Test: Positive case: Array, Array. Negative correlation arrays');
		// Case #24: Name, Name. Named range references
		oParser = new parserFormula('COVARIANCE.P(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name, Name. Named range references');
		// Case #25: Name, Name. Named range references
		oParser = new parserFormula('COVARIANCE.P(TestNameArea,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(TestNameArea,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.25', 'Test: Positive case: Name, Name. Named range references');
		// Case #26: Name3D, Name3D. Named 3D range references
		oParser = new parserFormula('COVARIANCE.P(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(TestName3D,TestName3D1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D, Name3D. Named 3D range references');
		// Case #27: Name3D, Name3D. Named 3D range references
		oParser = new parserFormula('COVARIANCE.P(TestNameArea3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(TestNameArea3D,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.25', 'Test: Positive case: Name3D, Name3D. Named 3D range references');
		// Case #28: Ref3D, Ref3D. 3D reference with sheet qualification
		oParser = new parserFormula('COVARIANCE.P(Sheet2!A1,Sheet2!B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(Sheet2!A1,Sheet2!B1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D, Ref3D. 3D reference with sheet qualification');
		// Case #29: Area3D, Area3D. 3D area reference across sheets
		oParser = new parserFormula('COVARIANCE.P(Sheet2!A1:A5,Sheet2!B1:B5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(Sheet2!A1:A5,Sheet2!B1:B5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '5.2', 'Test: Positive case: Area3D, Area3D. 3D area reference across sheets');
		// Case #30: Table, Table. Table column references
		oParser = new parserFormula('COVARIANCE.P(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '5.2', 'Test: Positive case: Table, Table. Table column references');
		// Case #31: Array, Array. All identical values in first array
		oParser = new parserFormula('COVARIANCE.P({5,5,5},{10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({5,5,5},{10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array, Array. All identical values in first array');
		// Case #32: Date, Date. Date formulas return 0
		oParser = new parserFormula('COVARIANCE.P(DATE(2025,1,1),DATE(2025,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(DATE(2025,1,1),DATE(2025,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date, Date. Date formulas return 0');
		// Case #33: Time, Time. Time formulas return 0
		oParser = new parserFormula('COVARIANCE.P(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time, Time. Time formulas return 0');

		// Negative cases:

		// Case #1: Array, Array. Different array sizes returns #N/A
		oParser = new parserFormula('COVARIANCE.P({1,2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1,2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Array. Different array sizes returns #N/A');
		// Case #2: Array, Array. Empty first array
		oParser = new parserFormula('COVARIANCE.P({},{5,10,15})', 'A2', ws);
		assert.strictEqual(oParser.parse(),false, 'Test: Formula COVARIANCE.P({},{5,10,15}) isn\'t parsed.');
		//assert.strictEqual(oParser.calculate().getValue(), '=COVARIANCE.P({};{5;10;15})', 'Test: Negative case: Array, Array. Empty first array');
		// Case #3: Array, Array. Empty second array
		oParser = new parserFormula('COVARIANCE.P({1,2,3},{})', 'A2', ws);
		assert.strictEqual(oParser.parse(), false, 'Test: Formula COVARIANCE.P({1,2,3},{}) isn\'t parsed.');
		//assert.strictEqual(oParser.calculate().getValue(), '=COVARIANCE.P({1;2;3};{})', 'Test: Negative case: Array, Array. Empty second array');
		// Case #4: String, String. String literals return #DIV/0!
		oParser = new parserFormula('COVARIANCE.P("text","string")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P("text","string") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String, String. String literals return #DIV/0!');
		// Case #5: Number, String. Number with string literal returns #DIV/0!
		oParser = new parserFormula('COVARIANCE.P(5,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(5,"text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, String. Number with string literal returns #DIV/0!');
		// Case #6: Boolean, Boolean. Boolean literals return #DIV/0!
		oParser = new parserFormula('COVARIANCE.P(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean, Boolean. Boolean literals return #DIV/0!');
		// Case #7: Error, Number. Error with number returns error
		oParser = new parserFormula('COVARIANCE.P(#VALUE!,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(#VALUE!,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Number. Error with number returns error');
		// Case #8: Number, Error. Number with error returns error
		oParser = new parserFormula('COVARIANCE.P(10,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(10,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Number with error returns error');
		// Case #9: Empty, Empty. Both arguments empty returns #VALUE!
		oParser = new parserFormula('COVARIANCE.P(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty, Empty. Both arguments empty returns #VALUE!');
		// Case #10: Date, String. Date with string returns #DIV/0!
		oParser = new parserFormula('COVARIANCE.P(DATE(2025,1,1),"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(DATE(2025,1,1),"text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Date, String. Date with string returns #DIV/0!');
		// Case #11: Time, Boolean. Time with boolean returns#DIV/0!
		oParser = new parserFormula('COVARIANCE.P(TIME(12,0,0),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(TIME(12,0,0),TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time, Boolean. Time with boolean returns#DIV/0!');
		// Case #12: Formula, String. Formula result with string returns #VALUE!
		oParser = new parserFormula('COVARIANCE.P(SUM(1,2,3),"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(SUM(1,2,3),"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, String. Formula result with string returns #VALUE!');
		// Case #13: Array, Array. Both arrays only text returns #DIV/0!
		oParser = new parserFormula('COVARIANCE.P({"text","string"},{"abc","def"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({"text","string"},{"abc","def"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array, Array. Both arrays only text returns #DIV/0!');
		// Case #14: Array, Array. Both arrays only booleans returns #DIV/0!
		oParser = new parserFormula('COVARIANCE.P({TRUE,FALSE},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({TRUE,FALSE},{TRUE,FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array, Array. Both arrays only booleans returns #DIV/0!');
		// Case #15: Array, Array. Error values in first array propagate
		oParser = new parserFormula('COVARIANCE.P({#VALUE!,#DIV/0!},{5,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({#VALUE!,#DIV/0!},{5,10}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Array. Error values in first array propagate');
		// Case #16: Array, Array. Error values in second array propagate
		oParser = new parserFormula('COVARIANCE.P({1,2},{#N/A,#REF!})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1,2},{#N/A,#REF!}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Array. Error values in second array propagate');

		// Bounded cases:

		// Case #1: Array, Array. Maximum positive numbers
		oParser = new parserFormula('COVARIANCE.P({1.79E+154,1.79E+153},{1.78E+154,1.78E+153})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1.79E+154,1.79E+153},{1.78E+154,1.78E+153}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.452055e+307, 'Test: Bounded case: Array, Array. Maximum positive numbers');
		// Case #2: Array, Array. Maximum negative numbers
		oParser = new parserFormula('COVARIANCE.P({-1.79E+154,-1.79E+153},{-1.78E+154,-1.78E+153})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({-1.79E+154,-1.79E+153},{-1.78E+154,-1.78E+153}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.452055e+307, 'Test: Bounded case: Array, Array. Maximum negative numbers');
		// Case #3: Array, Array. Smallest positive numbers
		oParser = new parserFormula('COVARIANCE.P({2.23E-307,2.23E-306},{3.23E-307,3.23E-306})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({2.23E-307,2.23E-306},{3.23E-307,3.23E-306}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array, Array. Smallest positive numbers');
		// Case #4: Array, Array. Mixed extreme values
		oParser = new parserFormula('COVARIANCE.P({1.79E+153,-1.79E+153},{-1.79E+153,1.79E+153})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P({1.79E+153,-1.79E+153},{-1.79E+153,1.79E+153}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.204100000000001e+306, 'Test: Bounded case: Array, Array. Mixed extreme values');
		// Case #5: Area, Area. Entire column references
		oParser = new parserFormula('COVARIANCE.P(A:A,B:B)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(A:A,B:B) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 14.802585054999998, 'Test: Bounded case: Area, Area. Entire column references');
		// Case #6: Area, Area. Entire row references
		oParser = new parserFormula('COVARIANCE.P(100:100,101:101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.P(100:100,101:101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3.8888888888888893, 'Test: Bounded case: Area, Area. Entire row references');

		// Need to fix: empty handle, error types diff, reults diff from MS
		// Case #12: Reference link, Reference link. Single cell references from example data
		// Case #24: Name, Name. Named range references
		// Case #26: Name3D, Name3D. Named 3D range references
		// Case #28: Ref3D, Ref3D. 3D reference with sheet qualification
		// Case #4: String, String. String literals return #DIV/0!
		// Case #5: Number, String. Number with string literal returns #DIV/0!
		// Case #6: Boolean, Boolean. Boolean literals return #DIV/0!
		// Case #9: Empty, Empty. Both arguments empty returns #VALUE!
		// Case #10: Date, String. Date with string returns #DIV/0!
		// Case #11: Time, Boolean. Time with boolean returns#DIV/0!
		// Case #12: Formula, String. Formula result with string returns #VALUE!
		// Case #13: Array, Array. Both arrays only text returns #DIV/0!
		// Case #14: Array, Array. Both arrays only booleans returns #DIV/0!
		// Case #15: Array, Array. Error values in first array propagate
		// Case #16: Array, Array. Error values in second array propagate
		// Case #5: Area, Area. Entire column references
		// Case #6: Area, Area. Entire row references


		testArrayFormula2(assert, "COVARIANCE.P", 2, 2, null, true);
	});

	QUnit.test("Test: \"COVARIANCE.S\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("3");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("4");
		ws.getRange2("A103").setValue("5");
		ws.getRange2("A104").setValue("6");
		ws.getRange2("B100").setValue("9");
		ws.getRange2("B101").setValue("7");
		ws.getRange2("B102").setValue("12");
		ws.getRange2("B103").setValue("15");
		ws.getRange2("B104").setValue("17");

		ws.getRange2("AA1").setValue("2");
		ws.getRange2("AA2").setValue("4");
		ws.getRange2("AA3").setValue("8");

		ws.getRange2("BB1").setValue("5");
		ws.getRange2("BB2").setValue("11");
		ws.getRange2("BB3").setValue("12");
		// Table type. Use A601:L6**
		getTableType(599, 0, 604, 1);
		ws.getRange2("A601").setValue("3"); // Column1
		ws.getRange2("A602").setValue("2"); // Column1
		ws.getRange2("A603").setValue("4"); // Column1
		ws.getRange2("A604").setValue("5"); // Column1
		ws.getRange2("A605").setValue("6"); // Column1
		ws.getRange2("B601").setValue("9"); // Column2
		ws.getRange2("B602").setValue("7"); // Column2
		ws.getRange2("B603").setValue("12"); // Column2
		ws.getRange2("B604").setValue("15"); // Column2
		ws.getRange2("B605").setValue("17"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("3");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("4");
		ws2.getRange2("A4").setValue("5");
		ws2.getRange2("A5").setValue("6");
		ws2.getRange2("B1").setValue("9");
		ws2.getRange2("B2").setValue("7");
		ws2.getRange2("B3").setValue("12");
		ws2.getRange2("B4").setValue("15");
		ws2.getRange2("B5").setValue("17");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("3"); // TestName
		ws.getRange2("A202").setValue("9"); // TestName1
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		ws.getRange2("A208").setValue("4"); // TestNameArea2
		ws.getRange2("B208").setValue("5"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("3") // TestName3D
		ws2.getRange2("A12").setValue("9") // TestName3D1
		ws2.getRange2("A16").setValue("1"); // TestNameArea3D
		ws2.getRange2("A17").setValue("2"); // TestNameArea3D
		ws2.getRange2("A18").setValue("4"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("5"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Array(2). Return 9.666666667
		oParser = new parserFormula('COVARIANCE.S({2,4,8},{5,11,12})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({2,4,8},{5,11,12}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '9.666666667', 'Test: Positive case: Array(2). Return 9.666666667');
		// Case #2: Area(2). Return 9.666666667
		oParser = new parserFormula('COVARIANCE.S(AA1:AA3,BB1:BB3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(AA1:AA3,BB1:BB3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '9.666666667', 'Test: Positive case: Area(2). Return 9.666666667');
		// Case #3: Array(2). Return -1.3753740625
		oParser = new parserFormula('COVARIANCE.S({2.532,5.621;2.1,3.4},{5.32,2.765;5.2,6.7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({2.532,5.621;2.1,3.4},{5.32,2.765;5.2,6.7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.833832083', 'Test: Positive case: Array(2). Return -1.3753740625');
		// Case #4: Array(2). Return 0.25
		oParser = new parserFormula('COVARIANCE.S({1,2},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1,2},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Array(2). Return 0.25');
		// Case #5: Array, Array. Basic numeric arrays with positive COVARIANCE.Siance from example data
		oParser = new parserFormula('COVARIANCE.S({3,2,4,5,6},{9,7,12,15,17})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({3,2,4,5,6},{9,7,12,15,17}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '6.5', 'Test: Positive case: Array, Array. Basic numeric arrays with positive COVARIANCE.Siance from example data');
		// Case #6: Array, Array. Simple three-element arrays with perfect correlation
		oParser = new parserFormula('COVARIANCE.S({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array, Array. Simple three-element arrays with perfect correlation');
		// Case #7: Array, Array. Arrays with negative numbers mixed correlation
		oParser = new parserFormula('COVARIANCE.S({-5,-2,0},{3,-10,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({-5,-2,0},{3,-10,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Array, Array. Arrays with negative numbers mixed correlation');
		// Case #8: Array, Array. Arrays with decimal values
		oParser = new parserFormula('COVARIANCE.S({1.5,2.3,3.7},{4.2,5.8,6.1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1.5,2.3,3.7},{4.2,5.8,6.1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.98', 'Test: Positive case: Array, Array. Arrays with decimal values');
		// Case #9: Array, Array. Arrays including zero values
		oParser = new parserFormula('COVARIANCE.S({0,5,10},{15,0,25})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({0,5,10},{15,0,25}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Array, Array. Arrays including zero values');
		// Case #10: Area, Area. Range references using example data
		oParser = new parserFormula('COVARIANCE.S(A100:A104,B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(A100:A104,B100:B104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '6.5', 'Test: Positive case: Area, Area. Range references using example data');
		// Case #11: Array, Array. Large round numbers correlation
		oParser = new parserFormula('COVARIANCE.S({100,200,300},{400,500,600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({100,200,300},{400,500,600}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10000, 'Test: Positive case: Array, Array. Large round numbers correlation');
		// Case #12: Array, Array. Decimal sequence correlation
		oParser = new parserFormula('COVARIANCE.S({0.1,0.2,0.3},{0.4,0.5,0.6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({0.1,0.2,0.3},{0.4,0.5,0.6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.01', 'Test: Positive case: Array, Array. Decimal sequence correlation');
		// Case #13: Area, Area. Three element references from example
		oParser = new parserFormula('COVARIANCE.S(A100:A102,B100:B102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(A100:A102,B100:B102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '2.5', 'Test: Positive case: Area, Area. Three element references from example');
		// Case #14: Array, Array. Zero values included in calculation
		oParser = new parserFormula('COVARIANCE.S({1,2,3,0,5},{2,4,6,8,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1,2,3,0,5},{2,4,6,8,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array, Array. Zero values included in calculation');
		// Case #15: Array, Array. Array constants with round numbers
		oParser = new parserFormula('COVARIANCE.S({10,20,30},{40,50,60})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({10,20,30},{40,50,60}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Array, Array. Array constants with round numbers');
		// Case #16: Array, Array. Array constants with scientific notation
		oParser = new parserFormula('COVARIANCE.S({1.2E+02,2.5E+02},{5.1E+02,6.4E+02})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1.2E+02,2.5E+02},{5.1E+02,6.4E+02}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8450, 'Test: Positive case: Array, Array. Array constants with scientific notation');
		// Case #17: Array, Array. Perfect positive correlation arrays
		oParser = new parserFormula('COVARIANCE.S({2,4,6},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({2,4,6},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array, Array. Perfect positive correlation arrays');
		// Case #18: Array, Array. Decreasing sequence correlation
		oParser = new parserFormula('COVARIANCE.S({10,5,0},{15,10,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({10,5,0},{15,10,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Array, Array. Decreasing sequence correlation');
		// Case #19: Array, Array. Small decimal precision values
		oParser = new parserFormula('COVARIANCE.S({0.001,0.002},{0.004,0.005})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({0.001,0.002},{0.004,0.005}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.000000000000001e-7, 'Test: Positive case: Array, Array. Small decimal precision values');
		// Case #20: Array, Array. Simple two-element correlation
		oParser = new parserFormula('COVARIANCE.S({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Array, Array. Simple two-element correlation');
		// Case #21: Array, Array. Negative correlation arrays
		oParser = new parserFormula('COVARIANCE.S({-1,-2,-3},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({-1,-2,-3},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Array, Array. Negative correlation arrays');
		// Case #22: Name, Name. Named range references
		oParser = new parserFormula('COVARIANCE.S(TestNameArea,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(TestNameArea,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Name, Name. Named range references');
		// Case #23: Name3D, Name3D. Named 3D range references
		oParser = new parserFormula('COVARIANCE.S(TestNameArea3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(TestNameArea3D,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Name3D, Name3D. Named 3D range references');
		// Case #24: Area3D, Area3D. 3D area reference across sheets
		oParser = new parserFormula('COVARIANCE.S(Sheet2!A1:A5,Sheet2!B1:B5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(Sheet2!A1:A5,Sheet2!B1:B5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '6.5', 'Test: Positive case: Area3D, Area3D. 3D area reference across sheets');
		// Case #25: Table, Table. Table column references
		oParser = new parserFormula('COVARIANCE.S(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '6.5', 'Test: Positive case: Table, Table. Table column references');
		// Case #26: Array, Array. All identical values in first array
		oParser = new parserFormula('COVARIANCE.S({5,5,5},{10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({5,5,5},{10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array, Array. All identical values in first array');

		// Negative cases:

		// Case #1: Array, Array. Different array sizes returns #N/A
		oParser = new parserFormula('COVARIANCE.S({1,2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1,2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Array. Different array sizes returns #N/A');
		// Case #2: Array, Array. Empty first array
		oParser = new parserFormula('COVARIANCE.S({},{5,10,15})', 'A2', ws);
		assert.notOk(oParser.parse(), 'Test: Formula COVARIANCE.S({},{5,10,15}) isn\'t parsed.');
		//assert.strictEqual(oParser.calculate().getValue(), '=COVARIANCE.S({};{5;10;15})', 'Test: Negative case: Array, Array. Empty first array');
		// Case #3: Array, Array. Empty second array
		oParser = new parserFormula('COVARIANCE.S({1,2,3},{})', 'A2', ws);
		assert.notOk(oParser.parse(), 'Test: Formula COVARIANCE.S({1,2,3},{}) isn\'t parsed.');
		//assert.strictEqual(oParser.calculate().getValue(), '=COVARIANCE.S({1;2;3};{})', 'Test: Negative case: Array, Array. Empty second array');
		// Case #4: String, String. String literals return #DIV/0!
		oParser = new parserFormula('COVARIANCE.S("text","string")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S("text","string") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String, String. String literals return #DIV/0!');
		// Case #5: Number, String. Number with string literal returns #DIV/0!
		oParser = new parserFormula('COVARIANCE.S(5,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(5,"text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, String. Number with string literal returns #DIV/0!');
		// Case #6: Boolean, Boolean. Boolean literals return #DIV/0!
		oParser = new parserFormula('COVARIANCE.S(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean, Boolean. Boolean literals return #DIV/0!');
		// Case #7: Error, Number. Error with number returns error
		oParser = new parserFormula('COVARIANCE.S(#VALUE!,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(#VALUE!,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Number. Error with number returns error');
		// Case #8: Number, Error. Number with error returns error
		oParser = new parserFormula('COVARIANCE.S(10,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(10,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Number with error returns error');
		// Case #9: Empty, Empty. Both arguments empty returns #VALUE!
		oParser = new parserFormula('COVARIANCE.S(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty, Empty. Both arguments empty returns #VALUE!');
		// Case #10: Date, String. Date with string returns #DIV/0!
		oParser = new parserFormula('COVARIANCE.S(DATE(2025,1,1),"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(DATE(2025,1,1),"text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Date, String. Date with string returns #DIV/0!');
		// Case #11: Time, Boolean. Time with boolean returns#DIV/0!
		oParser = new parserFormula('COVARIANCE.S(TIME(12,0,0),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(TIME(12,0,0),TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time, Boolean. Time with boolean returns#DIV/0!');
		// Case #12: Formula, String. Formula result with string returns #VALUE!
		oParser = new parserFormula('COVARIANCE.S(SUM(1,2,3),"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(SUM(1,2,3),"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, String. Formula result with string returns #VALUE!');
		// Case #13: Array, Array. Both arrays only text returns #DIV/0!
		oParser = new parserFormula('COVARIANCE.S({"text","string"},{"abc","def"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({"text","string"},{"abc","def"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array, Array. Both arrays only text returns #DIV/0!');
		// Case #14: Array, Array. Both arrays only booleans returns #DIV/0!
		oParser = new parserFormula('COVARIANCE.S({TRUE,FALSE},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({TRUE,FALSE},{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array, Array. Both arrays only booleans returns #DIV/0!');
		// Case #15: Array, Array. Error values in first array propagate
		oParser = new parserFormula('COVARIANCE.S({#VALUE!,#DIV/0!},{5,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({#VALUE!,#DIV/0!},{5,10}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Array. Error values in first array propagate');
		// Case #16: Array, Array. Error values in second array propagate
		oParser = new parserFormula('COVARIANCE.S({1,2},{#N/A,#REF!})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1,2},{#N/A,#REF!}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Array. Error values in second array propagate');
		// Case #17: Reference link, Reference link. Single cell references from example data
		oParser = new parserFormula('COVARIANCE.S(A100,B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(A100,B100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link, Reference link. Single cell references from example data');
		// Case #18: Formula, Formula. Formula results as single values
		oParser = new parserFormula('COVARIANCE.S(SUM(3,0),SUM(9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(SUM(3,0),SUM(9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, Formula. Formula results as single values');
		// Case #19: Array, Array. Single element arrays
		oParser = new parserFormula('COVARIANCE.S({25},{75})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({25},{75}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array, Array. Single element arrays');
		// Case #20: Name, Name. Named range references
		oParser = new parserFormula('COVARIANCE.S(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name, Name. Named range references');
		// Case #21: Name3D, Name3D. Named 3D range references
		oParser = new parserFormula('COVARIANCE.S(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D, Name3D. Named 3D range references');
		// Case #22: Ref3D, Ref3D. 3D reference with sheet qualification
		oParser = new parserFormula('COVARIANCE.S(Sheet2!A1,Sheet2!B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(Sheet2!A1,Sheet2!B1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D, Ref3D. 3D reference with sheet qualification');
		// Case #23: Date, Date. Date formulas return #DIV/0!
		oParser = new parserFormula('COVARIANCE.S(DATE(2025,1,1),DATE(2025,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(DATE(2025,1,1),DATE(2025,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Date, Date. Date formulas return #DIV/0!');
		// Case #24: Time, Time. Time formulas return #DIV/0!
		oParser = new parserFormula('COVARIANCE.S(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time, Time. Time formulas return #DIV/0!');

		// Bounded cases:

		// Case #1: Array, Array. Maximum positive numbers
		oParser = new parserFormula('COVARIANCE.S({1.79E+154,1.79E+153},{1.78E+154,1.78E+153})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1.79E+154,1.79E+153},{1.78E+154,1.78E+153}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.290411e+308, 'Test: Bounded case: Array, Array. Maximum positive numbers');
		// Case #2: Array, Array. Maximum negative numbers
		oParser = new parserFormula('COVARIANCE.S({-1.79E+154,-1.79E+153},{-1.78E+154,-1.78E+153})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({-1.79E+154,-1.79E+153},{-1.78E+154,-1.78E+153}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.290411e+308, 'Test: Bounded case: Array, Array. Maximum negative numbers');
		// Case #3: Array, Array. Smallest positive numbers
		oParser = new parserFormula('COVARIANCE.S({2.23E-307,2.23E-306},{3.23E-307,3.23E-306})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({2.23E-307,2.23E-306},{3.23E-307,3.23E-306}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array, Array. Smallest positive numbers');
		// Case #4: Array, Array. Mixed extreme values
		oParser = new parserFormula('COVARIANCE.S({1.79E+153,-1.79E+153},{-1.79E+153,1.79E+153})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S({1.79E+153,-1.79E+153},{-1.79E+153,1.79E+153}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6.408200000000002e+306, 'Test: Bounded case: Array, Array. Mixed extreme values');
		// Case #5: Area, Area. Entire column references
		oParser = new parserFormula('COVARIANCE.S(A:A,B:B)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(A:A,B:B) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 15.581668478947366, 'Test: Bounded case: Area, Area. Entire column references');
		// Case #6: Area, Area. Entire row references
		oParser = new parserFormula('COVARIANCE.S(100:100,101:101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COVARIANCE.S(100:100,101:101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5.833333333333334, 'Test: Bounded case: Area, Area. Entire row references');

		// Need to fix: string handle, error handle, error type diff

		testArrayFormula2(assert, "COVARIANCE.S", 2, 2, null, true);
	});

	QUnit.test("Test: \"CRITBINOM\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("6");
		ws.getRange2("A101").setValue("0.5");
		ws.getRange2("A102").setValue("0.75");
		ws.getRange2("A103").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("6"); // Column1
		ws.getRange2("B601").setValue("0.5"); // Column2
		ws.getRange2("C601").setValue("0.75"); // Column3
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("6");
		ws2.getRange2("A2").setValue("0.5");
		ws2.getRange2("A3").setValue("0.75");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("6"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("0.75"); // TestName2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("6") // TestName3D
		ws2.getRange2("A12").setValue("0.5") // TestName3D1
		ws2.getRange2("A13").setValue("0.75") // TestName3D2

		// Positive cases:

		// Case #1: Number(3). Return 4
		oParser = new parserFormula('CRITBINOM(6,0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Number(3). Return 4');
		// Case #2: Number(3). Return 6
		oParser = new parserFormula('CRITBINOM(12,0.3,0.95)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(12,0.3,0.95) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(3). Return 6');
		// Case #3: Number(3). All arguments are numbers. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(6,0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Number(3). All arguments are numbers. 3 of 3 arguments used.');
		// Case #4: Number(3). All arguments are integers and decimals. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(10,0.25,0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(10,0.25,0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Number(3). All arguments are integers and decimals. 3 of 3 arguments used.');
		// Case #5: Number(3). Large trials number. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(100,0.1,0.95)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(100,0.1,0.95) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Number(3). Large trials number. 3 of 3 arguments used.');
		// Case #6: Number(3). Trials as float (will be truncated). 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(6.8,0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6.8,0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Number(3). Trials as float (will be truncated). 3 of 3 arguments used.');
		// Case #7: String(3). All arguments as numeric strings. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM("6","0.5","0.75")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM("6","0.5","0.75") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: String(3). All arguments as numeric strings. 3 of 3 arguments used.');
		// Case #8: String,Number(2). Trials as string, others as numbers. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM("10",0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM("10",0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: String,Number(2). Trials as string, others as numbers. 3 of 3 arguments used.');
		// Case #9: Formula(3). All arguments from formulas. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(ROUND(6.4,0),ROUND(0.5,1),ROUND(0.75,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(ROUND(6.4,0),ROUND(0.5,1),ROUND(0.75,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula(3). All arguments from formulas. 3 of 3 arguments used.');
		// Case #10: Empty,Number(2). Trials empty (converted to 0). 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(,0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(,0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty,Number(2). Trials empty (converted to 0). 3 of 3 arguments used.');
		// Case #11: Formula. CRITBINOM inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(CRITBINOM(6,0.5,0.75),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CRITBINOM(6,0.5,0.75),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. CRITBINOM inside SUM formula. 3 of 3 arguments used.');
		// Case #12: Boolean,Number(2). Trials as boolean TRUE (converted to 1). 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(TRUE,0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(TRUE,0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean,Number(2). Trials as boolean TRUE (converted to 1). 3 of 3 arguments used.');
		// Case #13: Date(3). All arguments using date formulas. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(DATE(2025,1,1),DATE(2024,1,1)/DATE(2024,2,1),DATE(2024,1,1)/DATE(2024,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(DATE(2025,1,1),DATE(2024,1,1)/DATE(2024,2,1),DATE(2024,1,1)/DATE(2024,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45643, 'Test: Positive case: Date(3). All arguments using date formulas. 3 of 3 arguments used.');
		// Case #14: Time(3). All arguments using time formulas. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(TIME(0,0,10)+6,TIME(12,0,0),TIME(18,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(TIME(0,0,10)+6,TIME(12,0,0),TIME(18,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Time(3). All arguments using time formulas. 3 of 3 arguments used.');
		// Case #15: Reference link(3). All arguments as reference links. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Reference link(3). All arguments as reference links. 3 of 3 arguments used.');
		// Case #16: Reference link,Number(2). Trials as reference to empty cell. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(A103,0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(A103,0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link,Number(2). Trials as reference to empty cell. 3 of 3 arguments used.');
		// Case #17: Area(3). All arguments as single-cell areas. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Area(3). All arguments as single-cell areas. 3 of 3 arguments used.');
		// Case #18: Area(2),Number. Multi-cell areas with valid data. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(A100:A101,A101:A102,0.75)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(A100:A101,A101:A102,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 4, 'Test: Positive case: Area(2),Number. Multi-cell areas with valid data. 3 of 3 arguments used.');
		// Case #19: Array(3). All arguments as single-element arrays. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM({6},{0.5},{0.75})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM({6},{0.5},{0.75}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Array(3). All arguments as single-element arrays. 3 of 3 arguments used.');
		// Case #20: Array(3). Multi-element arrays with valid data. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM({6,10},{0.5,0.3},{0.75,0.25})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM({6,10},{0.5,0.3},{0.75,0.25}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Array(3). Multi-element arrays with valid data. 3 of 3 arguments used.');
		// Case #21: Name(3). All arguments as named ranges. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Name(3). All arguments as named ranges. 3 of 3 arguments used.');
		// Case #22: Name3D(3). All arguments as 3D named ranges. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(TestName3D,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(TestName3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Name3D(3). All arguments as 3D named ranges. 3 of 3 arguments used.');
		// Case #23: Ref3D(3). All arguments as 3D references. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Ref3D(3). All arguments as 3D references. 3 of 3 arguments used.');
		// Case #24: Area3D(3). All arguments as 3D single-cell areas. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Area3D(3). All arguments as 3D single-cell areas. 3 of 3 arguments used.');
		// Case #25: Table(3). All arguments as table references. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Table(3). All arguments as table references. 3 of 3 arguments used.');
		// Case #26: Formula(3). Nested IF formulas. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(IF(TRUE,6,10),IF(FALSE,0.1,0.5),IF(TRUE,0.75,0.25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(IF(TRUE,6,10),IF(FALSE,0.1,0.5),IF(TRUE,0.75,0.25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula(3). Nested IF formulas. 3 of 3 arguments used.');
		// Case #27: Number(3). Large trials with small probability. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(1000,0.01,0.99)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(1000,0.01,0.99) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18, 'Test: Positive case: Number(3). Large trials with small probability. 3 of 3 arguments used.');
		// Case #28: Number(3). High probability with low alpha. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(50,0.999,0.001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(50,0.999,0.001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 48, 'Test: Positive case: Number(3). High probability with low alpha. 3 of 3 arguments used.');
		// Case #29: Date,Number(2). Trials as date (serial number). 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(DATE(2025,1,1),0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(DATE(2025,1,1),0.5,0.75) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 22901, 'Test: Positive case: Date,Number(2). Trials as date (serial number). 3 of 3 arguments used.');
		// Case #30: Number,Date,Number. Probability_s from date calculation. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(10,DATE(2023,1,1)/DATE(2023,12,31),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(10,DATE(2023,1,1)/DATE(2023,12,31),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number,Date,Number. Probability_s from date calculation. 3 of 3 arguments used.');
		// Case #31: Number(2),Date. Alpha from date calculation. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(10,0.5,DATE(2023,1,1)/DATE(2023,12,31))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(10,0.5,DATE(2023,1,1)/DATE(2023,12,31)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Number(2),Date. Alpha from date calculation. 3 of 3 arguments used.');
		// Case #32: Time,Number(2). Trials from time formula. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(TIME(0,0,10)+6,0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(TIME(0,0,10)+6,0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Time,Number(2). Trials from time formula. 3 of 3 arguments used.');
		// Case #33: Number,Time,Number. Probability_s as time value. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(10,TIME(12,0,0),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(10,TIME(12,0,0),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number,Time,Number. Probability_s as time value. 3 of 3 arguments used.');
		// Case #34: Number(2),Time. Alpha as time value. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(10,0.5,TIME(18,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(10,0.5,TIME(18,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(2),Time. Alpha as time value. 3 of 3 arguments used.');
		// Case #35: Boolean,Number(2). Trials as FALSE (0) is valid but edge case. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(FALSE,0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(FALSE,0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean,Number(2). Trials as FALSE (0) is valid but edge case. 3 of 3 arguments used.');

		// Negative cases:

		// Case #1: Number(3). Return #NUM!
		oParser = new parserFormula('CRITBINOM(-12,0.3,0.95)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(-12,0.3,0.95) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!');
		// Case #2: Number(3). Return #NUM!
		oParser = new parserFormula('CRITBINOM(-12,1.3,0.95)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(-12,1.3,0.95) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!');
		// Case #3: Number(3). Return #NUM!
		oParser = new parserFormula('CRITBINOM(-12,-1.3,0.95)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(-12,-1.3,0.95) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!');
		// Case #4: Number(3). Return #NUM!
		oParser = new parserFormula('CRITBINOM(-12,0,0.95)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(-12,0,0.95) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!');
		// Case #5: Number(3). Return #NUM!
		oParser = new parserFormula('CRITBINOM(-12,0.3,1.95)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(-12,0.3,1.95) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!');
		// Case #6: Number,Empty,Number. Probability_s empty (converted to 0). 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(6,,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,,0.75) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Empty,Number. Probability_s empty (converted to 0). 3 of 3 arguments used.');
		// Case #7: Number(2),Empty. Alpha empty (converted to 0). 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(6,0.5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2),Empty. Alpha empty (converted to 0). 3 of 3 arguments used.');
		// Case #8: Number,Boolean,Number. Probability_s as boolean TRUE (converted to 1). 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(6,TRUE,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,TRUE,0.75) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Boolean,Number. Probability_s as boolean TRUE (converted to 1). 3 of 3 arguments used.');
		// Case #9: Number(2),Boolean. Alpha as boolean TRUE (converted to 1). 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(6,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2),Boolean. Alpha as boolean TRUE (converted to 1). 3 of 3 arguments used.');
		// Case #10: Number,Reference link,Number. Probability_s as reference to empty cell. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(6,A103,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,A103,0.75) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Reference link,Number. Probability_s as reference to empty cell. 3 of 3 arguments used.');
		// Case #11: Number(2),Reference link. Alpha as reference to empty cell. 3 of 3 arguments used.
		oParser = new parserFormula('CRITBINOM(6,0.5,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2),Reference link. Alpha as reference to empty cell. 3 of 3 arguments used.');
		// Case #12: Number(3). Trials < 0 returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(-1,0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(-1,0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Trials < 0 returns #NUM! error.');
		// Case #13: Number(3). Probability_s < 0 returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,-0.1,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,-0.1,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Probability_s < 0 returns #NUM! error.');
		// Case #14: Number(3). Probability_s > 1 returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,1.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,1.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Probability_s > 1 returns #NUM! error.');
		// Case #15: Number(3). Alpha < 0 returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,0.5,-0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,-0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha < 0 returns #NUM! error.');
		// Case #16: Number(3). Alpha > 1 returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,0.5,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha > 1 returns #NUM! error.');
		// Case #17: String(3). Non-numeric string for trials returns #VALUE! error.
		oParser = new parserFormula('CRITBINOM("abc","0.5","0.75")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM("abc","0.5","0.75") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). Non-numeric string for trials returns #VALUE! error.');
		// Case #18: Number,String,Number. Non-numeric string for probability_s returns #VALUE! error.
		oParser = new parserFormula('CRITBINOM(6,"text",0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,"text",0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String,Number. Non-numeric string for probability_s returns #VALUE! error.');
		// Case #19: Number(2),String. Non-numeric string for alpha returns #VALUE! error.
		oParser = new parserFormula('CRITBINOM(6,0.5,"invalid")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,"invalid") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2),String. Non-numeric string for alpha returns #VALUE! error.');
		// Case #20: Error,Number(2). Error in trials propagates #N/A.
		oParser = new parserFormula('CRITBINOM(NA(),0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(NA(),0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(2). Error in trials propagates #N/A.');
		// Case #21: Number,Error,Number. Error in probability_s propagates #N/A.
		oParser = new parserFormula('CRITBINOM(6,NA(),0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,NA(),0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error,Number. Error in probability_s propagates #N/A.');
		// Case #22: Number(2),Error. Error in alpha propagates #N/A.
		oParser = new parserFormula('CRITBINOM(6,0.5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2),Error. Error in alpha propagates #N/A.');
		// Case #23: Number(3). Probability_s = 0 returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,0,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0,0.75) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Probability_s = 0 returns #NUM! error.');
		// Case #24: Number(3). Probability_s = 1 returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,1,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,1,0.75) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Probability_s = 1 returns #NUM! error.');
		// Case #25: Number(3). Alpha = 0 returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,0.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha = 0 returns #NUM! error.');
		// Case #26: Number(3). Alpha = 1 returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,0.5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Alpha = 1 returns #NUM! error.');
		// Case #27: Number,Boolean,Number. Probability_s as FALSE (0) returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,FALSE,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,FALSE,0.75) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Boolean,Number. Probability_s as FALSE (0) returns #NUM! error.');
		// Case #28: Number(2),Boolean. Alpha as FALSE (0) returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(6,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2),Boolean. Alpha as FALSE (0) returns #NUM! error.');
		// Case #29: Array(3). Array with invalid values returns errors.
		oParser = new parserFormula('CRITBINOM({-1},{1.5},{"text"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM({-1},{1.5},{"text"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array(3). Array with invalid values returns errors.');
		// Case #30: Formula, Number(2). Formula resulting in #NUM! error.
		oParser = new parserFormula('CRITBINOM(SQRT(-1),0.5,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(SQRT(-1),0.5,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number(2). Formula resulting in #NUM! error.');
		// Case #31: Number(3). All arguments negative returns #NUM! error.
		oParser = new parserFormula('CRITBINOM(-10,-0.5,-0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(-10,-0.5,-0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). All arguments negative returns #NUM! error.');
		// Case #32: String(3). Empty string for trials returns #VALUE! error.
		oParser = new parserFormula('CRITBINOM("","0.5","0.75")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM("","0.5","0.75") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). Empty string for trials returns #VALUE! error.');
		// Case #33: Number,String,Number. Empty string for probability_s returns #VALUE! error.
		oParser = new parserFormula('CRITBINOM(6,"",0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,"",0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String,Number. Empty string for probability_s returns #VALUE! error.');
		// Case #34: Number(2),String. Empty string for alpha returns #VALUE! error.
		oParser = new parserFormula('CRITBINOM(6,0.5,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(6,0.5,"") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2),String. Empty string for alpha returns #VALUE! error.');

		// Bounded cases:

		// Case #1: Number(3). All arguments at minimum valid values.
		oParser = new parserFormula('CRITBINOM(0,0.000000001,0.000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(0,0.000000001,0.000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3). All arguments at minimum valid values.');
		// Case #2: Number(3). All arguments at maximum valid values.
		oParser = new parserFormula('CRITBINOM(1999999999,0.999999999999999,0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(1999999999,0.999999999999999,0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1999999999, 'Test: Bounded case: Number(3). All arguments at maximum valid values.');
		// Case #3: Area. Whole columns and rows as arguments.
		oParser = new parserFormula('CRITBINOM(A:A,100:100,101:101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CRITBINOM(A:A,100:100,101:101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Area. Whole columns and rows as arguments.');

		// Need to fix: empty handle, boolean handle, results diff from MS
		// Case #29: Date,Number(2). Trials as date (serial number). 3 of 3 arguments used.
		// Case #6: Number,Empty,Number. Probability_s empty (converted to 0). 3 of 3 arguments used.
		// Case #8: Number,Boolean,Number. Probability_s as boolean TRUE (converted to 1). 3 of 3 arguments used.
		// Case #10: Number,Reference link,Number. Probability_s as reference to empty cell. 3 of 3 arguments used.
		// Case #23: Number(3). Probability_s = 0 returns #NUM! error.
		// Case #24: Number(3). Probability_s = 1 returns #NUM! error.
		// Case #27: Number,Boolean,Number. Probability_s as FALSE (0) returns #NUM! error.

		testArrayFormula2(assert, "CRITBINOM", 3, 3);
	});

	QUnit.test("Test: \"DEVSQ\"", function (assert) {

		ws.getRange2("A1:J210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A1").setValue("5.6");
		ws.getRange2("A2").setValue("8.2");
		ws.getRange2("A3").setValue("9.2");

		ws.getRange2("A100").setValue("4");
		ws.getRange2("A101").setValue("5");
		ws.getRange2("A102").setValue("8");
		ws.getRange2("A103").setValue("7");
		ws.getRange2("A104").setValue("11");
		ws.getRange2("A105").setValue("text");
		ws.getRange2("A106").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("4"); // Column1
		ws.getRange2("B601").setValue("5"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("4");
		ws2.getRange2("A2").setValue("5");
		ws2.getRange2("A3").setValue("8");
		ws2.getRange2("A4").setValue("7");
		ws2.getRange2("A5").setValue("11");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("4"); // TestName
		ws.getRange2("A202").setValue("5"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("4") // TestName3D
		ws2.getRange2("A12").setValue("5") // TestName3D1

		let cellWithFormula = new AscCommonExcel.CCellWithFormula(ws, 0, 3); // A4

		// Positive cases:

		// Case #1: Number(3). Return 6.906666667
		oParser = new parserFormula('DEVSQ(5.6,8.2,9.2)', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(5.6,8.2,9.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '6.906666667', 'Test: Positive case: Number(3). Return 6.906666667');
		// Case #2: Array. Return 6.906666668
		oParser = new parserFormula('DEVSQ({5.6,8.2,9.2})', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ({5.6,8.2,9.2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.9066666666666645, 'Test: Positive case: Array. Return 6.906666668');
		// Case #3: Number(2),String. Return 6.906666669
		oParser = new parserFormula('DEVSQ(5.6,8.2,"9.2")', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(5.6,8.2,"9.2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9), '6.906666667', 'Test: Positive case: Number(2),String. Return 6.906666669');
		// Case #4: Area. Return 6.906666670
		oParser = new parserFormula("DEVSQ(" + ws.getName() + "!A1:A3)", cellWithFormula, ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(' + ws.getName() + '!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '6.906666667', 'Test: Positive case: Area. Return 6.906666670');
		// Case #5: Area. Sum of squared deviations for range with 7 numbers (4,5,8,7,11,4,3). Returns 30
		oParser = new parserFormula('DEVSQ(A100:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A100:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Area. Sum of squared deviations for range with 7 numbers (4,5,8,7,11,4,3). Returns 30');
		// Case #6: Number(3). Multiple number arguments. Returns 8.66666667
		oParser = new parserFormula('DEVSQ(4,5,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(4,5,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '8.666666667', 'Test: Positive case: Number(3). Multiple number arguments. Returns 8.66666667');
		// Case #7: Number(5). Five number arguments. Returns 30
		oParser = new parserFormula('DEVSQ(4,5,8,7,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(4,5,8,7,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Number(5). Five number arguments. Returns 30');
		// Case #8: Number. Single number argument. Returns 0
		oParser = new parserFormula('DEVSQ(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Single number argument. Returns 0');
		// Case #9: Number(2). Two identical numbers. Returns 0
		oParser = new parserFormula('DEVSQ(2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Two identical numbers. Returns 0');
		// Case #10: Number(3). Sequential numbers. Returns 2
		oParser = new parserFormula('DEVSQ(1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(3). Sequential numbers. Returns 2');
		// Case #11: Number(4). Mix of negative, zero and positive. Returns 98
		oParser = new parserFormula('DEVSQ(-5,-3,0,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(-5,-3,0,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 98, 'Test: Positive case: Number(4). Mix of negative, zero and positive. Returns 98');
		// Case #12: Number(3). Float numbers. Returns 2
		oParser = new parserFormula('DEVSQ(1.5,2.5,3.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(1.5,2.5,3.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(3). Float numbers. Returns 2');
		// Case #13: String(3). String numbers converted to numbers. Returns 8.66666667
		oParser = new parserFormula('DEVSQ("4","5","8")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ("4","5","8") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9), '8.666666667', 'Test: Positive case: String(3). String numbers converted to numbers. Returns 8.66666667');
		// Case #14: Number, String(2). Mix of number and string numbers. Returns 8.66666667
		oParser = new parserFormula('DEVSQ(4,"5","8")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(4,"5","8") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9), '8.666666667', 'Test: Positive case: Number, String(2). Mix of number and string numbers. Returns 8.66666667');
		// Case #15: Boolean(3). Booleans converted to numbers (1,1,0). Returns 0.66666667
		oParser = new parserFormula('DEVSQ(TRUE,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(TRUE,TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.666666667', 'Test: Positive case: Boolean(3). Booleans converted to numbers (1,1,0). Returns 0.66666667');
		// Case #16: Number, Boolean(2). Mix of number and booleans. Returns 0.66666667
		oParser = new parserFormula('DEVSQ(1,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(1,TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.666666667', 'Test: Positive case: Number, Boolean(2). Mix of number and booleans. Returns 0.66666667');
		// Case #17: Formula(3). Nested ROUND formulas. Returns 6
		oParser = new parserFormula('DEVSQ(ROUND(4.6,0),ROUND(5.4,0),ROUND(8.1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(ROUND(4.6,0),ROUND(5.4,0),ROUND(8.1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula(3). Nested ROUND formulas. Returns 6');
		// Case #18: Formula(3). Nested ABS formulas. Returns 8.66666667
		oParser = new parserFormula('DEVSQ(ABS(-4),ABS(-5),ABS(-8))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(ABS(-4),ABS(-5),ABS(-8)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '8.666666667', 'Test: Positive case: Formula(3). Nested ABS formulas. Returns 8.66666667');
		// Case #19: Formula. DEVSQ as part of SUM formula. Returns 12
		oParser = new parserFormula('SUM(DEVSQ(1,2,3),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DEVSQ(1,2,3),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Formula. DEVSQ as part of SUM formula. Returns 12');
		// Case #20: Reference link(3). Three reference links to 4,5,8. Returns 8.66666667
		oParser = new parserFormula('DEVSQ(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '8.666666667', 'Test: Positive case: Reference link(3). Three reference links to 4,5,8. Returns 8.66666667');
		// Case #21: Area, Number(2). Mix of range and numbers. Returns 30
		oParser = new parserFormula('DEVSQ(A100:A102,7,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A100:A102,7,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Area, Number(2). Mix of range and numbers. Returns 30');
		// Case #22: Area(2). Two separate ranges. Returns 30
		oParser = new parserFormula('DEVSQ(A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A100:A102,A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Area(2). Two separate ranges. Returns 30');
		// Case #23: Name(2). Named range. Returns calculated deviation
		oParser = new parserFormula('DEVSQ(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Name(2). Named range. Returns calculated deviation');
		// Case #24: Name3D(2). 3D named range. Returns calculated deviation
		oParser = new parserFormula('DEVSQ(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Name3D(2). 3D named range. Returns calculated deviation');
		// Case #25: Ref3D(3). 3D references to 4,5,8. Returns 8.66666667
		oParser = new parserFormula('DEVSQ(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '8.666666667', 'Test: Positive case: Ref3D(3). 3D references to 4,5,8. Returns 8.66666667');
		// Case #26: Area3D. 3D range. Returns 1.2
		oParser = new parserFormula('DEVSQ(Sheet2!A1:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(Sheet2!A1:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.2', 'Test: Positive case: Area3D. 3D range. Returns 1.2');
		// Case #27: Table(2). Table column reference. Returns calculated deviation
		oParser = new parserFormula('DEVSQ(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Table(2). Table column reference. Returns calculated deviation');
		// Case #28: Array. Array argument. Returns 8.66666667
		oParser = new parserFormula('DEVSQ({4,5,8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ({4,5,8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.666666666666666, 'Test: Positive case: Array. Array argument. Returns 8.66666667');
		// Case #29: Number(6). All zeros. Returns 0
		oParser = new parserFormula('DEVSQ(0,0,0,0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(0,0,0,0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(6). All zeros. Returns 0');
		// Case #30: Number(4). Large numbers. Returns 50000
		oParser = new parserFormula('DEVSQ(100,200,300,400)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(100,200,300,400) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50000, 'Test: Positive case: Number(4). Large numbers. Returns 50000');
		// Case #31: Formula(3). Date formulas as serial numbers. Returns 2
		oParser = new parserFormula('DEVSQ(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(3). Date formulas as serial numbers. Returns 2');
		// Case #32: Formula(3). Time formulas as decimal values. Returns calculated deviation
		oParser = new parserFormula('DEVSQ(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.003472222', 'Test: Positive case: Formula(3). Time formulas as decimal values. Returns calculated deviation');
		// Case #33: Number(10). Ten sequential numbers. Returns 82.5
		oParser = new parserFormula('DEVSQ(1,2,3,4,5,6,7,8,9,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(1,2,3,4,5,6,7,8,9,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '82.5', 'Test: Positive case: Number(10). Ten sequential numbers. Returns 82.5');
		// Case #34: Empty, Number(2). Empty argument treated as 0 in array/reference but ignored in direct input. Returns 16.66666667
		oParser = new parserFormula('DEVSQ(,5,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(,5,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(8)*/, '16.66666667', 'Test: Positive case: Empty, Number(2). Empty argument treated as 0 in array/reference but ignored in direct input. Returns 16.66666667');
		// Case #35: Number(2), Empty. Empty at end ignored. Returns 16.66666667
		oParser = new parserFormula('DEVSQ(5,5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(5,5,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue()/*.toFixed(8)*/, '16.66666667', 'Test: Positive case: Number(2), Empty. Empty at end ignored. Returns 16.66666667');
		// Case #36: Area. Single cell range. Returns 0
		oParser = new parserFormula('DEVSQ(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single cell range. Returns 0');
		// Case #37: Reference link. Single reference link to 4. Returns 0
		oParser = new parserFormula('DEVSQ(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Single reference link to 4. Returns 0');
		// Case #38: Number(7). Seven numbers matching example. Returns 48
		oParser = new parserFormula('DEVSQ(4,5,8,7,11,4,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(4,5,8,7,11,4,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 48, 'Test: Positive case: Number(7). Seven numbers matching example. Returns 48');
		// Case #39: Number, Reference link, Number. Reference to text in middle. Returns #VALUE!
		oParser = new parserFormula('DEVSQ(5,A105,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(5,A105,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue()/*.toFixed(1)*/, 4.5, 'Test: Positive case: Number, Reference link, Number. Reference to text in middle. Returns #VALUE!');

		// Negative cases:

		// Case #1: String(3). Non-numeric strings. Returns #VALUE!
		oParser = new parserFormula('DEVSQ("abc","def","ghi")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ("abc","def","ghi") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). Non-numeric strings. Returns #VALUE!');
		// Case #2: Number, String(2). Mix of number and non-numeric strings. Returns #VALUE!
		oParser = new parserFormula('DEVSQ(5,"text","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(5,"text","abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String(2). Mix of number and non-numeric strings. Returns #VALUE!');
		// Case #3: Error, Number(2). Error in arguments. Returns #N/A
		oParser = new parserFormula('DEVSQ(#N/A,5,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(#N/A,5,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(2). Error in arguments. Returns #N/A');
		// Case #4: Number, Error, Number. Error in middle argument. Returns #VALUE!
		oParser = new parserFormula('DEVSQ(5,#VALUE!,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(5,#VALUE!,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Error, Number. Error in middle argument. Returns #VALUE!');
		// Case #5: Number(2), Error. Error at end. Returns #NUM!
		oParser = new parserFormula('DEVSQ(5,8,#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(5,8,#NUM!) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Error. Error at end. Returns #NUM!');
		// Case #6: Error(3). Multiple errors, first returned. Returns #N/A
		oParser = new parserFormula('DEVSQ(#N/A,#VALUE!,#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(#N/A,#VALUE!,#NUM!) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(3). Multiple errors, first returned. Returns #N/A');
		// Case #7: Reference link, Number(2). Reference to text cell. Returns #VALUE!
		oParser = new parserFormula('DEVSQ(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Number(2). Reference to text cell. Returns #VALUE!');
		// Case #8: Reference link, Number(2). Reference to error cell. Returns #NULL!
		oParser = new parserFormula('DEVSQ(A106,5,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A106,5,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number(2). Reference to error cell. Returns #NULL!');
		// Case #9: Number(2), Reference link. Reference to error at end. Returns #NULL!
		oParser = new parserFormula('DEVSQ(5,8,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(5,8,A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number(2), Reference link. Reference to error at end. Returns #NULL!');
		// Case #10: Formula, Number(2). Formula resulting in error. Returns #NUM!
		oParser = new parserFormula('DEVSQ(SQRT(-1),5,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(SQRT(-1),5,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number(2). Formula resulting in error. Returns #NUM!');
		// Case #11: Number, Formula, Number. Division by zero error. Returns #DIV/0!
		oParser = new parserFormula('DEVSQ(5,1/0,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(5,1/0,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Formula, Number. Division by zero error. Returns #DIV/0!');
		// Case #12: Area. Range with text and error. Returns #VALUE!
		oParser = new parserFormula('DEVSQ(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A105:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Area. Range with text and error. Returns #VALUE!');
		// Case #13: String. Invalid numeric format. Returns #VALUE!
		oParser = new parserFormula('DEVSQ("5.5.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ("5.5.5") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Invalid numeric format. Returns #VALUE!');
		// Case #14: String, Number(2). Empty string argument. Returns #VALUE!
		oParser = new parserFormula('DEVSQ("",5,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ("",5,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(2). Empty string argument. Returns #VALUE!');
		// Case #15: String(2), Number. Invalid string formats. Returns #VALUE!
		oParser = new parserFormula('DEVSQ("12/ab","5cd",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ("12/ab","5cd",8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number. Invalid string formats. Returns #VALUE!');
		// Case #16: Formula. NA() function. Returns #N/A
		oParser = new parserFormula('DEVSQ(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. NA() function. Returns #N/A');

		// Bounded cases:

		// Case #1: Number(3). Maximum Excel numbers, all equal. Returns 0
		oParser = new parserFormula('DEVSQ(1E+307,1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(1E+307,1E+307,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3). Maximum Excel numbers, all equal. Returns 0');
		// Case #2: Number(3). Minimum Excel numbers, all equal. Returns 0
		oParser = new parserFormula('DEVSQ(-1E+307,-1E+307,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(-1E+307,-1E+307,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3). Minimum Excel numbers, all equal. Returns 0');
		// Case #3: Area(2). Whole column and row intersection. Returns calculated deviation
		oParser = new parserFormula('DEVSQ(A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEVSQ(A:A,100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Bounded case: Area(2). Whole column and row intersection. Returns calculated deviation');

		// Need to fix: empty handle, string handle, error handle, error types diff, ms result diff

		testArrayFormula2(assert, "DEVSQ", 1, 8, null, true);
	});

	QUnit.test("Test: \"EXPONDIST\"", function (assert) {

		oParser = new parserFormula("EXPONDIST(0.2,10,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(difBetween(oParser.calculate().getValue(), 1.353352832366127), true);

		oParser = new parserFormula("EXPONDIST(2.3,1.5,TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(difBetween(oParser.calculate().getValue(), 0.968254363621932), true);

		ws.getRange2("A100:D210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("1s");
		ws.getRange2("A104").setValue("");
		// For area
		ws.getRange2("A102").setValue("Text");
		ws.getRange2("A103").setValue("Text2");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: positive numbers, cumulative TRUE. Returns cumulative distribution.
		oParser = new parserFormula('EXPONDIST(1,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Positive case: Number. Basic valid input: positive numbers, cumulative TRUE. Returns cumulative distribution.');
		// Case #2: Number. Positive numbers, cumulative FALSE. Returns probability density.
		oParser = new parserFormula('EXPONDIST(1,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2706705664732254, 'Test: Positive case: Number. Positive numbers, cumulative FALSE. Returns probability density.');
		// Case #3: Formula. Nested formulas producing valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(SQRT(4),ABS(2),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(SQRT(4),ABS(2),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9816843611112658, 'Test: Positive case: Formula. Nested formulas producing valid numbers, cumulative TRUE.');
		// Case #4: Reference link. References to cells with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(A100,A101,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(A100,A101,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. References to cells with valid numbers, cumulative TRUE.');
		// Case #5: Area. Single-cell ranges with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(A102:A102,A103:A103,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(A102:A102,A103:A103,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell ranges with valid numbers, cumulative TRUE.');
		// Case #6: Array. Arrays with single valid number elements, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST({1},{2},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST({1},{2},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Positive case: Array. Arrays with single valid number elements, cumulative TRUE.');
		// Case #7: Name. Named ranges with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(TestName,TestName1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(TestName,TestName1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers, cumulative TRUE.');
		// Case #8: Name3D. 3D named ranges with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(TestName3D,TestName3D,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(TestName3D,TestName3D,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers, cumulative TRUE.');
		// Case #9: Ref3D. 3D references to cells with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(Sheet2!A1,Sheet2!A2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(Sheet2!A1,Sheet2!A2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5276334472589853, 'Test: Positive case: Ref3D. 3D references to cells with valid numbers, cumulative TRUE.');
		// Case #10: Area3D. 3D single-cell ranges with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(Sheet2!A3:A3,Sheet2!A4:A4,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(Sheet2!A3:A3,Sheet2!A4:A4,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers, cumulative TRUE.');
		// Case #11: Table. Table references with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(Table1[Column1],Table1[Column2],TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(Table1[Column1],Table1[Column2],TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Table. Table references with valid numbers, cumulative TRUE.');
		// Case #12: Formula. Nested IF producing valid numbers, cumulative FALSE.
		oParser = new parserFormula('EXPONDIST(IF(TRUE,1,0),IF(TRUE,2,0),FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(IF(TRUE,1,0),IF(TRUE,2,0),FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2706705664732254, 'Test: Positive case: Formula. Nested IF producing valid numbers, cumulative FALSE.');
		// Case #13: Number. Float numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(0.5,1.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(0.5,1.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5276334472589853, 'Test: Positive case: Number. Float numbers, cumulative TRUE.');
		// Case #14: Formula. Nested ROUND producing valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(ROUND(1.5,1),ROUND(2.5,1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(ROUND(1.5,1),ROUND(2.5,1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9764822541439909, 'Test: Positive case: Formula. Nested ROUND producing valid numbers, cumulative TRUE.');
		// Case #15: Formula. EXPON.DIST inside SUM formula, valid inputs.
		oParser = new parserFormula('SUM(EXPONDIST(1,2,TRUE),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(EXPONDIST(1,2,TRUE),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9646647167633873, 'Test: Positive case: Formula. EXPON.DIST inside SUM formula, valid inputs.');
		// Case #16: String. Numeric strings converted to numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST("1","2",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST("1","2",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Positive case: String. Numeric strings converted to numbers, cumulative TRUE.');
		// Case #17: Array. Multi-element arrays with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPONDIST({0.5,1},{1.5,2},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST({0.5,1},{1.5,2},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5276334472589853, 'Test: Positive case: Array. Multi-element arrays with valid numbers, cumulative TRUE.');
		// Case #18: Date. Date as serial number (>0), cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(DATE(2025,1,1),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(DATE(2025,1,1),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number (>0), cumulative TRUE.');
		// Case #19: Time. Time as fractional number (>0), cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(TIME(12,0,0),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(TIME(12,0,0),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3934693402873666, 'Test: Positive case: Time. Time as fractional number (>0), cumulative TRUE.');
		// Case #20: Number. Positive numbers, cumulative FALSE. Returns probability density.
		oParser = new parserFormula('EXPONDIST(1,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2706705664732254, 'Test: Positive case: Number. Positive numbers, cumulative FALSE. Returns probability density.');
		// Case #21: Formula. Nested ABS producing valid numbers, cumulative FALSE.
		oParser = new parserFormula('EXPONDIST(ABS(1),ABS(2),FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(ABS(1),ABS(2),FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2706705664732254, 'Test: Positive case: Formula. Nested ABS producing valid numbers, cumulative FALSE.');

		// Negative cases:
		// Case #1: Number. Negative x returns #NUM! error.
		oParser = new parserFormula('EXPONDIST(-1,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(-1,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative x returns #NUM! error.');
		// Case #2: Number. Lambda = 0 returns #NUM! error.
		oParser = new parserFormula('EXPONDIST(1,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,0,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Lambda = 0 returns #NUM! error.');
		// Case #3: Number. Negative lambda returns #NUM! error.
		oParser = new parserFormula('EXPONDIST(1,-2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,-2,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative lambda returns #NUM! error.');
		// Case #4: String. Non-numeric x returns #VALUE! error.
		oParser = new parserFormula('EXPONDIST("abc",2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST("abc",2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric x returns #VALUE! error.');
		// Case #5: String. Non-numeric lambda returns #VALUE! error.
		oParser = new parserFormula('EXPONDIST(1,"abc",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,"abc",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric lambda returns #VALUE! error.');
		// Case #6: Error. Propagates #N/A error for x.
		oParser = new parserFormula('EXPONDIST(NA(),2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(NA(),2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for x.');
		// Case #7: Error. Propagates #N/A error for lambda.
		oParser = new parserFormula('EXPONDIST(1,NA(),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,NA(),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for lambda.');
		// Case #8: Area. Multi-cell ranges for x and lambda. Returns #VALUE! error.
		oParser = new parserFormula('EXPONDIST(A104:A105,A106:A107,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(A104:A105,A106:A107,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell ranges for x and lambda. Returns #VALUE! error.');
		// Case #9: Boolean. Boolean x converted to 1, valid but may not be intended. Returns valid result.
		oParser = new parserFormula('EXPONDIST(TRUE,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(TRUE,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Negative case: Boolean. Boolean x converted to 1, valid but may not be intended. Returns valid result.');
		// Case #10: Boolean. Boolean lambda converted to 0, returns #NUM! error.
		oParser = new parserFormula('EXPONDIST(1,FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,FALSE,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean lambda converted to 0, returns #NUM! error.');
		// Case #11: Empty. Empty cell reference for x treated as 0, valid but may not be intended.
		oParser = new parserFormula('EXPONDIST(A108,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(A108,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty cell reference for x treated as 0, valid but may not be intended.');
		// Case #12: Empty. Empty cell reference for lambda treated as 0, returns #NUM! error.
		oParser = new parserFormula('EXPONDIST(1,A109,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,A109,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty cell reference for lambda treated as 0, returns #NUM! error.');
		// Case #13: Name. Named range with multi-cell data returns #VALUE! error.
		oParser = new parserFormula('EXPONDIST(TestNameArea2,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(TestNameArea2,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7981034820053446, 'Test: Negative case: Name. Named range with multi-cell data returns #VALUE! error.');
		// Case #14: Name3D. 3D named range with multi-cell data returns #VALUE! error.
		oParser = new parserFormula('EXPONDIST(TestNameArea3D2,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(TestNameArea3D2,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7981034820053446, 'Test: Negative case: Name3D. 3D named range with multi-cell data returns #VALUE! error.');
		// Case #15: Ref3D. 3D references to cells with non-numeric values return #VALUE! error.
		oParser = new parserFormula('EXPONDIST(Sheet2!A5,Sheet2!A6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(Sheet2!A5,Sheet2!A6,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D references to cells with non-numeric values return #VALUE! error.');
		// Case #16: Area3D. 3D multi-cell ranges return #VALUE! error.
		oParser = new parserFormula('EXPONDIST(Sheet2!A7:A8,Sheet2!A9:A10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(Sheet2!A7:A8,Sheet2!A9:A10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. 3D multi-cell ranges return #VALUE! error.');
		// Case #17: Table. Table references with non-numeric values return #VALUE! error.
		oParser = new parserFormula('EXPONDIST(Table1[Column3],Table1[Column3],TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(Table1[Column3],Table1[Column3],TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table references with non-numeric values return #VALUE! error.');
		// Case #18: Formula. Nested formula producing #NUM! error for x.
		oParser = new parserFormula('EXPONDIST(SQRT(-1),2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(SQRT(-1),2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula producing #NUM! error for x.');
		// Case #19: Formula. Nested formula producing #NUM! error for lambda.
		oParser = new parserFormula('EXPONDIST(1,SQRT(-1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,SQRT(-1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula producing #NUM! error for lambda.');
		// Case #20: Array. Array with boolean x returns #VALUE! error.
		oParser = new parserFormula('EXPONDIST({TRUE},2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST({TRUE},2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Negative case: Array. Array with boolean x returns #VALUE! error.');

		// Bounded cases:
		// Case #1: Number. Minimum valid x (0), cumulative TRUE. Returns 0.
		oParser = new parserFormula('EXPONDIST(0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid x (0), cumulative TRUE. Returns 0.');
		// Case #2: Number. Minimum valid lambda (>0), cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(1,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,1E-307,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum valid lambda (>0), cumulative TRUE.');
		// Case #3: Number. Maximum valid x (Excel number limit), cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(9.99999999999999E+307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(9.99999999999999E+307,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid x (Excel number limit), cumulative TRUE.');
		// Case #4: Number. Maximum valid lambda (Excel number limit), cumulative TRUE.
		oParser = new parserFormula('EXPONDIST(1,9.99999999999999E+307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPONDIST(1,9.99999999999999E+307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid lambda (Excel number limit), cumulative TRUE.');

		// Need to fix: area handle, error types diff, ms result diff in some cases
		// Case #4: Reference link. References to cells with valid numbers, cumulative TRUE.
		// Case #5: Area. Single-cell ranges with valid numbers, cumulative TRUE.
		// Case #2: Number. Lambda = 0 returns #NUM! error.
		// Case #3: Number. Negative lambda returns #NUM! error.
		// Case #8: Area. Multi-cell ranges for x and lambda. Returns #VALUE! error.
		// Case #10: Boolean. Boolean lambda converted to 0, returns #NUM! error.
		// Case #12: Empty. Empty cell reference for lambda treated as 0, returns #NUM! error.
		// Case #15: Ref3D. 3D references to cells with non-numeric values return #VALUE! error.
		// Case #16: Area3D. 3D multi-cell ranges return #VALUE! error.
		// Case #2: Number. Minimum valid lambda (>0), cumulative TRUE.


		testArrayFormula2(assert, "EXPONDIST", 3, 3);
	});

	QUnit.test("Test: \"EXPON.DIST\"", function (assert) {
		ws.getRange2("A2").setValue("0.2");
		ws.getRange2("A3").setValue("10");

		oParser = new parserFormula("EXPON.DIST(A2,A3,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "EXPON.DIST(A2,A3,TRUE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.86466472, "EXPON.DIST(A2,A3,TRUE)");

		oParser = new parserFormula("EXPON.DIST(0.2,10,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "EXPON.DIST(0.2,10,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 1.35335283, "EXPON.DIST(0.2,10,FALSE)");

		ws.getRange2("A100:D210").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("1s");
		ws.getRange2("A104").setValue("");
		// For area
		ws.getRange2("A102").setValue("Text");
		ws.getRange2("A103").setValue("Text2");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: positive numbers, cumulative TRUE. Returns cumulative distribution.
		oParser = new parserFormula('EXPON.DIST(1,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Positive case: Number. Basic valid input: positive numbers, cumulative TRUE. Returns cumulative distribution.');
		// Case #2: Number. Positive numbers, cumulative FALSE. Returns probability density.
		oParser = new parserFormula('EXPON.DIST(1,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2706705664732254, 'Test: Positive case: Number. Positive numbers, cumulative FALSE. Returns probability density.');
		// Case #3: Formula. Nested formulas producing valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(SQRT(4),ABS(2),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(SQRT(4),ABS(2),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9816843611112658, 'Test: Positive case: Formula. Nested formulas producing valid numbers, cumulative TRUE.');
		// Case #4: Reference link. References to cells with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(A100,A101,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(A100,A101,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. References to cells with valid numbers, cumulative TRUE.');
		// Case #5: Area. Single-cell ranges with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(A102:A102,A103:A103,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(A102:A102,A103:A103,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell ranges with valid numbers, cumulative TRUE.');
		// Case #6: Array. Arrays with single valid number elements, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST({1},{2},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST({1},{2},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Positive case: Array. Arrays with single valid number elements, cumulative TRUE.');
		// Case #7: Name. Named ranges with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(TestName,TestName1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(TestName,TestName1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers, cumulative TRUE.');
		// Case #8: Name3D. 3D named ranges with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(TestName3D,TestName3D,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(TestName3D,TestName3D,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers, cumulative TRUE.');
		// Case #9: Ref3D. 3D references to cells with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(Sheet2!A1,Sheet2!A2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(Sheet2!A1,Sheet2!A2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5276334472589853, 'Test: Positive case: Ref3D. 3D references to cells with valid numbers, cumulative TRUE.');
		// Case #10: Area3D. 3D single-cell ranges with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(Sheet2!A3:A3,Sheet2!A4:A4,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(Sheet2!A3:A3,Sheet2!A4:A4,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers, cumulative TRUE.');
		// Case #11: Table. Table references with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(Table1[Column1],Table1[Column2],TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(Table1[Column1],Table1[Column2],TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Table. Table references with valid numbers, cumulative TRUE.');
		// Case #12: Formula. Nested IF producing valid numbers, cumulative FALSE.
		oParser = new parserFormula('EXPON.DIST(IF(TRUE,1,0),IF(TRUE,2,0),FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(IF(TRUE,1,0),IF(TRUE,2,0),FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2706705664732254, 'Test: Positive case: Formula. Nested IF producing valid numbers, cumulative FALSE.');
		// Case #13: Number. Float numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(0.5,1.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(0.5,1.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5276334472589853, 'Test: Positive case: Number. Float numbers, cumulative TRUE.');
		// Case #14: Formula. Nested ROUND producing valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(ROUND(1.5,1),ROUND(2.5,1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(ROUND(1.5,1),ROUND(2.5,1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9764822541439909, 'Test: Positive case: Formula. Nested ROUND producing valid numbers, cumulative TRUE.');
		// Case #15: Formula. EXPON.DIST inside SUM formula, valid inputs.
		oParser = new parserFormula('SUM(EXPON.DIST(1,2,TRUE),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(EXPON.DIST(1,2,TRUE),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9646647167633873, 'Test: Positive case: Formula. EXPON.DIST inside SUM formula, valid inputs.');
		// Case #16: String. Numeric strings converted to numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST("1","2",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST("1","2",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Positive case: String. Numeric strings converted to numbers, cumulative TRUE.');
		// Case #17: Array. Multi-element arrays with valid numbers, cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST({0.5,1},{1.5,2},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST({0.5,1},{1.5,2},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5276334472589853, 'Test: Positive case: Array. Multi-element arrays with valid numbers, cumulative TRUE.');
		// Case #18: Date. Date as serial number (>0), cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(DATE(2025,1,1),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(DATE(2025,1,1),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number (>0), cumulative TRUE.');
		// Case #19: Time. Time as fractional number (>0), cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(TIME(12,0,0),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(TIME(12,0,0),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3934693402873666, 'Test: Positive case: Time. Time as fractional number (>0), cumulative TRUE.');
		// Case #20: Number. Positive numbers, cumulative FALSE. Returns probability density.
		oParser = new parserFormula('EXPON.DIST(1,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2706705664732254, 'Test: Positive case: Number. Positive numbers, cumulative FALSE. Returns probability density.');
		// Case #21: Formula. Nested ABS producing valid numbers, cumulative FALSE.
		oParser = new parserFormula('EXPON.DIST(ABS(1),ABS(2),FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(ABS(1),ABS(2),FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2706705664732254, 'Test: Positive case: Formula. Nested ABS producing valid numbers, cumulative FALSE.');

		// Negative cases:
		// Case #1: Number. Negative x returns #NUM! error.
		oParser = new parserFormula('EXPON.DIST(-1,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(-1,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative x returns #NUM! error.');
		// Case #2: Number. Lambda = 0 returns #NUM! error.
		oParser = new parserFormula('EXPON.DIST(1,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,0,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Lambda = 0 returns #NUM! error.');
		// Case #3: Number. Negative lambda returns #NUM! error.
		oParser = new parserFormula('EXPON.DIST(1,-2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,-2,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative lambda returns #NUM! error.');
		// Case #4: String. Non-numeric x returns #VALUE! error.
		oParser = new parserFormula('EXPON.DIST("abc",2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST("abc",2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric x returns #VALUE! error.');
		// Case #5: String. Non-numeric lambda returns #VALUE! error.
		oParser = new parserFormula('EXPON.DIST(1,"abc",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,"abc",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric lambda returns #VALUE! error.');
		// Case #6: Error. Propagates #N/A error for x.
		oParser = new parserFormula('EXPON.DIST(NA(),2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(NA(),2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for x.');
		// Case #7: Error. Propagates #N/A error for lambda.
		oParser = new parserFormula('EXPON.DIST(1,NA(),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,NA(),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for lambda.');
		// Case #8: Area. Multi-cell ranges for x and lambda. Returns #VALUE! error.
		oParser = new parserFormula('EXPON.DIST(A104:A105,A106:A107,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(A104:A105,A106:A107,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell ranges for x and lambda. Returns #VALUE! error.');
		// Case #9: Boolean. Boolean x converted to 1, valid but may not be intended. Returns valid result.
		oParser = new parserFormula('EXPON.DIST(TRUE,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(TRUE,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Negative case: Boolean. Boolean x converted to 1, valid but may not be intended. Returns valid result.');
		// Case #10: Boolean. Boolean lambda converted to 0, returns #NUM! error.
		oParser = new parserFormula('EXPON.DIST(1,FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,FALSE,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean lambda converted to 0, returns #NUM! error.');
		// Case #11: Empty. Empty cell reference for x treated as 0, valid but may not be intended.
		oParser = new parserFormula('EXPON.DIST(A108,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(A108,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty cell reference for x treated as 0, valid but may not be intended.');
		// Case #12: Empty. Empty cell reference for lambda treated as 0, returns #NUM! error.
		oParser = new parserFormula('EXPON.DIST(1,A109,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,A109,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty cell reference for lambda treated as 0, returns #NUM! error.');
		// Case #13: Name. Named range with multi-cell data returns #VALUE! error.
		oParser = new parserFormula('EXPON.DIST(TestNameArea2,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(TestNameArea2,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7981034820053446, 'Test: Negative case: Name. Named range with multi-cell data returns #VALUE! error.');
		// Case #14: Name3D. 3D named range with multi-cell data returns #VALUE! error.
		oParser = new parserFormula('EXPON.DIST(TestNameArea3D2,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(TestNameArea3D2,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7981034820053446, 'Test: Negative case: Name3D. 3D named range with multi-cell data returns #VALUE! error.');
		// Case #15: Ref3D. 3D references to cells with non-numeric values return #VALUE! error.
		oParser = new parserFormula('EXPON.DIST(Sheet2!A5,Sheet2!A6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(Sheet2!A5,Sheet2!A6,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D references to cells with non-numeric values return #VALUE! error.');
		// Case #16: Area3D. 3D multi-cell ranges return #VALUE! error.
		oParser = new parserFormula('EXPON.DIST(Sheet2!A7:A8,Sheet2!A9:A10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(Sheet2!A7:A8,Sheet2!A9:A10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. 3D multi-cell ranges return #VALUE! error.');
		// Case #17: Table. Table references with non-numeric values return #VALUE! error.
		oParser = new parserFormula('EXPON.DIST(Table1[Column3],Table1[Column3],TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(Table1[Column3],Table1[Column3],TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table references with non-numeric values return #VALUE! error.');
		// Case #18: Formula. Nested formula producing #NUM! error for x.
		oParser = new parserFormula('EXPON.DIST(SQRT(-1),2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(SQRT(-1),2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula producing #NUM! error for x.');
		// Case #19: Formula. Nested formula producing #NUM! error for lambda.
		oParser = new parserFormula('EXPON.DIST(1,SQRT(-1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,SQRT(-1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula producing #NUM! error for lambda.');
		// Case #20: Array. Array with boolean x returns #VALUE! error.
		oParser = new parserFormula('EXPON.DIST({TRUE},2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST({TRUE},2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633873, 'Test: Negative case: Array. Array with boolean x returns #VALUE! error.');

		// Bounded cases:
		// Case #1: Number. Minimum valid x (0), cumulative TRUE. Returns 0.
		oParser = new parserFormula('EXPON.DIST(0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid x (0), cumulative TRUE. Returns 0.');
		// Case #2: Number. Minimum valid lambda (>0), cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(1,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,1E-307,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum valid lambda (>0), cumulative TRUE.');
		// Case #3: Number. Maximum valid x (Excel number limit), cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(9.99999999999999E+307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(9.99999999999999E+307,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid x (Excel number limit), cumulative TRUE.');
		// Case #4: Number. Maximum valid lambda (Excel number limit), cumulative TRUE.
		oParser = new parserFormula('EXPON.DIST(1,9.99999999999999E+307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EXPON.DIST(1,9.99999999999999E+307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid lambda (Excel number limit), cumulative TRUE.');

		// Need to fix: area handle, error types diff, ms result diff in some cases
		// Case #4: Reference link. References to cells with valid numbers, cumulative TRUE.
		// Case #5: Area. Single-cell ranges with valid numbers, cumulative TRUE.
		// Case #2: Number. Lambda = 0 returns #NUM! error.
		// Case #3: Number. Negative lambda returns #NUM! error.
		// Case #8: Area. Multi-cell ranges for x and lambda. Returns #VALUE! error.
		// Case #10: Boolean. Boolean lambda converted to 0, returns #NUM! error.
		// Case #12: Empty. Empty cell reference for lambda treated as 0, returns #NUM! error.
		// Case #15: Ref3D. 3D references to cells with non-numeric values return #VALUE! error.
		// Case #16: Area3D. 3D multi-cell ranges return #VALUE! error.
		// Case #2: Number. Minimum valid lambda (>0), cumulative TRUE.

		testArrayFormula2(assert, "EXPON.DIST", 3, 3);
	});

	QUnit.test("Test: \"FDIST\"", function (assert) {
		ws.getRange2("A2").setValue("15.2069");
		ws.getRange2("A3").setValue("6");
		ws.getRange2("A4").setValue("4");

		oParser = new parserFormula("FDIST(A2,A3,A4)", "A1", ws);
		assert.ok(oParser.parse(), "FDIST(A2,A3,A4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.01, "FDIST(A2,A3,A4)");

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("5"); // Num (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8701603741696002, 'Test: Positive case: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0.3,"5","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0.3,"5","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9019579816310674, 'Test: Positive case: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.');
		// Case #3: Formula. Nested formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(SQRT(0.25),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(SQRT(0.25),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Formula. Nested formula for probability. 3 of 3 arguments used.');
		// Case #4: Formula. Nested IF formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(IF(TRUE,0.4,0.6),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(IF(TRUE,0.4,0.6),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8381652584780426, 'Test: Positive case: Formula. Nested IF formula for probability. 3 of 3 arguments used.');
		// Case #5: Reference link. Reference link to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Reference link. Reference link to valid probability. 3 of 3 arguments used.');
		// Case #6: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0.5,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0.5,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8701603741696002, 'Test: Positive case: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.');
		// Case #7: Area. Single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(A100:A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(A100:A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Area. Single-cell range for probability. 3 of 3 arguments used.');
		// Case #8: Array. Array with single valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST({0.5},5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST({0.5},5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Array. Array with single valid probability. 3 of 3 arguments used.');
		// Case #9: Name. Named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(TestName,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(TestName,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid probability. 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(TestName3D,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(TestName3D,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid probability. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(Sheet2!A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(Sheet2!A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46511942653779986, 'Test: Positive case: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.');
		// Case #12: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(Sheet2!A1:A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(Sheet2!A1:A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46511942653779986, 'Test: Positive case: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.');
		// Case #13: Table. Table structured reference with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(Table1[Column1],5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(Table1[Column1],5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.014868800408112979, 'Test: Positive case: Table. Table structured reference with valid probability. 3 of 3 arguments used.');
		// Case #14: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(DATE(2025,1,1)/1000000,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(DATE(2025,1,1)/1000000,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9983624375356968, 'Test: Positive case: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.');
		// Case #15: Time. Time as valid probability (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(TIME(12,0,0),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(TIME(12,0,0),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Time. Time as valid probability (0.5). 3 of 3 arguments used.');
		// Case #16: Formula. FINV inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(FDIST(0.5,5,10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FDIST(0.5,5,10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7700248806501016, 'Test: Positive case: Formula. FINV inside SUM formula. 3 of 3 arguments used.');
		// Case #17: Number. High valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0.999,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0.999,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47621518230180626, 'Test: Positive case: Number. High valid probability. 3 of 3 arguments used.');
		// Case #18: String. Numeric string converted to probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST("0.1",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST("0.1",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9996589026410869, 'Test: Positive case: String. Numeric string converted to probability. 3 of 3 arguments used.');
		// Case #19: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(ABS(-0.5),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(ABS(-0.5),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.');
		// Case #20: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(A100,A101,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(A100,A101,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8551541939744957, 'Test: Positive case: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.');
		// Case #21: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST({0.5},5,{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST({0.5},5,{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(1,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(1,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47550046843289157, 'Test: Negative case: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Negative probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(-0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(-0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0.5,0,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0.5,0,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #5: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0.5,10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0.5,10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #6: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST("abc",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST("abc",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(NA(),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(NA(),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(A100:A101,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(A100:A101,10,20) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.870160374, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(A103,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(A103,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: String. Empty string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST("",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST("",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(TRUE,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(TRUE,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47550046843289157, 'Test: Negative case: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(Sheet2!A2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(Sheet2!A2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08978271484374996, 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(TestNameArea2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(TestNameArea2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6306835578863199, 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(Table1[Column2],10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(Table1[Column2],10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.00000859411961792848, 'Test: Negative case: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(SQRT(-1),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(SQRT(-1),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #16: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0.5,-1,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0.5,-1,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0.5,10,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0.5,10,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST({0.5,1},10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST({0.5,1},10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8701603741696002, 'Test: Negative case: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(TestNameArea3D2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(TestNameArea3D2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6306835578863199, 'Test: Negative case: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(Sheet2!A2:A3,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(Sheet2!A2:A3,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(1E-307,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(1E-307,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('FDIST(0.999999999999999,1000000,1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FDIST(0.999999999999999,1000000,1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Bounded case: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.');

		// Need to fix:
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.

	});

	QUnit.test("Test: \"F.DIST\"", function (assert) {
		ws.getRange2("A2").setValue("15.2069");
		ws.getRange2("A3").setValue("6");
		ws.getRange2("A4").setValue("4");

		oParser = new parserFormula("F.DIST(A2,A3,A4,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "F.DIST(A2,A3,A4,TRUE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.99, "F.DIST(A2,A3,A4,TRUE)");

		oParser = new parserFormula("F.DIST(A2,A3,A4,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "F.DIST(A2,A3,A4,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0012238, "F.DIST(A2,A3,A4,FALSE)");

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("30");
		ws.getRange2("A104").setValue("40");
		ws.getRange2("A105").setValue("50");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("5s"); // Text (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: positive number for x, integers for degrees of freedom, cumulative TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,2,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,2,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.53524199845511, 'Test: Positive case: Number. Basic valid input: positive number for x, integers for degrees of freedom, cumulative TRUE. 4 of 4 arguments used.');
		// Case #2: String. String inputs convertible to valid numbers and boolean TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST("1","2","3","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST("1","2","3","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.53524199845511, 'Test: Positive case: String. String inputs convertible to valid numbers and boolean TRUE. 4 of 4 arguments used.');
		// Case #3: Formula. All arguments filled with formulas. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(SQRT(1),ROUND(2.3,0),ROUND(3.7,0),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(SQRT(1),ROUND(2.3,0),ROUND(3.7,0),IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5555555555555556, 'Test: Positive case: Formula. All arguments filled with formulas. 4 of 4 arguments used.');
		// Case #4: Number,Formula. Valid input with cumulative FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,2,3,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,2,3,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2788548009269341, 'Test: Positive case: Number,Formula. Valid input with cumulative FALSE. 4 of 4 arguments used.');
		// Case #5: Reference link. All arguments as cell references. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12983962583039976, 'Test: Positive case: Reference link. All arguments as cell references. 4 of 4 arguments used.');
		// Case #6: Area. All arguments as single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12983962583039976, 'Test: Positive case: Area. All arguments as single-cell ranges. 4 of 4 arguments used.');
		// Case #7: Array. All arguments as arrays with single valid element. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST({1},{2},{3},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST({1},{2},{3},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.53524199845511, 'Test: Positive case: Array. All arguments as arrays with single valid element. 4 of 4 arguments used.');
		// Case #8: Name. All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. All arguments as named ranges. 4 of 4 arguments used.');
		// Case #9: Name3D. All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #10: Ref3D. All arguments as 3D cell references. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. All arguments as 3D cell references. 4 of 4 arguments used.');
		// Case #11: Area3D. All arguments as 3D single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. All arguments as 3D single-cell ranges. 4 of 4 arguments used.');
		// Case #12: Table. All arguments as table structured references. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9989034106125647, 'Test: Positive case: Table. All arguments as table structured references. 4 of 4 arguments used.');
		// Case #13: Date. x as date (serial number), other arguments as numbers. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(DATE(2025,1,1),2,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(DATE(2025,1,1),2,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9999998117044044, 'Test: Positive case: Date. x as date (serial number), other arguments as numbers. 4 of 4 arguments used.');
		// Case #14: Time. x as time adjusted to ?1, other arguments as numbers. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(TIME(12,0,0)+1,2,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(TIME(12,0,0)+1,2,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6464466094067263, 'Test: Positive case: Time. x as time adjusted to ?1, other arguments as numbers. 4 of 4 arguments used.');
		// Case #16: Number,String. cumulative as string "FALSE" coerced to boolean. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,2,3,"FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,2,3,"FALSE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.278854801, 'Test: Positive case: Number,String. cumulative as string "FALSE" coerced to boolean. 4 of 4 arguments used.');
		// Case #17: Number. Small positive x, minimum degrees of freedom. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(0.0001,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(0.0001,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.006365985529817042, 'Test: Positive case: Number. Small positive x, minimum degrees of freedom. 4 of 4 arguments used.');
		// Case #18: Array. Arrays with multiple valid elements. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST({1,2},{2,3},{3,4},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST({1,2},{2,3},{3,4},{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.53524199845511, 'Test: Positive case: Array. Arrays with multiple valid elements. 4 of 4 arguments used.');
		// Case #19: Number,Formula. Degrees of freedom as rounded formulas. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,ROUND(2.7,0),ROUND(3.2,0),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,ROUND(2.7,0),ROUND(3.2,0),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Number,Formula. Degrees of freedom as rounded formulas. 4 of 4 arguments used.');
		// Case #20: Number,Empty. cumulative omitted, defaults to TRUE. 3 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,2,3,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,2,3,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2788548009269341, 'Test: Positive case: Number,Empty. cumulative omitted, defaults to TRUE. 3 of 4 arguments used.');
		// Case #21: Number,String. cumulative as string "1" coerced to TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,2,3,"1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,2,3,"1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number,String. cumulative as string "1" coerced to TRUE. 4 of 4 arguments used.');
		// Case #22: Formula. All arguments as formulas returning valid values. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(ABS(-1),CEILING(1.5,1),FLOOR(3.8,1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(ABS(-1),CEILING(1.5,1),FLOOR(3.8,1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.53524199845511, 'Test: Positive case: Formula. All arguments as formulas returning valid values. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(-1,2,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(-1,2,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative x returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number. deg_freedom1 < 1 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,0,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,0,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom1 < 1 returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number. deg_freedom2 < 1 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,2,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom2 < 1 returns #NUM!. 4 of 4 arguments used.');
		// Case #4: String. Non-numeric x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST("abc",2,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST("abc",2,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric x returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: Error. x as error propagates #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(NA(),2,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(NA(),2,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. x as error propagates #N/A. 4 of 4 arguments used.');
		// Case #6: Empty. x empty returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(,2,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(,2,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. x empty returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: Number,Empty. deg_freedom1 empty returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Empty. deg_freedom1 empty returns #VALUE!. 4 of 4 arguments used.');
		// Case #8: Number,Empty. deg_freedom2 empty returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,2,,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,2,,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Empty. deg_freedom2 empty returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Number,String. Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,2,3,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,2,3,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.');
		// Case #10: Reference link. x as reference to text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(A104,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(A104,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9999999999497187, 'Test: Negative case: Reference link. x as reference to text returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Area. x as multi-cell range returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(A104:A105,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(A104:A105,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area. x as multi-cell range returns #NUM!. 4 of 4 arguments used.');
		// Case #12: Array. x as array with boolean returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST({FALSE},2,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST({FALSE},2,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. x as array with boolean returns #NUM!. 4 of 4 arguments used.');
		// Case #13: Name. x as named range with area returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(TestNameArea2,TestNameArea2,TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(TestNameArea2,TestNameArea2,TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. x as named range with area returns #VALUE!. 4 of 4 arguments used.');
		// Case #14: Name3D. x as 3D named range with area returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. x as 3D named range with area returns #VALUE!. 4 of 4 arguments used.');
		// Case #15: Ref3D. x as 3D reference to text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. x as 3D reference to text returns #VALUE!. 4 of 4 arguments used.');
		// Case #16: Area3D. x as 3D multi-cell range returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(Sheet2!A5:A6,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(Sheet2!A5:A6,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. x as 3D multi-cell range returns #NUM!. 4 of 4 arguments used.');
		// Case #17: Table. x as table column with text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column6])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column6]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. x as table column with text returns #VALUE!. 4 of 4 arguments used.');
		// Case #18: Number. deg_freedom1 ? 10^10 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,1E10,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,1E10,3,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.391625176, 'Test: Negative case: Number. deg_freedom1 ? 10^10 returns #NUM!. 4 of 4 arguments used.');
		// Case #19: Number. deg_freedom2 ? 10^10 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,2,1E10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,2,1E10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.632120559, 'Test: Negative case: Number. deg_freedom2 ? 10^10 returns #NUM!. 4 of 4 arguments used.');
		// Case #20: Formula. x as formula returning #NUM! propagates error. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(SQRT(-1),2,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(SQRT(-1),2,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. x as formula returning #NUM! propagates error. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid x and degrees of freedom. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(0,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(0,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid x and degrees of freedom. 4 of 4 arguments used.');
		// Case #2: Number. Maximum valid x, minimum degrees of freedom. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1E307,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1E307,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid x, minimum degrees of freedom. 4 of 4 arguments used.');
		// Case #3: Number. Large valid degrees of freedom. 4 of 4 arguments used.
		oParser = new parserFormula('F.DIST(1,999999999,999999999,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST(1,999999999,999999999,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Bounded case: Number. Large valid degrees of freedom. 4 of 4 arguments used.');

		// Need to fix: string handle, ms result diff
		// Case #2: String. String inputs convertible to valid numbers and boolean TRUE. 4 of 4 arguments used.
		// Case #16: Number,String. cumulative as string "FALSE" coerced to boolean. 4 of 4 arguments used.
		// Case #21: Number,String. cumulative as string "1" coerced to TRUE. 4 of 4 arguments used.
		// Case #11: Area. x as multi-cell range returns #NUM!. 4 of 4 arguments used.
		// Case #15: Ref3D. x as 3D reference to text returns #VALUE!. 4 of 4 arguments used.
		// Case #18: Number. deg_freedom1 ? 10^10 returns #NUM!. 4 of 4 arguments used.
		// Case #19: Number. deg_freedom2 ? 10^10 returns #NUM!. 4 of 4 arguments used.


		testArrayFormula2(assert, "F.DIST", 4, 4);
	});

	QUnit.test("Test: \"F.DIST.RT\"", function (assert) {
		ws.getRange2("A2").setValue("15.2069");
		ws.getRange2("A3").setValue("6");
		ws.getRange2("A4").setValue("4");

		oParser = new parserFormula("F.DIST.RT(A2,A3,A4)", "A1", ws);
		assert.ok(oParser.parse(), "F.DIST.RT(A2,A3,A4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.01, "F.DIST.RT(A2,A3,A4)");

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("5"); // Num (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8701603741696002, 'Test: Positive case: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0.3,"5","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0.3,"5","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9019579816310674, 'Test: Positive case: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.');
		// Case #3: Formula. Nested formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(SQRT(0.25),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(SQRT(0.25),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Formula. Nested formula for probability. 3 of 3 arguments used.');
		// Case #4: Formula. Nested IF formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(IF(TRUE,0.4,0.6),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(IF(TRUE,0.4,0.6),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8381652584780426, 'Test: Positive case: Formula. Nested IF formula for probability. 3 of 3 arguments used.');
		// Case #5: Reference link. Reference link to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Reference link. Reference link to valid probability. 3 of 3 arguments used.');
		// Case #6: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0.5,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0.5,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8701603741696002, 'Test: Positive case: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.');
		// Case #7: Area. Single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(A100:A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(A100:A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Area. Single-cell range for probability. 3 of 3 arguments used.');
		// Case #8: Array. Array with single valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT({0.5},5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT({0.5},5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Array. Array with single valid probability. 3 of 3 arguments used.');
		// Case #9: Name. Named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(TestName,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(TestName,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid probability. 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(TestName3D,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(TestName3D,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid probability. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(Sheet2!A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(Sheet2!A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46511942653779986, 'Test: Positive case: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.');
		// Case #12: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(Sheet2!A1:A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(Sheet2!A1:A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46511942653779986, 'Test: Positive case: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.');
		// Case #13: Table. Table structured reference with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(Table1[Column1],5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(Table1[Column1],5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.014868800408112979, 'Test: Positive case: Table. Table structured reference with valid probability. 3 of 3 arguments used.');
		// Case #14: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(DATE(2025,1,1)/1000000,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(DATE(2025,1,1)/1000000,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9983624375356968, 'Test: Positive case: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.');
		// Case #15: Time. Time as valid probability (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(TIME(12,0,0),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(TIME(12,0,0),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Time. Time as valid probability (0.5). 3 of 3 arguments used.');
		// Case #16: Formula. FINV inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(F.DIST.RT(0.5,5,10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(F.DIST.RT(0.5,5,10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7700248806501016, 'Test: Positive case: Formula. FINV inside SUM formula. 3 of 3 arguments used.');
		// Case #17: Number. High valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0.999,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0.999,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47621518230180626, 'Test: Positive case: Number. High valid probability. 3 of 3 arguments used.');
		// Case #18: String. Numeric string converted to probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT("0.1",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT("0.1",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9996589026410869, 'Test: Positive case: String. Numeric string converted to probability. 3 of 3 arguments used.');
		// Case #19: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(ABS(-0.5),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(ABS(-0.5),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.');
		// Case #20: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(A100,A101,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(A100,A101,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8551541939744957, 'Test: Positive case: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.');
		// Case #21: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT({0.5},5,{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT({0.5},5,{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7700248806501017, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(1,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(1,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47550046843289157, 'Test: Negative case: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Negative probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(-0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(-0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0.5,0,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0.5,0,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #5: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0.5,10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0.5,10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #6: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT("abc",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT("abc",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(NA(),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(NA(),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(A100:A101,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(A100:A101,10,20) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.870160374, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(A103,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(A103,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: String. Empty string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT("",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT("",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(TRUE,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(TRUE,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47550046843289157, 'Test: Negative case: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(Sheet2!A2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(Sheet2!A2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08978271484374996, 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(TestNameArea2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(TestNameArea2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6306835578863199, 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(Table1[Column2],10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(Table1[Column2],10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.00000859411961792848, 'Test: Negative case: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(SQRT(-1),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(SQRT(-1),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #16: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0.5,-1,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0.5,-1,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0.5,10,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0.5,10,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT({0.5,1},10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT({0.5,1},10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8701603741696002, 'Test: Negative case: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(TestNameArea3D2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(TestNameArea3D2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6306835578863199, 'Test: Negative case: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(Sheet2!A2:A3,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(Sheet2!A2:A3,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(1E-307,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(1E-307,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.DIST.RT(0.999999999999999,1000000,1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.DIST.RT(0.999999999999999,1000000,1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Bounded case: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.');

		// Need to fix:
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.

		testArrayFormula2(assert, "F.DIST.RT", 3, 3);
	});

	QUnit.test("Test: \"FINV\"", function (assert) {
		ws.getRange2("A2").setValue("0.01");
		ws.getRange2("A3").setValue("6");
		ws.getRange2("A4").setValue("4");

		oParser = new parserFormula("FINV(A2,A3,A4)", "A1", ws);
		assert.ok(oParser.parse(), "FINV(A2,A3,A4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 15.206865, "FINV(A2,A3,A4)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A104").setValue("");
		// For area
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("0.123"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9662638885929166, 'Test: Positive case: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0.3,"5","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0.3,"5","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4113804485788377, 'Test: Positive case: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.');
		// Case #3: Formula. Nested formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(SQRT(0.25),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(SQRT(0.25),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Formula. Nested formula for probability. 3 of 3 arguments used.');
		// Case #4: Formula. Nested IF formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(IF(TRUE,0.4,0.6),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(IF(TRUE,0.4,0.6),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1411892534544323, 'Test: Positive case: Formula. Nested IF formula for probability. 3 of 3 arguments used.');
		// Case #5: Reference link. Reference link to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Reference link. Reference link to valid probability. 3 of 3 arguments used.');
		// Case #6: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0.5,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0.5,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9662638885929166, 'Test: Positive case: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.');
		// Case #7: Area. Single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(A100:A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(A100:A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Area. Single-cell range for probability. 3 of 3 arguments used.');
		// Case #8: Array. Array with single valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV({0.5},5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV({0.5},5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Array. Array with single valid probability. 3 of 3 arguments used.');
		// Case #9: Name. Named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(TestName,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(TestName,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid probability. 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(TestName3D,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(TestName3D,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid probability. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(Sheet2!A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(Sheet2!A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.');
		// Case #12: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(Sheet2!A1:A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(Sheet2!A1:A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.');
		// Case #13: Table. Table structured reference with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(Table1[Column1],5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(Table1[Column1],5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2990249691101305, 'Test: Positive case: Table. Table structured reference with valid probability. 3 of 3 arguments used.');
		// Case #14: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(DATE(2025,1,1)/1000000,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(DATE(2025,1,1)/1000000,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.4386680402921264, 'Test: Positive case: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.');
		// Case #15: Time. Time as valid probability (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('FINV(TIME(12,0,0),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(TIME(12,0,0),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Time. Time as valid probability (0.5). 3 of 3 arguments used.');
		// Case #16: Formula. FINV inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(FINV(0.5,5,10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FINV(0.5,5,10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9319331608510484, 'Test: Positive case: Formula. FINV inside SUM formula. 3 of 3 arguments used.');
		// Case #17: Number. High valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0.999,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0.999,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12814356913491992, 'Test: Positive case: Number. High valid probability. 3 of 3 arguments used.');
		// Case #18: String. Numeric string converted to probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV("0.1",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV("0.1",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9367382987079773, 'Test: Positive case: String. Numeric string converted to probability. 3 of 3 arguments used.');
		// Case #19: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(ABS(-0.5),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(ABS(-0.5),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.');
		// Case #20: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(A100,A101,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(A100,A101,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.');
		// Case #21: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('FINV({0.5},5,{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV({0.5},5,{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(1,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(1,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Negative probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(-0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(-0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0.5,0,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0.5,0,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #5: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0.5,10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0.5,10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #6: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV("abc",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV("abc",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(NA(),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(NA(),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(A100:A101,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(A100:A101,10,20) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.966263889, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(A103,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(A103,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: String. Empty string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV("",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV("",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(TRUE,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(TRUE,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(Sheet2!A2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(Sheet2!A2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(TestNameArea2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(TestNameArea2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5944412149020063, 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(Table1[Column2],10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(Table1[Column2],10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(SQRT(-1),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(SQRT(-1),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #16: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0.5,-1,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0.5,-1,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0.5,10,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0.5,10,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV({0.5,1},10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV({0.5,1},10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9662638885929166, 'Test: Negative case: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(TestNameArea3D2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(TestNameArea3D2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5944412149020063, 'Test: Negative case: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(Sheet2!A2:A3,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(Sheet2!A2:A3,10,20) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(1E-307,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(1E-307,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3.6961e+150, 'Test: Bounded case: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('FINV(0.999999999999999,1000000,1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FINV(0.999999999999999,1000000,1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9842460382391107, 'Test: Bounded case: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.');

		// Need to fix: error type fix, boundary case diff
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		// Case #20: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.
		// Case #1: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.


		testArrayFormula2(assert, "FINV", 3, 3);
	});

	QUnit.test("Test: \"F.INV\"", function (assert) {
		ws.getRange2("A2").setValue("0.01");
		ws.getRange2("A3").setValue("6");
		ws.getRange2("A4").setValue("4");

		oParser = new parserFormula("F.INV(A2,A3,A4)", "A1", ws);
		assert.ok(oParser.parse(), "F.INV(A2,A3,A4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.10930991, "F.INV(A2,A3,A4)");

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("5"); // Num (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9662638885929166, 'Test: Positive case: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0.3,"5","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0.3,"5","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6026031108360351, 'Test: Positive case: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.');
		// Case #3: Formula. Nested formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(SQRT(0.25),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(SQRT(0.25),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Formula. Nested formula for probability. 3 of 3 arguments used.');
		// Case #4: Formula. Nested IF formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(IF(TRUE,0.4,0.6),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(IF(TRUE,0.4,0.6),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7573473432338844, 'Test: Positive case: Formula. Nested IF formula for probability. 3 of 3 arguments used.');
		// Case #5: Reference link. Reference link to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Reference link. Reference link to valid probability. 3 of 3 arguments used.');
		// Case #6: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0.5,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0.5,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9662638885929166, 'Test: Positive case: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.');
		// Case #7: Area. Single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(A100:A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(A100:A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Area. Single-cell range for probability. 3 of 3 arguments used.');
		// Case #8: Array. Array with single valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV({0.5},5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV({0.5},5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Array. Array with single valid probability. 3 of 3 arguments used.');
		// Case #9: Name. Named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(TestName,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(TestName,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid probability. 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(TestName3D,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(TestName3D,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid probability. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(Sheet2!A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(Sheet2!A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.6328072917139297e+65, 'Test: Positive case: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.');
		// Case #12: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(Sheet2!A1:A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(Sheet2!A1:A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.6328072917139297e+65, 'Test: Positive case: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.');
		// Case #13: Table. Table structured reference with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(Table1[Column1],5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(Table1[Column1],5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with valid probability. 3 of 3 arguments used.');
		// Case #14: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(DATE(2025,1,1)/1000000,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(DATE(2025,1,1)/1000000,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.20186570039746887, 'Test: Positive case: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.');
		// Case #15: Time. Time as valid probability (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(TIME(12,0,0),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(TIME(12,0,0),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Time. Time as valid probability (0.5). 3 of 3 arguments used.');
		// Case #16: Formula. FINV inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(F.INV(0.5,5,10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(F.INV(0.5,5,10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9319331608510484, 'Test: Positive case: Formula. FINV inside SUM formula. 3 of 3 arguments used.');
		// Case #17: Number. High valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0.999,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0.999,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.075246211209698, 'Test: Positive case: Number. High valid probability. 3 of 3 arguments used.');
		// Case #18: String. Numeric string converted to probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV("0.1",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV("0.1",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4543918046586965, 'Test: Positive case: String. Numeric string converted to probability. 3 of 3 arguments used.');
		// Case #19: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(ABS(-0.5),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(ABS(-0.5),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.');
		// Case #20: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(A100,A101,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(A100,A101,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.');
		// Case #21: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV({0.5},5,{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV({0.5},5,{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0,10,20) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(1,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(1,10,20) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Negative probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(-0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(-0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0.5,0,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0.5,0,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #5: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0.5,10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0.5,10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #6: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV("abc",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV("abc",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(NA(),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(NA(),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(A100:A101,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(A100:A101,10,20) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.966263889, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(A103,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(A103,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: String. Empty string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV("",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV("",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(TRUE,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(TRUE,10,20) is parsed.');
		// ?assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(Sheet2!A2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(Sheet2!A2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(TestNameArea2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(TestNameArea2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.531347849027609, 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(Table1[Column2],10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(Table1[Column2],10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(SQRT(-1),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(SQRT(-1),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #16: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0.5,-1,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0.5,-1,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0.5,10,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0.5,10,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV({0.5,1},10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV({0.5,1},10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9662638885929166, 'Test: Negative case: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(TestNameArea3D2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(TestNameArea3D2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.531347849027609, 'Test: Negative case: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(Sheet2!A2:A3,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(Sheet2!A2:A3,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(1E-307,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(1E-307,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.7056e-151, 'Test: Bounded case: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV(0.999999999999999,1000000,1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV(0.999999999999999,1000000,1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.016009781345958, 'Test: Bounded case: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.');

		// Need to fix: ms result diff
		// Case #1: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.
		// Case #2: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		// Case #11: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.
		// Case #1: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.


		testArrayFormula2(assert, "F.INV", 3, 3);
	});

	QUnit.test("Test: \"F.INV.RT\"", function (assert) {
		ws.getRange2("A2").setValue("0.01");
		ws.getRange2("A3").setValue("6");
		ws.getRange2("A4").setValue("4");

		oParser = new parserFormula("F.INV.RT(A2,A3,A4)", "A1", ws);
		assert.ok(oParser.parse(), "F.INV.RT(A2,A3,A4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 15.20686, "F.INV.RT(A2,A3,A4)");

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("5"); // Num (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9662638885929166, 'Test: Positive case: Number. Basic valid input: probability between 0 and 1, positive integer degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0.3,"5","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0.3,"5","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4113804485788377, 'Test: Positive case: Number,String. String arguments convertible to valid numbers. 3 of 3 arguments used.');
		// Case #3: Formula. Nested formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(SQRT(0.25),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(SQRT(0.25),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Formula. Nested formula for probability. 3 of 3 arguments used.');
		// Case #4: Formula. Nested IF formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(IF(TRUE,0.4,0.6),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(IF(TRUE,0.4,0.6),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1411892534544323, 'Test: Positive case: Formula. Nested IF formula for probability. 3 of 3 arguments used.');
		// Case #5: Reference link. Reference link to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Reference link. Reference link to valid probability. 3 of 3 arguments used.');
		// Case #6: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0.5,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0.5,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9662638885929166, 'Test: Positive case: Reference link. Reference links for degrees of freedom. 3 of 3 arguments used.');
		// Case #7: Area. Single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(A100:A100,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(A100:A100,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Area. Single-cell range for probability. 3 of 3 arguments used.');
		// Case #8: Array. Array with single valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT({0.5},5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT({0.5},5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Array. Array with single valid probability. 3 of 3 arguments used.');
		// Case #9: Name. Named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(TestName,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(TestName,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid probability. 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named range with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(TestName3D,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(TestName3D,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid probability. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(Sheet2!A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(Sheet2!A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to valid probability. 3 of 3 arguments used.');
		// Case #12: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(Sheet2!A1:A1,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(Sheet2!A1:A1,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range for probability. 3 of 3 arguments used.');
		// Case #13: Table. Table structured reference with valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(Table1[Column1],5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(Table1[Column1],5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with valid probability. 3 of 3 arguments used.');
		// Case #14: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(DATE(2025,1,1)/1000000,5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(DATE(2025,1,1)/1000000,5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.4386680402921264, 'Test: Positive case: Date. Date as serial number adjusted to valid probability. 3 of 3 arguments used.');
		// Case #15: Time. Time as valid probability (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(TIME(12,0,0),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(TIME(12,0,0),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Time. Time as valid probability (0.5). 3 of 3 arguments used.');
		// Case #16: Formula. FINV inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(F.INV.RT(0.5,5,10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(F.INV.RT(0.5,5,10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9319331608510484, 'Test: Positive case: Formula. FINV inside SUM formula. 3 of 3 arguments used.');
		// Case #17: Number. High valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0.999,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0.999,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12814356913491992, 'Test: Positive case: Number. High valid probability. 3 of 3 arguments used.');
		// Case #18: String. Numeric string converted to probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT("0.1",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT("0.1",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9367382987079773, 'Test: Positive case: String. Numeric string converted to probability. 3 of 3 arguments used.');
		// Case #19: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(ABS(-0.5),5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(ABS(-0.5),5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Formula. Nested formula resolving to valid probability. 3 of 3 arguments used.');
		// Case #20: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(A100,A101,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(A100,A101,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Reference link. Multiple reference links for probability and deg_freedom1. 3 of 3 arguments used.');
		// Case #21: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT({0.5},5,{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT({0.5},5,{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9319331608510483, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(1,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(1,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Negative probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(-0.5,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(-0.5,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0.5,0,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0.5,0,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom1 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #5: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0.5,10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0.5,10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. deg_freedom2 = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #6: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT("abc",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT("abc",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(NA(),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(NA(),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(A100:A101,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(A100:A101,10,20) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.966263889, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(A103,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(A103,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: String. Empty string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT("",10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT("",10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(TRUE,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(TRUE,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean TRUE returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(Sheet2!A2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(Sheet2!A2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(TestNameArea2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(TestNameArea2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5944412149020063, 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(Table1[Column2],10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(Table1[Column2],10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(SQRT(-1),10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(SQRT(-1),10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #16: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0.5,-1,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0.5,-1,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom1 returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0.5,10,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0.5,10,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative deg_freedom2 returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT({0.5,1},10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT({0.5,1},10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9662638885929166, 'Test: Negative case: Array. Multi-element array returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(TestNameArea3D2,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(TestNameArea3D2,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5944412149020063, 'Test: Negative case: Name3D. 3D named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(Sheet2!A2:A3,10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(Sheet2!A2:A3,10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(1E-307,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(1E-307,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3.6961e+150, 'Test: Bounded case: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.
		oParser = new parserFormula('F.INV.RT(0.999999999999999,1000000,1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.INV.RT(0.999999999999999,1000000,1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9842460382391107, 'Test: Bounded case: Number. Maximum valid probability and large degrees of freedom. 3 of 3 arguments used.');

		// Need to fix: ms result diff
		// Case #8: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		// Case #1: Number. Minimum valid probability and degrees of freedom. 3 of 3 arguments used.

	});

	QUnit.test("Test: \"FISHER\"", function (assert) {

		function fisher(x) {
			return toFixed(0.5 * Math.ln((1 + x) / (1 - x)));
		}

		oParser = new parserFormula("FISHER(-0.43)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), fisher(-.43));

		oParser = new parserFormula("FISHER(0.578)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), fisher(0.578));

		oParser = new parserFormula("FISHER(1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("FISHER(-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("0.123"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: number between -1 and 1. 1 argument used.
		oParser = new parserFormula('FISHER(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5493061443340548, 'Test: Positive case: Number. Basic valid input: number between -1 and 1. 1 argument used.');
		// Case #2: Number. Negative number between -1 and 1. 1 argument used.
		oParser = new parserFormula('FISHER(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5493061443340549, 'Test: Positive case: Number. Negative number between -1 and 1. 1 argument used.');
		// Case #3: String. String convertible to valid number. 1 argument used.
		oParser = new parserFormula('FISHER("0.3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER("0.3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3095196042031118, 'Test: Positive case: String. String convertible to valid number. 1 argument used.');
		// Case #4: Formula. Nested formula resolving to valid number. 1 argument used.
		oParser = new parserFormula('FISHER(SQRT(0.25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(SQRT(0.25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5493061443340548, 'Test: Positive case: Formula. Nested formula resolving to valid number. 1 argument used.');
		// Case #5: Formula. Nested IF formula returning valid number. 1 argument used.
		oParser = new parserFormula('FISHER(IF(TRUE,0.4,-0.4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(IF(TRUE,0.4,-0.4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.42364893019360184, 'Test: Positive case: Formula. Nested IF formula returning valid number. 1 argument used.');
		// Case #6: Reference link. Reference link to valid number. 1 argument used.
		oParser = new parserFormula('FISHER(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10033534773107562, 'Test: Positive case: Reference link. Reference link to valid number. 1 argument used.');
		// Case #7: Area. Single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('FISHER(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10033534773107562, 'Test: Positive case: Area. Single-cell range with valid number. 1 argument used.');
		// Case #8: Array. Array with single valid number. 1 argument used.
		oParser = new parserFormula('FISHER({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.5493061443340548, 'Test: Positive case: Array. Array with single valid number. 1 argument used.');
		// Case #9: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('FISHER(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5493061443340549, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #10: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('FISHER(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5493061443340549, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #11: Ref3D. 3D reference to valid number. 1 argument used.
		oParser = new parserFormula('FISHER(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5493061443340548, 'Test: Positive case: Ref3D. 3D reference to valid number. 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('FISHER(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5493061443340548, 'Test: Positive case: Area3D. 3D single-cell range with valid number. 1 argument used.');
		// Case #13: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('FISHER(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12362598118313008, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #14: Date. Date as serial number adjusted to valid number. 1 argument used.
		oParser = new parserFormula('FISHER(DATE(2025,1,1)/1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(DATE(2025,1,1)/1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.045689766771436414, 'Test: Positive case: Date. Date as serial number adjusted to valid number. 1 argument used.');
		// Case #15: Time. Time as valid number (0.5). 1 argument used.
		oParser = new parserFormula('FISHER(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5493061443340548, 'Test: Positive case: Time. Time as valid number (0.5). 1 argument used.');
		// Case #16: Formula. FISHER inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(FISHER(0.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FISHER(0.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5493061443340548, 'Test: Positive case: Formula. FISHER inside SUM formula. 1 argument used.');
		// Case #17: Number. High valid number close to 1. 1 argument used.
		oParser = new parserFormula('FISHER(0.999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(0.999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.8002011672502, 'Test: Positive case: Number. High valid number close to 1. 1 argument used.');
		// Case #18: Number. Negative number close to -1. 1 argument used.
		oParser = new parserFormula('FISHER(-0.999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(-0.999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.8002011672502, 'Test: Positive case: Number. Negative number close to -1. 1 argument used.');
		// Case #19: String. Numeric string converted to valid number. 1 argument used.
		oParser = new parserFormula('FISHER("0.1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER("0.1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10033534773107562, 'Test: Positive case: String. Numeric string converted to valid number. 1 argument used.');
		// Case #20: Formula. Nested formula resolving to valid number. 1 argument used.
		oParser = new parserFormula('FISHER(ABS(-0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(ABS(-0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5493061443340548, 'Test: Positive case: Formula. Nested formula resolving to valid number. 1 argument used.');
		// Case #21: Reference link. Reference link to negative valid number. 1 argument used.
		oParser = new parserFormula('FISHER(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2027325540540821, 'Test: Positive case: Reference link. Reference link to negative valid number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Number x = 1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHER(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number x = 1 returns #NUM!. 1 argument used.');
		// Case #2: Number. Number x = -1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHER(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number x = -1 returns #NUM!. 1 argument used.');
		// Case #3: Number. Number x > 1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHER(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number x > 1 returns #NUM!. 1 argument used.');
		// Case #4: Number. Number x < -1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHER(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number x < -1 returns #NUM!. 1 argument used.');
		// Case #5: String. Nonnumeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Nonnumeric string returns #VALUE!. 1 argument used.');
		// Case #6: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('FISHER(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #7: Empty. Empty reference link returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3095196042031118, 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 1 argument used.');
		// Case #8: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #9: Boolean. Boolean TRUE returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean TRUE returns #VALUE!. 1 argument used.');
		// Case #10: Boolean. Boolean FALSE returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!. 1 argument used.');
		// Case #11: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.100335348, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #12: Array. Multi-element array returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER({0.5,0.3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER({0.5,0.3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.5493061443340548, 'Test: Negative case: Array. Multi-element array returns #VALUE!. 1 argument used.');
		// Case #13: Ref3D. 3D reference to nonnumeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to nonnumeric value returns #VALUE!. 1 argument used.');
		// Case #14: Name. Named range with nonnumeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0986122886681098, 'Test: Negative case: Name. Named range with nonnumeric value returns #VALUE!. 1 argument used.');
		// Case #15: Name3D. 3D named range with nonnumeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0986122886681098, 'Test: Negative case: Name3D. 3D named range with nonnumeric value returns #VALUE!. 1 argument used.');
		// Case #16: Table. Table column with nonnumeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with nonnumeric value returns #VALUE!. 1 argument used.');
		// Case #17: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('FISHER(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #18: Date. Date as large number (> 1) returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHER(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date as large number (> 1) returns #NUM!. 1 argument used.');
		// Case #19: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHER(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5493061443340548, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #20: String. String convertible to x = 1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHER("1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER("1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to x = 1 returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid positive number. 1 argument used.
		oParser = new parserFormula('FISHER(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid positive number. 1 argument used.');
		// Case #2: Number. Minimum valid negative number. 1 argument used.
		oParser = new parserFormula('FISHER(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid negative number. 1 argument used.');
		// Case #3: Number. Maximum valid number close to 1. 1 argument used.
		oParser = new parserFormula('FISHER(0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 17.616361586450413, 'Test: Bounded case: Number. Maximum valid number close to 1. 1 argument used.');
		// Case #4: Number. Maximum valid number close to -1. 1 argument used.
		oParser = new parserFormula('FISHER(-0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHER(-0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -17.616361586450413, 'Test: Bounded case: Number. Maximum valid number close to -1. 1 argument used.');

		// Need to fix:
		// Case #11: Area. Multi-cell range returns #VALUE!. 1 argument used.

		testArrayFormula(assert, "FISHER");

	});

	QUnit.test("Test: \"FISHERINV\"", function (assert) {

		function fisherInv(x) {
			return toFixed((Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1));
		}

		oParser = new parserFormula("FISHERINV(-0.43)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), fisherInv(-.43));

		oParser = new parserFormula("FISHERINV(0.578)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), fisherInv(0.578));

		oParser = new parserFormula("FISHERINV(1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), fisherInv(1));

		oParser = new parserFormula("FISHERINV(-1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), fisherInv(-1));

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("0.123"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: number between -1 and 1. 1 argument used.
		oParser = new parserFormula('FISHERINV(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46211715726000974, 'Test: Positive case: Number. Basic valid input: number between -1 and 1. 1 argument used.');
		// Case #2: Number. Negative number between -1 and 1. 1 argument used.
		oParser = new parserFormula('FISHERINV(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.46211715726000974, 'Test: Positive case: Number. Negative number between -1 and 1. 1 argument used.');
		// Case #3: String. String convertible to valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV("0.3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV("0.3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.29131261245159085, 'Test: Positive case: String. String convertible to valid number. 1 argument used.');
		// Case #4: Formula. Nested formula resolving to valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(SQRT(0.25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(SQRT(0.25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46211715726000974, 'Test: Positive case: Formula. Nested formula resolving to valid number. 1 argument used.');
		// Case #5: Formula. Nested IF formula returning valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(IF(TRUE,0.4,-0.4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(IF(TRUE,0.4,-0.4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.37994896225522495, 'Test: Positive case: Formula. Nested IF formula returning valid number. 1 argument used.');
		// Case #6: Reference link. Reference link to valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09966799462495583, 'Test: Positive case: Reference link. Reference link to valid number. 1 argument used.');
		// Case #7: Area. Single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09966799462495583, 'Test: Positive case: Area. Single-cell range with valid number. 1 argument used.');
		// Case #8: Array. Array with single valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.46211715726000974, 'Test: Positive case: Array. Array with single valid number. 1 argument used.');
		// Case #9: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.46211715726000974, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #10: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.46211715726000974, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #11: Ref3D. 3D reference to valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46211715726000974, 'Test: Positive case: Ref3D. 3D reference to valid number. 1 argument used.');
		// Case #12: Area3D. 3D single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46211715726000974, 'Test: Positive case: Area3D. 3D single-cell range with valid number. 1 argument used.');
		// Case #13: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12238344189440872, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #14: Date. Date as serial number adjusted to valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(DATE(2025,1,1)/1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(DATE(2025,1,1)/1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.045626299405289665, 'Test: Positive case: Date. Date as serial number adjusted to valid number. 1 argument used.');
		// Case #15: Time. Time as valid number (0.5). 1 argument used.
		oParser = new parserFormula('FISHERINV(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46211715726000974, 'Test: Positive case: Time. Time as valid number (0.5). 1 argument used.');
		// Case #16: Formula. FISHER inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(FISHERINV(0.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FISHERINV(0.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4621171572600098, 'Test: Positive case: Formula. FISHER inside SUM formula. 1 argument used.');
		// Case #17: Number. High valid number close to 1. 1 argument used.
		oParser = new parserFormula('FISHERINV(0.999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(0.999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.76117386166057, 'Test: Positive case: Number. High valid number close to 1. 1 argument used.');
		// Case #18: Number. Negative number close to -1. 1 argument used.
		oParser = new parserFormula('FISHERINV(-0.999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(-0.999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.76117386166057, 'Test: Positive case: Number. Negative number close to -1. 1 argument used.');
		// Case #19: String. Numeric string converted to valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV("0.1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV("0.1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09966799462495583, 'Test: Positive case: String. Numeric string converted to valid number. 1 argument used.');
		// Case #20: Formula. Nested formula resolving to valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(ABS(-0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(ABS(-0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46211715726000974, 'Test: Positive case: Formula. Nested formula resolving to valid number. 1 argument used.');
		// Case #21: Reference link. Reference link to negative valid number. 1 argument used.
		oParser = new parserFormula('FISHERINV(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.197375320224904, 'Test: Positive case: Reference link. Reference link to negative valid number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Number x = 1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHERINV(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7615941559557649, 'Test: Negative case: Number. Number x = 1 returns #NUM!. 1 argument used.');
		// Case #2: Number. Number x = -1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHERINV(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.7615941559557649, 'Test: Negative case: Number. Number x = -1 returns #NUM!. 1 argument used.');
		// Case #3: Number. Number x > 1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHERINV(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9640275800758169, 'Test: Negative case: Number. Number x > 1 returns #NUM!. 1 argument used.');
		// Case #4: Number. Number x < -1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHERINV(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.9640275800758168, 'Test: Negative case: Number. Number x < -1 returns #NUM!. 1 argument used.');
		// Case #5: String. Nonnumeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Nonnumeric string returns #VALUE!. 1 argument used.');
		// Case #6: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('FISHERINV(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #7: Empty. Empty reference link returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.29131261245159085, 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 1 argument used.');
		// Case #8: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #9: Boolean. Boolean TRUE returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7615941559557649, 'Test: Negative case: Boolean. Boolean TRUE returns #VALUE!. 1 argument used.');
		// Case #10: Boolean. Boolean FALSE returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!. 1 argument used.');
		// Case #11: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.099667995, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #12: Array. Multi-element array returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV({0.5,0.3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV({0.5,0.3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.46211715726000974, 'Test: Negative case: Array. Multi-element array returns #VALUE!. 1 argument used.');
		// Case #13: Ref3D. 3D reference to nonnumeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9051482536448664, 'Test: Negative case: Ref3D. 3D reference to nonnumeric value returns #VALUE!. 1 argument used.');
		// Case #14: Name. Named range with nonnumeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.664036770267849, 'Test: Negative case: Name. Named range with nonnumeric value returns #VALUE!. 1 argument used.');
		// Case #15: Name3D. 3D named range with nonnumeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.664036770267849, 'Test: Negative case: Name3D. 3D named range with nonnumeric value returns #VALUE!. 1 argument used.');
		// Case #16: Table. Table column with nonnumeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with nonnumeric value returns #VALUE!. 1 argument used.');
		// Case #17: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('FISHERINV(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #18: Date. Date as large number (> 1) returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHERINV(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(DATE(2025,1,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Date. Date as large number (> 1) returns #NUM!. 1 argument used.');
		// Case #19: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('FISHERINV(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46211715726000974, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #20: String. String convertible to x = 1 returns #NUM!. 1 argument used.
		oParser = new parserFormula('FISHERINV("1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV("1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7615941559557649, 'Test: Negative case: String. String convertible to x = 1 returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid positive number. 1 argument used.
		oParser = new parserFormula('FISHERINV(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid positive number. 1 argument used.');
		// Case #2: Number. Minimum valid negative number. 1 argument used.
		oParser = new parserFormula('FISHERINV(-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid negative number. 1 argument used.');
		// Case #3: Number. Maximum valid number close to 1. 1 argument used.
		oParser = new parserFormula('FISHERINV(0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7615941559557645, 'Test: Bounded case: Number. Maximum valid number close to 1. 1 argument used.');
		// Case #4: Number. Maximum valid number close to -1. 1 argument used.
		oParser = new parserFormula('FISHERINV(-0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FISHERINV(-0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.7615941559557644, 'Test: Bounded case: Number. Maximum valid number close to -1. 1 argument used.');

		// Need to fix: area handle, num error in on case
		// Case #11: Area. Multi-cell range returns #VALUE!. 1 argument used.
		// Case #18: Date. Date as large number (> 1) returns #NUM!. 1 argument used.

		testArrayFormula(assert, "FISHERINV");

	});

	QUnit.test("Test: \"FORECAST\"", function (assert) {


		function forecast(fx, y, x) {

			let fSumDeltaXDeltaY = 0, fSumSqrDeltaX = 0, _x = 0, _y = 0, xLength = 0;
			for (let i = 0; i < x.length; i++) {
				_x += x[i];
				_y += y[i];
				xLength++;
			}

			_x /= xLength;
			_y /= xLength;

			for (let i = 0; i < x.length; i++) {

				let fValX = x[i];
				let fValY = y[i];

				fSumDeltaXDeltaY += (fValX - _x) * (fValY - _y);
				fSumSqrDeltaX += (fValX - _x) * (fValX - _x);

			}

			return toFixed(_y + fSumDeltaXDeltaY / fSumSqrDeltaX * (fx - _x));

		}

		// add a sheet to check area3D type
		let ws2 = wb.createWorksheet(0, "Sheet2");

		oParser = new parserFormula("FORECAST(30,{6,7,9,15,21},{20,28,31,38,40})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), forecast(30, [6, 7, 9, 15, 21], [20, 28, 31, 38, 40]));

		oParser = new parserFormula("FORECAST(1,{1,2},{1,2})", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST(1,{1,2},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of FORECAST(1,{1,2},{1,2})");

		oParser = new parserFormula("FORECAST(1,{1,2},{1,2,3})", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST(1,{1,2},{1,2,3})");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST(1,{1,2},{1,2,3})");

		oParser = new parserFormula("FORECAST(1,{1,2,3},{1,2})", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST(1,{1,2,3},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST(1,{1,2,3},{1,2})");

		ws.getRange2("A1").setValue("1");
		ws.getRange2("A2").setValue("2");
		ws.getRange2("B1").setValue("3");
		ws.getRange2("B2").setValue("4");

		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		let cellWithFormula = new AscCommonExcel.CCellWithFormula(ws, 0, 2);

		oParser = new parserFormula("FORECAST(1,A1:A2,B1:B2)", cellWithFormula, ws);
		assert.ok(oParser.parse(), "FORECAST(1,A1:A2,B1:B2)");
		assert.strictEqual(oParser.calculate().getValue(), -1, "Result of FORECAST(1,A1:A2,B1:B2)");

		// for bug 65245
		oParser = new parserFormula("FORECAST(1,Sheet2!A1:A2,Sheet2!B1:B2)", cellWithFormula, ws);
		assert.ok(oParser.parse(), "FORECAST(1,Sheet2!A1:A2,Sheet2!B1:B2). Bug 65245 test");
		assert.strictEqual(oParser.calculate().getValue(), -1, "Result of FORECAST(1,Sheet2!A1:A2,Sheet2!B1:B2)");

		// errors
		oParser = new parserFormula("FORECAST(#N/A,A1:A2,B1:B2)", cellWithFormula, ws);
		assert.ok(oParser.parse(), "FORECAST(#N/A,A1:A2,B1:B2)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST(#N/A,A1:A2,B1:B2)");

		oParser = new parserFormula("FORECAST(1,#NUM!,#N/A)", cellWithFormula, ws);
		assert.ok(oParser.parse(), "FORECAST(1,#NUM!,#N/A)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of FORECAST(1,#NUM!,#N/A)");

		oParser = new parserFormula("FORECAST(1,A1:A2,#NUM!)", cellWithFormula, ws);
		assert.ok(oParser.parse(), "FORECAST(1,A1:A2,#NUM!)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of FORECAST(1,A1:A2,#NUM!)");

		// strings
		oParser = new parserFormula('FORECAST("1",A1:A2,B1:B2)', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'FORECAST("1",A1:A2,B1:B2)');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Result of FORECAST("1",A1:A2,B1:B2)');

		oParser = new parserFormula('FORECAST("1s",A1:A2,B1:B2)', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'FORECAST("1s",A1:A2,B1:B2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of FORECAST("1s",A1:A2,B1:B2)');

		oParser = new parserFormula('FORECAST(1,{1,"2"},{1,2})', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'FORECAST(1,{1,"2"},{1,2})');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Result of FORECAST(1,{1,"2"},{1,2})');

		oParser = new parserFormula('FORECAST(1,{1,2},{"1",2})', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'FORECAST(1,{1,2},{"1",2})');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Result of FORECAST(1,{1,2},{"1",2})');

		// bools
		oParser = new parserFormula('FORECAST(FALSE,A1:A2,B1:B2)', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'FORECAST(FALSE,A1:A2,B1:B2)');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Result of FORECAST(FALSE,A1:A2,B1:B2)');

		oParser = new parserFormula('FORECAST(TRUE,A1:A2,B1:B2)', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'FORECAST(TRUE,A1:A2,B1:B2)');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Result of FORECAST(TRUE,A1:A2,B1:B2)');

		oParser = new parserFormula('FORECAST(TRUE,{TRUE,2},{TRUE,2})', cellWithFormula, ws);
		assert.ok(oParser.parse(), 'FORECAST(TRUE,{TRUE,2},{TRUE,2})');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Result of FORECAST(TRUE,{TRUE,2},{TRUE,2})');

		// delete the previously created sheet
		wb.removeWorksheet(0);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A104").setValue("1");
		// For area
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("30");
		ws.getRange2("A105").setValue("5");
		ws.getRange2("A106").setValue("10");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("5"); // Num (Column6)

		// 3D links. Use A1:Z10
		ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: number for x, arrays with 3 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Basic valid input: number for x, arrays with 3 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #2: Number,Area. Area with 3 cells for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,A100:A102,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13.93387314439946, 'Test: Positive case: Number,Area. Area with 3 cells for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #3: Formula,Number. x as formula resolving to number. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(SQRT(25),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(SQRT(25),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Formula,Number. x as formula resolving to number. 3 of 3 arguments used.');
		// Case #4: String. String inputs convertible to number and arrays. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST("5","{10,20,30}","{1,2,3}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST("5","{10,20,30}","{1,2,3}") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String inputs convertible to number and arrays. 3 of 3 arguments used.');
		// Case #5: Date,Number. x as Date (serial number). 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(DATE(2025,1,1),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(DATE(2025,1,1),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 456580, 'Test: Positive case: Date,Number. x as Date (serial number). 3 of 3 arguments used.');
		// Case #6: Time,Number. x as Time adjusted to valid number. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(TIME(12,0,0)+5,{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(TIME(12,0,0)+5,{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 55, 'Test: Positive case: Time,Number. x as Time adjusted to valid number. 3 of 3 arguments used.');
		// Case #7: Reference link. Reference link for x, areas with 3 cells for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(A100,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(A100,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 19.262295081967213, 'Test: Positive case: Reference link. Reference link for x, areas with 3 cells for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #8: Array. Array with single element for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST({5},{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST({5},{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Array. Array with single element for x. 3 of 3 arguments used.');
		// Case #9: Name. Named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(TestName,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(TestName,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.090163934426233, 'Test: Positive case: Name. Named range for x. 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(TestName3D,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(TestName3D,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.090163934426233, 'Test: Positive case: Name3D. 3D named range for x. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(Sheet2!A1,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(Sheet2!A1,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.409836065573773, 'Test: Positive case: Ref3D. 3D reference for x. 3 of 3 arguments used.');
		// Case #12: Area3D. 3D range with 3 cells for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(Sheet2!A1:A3,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(Sheet2!A1:A3,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.409836065573773, 'Test: Positive case: Area3D. 3D range with 3 cells for x. 3 of 3 arguments used.');
		// Case #13: Table. Table structured reference with 3 elements. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Table. Table structured reference with 3 elements. 3 of 3 arguments used.');
		// Case #14: Number,Formula. known_y\'s as formula resolving to array. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,SUM({10,20,30}),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,SUM({10,20,30}),{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Formula. known_y\'s as formula resolving to array. 3 of 3 arguments used.');
		// Case #15: Formula. x as nested IF formula. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(IF(TRUE,5,0),A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(IF(TRUE,5,0),A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 19.262295081967213, 'Test: Positive case: Formula. x as nested IF formula. 3 of 3 arguments used.');
		// Case #16: Number. Larger arrays with 4 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,{10,20,30,40},{1,2,3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,{10,20,30,40},{1,2,3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Larger arrays with 4 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #17: String. Float strings convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST("5.5","{10.5,20.5,30.5}","{1.5,2.5,3.5}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST("5.5","{10.5,20.5,30.5}","{1.5,2.5,3.5}") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Float strings convertible to numbers. 3 of 3 arguments used.');
		// Case #18: Formula. x as formula with float. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(ROUND(5.5,0),A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(ROUND(5.5,0),A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21.475409836065573, 'Test: Positive case: Formula. x as formula with float. 3 of 3 arguments used.');
		// Case #19: Number. Smaller arrays with 2 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,{10,20},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,{10,20},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Smaller arrays with 2 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #20: Formula. Multiple nested formulas. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(SQRT(25),IF(TRUE,{10,20,30},{0,0,0}),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(SQRT(25),IF(TRUE,{10,20,30},{0,0,0}),{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Formula. Multiple nested formulas. 3 of 3 arguments used.');
		// Case #21: Formula,Number. FORECAST inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(FORECAST(5,{10,20,30},{1,2,3}),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FORECAST(5,{10,20,30},{1,2,3}),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 60, 'Test: Positive case: Formula,Number. FORECAST inside SUM formula. 3 of 3 arguments used.');
		// Case #22: Array. Array with multiple elements for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST({5,6},{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST({5,6},{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Array. Array with multiple elements for x. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. known_y\'s and known_x\'s arrays of different lengths returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,{10,20,30},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,{10,20,30},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. known_y\'s and known_x\'s arrays of different lengths returns #N/A. 3 of 3 arguments used.');
		// Case #2: Empty,Number. x is empty returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(,{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(,{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty,Number. x is empty returns #VALUE!. 3 of 3 arguments used.');
		// Case #3: Number,Empty. known_y\'s is empty returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. known_y\'s is empty returns #N/A. 3 of 3 arguments used.');
		// Case #4: Number,Empty. known_x\'s is empty returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,{10,20,30},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,{10,20,30},) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. known_x\'s is empty returns #N/A. 3 of 3 arguments used.');
		// Case #5: String. x as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST("abc",{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST("abc",{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. x as non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Number,String. known_y\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,"{abc,def,ghi}","{1,2,3}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,"{abc,def,ghi}","{1,2,3}") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number,String. known_y\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Number,String. known_x\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,{10,20,30},"{abc,def,ghi}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,{10,20,30},"{abc,def,ghi}") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,String. known_x\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Error,Number. x as error returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(NA(),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(NA(),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number. x as error returns #N/A. 3 of 3 arguments used.');
		// Case #9: Number,Error. known_y\'s as error returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,NA(),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,NA(),{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. known_y\'s as error returns #N/A. 3 of 3 arguments used.');
		// Case #10: Number,Error. known_x\'s as error returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,{10,20,30},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,{10,20,30},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. known_x\'s as error returns #N/A. 3 of 3 arguments used.');
		// Case #11: Number. Zero variance in known_x\'s returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,{10,20,30},{1,1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,{10,20,30},{1,1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Zero variance in known_x\'s returns #DIV/0!. 3 of 3 arguments used.');
		// Case #12: Number,Area. Mismatched range sizes (3 vs 2 cells) for known_y\'s and known_x\'s returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,A100:A102,A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area. Mismatched range sizes (3 vs 2 cells) for known_y\'s and known_x\'s returns #N/A. 3 of 3 arguments used.');
		// Case #13: Formula,Number. x as formula returning #NUM! returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(SQRT(-1),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(SQRT(-1),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Number. x as formula returning #NUM! returns #NUM!. 3 of 3 arguments used.');
		// Case #14: Ref3D. 3D ref to non-numeric value returns #VALUE!.
		oParser = new parserFormula('FORECAST(Sheet2!A2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(Sheet2!A2,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.622950819672134, 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!.');
		// Case #15: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST(TestNameArea2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(TestNameArea2,A101:A103,A104:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10.40983607, 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #16: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST(TestNameArea3D2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(TestNameArea3D2,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.9672131147541, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #17: Table. Table column with non-numeric data returns #VALUE!.
		oParser = new parserFormula('FORECAST(Table1[Column2],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(Table1[Column2],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with non-numeric data returns #VALUE!.');
		// Case #18: Number,Area. Range with more than 3 cells for known_y\'s returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,A100:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,A100:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area. Range with more than 3 cells for known_y\'s returns #N/A. 3 of 3 arguments used.');
		// Case #19: Boolean,Number. x as boolean (TRUE as 1) returns valid result but may be unexpected. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(TRUE,{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(TRUE,{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Boolean,Number. x as boolean (TRUE as 1) returns valid result but may be unexpected. 3 of 3 arguments used.');
		// Case #20: Time,Number. x as Time (0.5) returns valid result but may be unexpected. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(TIME(12,0,0),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(TIME(12,0,0),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Time,Number. x as Time (0.5) returns valid result but may be unexpected. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid positive values for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(2.2E-308,{1E-307,2E-307,3E-307},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(2.2E-308,{1E-307,2E-307,3E-307},{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid positive values for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid Excel number for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(9.99999999999999E+307,{1E+307,2E+307,3E+307},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(9.99999999999999E+307,{1E+307,2E+307,3E+307},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used.');
		// Case #3: Number. Minimum valid array sizes (2 elements) with smallest valid values. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST(5,{1E-307,2E-307},{1E-307,2E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST(5,{1E-307,2E-307},{1E-307,2E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Minimum valid array sizes (2 elements) with smallest valid values. 3 of 3 arguments used.');

		// Need to fix: diff in some cases results
		// Case #4: String. String inputs convertible to number and arrays. 3 of 3 arguments used.
		// Case #14: Number,Formula. known_y\'s as formula resolving to array. 3 of 3 arguments used.
		// Case #17: String. Float strings convertible to numbers. 3 of 3 arguments used.
		// Case #20: Formula. Multiple nested formulas. 3 of 3 arguments used. - result diff
		// Case #6: Number,String. known_y\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		// Case #7: Number,String. known_x\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		// Case #15: Name. Named range with text returns #VALUE!. - result diff
		// Case #1: Number. Minimum valid positive values for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used. - result diff


	});

	function putDataForForecastEts() {
		ws.getRange2('A4').setValue('39814');
		ws.getRange2('A5').setValue('39845');
		ws.getRange2('A6').setValue('39873');
		ws.getRange2('A7').setValue('39904');
		ws.getRange2('A8').setValue('39934');
		ws.getRange2('A9').setValue('39965');
		ws.getRange2('A10').setValue('39995');
		ws.getRange2('A11').setValue('40026');
		ws.getRange2('A12').setValue('40057');
		ws.getRange2('A13').setValue('40087');
		ws.getRange2('A14').setValue('40118');
		ws.getRange2('A15').setValue('40148');
		ws.getRange2('A16').setValue('40179');
		ws.getRange2('A17').setValue('40210');
		ws.getRange2('A18').setValue('40238');
		ws.getRange2('A19').setValue('40269');
		ws.getRange2('A20').setValue('40299');
		ws.getRange2('A21').setValue('40330');
		ws.getRange2('A22').setValue('40360');
		ws.getRange2('A23').setValue('40391');
		ws.getRange2('A24').setValue('40422');
		ws.getRange2('A25').setValue('40452');
		ws.getRange2('A26').setValue('40483');
		ws.getRange2('A27').setValue('40513');
		ws.getRange2('A28').setValue('40544');
		ws.getRange2('A29').setValue('40575');
		ws.getRange2('A30').setValue('40603');
		ws.getRange2('A31').setValue('40634');
		ws.getRange2('A32').setValue('40664');
		ws.getRange2('A33').setValue('40695');
		ws.getRange2('A34').setValue('40725');
		ws.getRange2('A35').setValue('40756');
		ws.getRange2('A36').setValue('40787');
		ws.getRange2('A37').setValue('40817');
		ws.getRange2('A38').setValue('40848');
		ws.getRange2('A39').setValue('40878');
		ws.getRange2('A40').setValue('40909');
		ws.getRange2('A41').setValue('40940');
		ws.getRange2('A42').setValue('40969');
		ws.getRange2('A43').setValue('41000');
		ws.getRange2('A44').setValue('41030');
		ws.getRange2('A45').setValue('41061');
		ws.getRange2('A46').setValue('41091');
		ws.getRange2('A47').setValue('41122');
		ws.getRange2('A48').setValue('41153');
		ws.getRange2('A49').setValue('41183');
		ws.getRange2('A50').setValue('41214');
		ws.getRange2('A51').setValue('41244');
		ws.getRange2('A52').setValue('41275');
		ws.getRange2('A53').setValue('41306');
		ws.getRange2('A54').setValue('41334');
		ws.getRange2('A55').setValue('41365');
		ws.getRange2('A56').setValue('41395');
		ws.getRange2('A57').setValue('41426');
		ws.getRange2('A58').setValue('41456');
		ws.getRange2('A59').setValue('41487');
		ws.getRange2('A60').setValue('41518');

		ws.getRange2('B4').setValue('2644539');
		ws.getRange2('B5').setValue('2359800');
		ws.getRange2('B6').setValue('2925918');
		ws.getRange2('B7').setValue('3024973');
		ws.getRange2('B8').setValue('3177100');
		ws.getRange2('B9').setValue('3419595');
		ws.getRange2('B10').setValue('3649702');
		ws.getRange2('B11').setValue('3650668');
		ws.getRange2('B12').setValue('3191526');
		ws.getRange2('B13').setValue('3249428');
		ws.getRange2('B14').setValue('2971484');
		ws.getRange2('B15').setValue('3074209');
		ws.getRange2('B16').setValue('2785466');
		ws.getRange2('B17').setValue('2515361');
		ws.getRange2('B18').setValue('3105958');
		ws.getRange2('B19').setValue('3139059');
		ws.getRange2('B20').setValue('3380355');
		ws.getRange2('B21').setValue('3612886');
		ws.getRange2('B22').setValue('3765824');
		ws.getRange2('B23').setValue('3771842');
		ws.getRange2('B24').setValue('3356365');
		ws.getRange2('B25').setValue('3490100');
		ws.getRange2('B26').setValue('3163659');
		ws.getRange2('B27').setValue('3167124');
		ws.getRange2('B28').setValue('2883810');
		ws.getRange2('B29').setValue('2610667');
		ws.getRange2('B30').setValue('3129205');
		ws.getRange2('B31').setValue('3200527');
		ws.getRange2('B32').setValue('3547804');
		ws.getRange2('B33').setValue('3766323');
		ws.getRange2('B34').setValue('3935589');
		ws.getRange2('B35').setValue('3917884');
		ws.getRange2('B36').setValue('3564970');
		ws.getRange2('B37').setValue('3602455');
		ws.getRange2('B38').setValue('3326859');
		ws.getRange2('B39').setValue('3441693');
		ws.getRange2('B40').setValue('3211600');
		ws.getRange2('B41').setValue('2998119');
		ws.getRange2('B42').setValue('3472440');
		ws.getRange2('B43').setValue('3563007');
		ws.getRange2('B44').setValue('3820570');
		ws.getRange2('B45').setValue('4107195');
		ws.getRange2('B46').setValue('4284443');
		ws.getRange2('B47').setValue('4356216');
		ws.getRange2('B48').setValue('3819379');
		ws.getRange2('B49').setValue('3844987');
		ws.getRange2('B50').setValue('3478890');
		ws.getRange2('B51').setValue('3443039');
		ws.getRange2('B52').setValue('3204637');
		ws.getRange2('B53').setValue('2966477');
		ws.getRange2('B54').setValue('3593364');
		ws.getRange2('B55').setValue('3604104');
		ws.getRange2('B56').setValue('3933016');
		ws.getRange2('B57').setValue('4146797');
		ws.getRange2('B58').setValue('4176486');
		ws.getRange2('B59').setValue('4347059');
		ws.getRange2('B60').setValue('3781168');


		ws.getRange2('A61').setValue('41548');
		ws.getRange2('A62').setValue('41579');
		ws.getRange2('A63').setValue('41609');
		ws.getRange2('A64').setValue('41640');
		ws.getRange2('A65').setValue('41671');
		ws.getRange2('A66').setValue('41699');
		ws.getRange2('A67').setValue('41730');
		ws.getRange2('A68').setValue('41760');
		ws.getRange2('A69').setValue('41791');
		ws.getRange2('A70').setValue('41821');
		ws.getRange2('A71').setValue('41852');
		ws.getRange2('A72').setValue('41883');
		ws.getRange2('A73').setValue('41913');
		ws.getRange2('A74').setValue('41944');
		ws.getRange2('A75').setValue('41974');
		ws.getRange2('A76').setValue('42005');
		ws.getRange2('A77').setValue('42036');
		ws.getRange2('A78').setValue('42064');
		ws.getRange2('A79').setValue('42095');
		ws.getRange2('A80').setValue('42125');
		ws.getRange2('A81').setValue('42156');
		ws.getRange2('A82').setValue('42186');
		ws.getRange2('A83').setValue('42217');
		ws.getRange2('A84').setValue('42248');
	}

	QUnit.test("Test: \"FORECAST.ETS\"", function (assert) {
		//результаты данного теста соответсвуют результатам LO, но отличаются от MS!!!

		putDataForForecastEts();

		oParser = new parserFormula("FORECAST.ETS(A61,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3868499.49723621);

		oParser = new parserFormula("FORECAST.ETS(A62,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3560200.99816396);

		oParser = new parserFormula("FORECAST.ETS(A63,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3619491.6524986);

		oParser = new parserFormula("FORECAST.ETS(A64,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3397521.44972895);

		oParser = new parserFormula("FORECAST.ETS(A65,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3152698.4854144);

		oParser = new parserFormula("FORECAST.ETS(A66,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3704079.5812005);

		oParser = new parserFormula("FORECAST.ETS(A67,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3747546.50043675);

		oParser = new parserFormula("FORECAST.ETS(A68,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4042011.75785885);

		oParser = new parserFormula("FORECAST.ETS(A69,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4250095.33429725);

		oParser = new parserFormula("FORECAST.ETS(A70,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4360538.1411926);

		oParser = new parserFormula("FORECAST.ETS(A71,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4463640.2710391);

		oParser = new parserFormula("FORECAST.ETS(A72,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3963675.88150212);

		oParser = new parserFormula("FORECAST.ETS(A73,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4028087.58056954);

		oParser = new parserFormula("FORECAST.ETS(A74,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3719789.0814973);

		oParser = new parserFormula("FORECAST.ETS(A75,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3779079.73583193);

		oParser = new parserFormula("FORECAST.ETS(A76,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3557109.53306228);

		oParser = new parserFormula("FORECAST.ETS(A77,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3312286.56874774);

		oParser = new parserFormula("FORECAST.ETS(A78,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3863667.66453383);

		oParser = new parserFormula("FORECAST.ETS(A79,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 3907134.58377009);

		oParser = new parserFormula("FORECAST.ETS(A80,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4201599.84119218);

		oParser = new parserFormula("FORECAST.ETS(A81,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4409683.41763059);

		oParser = new parserFormula("FORECAST.ETS(A82,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4520126.22452593);

		oParser = new parserFormula("FORECAST.ETS(A83,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4623228.35437243);

		oParser = new parserFormula("FORECAST.ETS(A84,B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 4123263.96483545);

		let sheetName = ws.getName();
		ws.getRange2("A100:A102").setValue("");
		ws.getRange2("B100").setValue("1");
		ws.getRange2("B101").setValue("2");
		ws.getRange2("B102").setValue("3");
		ws.getRange2("C100").setValue("1");
		ws.getRange2("C101").setValue("2");
		ws.getRange2("C102").setValue("3");

		ws.getRange2("D100").setValue("123");
		ws.getRange2("D101").setValue("123s");

		oParser = new parserFormula("FORECAST.ETS(B100:B102,B100:B102,B100:B102)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "FORECAST.ETS(B100:B102,B100:B102,B100:B102)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of FORECAST.ETS(B100:B102,B100:B102,B100:B102)[0,0]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of FORECAST.ETS(B100:B102,B100:B102,B100:B102)[1,0]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 3, "Result of FORECAST.ETS(B100:B102,B100:B102,B100:B102)[2,0]");

		oParser = new parserFormula("FORECAST.ETS("+sheetName+"!B100:B102,B100:B102,B100:B102)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "FORECAST.ETS("+sheetName+"!B100:B102,B100:B102,B100:B102)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of FORECAST.ETS("+sheetName+"!B100:B102,B100:B102,B100:B102)[0,0]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of FORECAST.ETS("+sheetName+"!B100:B102,B100:B102,B100:B102)[1,0]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 3, "Result of FORECAST.ETS("+sheetName+"!B100:B102,B100:B102,B100:B102)[2,0]");

		oParser = new parserFormula("FORECAST.ETS({1,2,3},B100:B102,B100:B102)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "FORECAST.ETS({1,2,3},B100:B102,B100:B102)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of FORECAST.ETS({1,2,3},B100:B102,B100:B102)[0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 2, "Result of FORECAST.ETS({1,2,3},B100:B102,B100:B102)[0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 3, "Result of FORECAST.ETS({1,2,3},B100:B102,B100:B102)[0,2]");

		oParser = new parserFormula("FORECAST.ETS({1;2;3},B100:B102,B100:B102)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "FORECAST.ETS({1;2;3},B100:B102,B100:B102)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result of FORECAST.ETS({1;2;3},B100:B102,B100:B102)[0,0]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result of FORECAST.ETS({1;2;3},B100:B102,B100:B102)[1,0]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 3, "Result of FORECAST.ETS({1;2;3},B100:B102,B100:B102)[2,0]");

		oParser = new parserFormula("FORECAST.ETS(123,{1;2;3},B100:B102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(123,{1;2;3},B100:B102)");
		assert.strictEqual(oParser.calculate().getValue(), 123, "Result of FORECAST.ETS(123,{1;2;3},B100:B102)");

		oParser = new parserFormula("FORECAST.ETS(123,{1;2;3},{1;2;3})", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(123,{1;2;3},{1;2;3})");
		assert.strictEqual(oParser.calculate().getValue(), 123, "Result of FORECAST.ETS(123,{1;2;3},{1;2;3})");

		oParser = new parserFormula("FORECAST.ETS(123,A100:A102,A100:A102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(123,A100:A102,A100:A102) - empty array in 2 and 3 arguments");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST.ETS(123,A100:A102,A100:A102) - empty array in 2 and 3 arguments");

		oParser = new parserFormula("FORECAST.ETS(123,A100:A102,B100:B102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(123,A100:A102,B100:B102) - empty array in 2 argument");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST.ETS(123,A100:A102,B100:B102) - empty array in 2 argument");

		oParser = new parserFormula("FORECAST.ETS(123,B100:B102,A100:A102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(123,B100:B102,A100:A102) - empty array in 3 argument");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of FORECAST.ETS(123,B100:B102,A100:A102) - empty array in 3 argument");		// in the editor returns #N/A

		oParser = new parserFormula("FORECAST.ETS(123,B100:B102,C100:C102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(123,B100:B102,C100:C102)");
		assert.strictEqual(oParser.calculate().getValue(), 123, "Result of FORECAST.ETS(123,B100:B102,C100:C102)");

		// base type checks
		oParser = new parserFormula('FORECAST.ETS("123",B100:B102,C100:C102)', "A1", ws);
		assert.ok(oParser.parse(), 'FORECAST.ETS("123",B100:B102,C100:C102)');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Result of FORECAST.ETS("123",B100:B102,C100:C102)');

		oParser = new parserFormula('FORECAST.ETS(D100,B100:B102,C100:C102)', "A1", ws);
		assert.ok(oParser.parse(), 'FORECAST.ETS(D100,B100:B102,C100:C102)');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Result of FORECAST.ETS(D100,B100:B102,C100:C102)');

		oParser = new parserFormula('FORECAST.ETS("123s",B100:B102,C100:C102)', "A1", ws);
		assert.ok(oParser.parse(), 'FORECAST.ETS("123s",B100:B102,C100:C102)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of FORECAST.ETS("123s",B100:B102,C100:C102)');

		oParser = new parserFormula('FORECAST.ETS(D101,B100:B102,C100:C102)', "A1", ws);
		assert.ok(oParser.parse(), 'FORECAST.ETS(D101,B100:B102,C100:C102)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of FORECAST.ETS(D101,B100:B102,C100:C102)');

		oParser = new parserFormula("FORECAST.ETS(#N/A,B100:B102,C100:C102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(#N/A,B100:B102,C100:C102)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST.ETS(#N/A,B100:B102,C100:C102)");

		oParser = new parserFormula("FORECAST.ETS(123,#N/A,C100:C102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(123,#N/A,C100:C102)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST.ETS(123,#N/A,C100:C102)");

		oParser = new parserFormula("FORECAST.ETS(123,B100:B102,#N/A)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(123,B100:B102,#N/A)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST.ETS(123,B100:B102,#N/A)");

		oParser = new parserFormula("FORECAST.ETS(#N/A,#NUM!,C100:C102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS(#N/A,#NUM!,C100:C102)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST.ETS(#N/A,#NUM!,C100:C102)");

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("Dates");
		ws.getRange2("A101").setValue("43466");
		ws.getRange2("A102").setValue("43497");
		ws.getRange2("A103").setValue("43525");
		ws.getRange2("A104").setValue("43556");
		ws.getRange2("A105").setValue("43586");
		ws.getRange2("A106").setValue("43617");
		ws.getRange2("A107").setValue("43647");
		ws.getRange2("A108").setValue("43678");
		ws.getRange2("A109").setValue("43709");
		ws.getRange2("A110").setValue("43739");
		ws.getRange2("A111").setValue("43770");
		ws.getRange2("A112").setValue("43800");
		ws.getRange2("A113").setValue("43831");
		ws.getRange2("A114").setValue("43862");

		ws.getRange2("B100").setValue("Values");
		ws.getRange2("B101").setValue("1000");
		ws.getRange2("B102").setValue("1100");
		ws.getRange2("B103").setValue("1200");
		ws.getRange2("B104").setValue("1500");
		ws.getRange2("B105").setValue("2100");
		ws.getRange2("B106").setValue("2000");
		ws.getRange2("B107").setValue("2200");
		ws.getRange2("B108").setValue("2300");
		ws.getRange2("B109").setValue("2400");
		ws.getRange2("B110").setValue("2650");
		ws.getRange2("B111").setValue("2789");
		ws.getRange2("B112").setValue("3000");
		ws.getRange2("B113").setValue("2999");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("Text"); // Text (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(DATE(2025,1,4),{10,20,30},{45658,45659,45660})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(DATE(2025,1,4),{10,20,30},{45658,45659,45660}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used.');
		// Case #2: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,A100:A102,A103:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 45605, 'Test: Positive case: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used.');
		// Case #3: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(DATE(2025,1,4)+1,{10,20,30},{45658,45659,45660})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(DATE(2025,1,4)+1,{10,20,30},{45658,45659,45660}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used.');
		// Case #4: String. String inputs convertible to date and arrays. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS("01/04/2025",{10,20,30},{"01/01/2025","01/02/2025","01/03/2025"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS("01/04/2025",{10,20,30},{"01/01/2025","01/02/2025","01/03/2025"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String inputs convertible to date and arrays. 3 of 6 arguments used.');
		// Case #5: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(TIME(12,0,0)+45658,{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(TIME(12,0,0)+45658,{10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 45, 'Test: Positive case: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used.');
		// Case #6: Reference link,Area,Area. Reference link for target_date, areas with 3 cells for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(A107,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(A107,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 43554.5, 'Test: Positive case: Reference link,Area,Area. Reference link for target_date, areas with 3 cells for values and timeline. 3 of 6 arguments used.');
		// Case #7: Array. Array with single element for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS({45658},{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS({45658},{10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Array. Array with single element for target_date. 3 of 6 arguments used.');
		// Case #8: Name. Named range for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(TestName,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(TestName,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range for target_date. 3 of 6 arguments used.');
		// Case #9: Name3D. 3D named range for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(TestName3D,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(TestName3D,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range for target_date. 3 of 6 arguments used.');
		// Case #10: Ref3D. 3D reference for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(Sheet2!A1,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(Sheet2!A1,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference for target_date. 3 of 6 arguments used.');
		// Case #11: Area3D. 3D range with 3 cells for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(Sheet2!A1:A3,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(Sheet2!A1:A3,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D range with 3 cells for target_date. 3 of 6 arguments used.');
		// Case #12: Table. Table structured reference with 3 elements. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured reference with 3 elements. 3 of 6 arguments used.');
		// Case #13: Number. Seasonality set to 1 (auto-detect). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30,40},{45654,45655,45656,45657},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30,40},{45654,45655,45656,45657},1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Seasonality set to 1 (auto-detect). 4 of 6 arguments used.');
		// Case #14: Number. No seasonality (0), data_completion = 1. 5 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Number. No seasonality (0), data_completion = 1. 5 of 6 arguments used.');
		// Case #15: Number. Aggregation set to 2 (SUM). 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},1,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},1,1,2) is parsed.');
		// ?assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Aggregation set to 2 (SUM). 6 of 6 arguments used.');
		// Case #16: Formula. target_date as formula with float. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(ROUND(45658.5,0),B101:B113,A101:A113)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(ROUND(45658.5,0),B101:B113,A101:A113) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 13773.22468, 'Test: Positive case: Formula. target_date as formula with float. 3 of 6 arguments used.');
		// Case #17: Formula,Number. Nested IF for target_date, specific seasonality (2). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(IF(TRUE,45658,0),B101:B113,A101:A113,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(IF(TRUE,45658,0),B101:B113,A101:A113,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 13827.26112, 'Test: Positive case: Formula,Number. Nested IF for target_date, specific seasonality (2). 4 of 6 arguments used.');
		// Case #18: Number. Larger arrays with 5 elements for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30,40,50},{45653,45654,45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30,40,50},{45653,45654,45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 60, 'Test: Positive case: Number. Larger arrays with 5 elements for values and timeline. 3 of 6 arguments used.');
		// Case #19: String. Float strings convertible to numbers, seasonality = 1. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS("01/04/2025","{10.5,20.5,30.5}","{01/01/2025,01/02/2025,01/03/2025}",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS("01/04/2025","{10.5,20.5,30.5}","{01/01/2025,01/02/2025,01/03/2025}",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Float strings convertible to numbers, seasonality = 1. 4 of 6 arguments used.');
		// Case #20: Formula,Number. FORECAST.ETS inside SUM formula. 3 of 6 arguments used.
		oParser = new parserFormula('SUM(FORECAST.ETS(45658,{10,20,30},{45655,45656,45657}),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FORECAST.ETS(45658,{10,20,30},{45655,45656,45657}),10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Formula,Number. FORECAST.ETS inside SUM formula. 3 of 6 arguments used.');
		// Case #21: Array. Array with multiple elements for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS({45658,45659},{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS({45658,45659},{10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Array. Array with multiple elements for target_date. 3 of 6 arguments used.');
		// Case #22: Number. Maximum valid seasonality (8760), data_completion = 1, aggregation = 6 (MEDIAN). 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},8760,1,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},8760,1,6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Number. Maximum valid seasonality (8760), data_completion = 1, aggregation = 6 (MEDIAN). 6 of 6 arguments used.');

		// Negative cases:
		// Case #1: Date,Number. target_date equals timeline start returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},{45658,45658,45658})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},{45658,45658,45658}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date,Number. target_date equals timeline start returns #NUM!. 3 of 6 arguments used.');
		// Case #2: Empty,Number. target_date is empty returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(,{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(,{10,20,30},{45655,45656,45657}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty,Number. target_date is empty returns #VALUE!. 3 of 6 arguments used.');
		// Case #3: Number,Empty. values is empty returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,,{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,,{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. values is empty returns #N/A. 3 of 6 arguments used.');
		// Case #4: Number,Empty. timeline is empty returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. timeline is empty returns #N/A. 3 of 6 arguments used.');
		// Case #5: String. target_date as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS("45658",{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS("45658",{10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Negative case: String. target_date as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #6: Number,String. values as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,"{abc,def,ghi}","{45655,45656,45657}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,"{abc,def,ghi}","{45655,45656,45657}") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number,String. values as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #7: Number,String. timeline as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS("45658s",{10,20,30},{"abc","def","ghi"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS("45658s",{10,20,30},{"abc","def","ghi"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. timeline as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #8: Error,Number. target_date as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(NA(),{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(NA(),{10,20,30},{45655,45656,45657}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number. target_date as error returns #N/A. 3 of 6 arguments used.');
		// Case #9: Number,Error. values as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,NA(),{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,NA(),{45655,45656,45657}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. values as error returns #N/A. 3 of 6 arguments used.');
		// Case #10: Number,Error. timeline as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. timeline as error returns #N/A. 3 of 6 arguments used.');
		// Case #11: Number. Duplicate values in timeline returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},{45655,45655,45656},"s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},{45655,45655,45656},"s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Duplicate values in timeline returns #VALUE!. 3 of 6 arguments used.');
		// Case #12: Number. Inconsistent step in timeline returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},{45655,45656,45658})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},{45655,45656,45658}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Inconsistent step in timeline returns #NUM!. 3 of 6 arguments used.');
		// Case #13: Number,Area. Mismatched range sizes (3 vs 2 cells) for values and timeline returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,A100:A102,A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,A100:A102,A100:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 45698, 'Test: Negative case: Number,Area. Mismatched range sizes (3 vs 2 cells) for values and timeline returns #N/A. 3 of 6 arguments used.');
		// Case #14: Formula,Number. target_date as formula returning #NUM! returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(1/0,{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(1/0,{10,20,30},{45655,45656,45657}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula,Number. target_date as formula returning #NUM! returns #NUM!. 3 of 6 arguments used.');
		// Case #15: Ref3D. 3D ref to non-numeric value returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS(Sheet2!A2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(Sheet2!A2,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!.');
		// Case #16: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS(TestNameArea2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(TestNameArea2,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #17: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS(TestNameArea3D2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(TestNameArea3D2,A101:A103,A104:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #18: Table. Table column with non-numeric data returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS(Table1[Column6],Table1[Column5],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(Table1[Column6],Table1[Column5],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with non-numeric data returns #VALUE!.');
		// Case #19: Number. Mismatched array sizes (4 vs 3) for values and timeline returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30,40},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30,40},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Mismatched array sizes (4 vs 3) for values and timeline returns #N/A. 3 of 6 arguments used.');
		// Case #20: Number. Negative seasonality returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative seasonality returns #NUM!. 4 of 6 arguments used.');
		// Case #21: Number. Seasonality > 8760 returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},8761)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},8761) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Negative case: Number. Seasonality > 8760 returns #NUM!. 4 of 6 arguments used.');
		// Case #22: Number. Non-integer seasonality returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{10,20,30},{45655,45656,45657},1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Non-integer seasonality returns #NUM!. 4 of 6 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid positive values for target_date and arrays, consistent timeline step. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(2.2E-308,{1E-307,2E-307,3E-307},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(2.2E-308,{1E-307,2E-307,3E-307},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid positive values for target_date and arrays, consistent timeline step. 3 of 6 arguments used.');
		// Case #2: Number. Maximum valid Excel number for target_date and arrays, maximum valid seasonality (8760). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(9.99999999999999E+307,{1E+307,2E+307,3E+307},{1,2,3},8760)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(9.99999999999999E+307,{1E+307,2E+307,3E+307},{1,2,3},8760) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number for target_date and arrays, maximum valid seasonality (8760). 4 of 6 arguments used.');
		// Case #3: Number. Minimum valid array sizes (3 elements) with smallest valid values, all optional arguments used. 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS(45658,{1E-307,2E-307,3E-307},{45655,45656,45657},2,1,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS(45658,{1E-307,2E-307,3E-307},{45655,45656,45657},2,1,6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4e-307, 'Test: Bounded case: Number. Minimum valid array sizes (3 elements) with smallest valid values, all optional arguments used. 6 of 6 arguments used.');

		// TODO много проблем с результатами вычислений - ошибки и значения отличные от реузльтатов мс.
		// TODO также отрицательное число в первом аргументе крашит редактор в мс
		// Need to fix:ms result diff, error types diff
		// Case #1: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used. - result diff
		// Case #2: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used. - result diff
		// Case #3: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used. - result diff
		// Case #4: String. String inputs convertible to date and arrays. 3 of 6 arguments used. - error type diff
		// Case #5: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used. - result diff
		// Case #7: Array. Array with single element for target_date. 3 of 6 arguments used. - result diff
		// Case #13: Number. Seasonality set to 1 (auto-detect). 4 of 6 arguments used. - result diff
		// Case #14: Number. No seasonality (0), data_completion = 1. 5 of 6 arguments used. - result diff
		// Case #15: Number. Aggregation set to 2 (SUM). 6 of 6 arguments used. - result diff
		// Case #16: Formula. target_date as formula with float. 3 of 6 arguments used. - result diff
		// Case #17: Formula,Number. Nested IF for target_date, specific seasonality (2). 4 of 6 arguments used. - result diff
		// Case #18: Number. Larger arrays with 5 elements for values and timeline. 3 of 6 arguments used. - result diff
		// Case #19: Number. Mismatched array sizes (4 vs 3) for values and timeline returns #N/A. 3 of 6 arguments used. - array sizes diff #N/A



	});

	QUnit.test("Test: \"FORECAST.ETS.CONFINT\"", function (assert) {
		putDataForForecastEts();

		ws.getRange2("A100:A102").setValue("");
		ws.getRange2("B100").setValue("1");
		ws.getRange2("B101").setValue("2");
		ws.getRange2("B102").setValue("3");
		ws.getRange2("C100").setValue("1");
		ws.getRange2("C101").setValue("2");
		ws.getRange2("C102").setValue("3");

		ws.getRange2("D100").setValue("123");
		ws.getRange2("D101").setValue("123s");

		oParser = new parserFormula("FORECAST.ETS.CONFINT(123,A100:A102,A100:A102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS.CONFINT(123,A100:A102,A100:A102) - empty array in 2 and 3 arguments");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST.ETS.CONFINT(123,A100:A102,A100:A102) - empty array in 2 and 3 arguments");	// #DIV/0! 

		oParser = new parserFormula("FORECAST.ETS.CONFINT(123,A100:A102,B100:B102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS.CONFINT(123,A100:A102,B100:B102) - empty array in 2 argument");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of FORECAST.ETS.CONFINT(123,A100:A102,B100:B102) - empty array in 2 argument");		// #DIV/0!

		oParser = new parserFormula("FORECAST.ETS.CONFINT(123,B100:B102,A100:A102)", "A1", ws);
		assert.ok(oParser.parse(), "FORECAST.ETS.CONFINT(123,B100:B102,A100:A102) - empty array in 3 argument");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT(123,B100:B102,A100:A102) - empty array in 3 argument");		// #DIV/0!

		oParser = new parserFormula("FORECAST.ETS.CONFINT(B100:B102,B100:B102,B100:B102)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "FORECAST.ETS.CONFINT(B100:B102,B100:B102,B100:B102)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT(B100:B102,B100:B102,B100:B102)[0,0]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT(B100:B102,B100:B102,B100:B102)[1,0]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT(B100:B102,B100:B102,B100:B102)[2,0]");

		oParser = new parserFormula("FORECAST.ETS.CONFINT({1;2;3},B100:B102,B100:B102)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "FORECAST.ETS.CONFINT({1;2;3},B100:B102,B100:B102)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT({1;2;3},B100:B102,B100:B102)[0,0]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT({1;2;3},B100:B102,B100:B102)[1,0]");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT({1;2;3},B100:B102,B100:B102)[2,0]");

		// base type checks
		oParser = new parserFormula("FORECAST.ETS.CONFINT(123,B100:B102,C100:C102)", "A1", ws);	
		assert.ok(oParser.parse(), "FORECAST.ETS.CONFINT(123,B100:B102,C100:C102)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT(123,B100:B102,C100:C102)");		// 0

		oParser = new parserFormula("FORECAST.ETS.CONFINT(0,B100:B102,C100:C102)", "A1", ws);	
		assert.ok(oParser.parse(), "FORECAST.ETS.CONFINT(0,B100:B102,C100:C102)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT(0,B100:B102,C100:C102)");

		oParser = new parserFormula("FORECAST.ETS.CONFINT(-1,B100:B102,C100:C102)", "A1", ws);	
		assert.ok(oParser.parse(), "FORECAST.ETS.CONFINT(-1,B100:B102,C100:C102)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of FORECAST.ETS.CONFINT(-1,B100:B102,C100:C102)");

		oParser = new parserFormula('FORECAST.ETS.CONFINT("123s",B100:B102,C100:C102)', "A1", ws);
		assert.ok(oParser.parse(), 'FORECAST.ETS.CONFINT("123s",B100:B102,C100:C102)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of FORECAST.ETS.CONFINT("123s",B100:B102,C100:C102)');

		oParser = new parserFormula('FORECAST.ETS.CONFINT(D101,B100:B102,C100:C102)', "A1", ws);
		assert.ok(oParser.parse(), 'FORECAST.ETS.CONFINT(D101,B100:B102,C100:C102)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of FORECAST.ETS.CONFINT(D101,B100:B102,C100:C102)');

		oParser = new parserFormula('FORECAST.ETS.CONFINT(FALSE,B100:B102,C100:C102)', "A1", ws);
		assert.ok(oParser.parse(), 'FORECAST.ETS.CONFINT(FALSE,B100:B102,C100:C102)');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Result of FORECAST.ETS.CONFINT(FALSE,B100:B102,C100:C102)');

		oParser = new parserFormula('FORECAST.ETS.CONFINT(TRUE,B100:B102,C100:C102)', "A1", ws);
		assert.ok(oParser.parse(), 'FORECAST.ETS.CONFINT(TRUE,B100:B102,C100:C102)');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Result of FORECAST.ETS.CONFINT(TRUE,B100:B102,C100:C102)');

		oParser = new parserFormula('FORECAST.ETS.CONFINT(#N/A,B100:B102,C100:C102)', "A1", ws);
		assert.ok(oParser.parse(), 'FORECAST.ETS.CONFINT(#N/A,B100:B102,C100:C102)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", 'Result of FORECAST.ETS.CONFINT(#N/A,B100:B102,C100:C102)');

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("Dates");
		ws.getRange2("A101").setValue("43466");
		ws.getRange2("A102").setValue("43497");
		ws.getRange2("A103").setValue("43525");
		ws.getRange2("A104").setValue("43556");
		ws.getRange2("A105").setValue("43586");
		ws.getRange2("A106").setValue("43617");
		ws.getRange2("A107").setValue("43647");
		ws.getRange2("A108").setValue("43678");
		ws.getRange2("A109").setValue("43709");
		ws.getRange2("A110").setValue("43739");
		ws.getRange2("A111").setValue("43770");
		ws.getRange2("A112").setValue("43800");
		ws.getRange2("A113").setValue("43831");
		ws.getRange2("A114").setValue("43862");

		ws.getRange2("B100").setValue("Values");
		ws.getRange2("B101").setValue("1000");
		ws.getRange2("B102").setValue("1100");
		ws.getRange2("B103").setValue("1200");
		ws.getRange2("B104").setValue("1500");
		ws.getRange2("B105").setValue("2100");
		ws.getRange2("B106").setValue("2000");
		ws.getRange2("B107").setValue("2200");
		ws.getRange2("B108").setValue("2300");
		ws.getRange2("B109").setValue("2400");
		ws.getRange2("B110").setValue("2650");
		ws.getRange2("B111").setValue("2789");
		ws.getRange2("B112").setValue("3000");
		ws.getRange2("B113").setValue("2999");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("Text"); // Text (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(DATE(2025,1,5),{10,20,30,35},{45658,45659,45660,45661})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(DATE(2025,1,5),{10,20,30,35},{45658,45659,45660,45661}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3.415320885, 'Test: Positive case: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used.');
		// Case #2: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(A114,B101:B113,A101:A113)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(A114,B101:B113,A101:A113) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 268.4544413, 'Test: Positive case: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used.');
		// Case #3: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(DATE(2025,1,5)+1,{10,20,30,50},{45658,45659,45660,45661})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(DATE(2025,1,5)+1,{10,20,30,50},{45658,45659,45660,45661}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 7.042524169, 'Test: Positive case: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used.');
		// Case #4: String. String inputs convertible to date and arrays. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT("45662",{10,20,30,35},{45658,45659,45660,45661})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT("45662",{10,20,30,35},{45658,45659,45660,45661}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3.415320885, 'Test: Positive case: String. String inputs convertible to date and arrays. 3 of 6 arguments used.');
		// Case #5: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(TIME(12,0,0)+45658,{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(TIME(12,0,0)+45658,{10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used.');
		// Case #6: Reference link,Area,Area. Reference link for target_date, areas with 3 cells for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(A107,B101:B106,A101:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(A107,B101:B106,A101:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 355.6375065, 'Test: Positive case: Reference link,Area,Area. Reference link for target_date, areas with 3 cells for values and timeline. 3 of 6 arguments used.');
		// Case #7: Array. Array with single element for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT({45659},{10,20,30,60},{45655,45656,45657,45658})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT({45659},{10,20,30,60},{45655,45656,45657,45658}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 13.66128354, 'Test: Positive case: Array. Array with single element for target_date. 3 of 6 arguments used.');
		// Case #9: Name3D. 3D named range for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(TestName3D,A101:A110,A101:A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(TestName3D,A101:A110,A101:A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range for target_date. 3 of 6 arguments used.');
		// Case #10: Ref3D. 3D reference for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(Sheet2!A1,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(Sheet2!A1,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference for target_date. 3 of 6 arguments used.');
		// Case #11: Area3D. 3D range with 3 cells for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(Sheet2!A1:A3,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(Sheet2!A1:A3,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D range with 3 cells for target_date. 3 of 6 arguments used.');
		// Case #12: Table. Table structured reference with 3 elements. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured reference with 3 elements. 3 of 6 arguments used.');
		// Case #13: Number. Seasonality set to 1 (auto-detect). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45660,{10,20,30,44},{45654,45655,45656,45657},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45660,{10,20,30,44},{45654,45655,45656,45657},0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.997965036, 'Test: Positive case: Number. Seasonality set to 1 (auto-detect). 4 of 6 arguments used.');
		// Case #14: Number. No seasonality (0), data_completion = 1. 5 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45659,{10,20,30,46},{45655,45656,45657,45658},0.2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45659,{10,20,30,46},{45655,45656,45657,45658},0.2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.529761767, 'Test: Positive case: Number. No seasonality (0), data_completion = 1. 5 of 6 arguments used.');
		// Case #15: Number. Aggregation set to 2 (SUM). 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45659,{10,20,30,46},{45655,45656,45657,45658},0.02,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45659,{10,20,30,46},{45655,45656,45657,45658},0.02,2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.052420371, 'Test: Positive case: Number. Aggregation set to 2 (SUM). 6 of 6 arguments used.');
		// Case #16: Formula. target_date as formula with float. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(ROUND(45658.5,0),B101:B113,A101:A113)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(ROUND(45658.5,0),B101:B113,A101:A113) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 278.6823473, 'Test: Positive case: Formula. target_date as formula with float. 3 of 6 arguments used.');
		// Case #17: Formula,Number. Nested IF for target_date, specific seasonality (2). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(IF(TRUE,45658,0),B101:B113,A101:A113,0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(IF(TRUE,45658,0),B101:B113,A101:A113,0.9) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 233.8641425, 'Test: Positive case: Formula,Number. Nested IF for target_date, specific seasonality (2). 4 of 6 arguments used.');
		// Case #18: Number. Larger arrays with 5 elements for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30,40,59},{45653,45654,45655,45656,45657},0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30,40,59},{45653,45654,45655,45656,45657},0.05) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.198318312, 'Test: Positive case: Number. Larger arrays with 5 elements for values and timeline. 3 of 6 arguments used.');
		// Case #19: String. Float strings convertible to numbers, seasonality = 1. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT("01/04/2025",{10.5,20.5,30.5},{"01/01/2025","01/02/2025","01/03/2025"},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT("01/04/2025",{10.5,20.5,30.5},{"01/01/2025","01/02/2025","01/03/2025"},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. Float strings convertible to numbers, seasonality = 1. 4 of 6 arguments used.');
		// Case #20: Formula,Number. FORECAST.ETS inside SUM formula. 3 of 6 arguments used.
		oParser = new parserFormula('SUM(FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45657}),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45657}),10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula,Number. FORECAST.ETS inside SUM formula. 3 of 6 arguments used.');
		// Case #21: Array. Array with multiple elements for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT({45658,45659},{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT({45658,45659},{10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Array with multiple elements for target_date. 3 of 6 arguments used.');
		// Case #22: Number. Maximum valid seasonality (8760), data_completion = 1, aggregation = 6 (MEDIAN). 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,60},{45655,45656,45657},0.876,1,1,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,60},{45655,45656,45657},0.876,1,1,6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 13.58239826, 'Test: Positive case: Number. Maximum valid seasonality (8760), data_completion = 1, aggregation = 6 (MEDIAN). 6 of 6 arguments used.');

		// Negative cases:
		// Case #1: Date,Number. target_date equals timeline start returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30},{45658,45658,45658})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30},{45658,45658,45658}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date,Number. target_date equals timeline start returns #NUM!. 3 of 6 arguments used.');
		// Case #2: Empty,Number. target_date is empty returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(,{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(,{10,20,30},{45655,45656,45657}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty,Number. target_date is empty returns #VALUE!. 3 of 6 arguments used.');
		// Case #3: Number,Empty. values is empty returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,,{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,,{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. values is empty returns #N/A. 3 of 6 arguments used.');
		// Case #4: Number,Empty. timeline is empty returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30},) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. timeline is empty returns #N/A. 3 of 6 arguments used.');
		// Case #5: String. target_date as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT("45658",{10,20,30},{45655,45656,45657},"0.1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT("45658",{10,20,30},{45655,45656,45657},"0.1","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String. target_date as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #6: Number,String. values as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,"{abc,def,ghi}","{45655,45656,45657}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,"{abc,def,ghi}","{45655,45656,45657}") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number,String. values as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #7: Number,String. timeline as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT("45658s",{10,20,30},{"abc","def","ghi"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT("45658s",{10,20,30},{"abc","def","ghi"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. timeline as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #8: Error,Number. target_date as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(NA(),{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(NA(),{10,20,30},{45655,45656,45657}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number. target_date as error returns #N/A. 3 of 6 arguments used.');
		// Case #9: Number,Error. values as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,NA(),{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,NA(),{45655,45656,45657}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. values as error returns #N/A. 3 of 6 arguments used.');
		// Case #10: Number,Error. timeline as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. timeline as error returns #N/A. 3 of 6 arguments used.');
		// Case #11: Number. Duplicate values in timeline returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45655,45656},"s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45655,45656},"s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Duplicate values in timeline returns #VALUE!. 3 of 6 arguments used.');
		// Case #12: Number. Inconsistent step in timeline returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45658})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45658}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Inconsistent step in timeline returns #NUM!. 3 of 6 arguments used.');
		// Case #13: Number,Area. Mismatched range sizes (3 vs 2 cells) for values and timeline returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,A100:A102,A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,A100:A102,A100:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number,Area. Mismatched range sizes (3 vs 2 cells) for values and timeline returns #N/A. 3 of 6 arguments used.');
		// Case #14: Formula,Number. target_date as formula returning #NUM! returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(1/0,{10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(1/0,{10,20,30},{45655,45656,45657}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula,Number. target_date as formula returning #NUM! returns #NUM!. 3 of 6 arguments used.');
		// Case #15: Ref3D. 3D ref to non-numeric value returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(Sheet2!A2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(Sheet2!A2,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!.');
		// Case #16: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(TestNameArea2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(TestNameArea2,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #17: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(TestNameArea3D2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(TestNameArea3D2,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #18: Table. Table column with non-numeric data returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(Table1[Column6],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(Table1[Column6],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with non-numeric data returns #VALUE!.');
		// Case #19: Number. Mismatched array sizes (4 vs 3) for values and timeline returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30,40},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30,40},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Mismatched array sizes (4 vs 3) for values and timeline returns #N/A. 3 of 6 arguments used.');
		// Case #20: Number. Negative seasonality returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45657},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45657},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative seasonality returns #NUM!. 4 of 6 arguments used.');
		// Case #21: Number. Seasonality > 8760 returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45657},8761)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45657},8761) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Seasonality > 8760 returns #NUM!. 4 of 6 arguments used.');
		// Case #22: Number. Non-integer seasonality returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45657},1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{10,20,30},{45655,45656,45657},1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Non-integer seasonality returns #NUM!. 4 of 6 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid positive values for target_date and arrays, consistent timeline step. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(1E-307,{1E-307,2E-307,3E-307,3E-307},{1,2,3,4},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(1E-307,{1E-307,2E-307,3E-307,3E-307},{1,2,3,4},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid positive values for target_date and arrays, consistent timeline step. 3 of 6 arguments used.');
		// Case #2: Number. Maximum valid Excel number for target_date and arrays, maximum valid seasonality (8760). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(9.99999999999999E+307,{1E+307,2E+307,3E+307},{1,2,3},8760)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(9.99999999999999E+307,{1E+307,2E+307,3E+307},{1,2,3},8760) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number for target_date and arrays, maximum valid seasonality (8760). 4 of 6 arguments used.');
		// Case #3: Number. Minimum valid array sizes (3 elements) with smallest valid values, all optional arguments used. 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.CONFINT(45658,{1E-307,2E-307,3E-307},{45655,45656,45657},2,1,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.CONFINT(45658,{1E-307,2E-307,3E-307},{45655,45656,45657},2,1,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid array sizes (3 elements) with smallest valid values, all optional arguments used. 6 of 6 arguments used.');

		// TODO множество расхождений в результатах в этой функции. Нужно пересмотреть алгоритм расчета для того набора данных что используется в тестах
		// Need to fix: error type diff, MS result diff, missmatch array sizes

	});

	QUnit.test("Test: \"FORECAST.ETS.SEASONALITY\"", function (assert) {
		//результаты данного теста соответсвуют результатам LO, но отличаются от MS!!!

		putDataForForecastEts();

		oParser = new parserFormula("FORECAST.ETS.SEASONALITY(B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 12);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("Dates");
		ws.getRange2("A101").setValue("43466");
		ws.getRange2("A102").setValue("43497");
		ws.getRange2("A103").setValue("43525");
		ws.getRange2("A104").setValue("43556");
		ws.getRange2("A105").setValue("43586");
		ws.getRange2("A106").setValue("43617");
		ws.getRange2("A107").setValue("43647");
		ws.getRange2("A108").setValue("43678");
		ws.getRange2("A109").setValue("43709");
		ws.getRange2("A110").setValue("43739");
		ws.getRange2("A111").setValue("43770");
		ws.getRange2("A112").setValue("43800");
		ws.getRange2("A113").setValue("43831");
		ws.getRange2("A114").setValue("43862");

		ws.getRange2("B100").setValue("Values");
		ws.getRange2("B101").setValue("1000");
		ws.getRange2("B102").setValue("1100");
		ws.getRange2("B103").setValue("1200");
		ws.getRange2("B104").setValue("1500");
		ws.getRange2("B105").setValue("2100");
		ws.getRange2("B106").setValue("2000");
		ws.getRange2("B107").setValue("2200");
		ws.getRange2("B108").setValue("2300");
		ws.getRange2("B109").setValue("2400");
		ws.getRange2("B110").setValue("2650");
		ws.getRange2("B111").setValue("2789");
		ws.getRange2("B112").setValue("3000");
		ws.getRange2("B113").setValue("2999");

		ws.getRange2("A119").setValue("Dates");
		ws.getRange2("B119").setValue("Values1");
		ws.getRange2("C119").setValue("Values2");

		ws.getRange2("A120").setValue("39814");
		ws.getRange2("B120").setValue("2644539");
		ws.getRange2("C120").setValue("1000");

		ws.getRange2("A121").setValue("39845");
		ws.getRange2("B121").setValue("2359800");
		ws.getRange2("C121").setValue("1100");

		ws.getRange2("A122").setValue("39873");
		ws.getRange2("B122").setValue("2925918");
		ws.getRange2("C122").setValue("1200");

		ws.getRange2("A123").setValue("39904");
		ws.getRange2("B123").setValue("3024973");
		ws.getRange2("C123").setValue("1500");

		ws.getRange2("A124").setValue("39934");
		ws.getRange2("B124").setValue("3177100");
		ws.getRange2("C124").setValue("2100");

		ws.getRange2("A125").setValue("39965");
		ws.getRange2("B125").setValue("3419595");
		ws.getRange2("C125").setValue("2000");

		ws.getRange2("A126").setValue("39995");
		ws.getRange2("B126").setValue("3649702");
		ws.getRange2("C126").setValue("2200");

		ws.getRange2("A127").setValue("40026");
		ws.getRange2("B127").setValue("3650668");
		ws.getRange2("C127").setValue("2300");

		ws.getRange2("A128").setValue("40057");
		ws.getRange2("B128").setValue("3191526");
		ws.getRange2("C128").setValue("2400");

		ws.getRange2("A129").setValue("40087");
		ws.getRange2("B129").setValue("3249428");
		ws.getRange2("C129").setValue("2650");

		ws.getRange2("A130").setValue("40118");
		ws.getRange2("B130").setValue("2971484");
		ws.getRange2("C130").setValue("2789");

		ws.getRange2("A131").setValue("40148");
		ws.getRange2("B131").setValue("3074209");
		ws.getRange2("C131").setValue("3000");

		ws.getRange2("A132").setValue("40179");
		ws.getRange2("B132").setValue("2785466");
		ws.getRange2("C132").setValue("2999");

		ws.getRange2("A133").setValue("40210");
		ws.getRange2("B133").setValue("2515361");
		ws.getRange2("C133").setValue("3220");

		ws.getRange2("A134").setValue("40238");
		ws.getRange2("B134").setValue("3105958");
		ws.getRange2("C134").setValue("3000");

		ws.getRange2("A135").setValue("40269");
		ws.getRange2("B135").setValue("3139059");
		ws.getRange2("C135").setValue("3101");

		ws.getRange2("A136").setValue("40299");
		ws.getRange2("B136").setValue("3380355");
		ws.getRange2("C136").setValue("3981");

		ws.getRange2("A137").setValue("40330");
		ws.getRange2("B137").setValue("3612886");
		ws.getRange2("C137").setValue("3700");

		ws.getRange2("A138").setValue("40360");
		ws.getRange2("B138").setValue("3765824");
		ws.getRange2("C138").setValue("4500");

		ws.getRange2("A139").setValue("40391");
		ws.getRange2("B139").setValue("3771842");
		ws.getRange2("C139").setValue("4550");

		ws.getRange2("A140").setValue("40422");
		ws.getRange2("B140").setValue("3356365");
		ws.getRange2("C140").setValue("4560");

		ws.getRange2("A141").setValue("40452");
		ws.getRange2("B141").setValue("3490100");
		ws.getRange2("C141").setValue("4570");

		ws.getRange2("A142").setValue("40483");
		ws.getRange2("B142").setValue("3163659");
		ws.getRange2("C142").setValue("4800");

		ws.getRange2("A143").setValue("40513");
		ws.getRange2("B143").setValue("3167124");
		ws.getRange2("C143").setValue("4920");

		ws.getRange2("A144").setValue("40544");
		ws.getRange2("B144").setValue("2883810");
		ws.getRange2("C144").setValue("4930");

		ws.getRange2("A145").setValue("40575");
		ws.getRange2("B145").setValue("2610667");
		ws.getRange2("C145").setValue("4940");

		ws.getRange2("A146").setValue("40603");
		ws.getRange2("B146").setValue("3129205");
		ws.getRange2("C146").setValue("5100");

		ws.getRange2("A147").setValue("40634");
		ws.getRange2("B147").setValue("3200527");
		ws.getRange2("C147").setValue("5200");

		ws.getRange2("A148").setValue("40664");
		ws.getRange2("B148").setValue("3547804");
		ws.getRange2("C148").setValue("5350");

		ws.getRange2("A149").setValue("40695");
		ws.getRange2("B149").setValue("3766323");
		ws.getRange2("C149").setValue("5400");

		ws.getRange2("A150").setValue("40725");
		ws.getRange2("B150").setValue("3935589");
		ws.getRange2("C150").setValue("5450");

		ws.getRange2("A151").setValue("40756");
		ws.getRange2("B151").setValue("3917884");
		ws.getRange2("C151").setValue("5510");

		ws.getRange2("A152").setValue("40787");
		ws.getRange2("B152").setValue("3564970");
		ws.getRange2("C152").setValue("5100");

		ws.getRange2("A153").setValue("40817");
		ws.getRange2("B153").setValue("3602455");
		ws.getRange2("C153").setValue("5200");

		ws.getRange2("A154").setValue("40848");
		ws.getRange2("B154").setValue("3326859");
		ws.getRange2("C154").setValue("5909");

		ws.getRange2("A155").setValue("40878");
		ws.getRange2("B155").setValue("3441693");
		ws.getRange2("C155").setValue("6000");

		ws.getRange2("A156").setValue("40909");
		ws.getRange2("B156").setValue("3211600");
		ws.getRange2("C156").setValue("6100");

		ws.getRange2("A157").setValue("40940");
		ws.getRange2("B157").setValue("2998119");
		ws.getRange2("C157").setValue("6200");

		ws.getRange2("A158").setValue("40969");
		ws.getRange2("B158").setValue("3472440");
		ws.getRange2("C158").setValue("6300");

		ws.getRange2("A159").setValue("41000");
		ws.getRange2("B159").setValue("3563007");
		ws.getRange2("C159").setValue("6400");

		ws.getRange2("A160").setValue("41030");
		ws.getRange2("B160").setValue("3820570");
		ws.getRange2("C160").setValue("6500");

		ws.getRange2("A161").setValue("41061");
		ws.getRange2("B161").setValue("4107195");
		ws.getRange2("C161").setValue("6600");

		ws.getRange2("A162").setValue("41091");
		ws.getRange2("B162").setValue("4284443");
		ws.getRange2("C162").setValue("6700");

		ws.getRange2("A163").setValue("41122");
		ws.getRange2("B163").setValue("4356216");
		ws.getRange2("C163").setValue("6800");

		ws.getRange2("A164").setValue("41153");
		ws.getRange2("B164").setValue("3819379");
		ws.getRange2("C164").setValue("6900");

		ws.getRange2("A165").setValue("41183");
		ws.getRange2("B165").setValue("3844987");
		ws.getRange2("C165").setValue("7000");

		ws.getRange2("A166").setValue("41214");
		ws.getRange2("B166").setValue("3478890");
		ws.getRange2("C166").setValue("7100");

		ws.getRange2("A167").setValue("41244");
		ws.getRange2("B167").setValue("3443039");
		ws.getRange2("C167").setValue("7200");

		ws.getRange2("A168").setValue("41275");
		ws.getRange2("B168").setValue("3204637");
		ws.getRange2("C168").setValue("7300");

		ws.getRange2("A169").setValue("41306");
		ws.getRange2("B169").setValue("2966477");
		ws.getRange2("C169").setValue("7400");

		ws.getRange2("A170").setValue("41334");
		ws.getRange2("B170").setValue("3593364");
		ws.getRange2("C170").setValue("7500");

		ws.getRange2("A171").setValue("41365");
		ws.getRange2("B171").setValue("3604104");
		ws.getRange2("C171").setValue("7600");

		ws.getRange2("A172").setValue("41395");
		ws.getRange2("B172").setValue("3933016");
		ws.getRange2("C172").setValue("7700");

		ws.getRange2("A173").setValue("41426");
		ws.getRange2("B173").setValue("4146797");
		ws.getRange2("C173").setValue("7800");

		ws.getRange2("A174").setValue("41456");
		ws.getRange2("B174").setValue("4176486");
		ws.getRange2("C174").setValue("7900");

		ws.getRange2("A175").setValue("41487");
		ws.getRange2("B175").setValue("4347059");
		ws.getRange2("C175").setValue("8000");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("Text"); // Text (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30,35},{45658,45659,45660,45661})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30,35},{45658,45659,45660,45661}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used.');
		// Case #2: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(B120:B175,A120:A175)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(B120:B175,A120:A175) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used.');
		// Case #3: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30,50},{45658,45659,45660,45661})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30,50},{45658,45659,45660,45661}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used.');
		// Case #4: String. String inputs convertible to date and arrays. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30,35},{45658,45659,45660,45661})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30,35},{45658,45659,45660,45661}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String inputs convertible to date and arrays. 3 of 6 arguments used.');
		// Case #5: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used.');
		// Case #6: Reference link,Area,Area. Reference link for target_date, areas with 3 cells for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(B130:B175,A130:A175)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(B130:B175,A130:A175) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Reference link,Area,Area. Reference link for target_date, areas with 3 cells for values and timeline. 3 of 6 arguments used.');
		// Case #7: Array. Array with single element for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30,60},{45655,45656,45657,45658})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30,60},{45655,45656,45657,45658}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Array with single element for target_date. 3 of 6 arguments used.');
		// Case #8: Name. Named range for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(A120:A175,A120:A175)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(A120:A175,A120:A175) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Name. Named range for target_date. 3 of 6 arguments used.');
		// Case #9: Name3D. 3D named range for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(B130:B175,Sheet2!A130:A175)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(B130:B175,Sheet2!A130:A175) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named range for target_date. 3 of 6 arguments used.');
		// Case #10: Ref3D. 3D reference for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(Sheet2!B130:B175,A130:A175)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(Sheet2!B130:B175,A130:A175) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D. 3D reference for target_date. 3 of 6 arguments used.');
		// Case #11: Area3D. 3D range with 3 cells for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(A101:A103,A104:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D range with 3 cells for target_date. 3 of 6 arguments used.');
		// Case #12: Table. Table structured reference with 3 elements. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Test: Positive case: Table. Table structured reference with 3 elements. 3 of 6 arguments used.');
		// Case #13: Number. Seasonality set to 1 (auto-detect). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30,44},{45654,45655,45656,45657},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30,44},{45654,45655,45656,45657},0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Seasonality set to 1 (auto-detect). 4 of 6 arguments used.');
		// Case #14: Number. No seasonality (0), data_completion = 1. 5 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30,46},{45655,45656,45657,45658},0.2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30,46},{45655,45656,45657,45658},0.2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. No seasonality (0), data_completion = 1. 5 of 6 arguments used.');
		// Case #15: Number. Aggregation set to 2 (SUM). 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30,46},{45655,45656,45657,45658},0.02,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30,46},{45655,45656,45657,45658},0.02,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Aggregation set to 2 (SUM). 6 of 6 arguments used.');
		// Case #16: Formula. target_date as formula with float. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(B101:B113,A101:A113)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(B101:B113,A101:A113) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula. target_date as formula with float. 3 of 6 arguments used.');
		// Case #17: Formula,Number. Nested IF for target_date, specific seasonality (2). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(B120:B175,A120:A175,0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(B120:B175,A120:A175,0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula,Number. Nested IF for target_date, specific seasonality (2). 4 of 6 arguments used.');
		// Case #18: Number. Larger arrays with 5 elements for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30,40,59},{45653,45654,45655,45656,45657},0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30,40,59},{45653,45654,45655,45656,45657},0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Larger arrays with 5 elements for values and timeline. 3 of 6 arguments used.');
		// Case #19: String. Float strings convertible to numbers, seasonality = 1. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY("{10.5,20.5,30.5}","{01/01/2025,01/02/2025,01/03/2025}",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY("{10.5,20.5,30.5}","{01/01/2025,01/02/2025,01/03/2025}",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Float strings convertible to numbers, seasonality = 1. 4 of 6 arguments used.');
		// Case #20: Formula,Number. FORECAST.ETS inside SUM formula. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula,Number. FORECAST.ETS inside SUM formula. 3 of 6 arguments used.');
		// Case #21: Array. Array with multiple elements for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Array with multiple elements for target_date. 3 of 6 arguments used.');
		// Case #22: Number. Maximum valid seasonality (8760), data_completion = 1, aggregation = 6 (MEDIAN). 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,60},{45655,45656,45657},0.876,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,60},{45655,45656,45657},0.876,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Maximum valid seasonality (8760), data_completion = 1, aggregation = 6 (MEDIAN). 6 of 6 arguments used.');

		// Negative cases:
		// Case #1: Date,Number. target_date equals timeline start returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45658,45658,45658})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45658,45658,45658}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date,Number. target_date equals timeline start returns #NUM!. 3 of 6 arguments used.');
		// Case #2: Empty,Number. target_date is empty returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(,{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(,{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty,Number. target_date is empty returns #VALUE!. 3 of 6 arguments used.');
		// Case #3: Number,Empty. values is empty returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(,{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(,{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. values is empty returns #N/A. 3 of 6 arguments used.');
		// Case #4: Number,Empty. timeline is empty returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. timeline is empty returns #N/A. 3 of 6 arguments used.');
		// Case #5: String. target_date as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657},"0.1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657},"0.1","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. target_date as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #6: Number,String. values as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY("{abc,def,ghi}","{45655,45656,45657}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY("{abc,def,ghi}","{45655,45656,45657}") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number,String. values as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #7: Number,String. timeline as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{"abc","def","ghi"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{"abc","def","ghi"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number,String. timeline as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #8: Error,Number. target_date as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Error,Number. target_date as error returns #N/A. 3 of 6 arguments used.');
		// Case #9: Number,Error. values as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(NA(),{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(NA(),{45655,45656,45657}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. values as error returns #N/A. 3 of 6 arguments used.');
		// Case #10: Number,Error. timeline as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. timeline as error returns #N/A. 3 of 6 arguments used.');
		// Case #11: Number. Duplicate values in timeline returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45655,45656},"s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45655,45656},"s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Duplicate values in timeline returns #VALUE!. 3 of 6 arguments used.');
		// Case #12: Number. Inconsistent step in timeline returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45658})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45658}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Inconsistent step in timeline returns #NUM!. 3 of 6 arguments used.');
		// Case #13: Number,Area. Mismatched range sizes (3 vs 2 cells) for values and timeline returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(A100:A102,A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(A100:A102,A100:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number,Area. Mismatched range sizes (3 vs 2 cells) for values and timeline returns #N/A. 3 of 6 arguments used.');
		// Case #14: Formula,Number. target_date as formula returning #NUM! returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Formula,Number. target_date as formula returning #NUM! returns #NUM!. 3 of 6 arguments used.');
		// Case #15: Ref3D. 3D ref to non-numeric value returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(A101:A103,A104:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!.');
		// Case #16: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(A101:A103,A104:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #17: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(A101:A103,A104:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #18: Table. Table column with non-numeric data returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY(Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY(Table1[Column2],Table1[Column3]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=FORECAST.ETS.SEASONALITY(Table1[Column2],Table1[Column3])', 'Test: Negative case: Table. Table column with non-numeric data returns #VALUE!.');
		// Case #19: Number. Mismatched array sizes (4 vs 3) for values and timeline returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30,40},{45655,45656,45657})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30,40},{45655,45656,45657}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Mismatched array sizes (4 vs 3) for values and timeline returns #N/A. 3 of 6 arguments used.');
		// Case #20: Number. Negative seasonality returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative seasonality returns #NUM!. 4 of 6 arguments used.');
		// Case #21: Number. Seasonality > 8760 returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657},8761)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657},8761) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Seasonality > 8760 returns #NUM!. 4 of 6 arguments used.');
		// Case #22: Number. Non-integer seasonality returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657},1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({10,20,30},{45655,45656,45657},1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Non-integer seasonality returns #NUM!. 4 of 6 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid positive values for target_date and arrays, consistent timeline step. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({1E-307,2E-307,3E-307,3E-307},{1,2,3,4},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({1E-307,2E-307,3E-307,3E-307},{1,2,3,4},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid positive values for target_date and arrays, consistent timeline step. 3 of 6 arguments used.');
		// Case #2: Number. Maximum valid Excel number for target_date and arrays, maximum valid seasonality (8760). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({1E+307,2E+307,3E+307},{1,2,3},8760)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({1E+307,2E+307,3E+307},{1,2,3},8760) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number for target_date and arrays, maximum valid seasonality (8760). 4 of 6 arguments used.');
		// Case #3: Number. Minimum valid array sizes (3 elements) with smallest valid values, all optional arguments used. 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.SEASONALITY({1E-307,2E-307,3E-307},{45655,45656,45657},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.SEASONALITY({1E-307,2E-307,3E-307},{45655,45656,45657},2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid array sizes (3 elements) with smallest valid values, all optional arguments used. 6 of 6 arguments used.');

		// TODO critical err and many problem in calc in this function
		// Need to fix: 3D arguments handle, error type diff, ms result diff
		// Case #1: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used.
		// Case #2: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used.
		// Case #3: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used.
		// Case #4: String. String inputs convertible to date and arrays. 3 of 6 arguments used.
		// Case #5: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used.
		// Case #7: Array. Array with single element for target_date. 3 of 6 arguments used.
		// Case #8: Name. Named range for target_date. 3 of 6 arguments used.
		// Case #9: Name3D. 3D named range for target_date. 3 of 6 arguments used. - critical
		// Case #10: Ref3D. 3D reference for target_date. 3 of 6 arguments used. - critical
		// Case #11: Area3D. 3D range with 3 cells for target_date. 3 of 6 arguments used.
		// Case #16: Formula. target_date as formula with float. 3 of 6 arguments used.


	});

	QUnit.test("Test: \"FORECAST.ETS.STAT\"", function (assert) {
		//результаты данного теста соответсвуют результатам LO, но отличаются от MS!!!

		putDataForForecastEts();

		oParser = new parserFormula("FORECAST.ETS.STAT(B4:B60,A4:A60,1,1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.65234375);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("Dates");
		ws.getRange2("A101").setValue("43466");
		ws.getRange2("A102").setValue("43497");
		ws.getRange2("A103").setValue("43525");
		ws.getRange2("A104").setValue("43556");
		ws.getRange2("A105").setValue("43586");
		ws.getRange2("A106").setValue("43617");
		ws.getRange2("A107").setValue("43647");
		ws.getRange2("A108").setValue("43678");
		ws.getRange2("A109").setValue("43709");
		ws.getRange2("A110").setValue("43739");
		ws.getRange2("A111").setValue("43770");
		ws.getRange2("A112").setValue("43800");
		ws.getRange2("A113").setValue("43831");
		ws.getRange2("A114").setValue("43862");

		ws.getRange2("B100").setValue("Values");
		ws.getRange2("B101").setValue("1000");
		ws.getRange2("B102").setValue("1100");
		ws.getRange2("B103").setValue("1200");
		ws.getRange2("B104").setValue("1500");
		ws.getRange2("B105").setValue("2100");
		ws.getRange2("B106").setValue("2000");
		ws.getRange2("B107").setValue("2200");
		ws.getRange2("B108").setValue("2300");
		ws.getRange2("B109").setValue("2400");
		ws.getRange2("B110").setValue("2650");
		ws.getRange2("B111").setValue("2789");
		ws.getRange2("B112").setValue("3000");
		ws.getRange2("B113").setValue("2999");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("Text"); // Text (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30,50},{45658,45659,45660,45661},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30,50},{45658,45659,45660,45661},1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Date,Number. Basic valid input: date for target_date, arrays with 3 elements for values and timeline. 3 of 6 arguments used.');
		// Case #2: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(B101:B113,A101:A113,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(B101:B113,A101:A113,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.250593799, 'Test: Positive case: Number,Area. Area with 3 cells for values and timeline, numeric target_date. 3 of 6 arguments used.');
		// Case #3: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30,50},{45658,45659,45660,45661},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30,50},{45658,45659,45660,45661},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.001, 'Test: Positive case: Formula,Number. target_date as formula resolving to date. 3 of 6 arguments used.');
		// Case #4: String. String inputs convertible to date and arrays. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30,50},{45658,45659,45660,45661},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30,50},{45658,45659,45660,45661},3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.22045e-16, 'Test: Positive case: String. String inputs convertible to date and arrays. 3 of 6 arguments used.');
		// Case #5: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time,Number. target_date as Time adjusted to valid number. 3 of 6 arguments used.');
		// Case #6: Reference link,Area,Area. Reference link for target_date, areas with 3 cells for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(B101:B106,A101:A106,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(B101:B106,A101:A106,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.668441217, 'Test: Positive case: Reference link,Area,Area. Reference link for target_date, areas with 3 cells for values and timeline. 3 of 6 arguments used.');
		// Case #7: Array. Array with single element for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30,60},{45655,45656,45657,45658},5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30,60},{45655,45656,45657,45658},5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.170589907, 'Test: Positive case: Array. Array with single element for target_date. 3 of 6 arguments used.');
		// Case #8: Name. Named range for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(A101:A110,A101:A110,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(A101:A110,A101:A110,6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.571777347, 'Test: Positive case: Name. Named range for target_date. 3 of 6 arguments used.');
		// Case #9: Name3D. 3D named range for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(A101:A110,A101:A110,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(A101:A110,A101:A110,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.796966619, 'Test: Positive case: Name3D. 3D named range for target_date. 3 of 6 arguments used.');
		// Case #10: Ref3D. 3D reference for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(A101:A103,A104:A106,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(A101:A103,A104:A106,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.1, 'Test: Positive case: Ref3D. 3D reference for target_date. 3 of 6 arguments used.');
		// Case #11: Area3D. 3D range with 3 cells for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(A101:A103,A104:A106,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(A101:A103,A104:A106,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Area3D. 3D range with 3 cells for target_date. 3 of 6 arguments used.');
		// Case #12: Table. Table structured reference with 3 elements. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(Table1[Column2],Table1[Column3],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(Table1[Column2],Table1[Column3],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured reference with 3 elements. 3 of 6 arguments used.');
		// Case #13: Number. Seasonality set to 1 (auto-detect). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30,44},{45654,45655,45656,45657},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30,44},{45654,45655,45656,45657},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.001, 'Test: Positive case: Number. Seasonality set to 1 (auto-detect). 4 of 6 arguments used.');
		// Case #14: Number. No seasonality (0), data_completion = 1. 5 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30,46},{45655,45656,45657,45658},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30,46},{45655,45656,45657,45658},1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Number. No seasonality (0), data_completion = 1. 5 of 6 arguments used.');
		// Case #15: Number. Aggregation set to 2 (SUM). 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30,46},{45655,45656,45657,45658},1,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30,46},{45655,45656,45657,45658},1,2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Number. Aggregation set to 2 (SUM). 6 of 6 arguments used.');
		// Case #16: Formula. target_date as formula with float. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(B101:B113,A101:A113,1,1,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(B101:B113,A101:A113,1,1,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.9, 'Test: Positive case: Formula. target_date as formula with float. 3 of 6 arguments used.');
		// Case #17: Formula,Number. Nested IF for target_date, specific seasonality (2). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(B101:B113,A101:A113,3,1,0,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(B101:B113,A101:A113,3,1,0,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.22045e-16, 'Test: Positive case: Formula,Number. Nested IF for target_date, specific seasonality (2). 4 of 6 arguments used.');
		// Case #18: Number. Larger arrays with 5 elements for values and timeline. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30,40,59},{45653,45654,45655,45656,45657},8,,0,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30,40,59},{45653,45654,45655,45656,45657},8,,0,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Larger arrays with 5 elements for values and timeline. 3 of 6 arguments used.');
		// Case #19: String. Float strings convertible to numbers, seasonality = 1. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10.5,20.5,30.5},{"01/01/2025","01/02/2025","01/03/2025"},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10.5,20.5,30.5},{"01/01/2025","01/02/2025","01/03/2025"},1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Float strings convertible to numbers, seasonality = 1. 4 of 6 arguments used.');
		// Case #20: Formula,Number. FORECAST.ETS inside SUM formula. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,300},{45655,45656,45657},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,300},{45655,45656,45657},4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.372103448, 'Test: Positive case: Formula,Number. FORECAST.ETS inside SUM formula. 3 of 6 arguments used.');
		// Case #21: Array. Array with multiple elements for target_date. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,350,620},{45655,45656,45657,45658},8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,350,620},{45655,45656,45657,45658},8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Array with multiple elements for target_date. 3 of 6 arguments used.');
		// Case #22: Number. Maximum valid seasonality (8760), data_completion = 1, aggregation = 6 (MEDIAN). 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,60},{45655,45656,45657},1,1,1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,60},{45655,45656,45657},1,1,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9990234375, 'Test: Positive case: Number. Maximum valid seasonality (8760), data_completion = 1, aggregation = 6 (MEDIAN). 6 of 6 arguments used.');

		// Negative cases:
		// Case #1: Date,Number. target_date equals timeline start returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45658,45658,45658},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45658,45658,45658},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date,Number. target_date equals timeline start returns #NUM!. 3 of 6 arguments used.');
		// Case #2: Empty,Number. target_date is empty returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(,{45655,45656,45657},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(,{45655,45656,45657},1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty,Number. target_date is empty returns #VALUE!. 3 of 6 arguments used.');
		// Case #3: Number,Empty. values is empty returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(,{45655,45656,45657},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(,{45655,45656,45657},) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. values is empty returns #N/A. 3 of 6 arguments used.');
		// Case #4: Number,Empty. timeline is empty returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},,1) is parsed.');
		//?	 assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. timeline is empty returns #N/A. 3 of 6 arguments used.');
		// Case #5: String. target_date as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},"0.1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},"0.1","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. target_date as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #6: Number,String. values as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({"123","456s",789},{45655,45656,45657},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({"123","456s",789},{45655,45656,45657},1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number,String. values as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #7: Number,String. timeline as non-numeric string returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{"abc","def","ghi"},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{"abc","def","ghi"},1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number,String. timeline as non-numeric string returns #VALUE!. 3 of 6 arguments used.');
		// Case #8: Error,Number. target_date as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number. target_date as error returns #N/A. 3 of 6 arguments used.');
		// Case #9: Number,Error. values as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(1/0,{45655,45656,45657},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(1/0,{45655,45656,45657},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number,Error. values as error returns #N/A. 3 of 6 arguments used.');
		// Case #10: Number,Error. timeline as error returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. timeline as error returns #N/A. 3 of 6 arguments used.');
		// Case #11: Number. Duplicate values in timeline returns #VALUE!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45655,45655,45656},"s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45655,45655,45656},"s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Duplicate values in timeline returns #VALUE!. 3 of 6 arguments used.');
		// Case #12: Number. Inconsistent step in timeline returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45655,45656,45658},1.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45655,45656,45658},1.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Inconsistent step in timeline returns #NUM!. 3 of 6 arguments used.');
		// Case #13: Number,Area. Mismatched range sizes (3 vs 2 cells) for values and timeline returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT(A100:A102,A100:A102,A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(A100:A102,A100:A102,A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Area. Mismatched range sizes (3 vs 2 cells) for values and timeline returns #N/A. 3 of 6 arguments used.');
		// Case #14: Formula,Number. target_date as formula returning #NUM! returns #NUM!. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},0.009)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},0.009) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Number. target_date as formula returning #NUM! returns #NUM!. 3 of 6 arguments used.');
		// Case #15: Ref3D. 3D ref to non-numeric value returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.STAT(A101:A103,A104:A106,Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(A101:A103,A104:A106,Sheet2!A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.1, 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!.');
		// Case #16: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.STAT(A101:A103,A104:A106,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(A101:A103,A104:A106,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #17: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.STAT(A101:A103,A104:A106,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(A101:A103,A104:A106,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #18: Table. Table column with non-numeric data returns #VALUE!.
		oParser = new parserFormula('FORECAST.ETS.STAT(Table1[Column2],Table1[Column3],Table1[Column6])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT(Table1[Column2],Table1[Column3],Table1[Column6]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with non-numeric data returns #VALUE!.');
		// Case #19: Number. Mismatched array sizes (4 vs 3) for values and timeline returns #N/A. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30,40},{45655,45656,45657},1,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30,40},{45655,45656,45657},1,0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Mismatched array sizes (4 vs 3) for values and timeline returns #N/A. 3 of 6 arguments used.');
		// Case #20: Number. Negative seasonality returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative seasonality returns #NUM!. 4 of 6 arguments used.');
		// Case #21: Number. Seasonality > 8760 returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},8761)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},8761) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Seasonality > 8760 returns #NUM!. 4 of 6 arguments used.');
		// Case #22: Number. Non-integer seasonality returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},1,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({10,20,30},{45655,45656,45657},1,1.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Non-integer seasonality returns #NUM!. 4 of 6 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid positive values for target_date and arrays, consistent timeline step. 3 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({1E-307,2E-307,3E-307,3E-307},{1,2,3,4},1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({1E-307,2E-307,3E-307,3E-307},{1,2,3,4},1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9990234375, 'Test: Bounded case: Number. Minimum valid positive values for target_date and arrays, consistent timeline step. 3 of 6 arguments used.');
		// Case #2: Number. Maximum valid Excel number for target_date and arrays, maximum valid seasonality (8760). 4 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({1E+307,2E+307,3E+307},{1,2,3},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({1E+307,2E+307,3E+307},{1,2,3},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9990234375, 'Test: Bounded case: Number. Maximum valid Excel number for target_date and arrays, maximum valid seasonality (8760). 4 of 6 arguments used.');
		// Case #3: Number. Minimum valid array sizes (3 elements) with smallest valid values, all optional arguments used. 6 of 6 arguments used.
		oParser = new parserFormula('FORECAST.ETS.STAT({1E-307,2E-307,3E-307},{45655,45656,45657},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.ETS.STAT({1E-307,2E-307,3E-307},{45655,45656,45657},2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.001, 'Test: Bounded case: Number. Minimum valid array sizes (3 elements) with smallest valid values, all optional arguments used. 6 of 6 arguments used.');


		// TODO: ScETSForecastCalculation.prototype.prefillTrendData - добавить округление числа в this.mnSmplInPrd
		// TODO множество расхождений в результатах в этой функции. Нужно пересмотреть алгоритм расчета для того набора данных что используется в тестах
		// Need to fix: error types diff, MS result diff, array missmatch, Case #19 problem in tests

	});

	QUnit.test("Test: \"FORECAST.LINEAR\"", function (assert) {
		oParser = new parserFormula("FORECAST(30,{6,7,9,15,21},{20,28,31,38,40})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(13) - 0, 10.6072530864198);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("5");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A104").setValue("1");
		// For area
		ws.getRange2("A102").setValue("20");
		ws.getRange2("A103").setValue("30");
		ws.getRange2("A105").setValue("5");
		ws.getRange2("A106").setValue("10");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("20"); // Num (Column3)
		ws.getRange2("D601").setValue("30"); // Num (Column4)
		ws.getRange2("E601").setValue("1"); // Num (Column5)
		ws.getRange2("F601").setValue("5"); // Num (Column6)

		// 3D links. Use A1:Z10
		ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: number for x, arrays with 3 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Basic valid input: number for x, arrays with 3 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #2: Number,Area. Area with 3 cells for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,A100:A102,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13.93387314439946, 'Test: Positive case: Number,Area. Area with 3 cells for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #3: Formula,Number. x as formula resolving to number. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(SQRT(25),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(SQRT(25),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Formula,Number. x as formula resolving to number. 3 of 3 arguments used.');
		// Case #4: String. String inputs convertible to number and arrays. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR("5","{10,20,30}","{1,2,3}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR("5","{10,20,30}","{1,2,3}") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String inputs convertible to number and arrays. 3 of 3 arguments used.');
		// Case #5: Date,Number. x as Date (serial number). 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(DATE(2025,1,1),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(DATE(2025,1,1),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 456580, 'Test: Positive case: Date,Number. x as Date (serial number). 3 of 3 arguments used.');
		// Case #6: Time,Number. x as Time adjusted to valid number. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(TIME(12,0,0)+5,{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(TIME(12,0,0)+5,{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 55, 'Test: Positive case: Time,Number. x as Time adjusted to valid number. 3 of 3 arguments used.');
		// Case #7: Reference link. Reference link for x, areas with 3 cells for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(A100,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(A100,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 19.262295081967213, 'Test: Positive case: Reference link. Reference link for x, areas with 3 cells for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #8: Array. Array with single element for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR({5},{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR({5},{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Array. Array with single element for x. 3 of 3 arguments used.');
		// Case #9: Name. Named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(TestName,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(TestName,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.090163934426233, 'Test: Positive case: Name. Named range for x. 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(TestName3D,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(TestName3D,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.090163934426233, 'Test: Positive case: Name3D. 3D named range for x. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(Sheet2!A1,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(Sheet2!A1,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.409836065573773, 'Test: Positive case: Ref3D. 3D reference for x. 3 of 3 arguments used.');
		// Case #12: Area3D. 3D range with 3 cells for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(Sheet2!A1:A3,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(Sheet2!A1:A3,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.409836065573773, 'Test: Positive case: Area3D. 3D range with 3 cells for x. 3 of 3 arguments used.');
		// Case #13: Table. Table structured reference with 3 elements. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Table. Table structured reference with 3 elements. 3 of 3 arguments used.');
		// Case #14: Number,Formula. known_y\'s as formula resolving to array. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,SUM({10,20,30}),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,SUM({10,20,30}),{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Formula. known_y\'s as formula resolving to array. 3 of 3 arguments used.');
		// Case #15: Formula. x as nested IF formula. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(IF(TRUE,5,0),A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(IF(TRUE,5,0),A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 19.262295081967213, 'Test: Positive case: Formula. x as nested IF formula. 3 of 3 arguments used.');
		// Case #16: Number. Larger arrays with 4 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,{10,20,30,40},{1,2,3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,{10,20,30,40},{1,2,3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Larger arrays with 4 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #17: String. Float strings convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR("5.5","{10.5,20.5,30.5}","{1.5,2.5,3.5}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR("5.5","{10.5,20.5,30.5}","{1.5,2.5,3.5}") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Float strings convertible to numbers. 3 of 3 arguments used.');
		// Case #18: Formula. x as formula with float. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(ROUND(5.5,0),A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(ROUND(5.5,0),A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21.475409836065573, 'Test: Positive case: Formula. x as formula with float. 3 of 3 arguments used.');
		// Case #19: Number. Smaller arrays with 2 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,{10,20},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,{10,20},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Smaller arrays with 2 elements for known_y\'s and known_x\'s. 3 of 3 arguments used.');
		// Case #20: Formula. Multiple nested formulas. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(SQRT(25),IF(TRUE,{10,20,30},{0,0,0}),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(SQRT(25),IF(TRUE,{10,20,30},{0,0,0}),{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Formula. Multiple nested formulas. 3 of 3 arguments used.');
		// Case #21: Formula,Number. FORECAST.LINEAR inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(FORECAST.LINEAR(5,{10,20,30},{1,2,3}),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(FORECAST.LINEAR(5,{10,20,30},{1,2,3}),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 60, 'Test: Positive case: Formula,Number. FORECAST.LINEAR inside SUM formula. 3 of 3 arguments used.');
		// Case #22: Array. Array with multiple elements for x. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR({5,6},{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR({5,6},{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Array. Array with multiple elements for x. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. known_y\'s and known_x\'s arrays of different lengths returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,{10,20,30},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,{10,20,30},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. known_y\'s and known_x\'s arrays of different lengths returns #N/A. 3 of 3 arguments used.');
		// Case #2: Empty,Number. x is empty returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(,{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(,{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty,Number. x is empty returns #VALUE!. 3 of 3 arguments used.');
		// Case #3: Number,Empty. known_y\'s is empty returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,,{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. known_y\'s is empty returns #N/A. 3 of 3 arguments used.');
		// Case #4: Number,Empty. known_x\'s is empty returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,{10,20,30},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,{10,20,30},) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Empty. known_x\'s is empty returns #N/A. 3 of 3 arguments used.');
		// Case #5: String. x as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR("abc",{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR("abc",{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. x as non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Number,String. known_y\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,"{abc,def,ghi}","{1,2,3}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,"{abc,def,ghi}","{1,2,3}") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number,String. known_y\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Number,String. known_x\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,{10,20,30},"{abc,def,ghi}")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,{10,20,30},"{abc,def,ghi}") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,String. known_x\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Error,Number. x as error returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(NA(),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(NA(),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number. x as error returns #N/A. 3 of 3 arguments used.');
		// Case #9: Number,Error. known_y\'s as error returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,NA(),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,NA(),{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. known_y\'s as error returns #N/A. 3 of 3 arguments used.');
		// Case #10: Number,Error. known_x\'s as error returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,{10,20,30},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,{10,20,30},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. known_x\'s as error returns #N/A. 3 of 3 arguments used.');
		// Case #11: Number. Zero variance in known_x\'s returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,{10,20,30},{1,1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,{10,20,30},{1,1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Zero variance in known_x\'s returns #DIV/0!. 3 of 3 arguments used.');
		// Case #12: Number,Area. Mismatched range sizes (3 vs 2 cells) for known_y\'s and known_x\'s returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,A100:A102,A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area. Mismatched range sizes (3 vs 2 cells) for known_y\'s and known_x\'s returns #N/A. 3 of 3 arguments used.');
		// Case #13: Formula,Number. x as formula returning #NUM! returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(SQRT(-1),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(SQRT(-1),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Number. x as formula returning #NUM! returns #NUM!. 3 of 3 arguments used.');
		// Case #14: Ref3D. 3D ref to non-numeric value returns #VALUE!.
		oParser = new parserFormula('FORECAST.LINEAR(Sheet2!A2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(Sheet2!A2,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.622950819672134, 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!.');
		// Case #15: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.LINEAR(TestNameArea2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(TestNameArea2,A101:A103,A104:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10.40983607, 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #16: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('FORECAST.LINEAR(TestNameArea3D2,A101:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(TestNameArea3D2,A101:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.9672131147541, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #17: Table. Table column with non-numeric data returns #VALUE!.
		oParser = new parserFormula('FORECAST.LINEAR(Table1[Column2],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(Table1[Column2],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with non-numeric data returns #VALUE!.');
		// Case #18: Number,Area. Range with more than 3 cells for known_y\'s returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,A100:A103,A104:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,A100:A103,A104:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area. Range with more than 3 cells for known_y\'s returns #N/A. 3 of 3 arguments used.');
		// Case #19: Boolean,Number. x as boolean (TRUE as 1) returns valid result but may be unexpected. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(TRUE,{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(TRUE,{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Boolean,Number. x as boolean (TRUE as 1) returns valid result but may be unexpected. 3 of 3 arguments used.');
		// Case #20: Time,Number. x as Time (0.5) returns valid result but may be unexpected. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(TIME(12,0,0),{10,20,30},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(TIME(12,0,0),{10,20,30},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Time,Number. x as Time (0.5) returns valid result but may be unexpected. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid positive values for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(2.2E-308,{1E-307,2E-307,3E-307},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(2.2E-308,{1E-307,2E-307,3E-307},{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid positive values for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid Excel number for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(9.99999999999999E+307,{1E+307,2E+307,3E+307},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(9.99999999999999E+307,{1E+307,2E+307,3E+307},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used.');
		// Case #3: Number. Minimum valid array sizes (2 elements) with smallest valid values. 3 of 3 arguments used.
		oParser = new parserFormula('FORECAST.LINEAR(5,{1E-307,2E-307},{1E-307,2E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FORECAST.LINEAR(5,{1E-307,2E-307},{1E-307,2E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Minimum valid array sizes (2 elements) with smallest valid values. 3 of 3 arguments used.');

		// Need to fix: diff in some cases results
		// Case #4: String. String inputs convertible to number and arrays. 3 of 3 arguments used.
		// Case #14: Number,Formula. known_y\'s as formula resolving to array. 3 of 3 arguments used.
		// Case #17: String. Float strings convertible to numbers. 3 of 3 arguments used.
		// Case #20: Formula. Multiple nested formulas. 3 of 3 arguments used. - result diff
		// Case #6: Number,String. known_y\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		// Case #7: Number,String. known_x\'s as non-numeric string returns #VALUE!. 3 of 3 arguments used.
		// Case #15: Name. Named range with text returns #VALUE!. - result diff
		// Case #1: Number. Minimum valid positive values for x and arrays, non-zero variance in known_x\'s. 3 of 3 arguments used. - result diff

	});

	QUnit.test("Test: \"FREQUENCY\"", function (assert) {

		ws.getRange2("A202").setValue("79");
		ws.getRange2("A203").setValue("85");
		ws.getRange2("A204").setValue("78");
		ws.getRange2("A205").setValue("85");
		ws.getRange2("A206").setValue("50");
		ws.getRange2("A207").setValue("81");
		ws.getRange2("A208").setValue("95");
		ws.getRange2("A209").setValue("88");
		ws.getRange2("A210").setValue("97");

		ws.getRange2("B202").setValue("70");
		ws.getRange2("B203").setValue("89");
		ws.getRange2("B204").setValue("79");

		ws.getRange2("C202").setValue("234");
		ws.getRange2("C203").setValue("4");

		var a;
		oParser = new parserFormula("FREQUENCY(A202:A210,B202:B204)", "A201", ws);
		assert.ok(oParser.parse());
		a = oParser.calculate();
		assert.strictEqual(a.getElementRowCol(0, 0).getValue(), 1);
		assert.strictEqual(a.getElementRowCol(1, 0).getValue(), 2);
		assert.strictEqual(a.getElementRowCol(2, 0).getValue(), 4);
		assert.strictEqual(a.getElementRowCol(3, 0).getValue(), 2);

		oParser = new parserFormula("FREQUENCY(A202:C202,A203:C203)", "A201", ws);
		assert.ok(oParser.parse());
		a = oParser.calculate();
		assert.strictEqual(a.getElementRowCol(0, 0).getValue(), 0);
		assert.strictEqual(a.getElementRowCol(1, 0).getValue(), 2);
		assert.strictEqual(a.getElementRowCol(2, 0).getValue(), 0);
		assert.strictEqual(a.getElementRowCol(3, 0).getValue(), 1);

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: numeric array for data_array and bins_array. Returns {2,2,1}.
		oParser = new parserFormula('FREQUENCY({1,2,3,4,5},{2,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2,3,4,5},{2,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Number. Basic valid input: numeric array for data_array and bins_array. Returns {2,2,1}.');
		// Case #2: Number. Numeric array with larger values. Returns {1,1,1}.
		oParser = new parserFormula('FREQUENCY({10,20,30},{15,25})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({10,20,30},{15,25}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Numeric array with larger values. Returns {1,1,1}.');
		// Case #3: String. String convertible to numbers in both arrays. Returns {2,1,0}.
		oParser = new parserFormula('FREQUENCY({"1","2","3"},{"2"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({"1","2","3"},{"2"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: String. String convertible to numbers in both arrays. Returns {2,1,0}.');
		// Case #4: Formula. Nested formula evaluating to numbers in data_array and bins_array. Returns {1,2,0}.
		oParser = new parserFormula('FREQUENCY({1,3,4},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,3,4},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Formula. Nested formula evaluating to numbers in data_array and bins_array. Returns {1,2,0}.');
		// Case #5: Reference link. Reference to cells with valid numbers. Returns {1,0}.
		oParser = new parserFormula('FREQUENCY(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Reference link. Reference to cells with valid numbers. Returns {1,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Reference link. Reference to cells with valid numbers. Returns {1,0}.');
		// Case #6: Area. Single-cell range for both arguments. Returns {1,1,0}.
		oParser = new parserFormula('FREQUENCY(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Area. Single-cell range for both arguments. Returns {1,1,0}.');
		// Case #7: Array. Array with multiple elements. Returns {1,2,0}.
		oParser = new parserFormula('FREQUENCY({1,2,3},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2,3},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Array with multiple elements. Returns {1,1,1}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Test: Positive case: Array. Array with multiple elements. Returns {1,1,1}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 1, 'Test: Positive case: Array. Array with multiple elements. Returns {1,1,1}.');
		// Case #8: Name. Named range with valid numbers. Returns {2,1,0}.
		oParser = new parserFormula('FREQUENCY(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Name. Named range with valid numbers. Returns {1,0}.');
		// Case #9: Name3D. 3D named range with valid numbers. Returns {2,1,0}.
		oParser = new parserFormula('FREQUENCY(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Name3D. 3D named range with valid numbers. Returns {1,0}.');
		// Case #10: Ref3D. 3D reference to cells with valid numbers. Returns {2,1,0}.
		oParser = new parserFormula('FREQUENCY(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. Returns {1,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. Returns {1,0}.');
		// Case #11: Area3D. 3D single-cell range. Returns {1,1,0}.
		oParser = new parserFormula('FREQUENCY(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range. Returns {0,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), "", 'Test: Positive case: Area3D. 3D single-cell range. Returns {0,0}.');
		// Case #12: Table. Table structured reference with valid numbers in column.
		oParser = new parserFormula('FREQUENCY(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid numbers. Returns {1,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Table. Table structured reference with valid numbers. Returns {1,0}.');
		// Case #13: Date. Date serial numbers as numbers. Returns {4,0}.
		oParser = new parserFormula('FREQUENCY({45.58,45,68,9},{45672})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({45.58,45,68,9},{45672}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 4, 'Test: Positive case: Date. Date serial numbers as numbers. Returns {4,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Date. Date serial numbers as numbers. Returns {4,0}.');
		// Case #14: Time. Time adjusted to valid numbers (>1). Returns {3,1}.
		oParser = new parserFormula('FREQUENCY({1.5,2.5,3.5,10.5},{4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1.5,2.5,3.5,10.5},{4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Positive case: Time. Time adjusted to valid numbers (>1). Returns {3,1}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Test: Positive case: Time. Time adjusted to valid numbers (>1). Returns {3,1}.');
		// Case #15: Formula. Nested IF returning valid numbers. Returns {1,0}.
		oParser = new parserFormula('FREQUENCY(IF(TRUE,2,1),IF(TRUE,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(IF(TRUE,2,1),IF(TRUE,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Formula. Nested IF returning valid numbers. Returns {1,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Formula. Nested IF returning valid numbers. Returns {1,0}.');
		// Case #16: Number. Value slightly above 1 in data_array. Returns {1,1}.
		oParser = new parserFormula('FREQUENCY({1.000000000000001,2},{1.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1.000000000000001,2},{1.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Value slightly above 1 in data_array. Returns {1,1}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Test: Positive case: Number. Value slightly above 1 in data_array. Returns {1,1}.');
		// Case #17: String. String convertible to float numbers. Returns {0,0}.
		oParser = new parserFormula('FREQUENCY({"1.5","2.5"},{"1.75"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({"1.5","2.5"},{"1.75"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: String. String convertible to float numbers. Returns {0,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: String. String convertible to float numbers. Returns {0,0}.');
		// Case #18: Array. Multi-element arrays for both arguments. Returns {1,1,1,1}.
		oParser = new parserFormula('FREQUENCY({1,2,3,4},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2,3,4},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Multi-element arrays for both arguments. Returns {1,1,1,1}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Test: Positive case: Array. Multi-element arrays for both arguments. Returns {1,1,1,1}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 1, 'Test: Positive case: Array. Multi-element arrays for both arguments. Returns {1,1,1,1}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(3,0).getValue(), 1, 'Test: Positive case: Array. Multi-element arrays for both arguments. Returns {1,1,1,1}.');
		// Case #19: Number. Zero and positive numbers in data_array. Returns {2,1}.
		oParser = new parserFormula('FREQUENCY({0,1,2},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({0,1,2},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Number. Zero and positive numbers in data_array. Returns {2,1}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 1, 'Test: Positive case: Number. Zero and positive numbers in data_array. Returns {2,1}.');
		// Case #20: Array, Array. -1 in bins array. Returns {0,6}.
		oParser = new parserFormula('FREQUENCY({2,2,2,2,2,2},{-1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({2,2,2,2,2,2},{-1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array, Array. -1 in bins array. Returns {0,6}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 6, 'Test: Positive case: Array, Array. -1 in bins array. Returns {0,6}.');
		// Case #21: Array. Array with duplicate values. Returns {2,0,2,0}.
		oParser = new parserFormula('FREQUENCY({10,10,20,20},{10,15,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({10,10,20,20},{10,15,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Array. Array with duplicate values. Returns {2,0,2,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Array. Array with duplicate values. Returns {2,0,2,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 2, 'Test: Positive case: Array. Array with duplicate values. Returns {2,0,2,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(3,0).getValue(), 0, 'Test: Positive case: Array. Array with duplicate values. Returns {2,0,2,0}.');
		// Case #22: Empty. Empty data_array returns array of zeros. Returns {0,0}.
		oParser = new parserFormula('FREQUENCY({""},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({""},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Empty. Empty data_array returns array of zeros. Returns {0,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Empty. Empty data_array returns array of zeros. Returns {0,0}.');
		// Case #23: Empty. Empty bins_array returns count of data_array elements. Returns {0,3}.
		oParser = new parserFormula('FREQUENCY({1,2,3},{""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2,3},{""}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Empty string. Empty string in bins_array returns count of data_array elements. Returns {0,3}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 3, 'Test: Positive case: Empty string. Empty string in bins_array returns count of data_array elements. Returns {0,3}.');
		// Case #24: Array, array. String in bins_array.
		oParser = new parserFormula('FREQUENCY({0,2,3,0},{"E"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({0,2,3,0},{"E"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Array, array. String in bins_array.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 2, 'Test: Positive case: Array, array. String in bins_array.');
		// Case #25: Array, number. Empty string in first array
		oParser = new parserFormula('FREQUENCY({""},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({""},0) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array, number. Empty string in first array.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Array, number. Empty string in first array.');
		// Case #26: Array, number. Bool in first array.
		oParser = new parserFormula('FREQUENCY({TRUE},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({TRUE},0) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Array, number. Bool in first array.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Positive case: Array, number. Bool in first array.');


		// Negative cases:
		// Case #1: Number. Negative numbers in data_array are counted. Returns {3,0,0}.
		oParser = new parserFormula('FREQUENCY({-1,-2,-3},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({-1,-2,-3},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Negative case: Number. Negative numbers in data_array are counted. Returns {3,0,0}.');
		// Case #2: String. Non-numeric strings in data_array ignored. Returns {0,0}.
		oParser = new parserFormula('FREQUENCY({"abc","def"},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({"abc","def"},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: String. Non-numeric strings in data_array ignored. Returns {0,0}.');
		// Case #3: Error. Error in data_array propagates #N/A. Returns #N/A.
		oParser = new parserFormula('FREQUENCY(NA(),{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(NA(),{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in data_array propagates #N/A. Returns #N/A.');
		// Case #4: Area. Multi-cell range for data_array returns #N/A.
		oParser = new parserFormula('FREQUENCY(A102:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(A102:A103,A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Negative case: Area. Multi-cell range for data_array returns #N/A.');
		// Case #5: Empty. Empty cell reference for data_array returns {1,0}.
		oParser = new parserFormula('FREQUENCY(A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Empty. Empty cell reference for data_array returns {1,0}.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 0, 'Test: Negative case: Empty. Empty cell reference for data_array returns {1,0}.');
		// Case #6: String. Empty string in data_array ignored. Returns {0,0}.
		oParser = new parserFormula('FREQUENCY({""},{"1"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({""},{"1"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: String. Empty string in data_array ignored. Returns {0,0}.');
		// Case #7: Boolean. Boolean values (0,1) in data_array counted. Returns {0,0}.
		oParser = new parserFormula('FREQUENCY({FALSE,TRUE},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({FALSE,TRUE},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Boolean. Boolean values (0,1) in data_array counted. Returns {0,0}.');
		// Case #8: Ref3D. 3D ref to empty values.
		oParser = new parserFormula('FREQUENCY(Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Ref3D. 3D ref to empty values.');
		// Case #9: Name. Named range with multi-cell area.
		oParser = new parserFormula('FREQUENCY(TestNameArea2,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(TestNameArea2,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Name. Named range with multi-cell area');
		// Case #11: Formula. Formula resulting in #NUM! propagates error. Returns #NUM.
		oParser = new parserFormula('FREQUENCY(SQRT(-1),{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(SQRT(-1),{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. Returns #N/A.');
		// Case #12: Number. Zero in bins_array is valid but counts correctly. Returns {1,1}.
		oParser = new parserFormula('FREQUENCY({0,1},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({0,1},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Number. Zero in bins_array is valid but counts correctly. Returns {2,0,0}.');
		// Case #13: Array. Boolean in bins_array treated as 0. Returns {2,0,0}.
		oParser = new parserFormula('FREQUENCY({1,2},{FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2},{FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Array. Boolean in bins_array treated as 0. Returns {2,0,0}.');
		// Case #14: Number. Negative value in bins_array is valid but counts correctly. Returns {2,0,0}.
		oParser = new parserFormula('FREQUENCY({1,2},{-1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2},{-1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Number. Negative value in bins_array is valid but counts correctly. Returns {2,0,0}.');
		// Case #15: String. Non-numeric string in bins_array ignored, returns #VALUE!.
		oParser = new parserFormula('FREQUENCY({1,2},{"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2},{"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: String. Non-numeric string in bins_array ignored, returns #VALUE!.');
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 2, 'Test: Negative case: String. Non-numeric string in bins_array ignored, returns #VALUE!.');
		// Case #16: Area3D. Multi-cell 3D range for data_array returns #N/A.
		oParser = new parserFormula('FREQUENCY(Sheet2!A7:A8,Sheet2!A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(Sheet2!A7:A8,Sheet2!A9) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Area3D. Multi-cell 3D range for data_array.');
		// Case #17: Name3D. 3D named range with multi-cell area.
		oParser = new parserFormula('FREQUENCY(TestNameArea3D2,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY(TestNameArea3D2,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Name3D. 3D named range with multi-cell area.');
		// Case #18: Time. Time value (0.5) in data_array counted. Returns {2,0}.
		oParser = new parserFormula('FREQUENCY({0.5,0.5},{0.6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({0.5,0.5},{0.6}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Negative case: Time. Time value (0.5) in data_array counted. Returns {2,0}.');
		// Case #19: Date. Negative date serial number counted. Returns {2,0,0}.
		oParser = new parserFormula('FREQUENCY({-45658,1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({-45658,1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Negative case: Date. Negative date serial number counted. Returns {2,0,0}.');
		// Case #20: Error. Error in bins_array propagates #N/A. Returns #N/A.
		oParser = new parserFormula('FREQUENCY({1,2},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in bins_array propagates #N/A. Returns #N/A.');

		// Bounded cases:
		// Case #1: Number. Maximum Excel number in data_array. Returns {1,1,0}.
		oParser = new parserFormula('FREQUENCY({1.79769313486232E+307,1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1.79769313486232E+307,1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Number. Maximum Excel number in data_array. Returns {1,1,0}.');
		// Case #2: Number. Minimum Excel number in data_array. Returns {1,1,0}.
		oParser = new parserFormula('FREQUENCY({-1.79769313486232E+307,1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({-1.79769313486232E+307,1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Bounded case: Number. Minimum Excel number in data_array. Returns {1,1,0}.');
		// Case #3: Number. Maximum Excel number in bins_array. Returns {2,0,0}.
		oParser = new parserFormula('FREQUENCY({1,2},{1.79769313486232E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2},{1.79769313486232E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Bounded case: Number. Maximum Excel number in bins_array. Returns {2,0,0}.');
		// Case #4: Number. Minimum Excel number in bins_array. Returns {2,0,0}.
		oParser = new parserFormula('FREQUENCY({1,2},{-1.79769313486232E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FREQUENCY({1,2},{-1.79769313486232E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Bounded case: Number. Minimum Excel number in bins_array. Returns {2,0,0}.');

	});

	function fTestFormulaTest(assert) {
		ws.getRange2("A2").setValue("6");
		ws.getRange2("A3").setValue("7");
		ws.getRange2("A4").setValue("9");
		ws.getRange2("A5").setValue("15");
		ws.getRange2("A6").setValue("21");

		ws.getRange2("B2").setValue("20");
		ws.getRange2("B3").setValue("28");
		ws.getRange2("B4").setValue("31");
		ws.getRange2("B5").setValue("38");
		ws.getRange2("B6").setValue("40");

		oParser = new parserFormula("FTEST(A2:A6,B2:B6)", "A1", ws);
		assert.ok(oParser.parse(), "FTEST(A2:A6,B2:B6)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.64831785, "FTEST(A2:A6,B2:B6)");

		oParser = new parserFormula("FTEST(A2,B2:B6)", "A1", ws);
		assert.ok(oParser.parse(), "FTEST(A2,B2:B6)");
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", "FTEST(A2,B2:B6)");

		oParser = new parserFormula("FTEST(1,B2:B6)", "A1", ws);
		assert.ok(oParser.parse(), "FTEST(1,B2:B6)");
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", "FTEST(1,B2:B6)");

		oParser = new parserFormula("FTEST({1,2,3},{2,3,4,5})", "A1", ws);
		assert.ok(oParser.parse(), "FTEST({1,2,3},{2,3,4,5})");
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.792636779, "FTEST({1,2,3},{2,3,4,5})");

		oParser = new parserFormula("FTEST({1,\"test\",\"test\"},{2,3,4,5})", "A1", ws);
		assert.ok(oParser.parse(), "FTEST({1,\"test\",\"test\"},{2,3,4,5})");
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", "FTEST({1,\"test\",\"test\"},{2,3,4,5})");
	}

	QUnit.test("Test: \"FTEST\"", function (assert) {
		fTestFormulaTest(assert);
		testArrayFormula2(assert, "FTEST", 2, 2, null, true);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("6");
		ws.getRange2("A101").setValue("7");
		ws.getRange2("A104").setValue("21");
		// For area
		ws.getRange2("A102").setValue("9");
		ws.getRange2("A103").setValue("15");

		ws.getRange2("B100").setValue("20");
		ws.getRange2("B101").setValue("28");
		ws.getRange2("B102").setValue("31");
		ws.getRange2("B103").setValue("38");
		ws.getRange2("B104").setValue("40");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("6"); // Num (Column1)
		ws.getRange2("B601").setValue("7"); // Num (Column2)
		ws.getRange2("C601").setValue("Text"); // Number (Column3)

		// 3D links. Use A1:Z10
		ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2\


		// Positive cases:
		// Case #1: Array(2). Valid numeric arrays, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(2). Valid numeric arrays, returns probability. 2 of 2 arguments used.');
		// Case #2: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A100:A104,B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A100:A104,B100:B104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.721094633, 'Test: Positive case: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.');
		// Case #3: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(CHOOSE(1,A100:A104),B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(CHOOSE(1,A100:A104),B100:B104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.721094633, 'Test: Positive case: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.');
		// Case #4: Array(2). Arrays with ignored text, logical, empty values, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1,2,3,TRUE,"text"},{4,5,6,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1,2,3,TRUE,"text"},{4,5,6,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(2). Arrays with ignored text, logical, empty values, returns probability. 2 of 2 arguments used.');
		// Case #5: Reference link(2). Reference links to valid ranges (A100=A1:A3, A101=A4:A6), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link(2). Reference links to valid ranges (A100=A1:A3, A101=A4:A6), returns probability. 2 of 2 arguments used.');
		// Case #6: Area(2). Valid multi-cell ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A100:A102,A103:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.409665529, 'Test: Positive case: Area(2). Valid multi-cell ranges, returns probability. 2 of 2 arguments used.');
		// Case #7: Name(2). Named ranges referencing valid ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name(2). Named ranges referencing valid ranges, returns probability. 2 of 2 arguments used.');
		// Case #8: Name3D(2). 3D named ranges referencing valid ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D(2). 3D named ranges referencing valid ranges, returns probability. 2 of 2 arguments used.');
		// Case #9: Ref3D(2). 3D references to valid ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(Sheet2!A1:A3,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(Sheet2!A1:A3,Sheet2!A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D(2). 3D references to valid ranges, returns probability. 2 of 2 arguments used.');
		// Case #10: Area3D(2). 3D multi-cell ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(Sheet2!A1:A3,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(Sheet2!A1:A3,Sheet2!A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D(2). 3D multi-cell ranges, returns probability. 2 of 2 arguments used.');
		// Case #11: Table(2). Table columns with valid numbers, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table(2). Table columns with valid numbers, returns probability. 2 of 2 arguments used.');
		// Case #12: Formula(2). Both arguments as IF formulas returning ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(IF(TRUE,A100:A103,A101:A104),IF(FALSE,B100:B103,B101:B104))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(IF(TRUE,A100:A103,A101:A104),IF(FALSE,B100:B103,B101:B104)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.736629344, 'Test: Positive case: Formula(2). Both arguments as IF formulas returning ranges, returns probability. 2 of 2 arguments used.');
		// Case #13: Array(2). Arrays with zeros (included), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1,2,3,0},{4,5,6,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1,2,3,0},{4,5,6,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.27295536183907904, 'Test: Positive case: Array(2). Arrays with zeros (included), returns probability. 2 of 2 arguments used.');
		// Case #14: Area, Formula. array2 as INDIRECT formula, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A100:A103,INDIRECT("A101:A104"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A100:A103,INDIRECT("A101:A104")) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.633194317, 'Test: Positive case: Area, Formula. array2 as INDIRECT formula, returns probability. 2 of 2 arguments used.');
		// Case #15: Area(2). Duplicate of case #2 to ensure consistency, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A100:A103,A101:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A100:A103,A101:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.633194317, 'Test: Positive case: Area(2). Duplicate of case #2 to ensure consistency, returns probability. 2 of 2 arguments used.');
		// Case #16: Name, Area. Named range and cell range, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(TestName,A101:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(TestName,A101:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name, Area. Named range and cell range, returns probability. 2 of 2 arguments used.');
		// Case #17: Array(2). Arrays with decimal numbers, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1.5,2.5,3.5},{4.5,5.5,6.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1.5,2.5,3.5},{4.5,5.5,6.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(2). Arrays with decimal numbers, returns probability. 2 of 2 arguments used.');
		// Case #18: Formula, Area. array1 as CHOOSE formula, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(CHOOSE(1,A100:A103,A101:A104),A101:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(CHOOSE(1,A100:A103,A101:A104),A101:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.633194317, 'Test: Positive case: Formula, Area. array1 as CHOOSE formula, returns probability. 2 of 2 arguments used.');
		// Case #19: Area(2). Overlapping ranges with valid numbers, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A100:A103,A100:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A100:A103,A100:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.633194317, 'Test: Positive case: Area(2). Overlapping ranges with valid numbers, returns probability. 2 of 2 arguments used.');
		// Case #20: Array(2). Larger arrays (5 elements), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1,2,3,4,5},{6,7,8,9,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1,2,3,4,5},{6,7,8,9,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Array(2). Larger arrays (5 elements), returns probability. 2 of 2 arguments used.');
		// Case #21: Area(2). Ranges with mixed numbers (e.g., positive/negative), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A100:A103,A102:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A100:A103,A102:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.65, 'Test: Positive case: Area(2). Ranges with mixed numbers (e.g., positive/negative), returns probability. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Array(2). Arrays with 1 data point return #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1},{4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1},{4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). Arrays with 1 data point return #DIV/0!. 2 of 2 arguments used.');
		// Case #2: Array(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1,1},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1,1},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.');
		// Case #3: Array(2). array2 with zero variance returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1,2},{4,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1,2},{4,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). array2 with zero variance returns #DIV/0!. 2 of 2 arguments used.');
		// Case #4: Reference link(2). Single-cell references (not arrays) return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A102,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A102,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link(2). Single-cell references (not arrays) return #VALUE!. 2 of 2 arguments used.');
		// Case #5: Number(2). Numeric arguments return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(123,456)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(123,456) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Numeric arguments return #VALUE!. 2 of 2 arguments used.');
		// Case #6: String(2). Text arguments return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST("text","data")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST("text","data") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String(2). Text arguments return #VALUE!. 2 of 2 arguments used.');
		// Case #7: Boolean(2). Boolean arguments return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean(2). Boolean arguments return #VALUE!. 2 of 2 arguments used.');
		// Case #8: Error(2). array1 as error returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(NA(),A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(NA(),A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). array1 as error returns #N/A. 2 of 2 arguments used.');
		// Case #9: Area, Error. array2 as error returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A1:A3,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A1:A3,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area, Error. array2 as error returns #N/A. 2 of 2 arguments used.');
		// Case #10: Reference link, Area. Reference to text cell returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A104,B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A104,B100:B104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link, Area. Reference to text cell returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Name(2). Named range with non-numeric (text) returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(TestNameArea2,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(TestNameArea2,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name(2). Named range with non-numeric (text) returns #VALUE!. 2 of 2 arguments used.');
		// Case #12: Name3D(2). 3D named range with non-numeric (text) returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(TestNameArea3D2,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(TestNameArea3D2,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D(2). 3D named range with non-numeric (text) returns #VALUE!. 2 of 2 arguments used.');
		// Case #13: Table(2). Table with non-numeric values returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Table(2). Table with non-numeric values returns #VALUE!. 2 of 2 arguments used.');
		// Case #14: Formula(2). array1 as #NUM! formula returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(SQRT(-1),A101:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(SQRT(-1),A101:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). array1 as #NUM! formula returns #NUM!. 2 of 2 arguments used.');
		// Case #15: Area, Formula. array2 as #NUM! formula returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A100:A103,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A100:A103,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Formula. array2 as #NUM! formula returns #NUM!. 2 of 2 arguments used.');
		// Case #16: Array(2). array1 with text (ignored, but only 1 number) returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1,"text"},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1,"text"},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). array1 with text (ignored, but only 1 number) returns #DIV/0!. 2 of 2 arguments used.');
		// Case #17: Area(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A100:A104,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A100:A104,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.');
		// Case #18: Empty(2). Missing arguments return #VALUE!. 0 of 2 arguments used.
		oParser = new parserFormula('FTEST(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty(2). Missing arguments return #VALUE!. 0 of 2 arguments used.');
		// Case #19: Ref3D(2). 3D reference with zero variance returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(Sheet2!A7:A8,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(Sheet2!A7:A8,Sheet2!A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D(2). 3D reference with zero variance returns #DIV/0!. 2 of 2 arguments used.');
		// Case #20: Array(2). array1 with only logical values (ignored, no numbers) returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({TRUE,FALSE},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({TRUE,FALSE},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). array1 with only logical values (ignored, no numbers) returns #DIV/0!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Array(2). Minimal valid arrays (2 data points), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1,2},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1,2},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Bounded case: Array(2). Minimal valid arrays (2 data points), returns probability. 2 of 2 arguments used.');
		// Case #2: Array(2). Arrays with minimal variance, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({1,1.000001},{4,4.000001})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({1,1.000001},{4,4.000001}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array(2). Arrays with minimal variance, returns probability. 2 of 2 arguments used.');
		// Case #3: Area(2). Large ranges (100 data points), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST(A1:A100,A101:A200)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST(A1:A100,A101:A200) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Area(2). Large ranges (100 data points), returns probability. 2 of 2 arguments used.');
		// Case #4: Array(2). Arrays with zeros and valid variance, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('FTEST({0,0,1},{0,0,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FTEST({0,0,1},{0,0,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.11764705882352941, 'Test: Bounded case: Array(2). Arrays with zeros and valid variance, returns probability. 2 of 2 arguments used.');

		// TODO many problem in results
		// Need to fix: results diff from MS, error types diff
		// Case #2: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.
		// Case #3: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.
		// Case #6: Area(2). Valid multi-cell ranges, returns probability. 2 of 2 arguments used.
		// Case #12: Formula(2). Both arguments as IF formulas returning ranges, returns probability. 2 of 2 arguments used.
		// Case #14: Area, Formula. array2 as INDIRECT formula, returns probability. 2 of 2 arguments used.
		// Case #15: Area(2). Duplicate of case #2 to ensure consistency, returns probability. 2 of 2 arguments used.
		// Case #18: Formula, Area. array1 as CHOOSE formula, returns probability. 2 of 2 arguments used.
		// Case #19: Area(2). Overlapping ranges with valid numbers, returns probability. 2 of 2 arguments used.
		// Case #21: Area(2). Ranges with mixed numbers (e.g., positive/negative), returns probability. 2 of 2 arguments used.
		// Case #17: Area(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.
		// Case #18: Empty(2). Missing arguments return #VALUE!. 0 of 2 arguments used.
		// Case #2: Array(2). Arrays with minimal variance, returns probability. 2 of 2 arguments used.
		// Case #3: Area(2). Large ranges (100 data points), returns probability. 2 of 2 arguments used.

	});

	QUnit.test("Test: \"F.TEST\"", function (assert) {
		fTestFormulaTest(assert);
		testArrayFormula2(assert, "F.TEST", 2, 2, null, true);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("6");
		ws.getRange2("A101").setValue("7");
		ws.getRange2("A104").setValue("21");
		// For area
		ws.getRange2("A102").setValue("9");
		ws.getRange2("A103").setValue("15");

		ws.getRange2("B100").setValue("20");
		ws.getRange2("B101").setValue("28");
		ws.getRange2("B102").setValue("31");
		ws.getRange2("B103").setValue("38");
		ws.getRange2("B104").setValue("40");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("6"); // Num (Column1)
		ws.getRange2("B601").setValue("7"); // Num (Column2)
		ws.getRange2("C601").setValue("Text"); // Number (Column3)

		// 3D links. Use A1:Z10
		ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2\


		// Positive cases:
		// Case #1: Array(2). Valid numeric arrays, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(2). Valid numeric arrays, returns probability. 2 of 2 arguments used.');
		// Case #2: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A100:A104,B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A100:A104,B100:B104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.721094633, 'Test: Positive case: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.');
		// Case #3: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(CHOOSE(1,A100:A104),B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(CHOOSE(1,A100:A104),B100:B104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.721094633, 'Test: Positive case: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.');
		// Case #4: Array(2). Arrays with ignored text, logical, empty values, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1,2,3,TRUE,"text"},{4,5,6,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1,2,3,TRUE,"text"},{4,5,6,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(2). Arrays with ignored text, logical, empty values, returns probability. 2 of 2 arguments used.');
		// Case #5: Reference link(2). Reference links to valid ranges (A100=A1:A3, A101=A4:A6), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link(2). Reference links to valid ranges (A100=A1:A3, A101=A4:A6), returns probability. 2 of 2 arguments used.');
		// Case #6: Area(2). Valid multi-cell ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A100:A102,A103:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.409665529, 'Test: Positive case: Area(2). Valid multi-cell ranges, returns probability. 2 of 2 arguments used.');
		// Case #7: Name(2). Named ranges referencing valid ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name(2). Named ranges referencing valid ranges, returns probability. 2 of 2 arguments used.');
		// Case #8: Name3D(2). 3D named ranges referencing valid ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D(2). 3D named ranges referencing valid ranges, returns probability. 2 of 2 arguments used.');
		// Case #9: Ref3D(2). 3D references to valid ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(Sheet2!A1:A3,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(Sheet2!A1:A3,Sheet2!A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D(2). 3D references to valid ranges, returns probability. 2 of 2 arguments used.');
		// Case #10: Area3D(2). 3D multi-cell ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(Sheet2!A1:A3,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(Sheet2!A1:A3,Sheet2!A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D(2). 3D multi-cell ranges, returns probability. 2 of 2 arguments used.');
		// Case #11: Table(2). Table columns with valid numbers, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table(2). Table columns with valid numbers, returns probability. 2 of 2 arguments used.');
		// Case #12: Formula(2). Both arguments as IF formulas returning ranges, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(IF(TRUE,A100:A103,A101:A104),IF(FALSE,B100:B103,B101:B104))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(IF(TRUE,A100:A103,A101:A104),IF(FALSE,B100:B103,B101:B104)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.736629344, 'Test: Positive case: Formula(2). Both arguments as IF formulas returning ranges, returns probability. 2 of 2 arguments used.');
		// Case #13: Array(2). Arrays with zeros (included), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1,2,3,0},{4,5,6,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1,2,3,0},{4,5,6,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.27295536183907904, 'Test: Positive case: Array(2). Arrays with zeros (included), returns probability. 2 of 2 arguments used.');
		// Case #14: Area, Formula. array2 as INDIRECT formula, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A100:A103,INDIRECT("A101:A104"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A100:A103,INDIRECT("A101:A104")) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.633194317, 'Test: Positive case: Area, Formula. array2 as INDIRECT formula, returns probability. 2 of 2 arguments used.');
		// Case #15: Area(2). Duplicate of case #2 to ensure consistency, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A100:A103,A101:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A100:A103,A101:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.633194317, 'Test: Positive case: Area(2). Duplicate of case #2 to ensure consistency, returns probability. 2 of 2 arguments used.');
		// Case #16: Name, Area. Named range and cell range, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(TestName,A101:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(TestName,A101:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name, Area. Named range and cell range, returns probability. 2 of 2 arguments used.');
		// Case #17: Array(2). Arrays with decimal numbers, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1.5,2.5,3.5},{4.5,5.5,6.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1.5,2.5,3.5},{4.5,5.5,6.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(2). Arrays with decimal numbers, returns probability. 2 of 2 arguments used.');
		// Case #18: Formula, Area. array1 as CHOOSE formula, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(CHOOSE(1,A100:A103,A101:A104),A101:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(CHOOSE(1,A100:A103,A101:A104),A101:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.633194317, 'Test: Positive case: Formula, Area. array1 as CHOOSE formula, returns probability. 2 of 2 arguments used.');
		// Case #19: Area(2). Overlapping ranges with valid numbers, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A100:A103,A100:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A100:A103,A100:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.633194317, 'Test: Positive case: Area(2). Overlapping ranges with valid numbers, returns probability. 2 of 2 arguments used.');
		// Case #20: Array(2). Larger arrays (5 elements), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1,2,3,4,5},{6,7,8,9,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1,2,3,4,5},{6,7,8,9,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Array(2). Larger arrays (5 elements), returns probability. 2 of 2 arguments used.');
		// Case #21: Area(2). Ranges with mixed numbers (e.g., positive/negative), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A100:A103,A102:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A100:A103,A102:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.65, 'Test: Positive case: Area(2). Ranges with mixed numbers (e.g., positive/negative), returns probability. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Array(2). Arrays with 1 data point return #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1},{4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1},{4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). Arrays with 1 data point return #DIV/0!. 2 of 2 arguments used.');
		// Case #2: Array(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1,1},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1,1},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.');
		// Case #3: Array(2). array2 with zero variance returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1,2},{4,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1,2},{4,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). array2 with zero variance returns #DIV/0!. 2 of 2 arguments used.');
		// Case #4: Reference link(2). Single-cell references (not arrays) return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A102,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A102,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link(2). Single-cell references (not arrays) return #VALUE!. 2 of 2 arguments used.');
		// Case #5: Number(2). Numeric arguments return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(123,456)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(123,456) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Numeric arguments return #VALUE!. 2 of 2 arguments used.');
		// Case #6: String(2). Text arguments return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST("text","data")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST("text","data") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String(2). Text arguments return #VALUE!. 2 of 2 arguments used.');
		// Case #7: Boolean(2). Boolean arguments return #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean(2). Boolean arguments return #VALUE!. 2 of 2 arguments used.');
		// Case #8: Error(2). array1 as error returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(NA(),A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(NA(),A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). array1 as error returns #N/A. 2 of 2 arguments used.');
		// Case #9: Area, Error. array2 as error returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A1:A3,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A1:A3,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area, Error. array2 as error returns #N/A. 2 of 2 arguments used.');
		// Case #10: Reference link, Area. Reference to text cell returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A104,B100:B104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A104,B100:B104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link, Area. Reference to text cell returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Name(2). Named range with non-numeric (text) returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(TestNameArea2,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(TestNameArea2,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name(2). Named range with non-numeric (text) returns #VALUE!. 2 of 2 arguments used.');
		// Case #12: Name3D(2). 3D named range with non-numeric (text) returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(TestNameArea3D2,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(TestNameArea3D2,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D(2). 3D named range with non-numeric (text) returns #VALUE!. 2 of 2 arguments used.');
		// Case #13: Table(2). Table with non-numeric values returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Table(2). Table with non-numeric values returns #VALUE!. 2 of 2 arguments used.');
		// Case #14: Formula(2). array1 as #NUM! formula returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(SQRT(-1),A101:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(SQRT(-1),A101:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). array1 as #NUM! formula returns #NUM!. 2 of 2 arguments used.');
		// Case #15: Area, Formula. array2 as #NUM! formula returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A100:A103,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A100:A103,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Formula. array2 as #NUM! formula returns #NUM!. 2 of 2 arguments used.');
		// Case #16: Array(2). array1 with text (ignored, but only 1 number) returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1,"text"},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1,"text"},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). array1 with text (ignored, but only 1 number) returns #DIV/0!. 2 of 2 arguments used.');
		// Case #17: Area(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A100:A104,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A100:A104,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.');
		// Case #18: Empty(2). Missing arguments return #VALUE!. 0 of 2 arguments used.
		oParser = new parserFormula('F.TEST(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty(2). Missing arguments return #VALUE!. 0 of 2 arguments used.');
		// Case #19: Ref3D(2). 3D reference with zero variance returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(Sheet2!A7:A8,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(Sheet2!A7:A8,Sheet2!A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D(2). 3D reference with zero variance returns #DIV/0!. 2 of 2 arguments used.');
		// Case #20: Array(2). array1 with only logical values (ignored, no numbers) returns #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({TRUE,FALSE},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({TRUE,FALSE},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array(2). array1 with only logical values (ignored, no numbers) returns #DIV/0!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Array(2). Minimal valid arrays (2 data points), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1,2},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1,2},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Bounded case: Array(2). Minimal valid arrays (2 data points), returns probability. 2 of 2 arguments used.');
		// Case #2: Array(2). Arrays with minimal variance, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({1,1.000001},{4,4.000001})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({1,1.000001},{4,4.000001}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array(2). Arrays with minimal variance, returns probability. 2 of 2 arguments used.');
		// Case #3: Area(2). Large ranges (100 data points), returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST(A1:A100,A101:A200)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST(A1:A100,A101:A200) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Area(2). Large ranges (100 data points), returns probability. 2 of 2 arguments used.');
		// Case #4: Array(2). Arrays with zeros and valid variance, returns probability. 2 of 2 arguments used.
		oParser = new parserFormula('F.TEST({0,0,1},{0,0,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: F.TEST({0,0,1},{0,0,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.11764705882352941, 'Test: Bounded case: Array(2). Arrays with zeros and valid variance, returns probability. 2 of 2 arguments used.');

		// TODO many problem in results
		// Need to fix: results diff from MS, error types diff
		// Case #2: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.
		// Case #3: Formula, Area. array1 as formula returning range, returns probability. 2 of 2 arguments used.
		// Case #6: Area(2). Valid multi-cell ranges, returns probability. 2 of 2 arguments used.
		// Case #12: Formula(2). Both arguments as IF formulas returning ranges, returns probability. 2 of 2 arguments used.
		// Case #14: Area, Formula. array2 as INDIRECT formula, returns probability. 2 of 2 arguments used.
		// Case #15: Area(2). Duplicate of case #2 to ensure consistency, returns probability. 2 of 2 arguments used.
		// Case #18: Formula, Area. array1 as CHOOSE formula, returns probability. 2 of 2 arguments used.
		// Case #19: Area(2). Overlapping ranges with valid numbers, returns probability. 2 of 2 arguments used.
		// Case #21: Area(2). Ranges with mixed numbers (e.g., positive/negative), returns probability. 2 of 2 arguments used.
		// Case #17: Area(2). array1 with zero variance returns #DIV/0!. 2 of 2 arguments used.
		// Case #18: Empty(2). Missing arguments return #VALUE!. 0 of 2 arguments used.
		// Case #2: Array(2). Arrays with minimal variance, returns probability. 2 of 2 arguments used.
		// Case #3: Area(2). Large ranges (100 data points), returns probability. 2 of 2 arguments used.

	});

	QUnit.test("Test: \"GAMMA\"", function (assert) {

		oParser = new parserFormula("GAMMA(2.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), "1.329");

		oParser = new parserFormula("GAMMA(-3.75)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), "0.268");

		oParser = new parserFormula("GAMMA(0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("GAMMA(-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: integer > 0. 1 argument used.
		oParser = new parserFormula('GAMMA(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 362880, 'Test: Positive case: Number. Basic valid input: integer > 0. 1 argument used.');
		// Case #1: Number. Basic valid input: positive float. 1 argument used.
		oParser = new parserFormula('GAMMA(2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.329340388179137, 'Test: Positive case: Number. Basic valid input: positive float. 1 argument used.');
		// Case #2: Number. Small positive number close to 1. 1 argument used.
		oParser = new parserFormula('GAMMA(1.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(1.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9999999422784429, 'Test: Positive case: Number. Small positive number close to 1. 1 argument used.');
		// Case #3: String. String convertible to positive number. 1 argument used.
		oParser = new parserFormula('GAMMA("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String convertible to positive number. 1 argument used.');
		// Case #4: Formula. Nested formula returning valid number. 1 argument used.
		oParser = new parserFormula('GAMMA(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested formula returning valid number. 1 argument used.');
		// Case #5: Reference link. Reference to cell with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMA(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.513507698668734, 'Test: Positive case: Reference link. Reference to cell with valid number (2). 1 argument used.');
		// Case #6: Area. Single-cell range with valid number (1.5). 1 argument used.
		oParser = new parserFormula('GAMMA(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.590843711998807, 'Test: Positive case: Area. Single-cell range with valid number (1.5). 1 argument used.');
		// Case #7: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('GAMMA({2.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA({2.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.329340388179137, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #8: Name. Named range with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMA(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.5449077018110318, 'Test: Positive case: Name. Named range with valid number (2). 1 argument used.');
		// Case #9: Name3D. 3D named range with valid number (3). 1 argument used.
		oParser = new parserFormula('GAMMA(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.5449077018110318, 'Test: Positive case: Name3D. 3D named range with valid number (3). 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMA(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7724538509055159, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (2). 1 argument used.');
		// Case #11: Area3D. 3D single-cell range with valid number (3). 1 argument used.
		oParser = new parserFormula('GAMMA(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8862269254527579, 'Test: Positive case: Area3D. 3D single-cell range with valid number (3). 1 argument used.');
		// Case #12: Table. Table structured reference with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMA(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9971385352510179, 'Test: Positive case: Table. Table structured reference with valid number (2). 1 argument used.');
		// Case #13: Date. Date as serial number (> 0). 1 argument used.
		oParser = new parserFormula('GAMMA(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(DATE(2025,1,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Date. Date as serial number (> 0). 1 argument used.');
		// Case #14: Time. Time adjusted to valid number (>= 1). 1 argument used.
		oParser = new parserFormula('GAMMA(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8862269254527579, 'Test: Positive case: Time. Time adjusted to valid number (>= 1). 1 argument used.');
		// Case #15: Formula. GAMMA inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(GAMMA(2.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GAMMA(2.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.329340388179137, 'Test: Positive case: Formula. GAMMA inside SUM formula. 1 argument used.');
		// Case #16: Number. Very small positive number. 1 argument used.
		oParser = new parserFormula('GAMMA(0.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(0.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9999999.422784435, 'Test: Positive case: Number. Very small positive number. 1 argument used.');
		// Case #17: String. Short date string convertible to number. 1 argument used.
		oParser = new parserFormula('GAMMA("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA("12/12") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. Short date string convertible to number. 1 argument used.');
		// Case #18: Array. Array with single valid element (duplicate for coverage). 1 argument used.
		oParser = new parserFormula('GAMMA({2.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA({2.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.329340388179137, 'Test: Positive case: Array. Array with single valid element (duplicate for coverage). 1 argument used.');
		// Case #19: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('GAMMA(IF(TRUE, 2.5, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(IF(TRUE, 2.5, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.329340388179137, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');
		// Case #20: Number. Negative non-integer number (valid). 1 argument used.
		oParser = new parserFormula('GAMMA(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.5449077018110318, 'Test: Positive case: Number. Negative non-integer number (valid). 1 argument used.');
		// Case #21: String. String convertible to negative non-integer number. 1 argument used.
		oParser = new parserFormula('GAMMA("-0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA("-0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.5449077018110318, 'Test: Positive case: String. String convertible to negative non-integer number. 1 argument used.');
		// Case #22: Formula. Nested formula converting negative to positive number. 1 argument used.
		oParser = new parserFormula('GAMMA(ABS(-2.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(ABS(-2.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.329340388179137, 'Test: Positive case: Formula. Nested formula converting negative to positive number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative integer returns #NUM!. 1 argument used.');
		// Case #2: Number. Zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero returns #NUM!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMA("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('GAMMA(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMA(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.991568987687589, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.218159544, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMA("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Boolean. Boolean FALSE (0) returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!. 1 argument used.');
		// Case #9: Boolean. Boolean TRUE (1) returns valid result, but testing for clarity. 1 argument used.
		oParser = new parserFormula('GAMMA(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result, but testing for clarity. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with text (abc) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMA(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with text (abc) returns #VALUE!. 1 argument used.');
		// Case #11: Name. Named range with text (invalid) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMA(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1642297137253033, 'Test: Negative case: Name. Named range with text (invalid) returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text (error) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMA(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text (error) returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('GAMMA(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #14: Array. Array with boolean returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!. 1 argument used.');
		// Case #15: Number. Negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative integer returns #NUM!. 1 argument used.');
		// Case #16: String. String convertible to zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to zero returns #NUM!. 1 argument used.');
		// Case #17: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.');
		// Case #18: Name3D. 3D named range with text (invalid) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMA(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1642297137253033, 'Test: Negative case: Name3D. 3D named range with text (invalid) returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA(DATE(2025,1,1)-DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(DATE(2025,1,1)-DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in zero returns #NUM!. 1 argument used.');
		// Case #20: Number. Large negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMA(-1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(-1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large negative integer returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive number accepted by Excel. 1 argument used.
		oParser = new parserFormula('GAMMA(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0000000000000001e+307, 'Test: Bounded case: Number. Minimum positive number accepted by Excel. 1 argument used.');
		// Case #2: Number. Maximum positive number accepted by Excel. 1 argument used.
		oParser = new parserFormula('GAMMA(1.7E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(1.7E307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum positive number accepted by Excel. 1 argument used.');
		// Case #3: Number. Negative number close to -1 but non-integer. 1 argument used.
		oParser = new parserFormula('GAMMA(-0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA(-0.999999999999999) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1000800000000000, 'Test: Bounded case: Number. Negative number close to -1 but non-integer. 1 argument used.');

		// Need to fix: ms result diff
		// Case #13: Date. Date as serial number (> 0). 1 argument used.
		// Case #17: String. Short date string convertible to number. 1 argument used.
		// Case #6: Area. Multi-cell range returns #NUM!. 1 argument used.
		// Case #2: Number. Maximum positive number accepted by Excel. 1 argument used.
		// Case #3: Number. Negative number close to -1 but non-integer. 1 argument used.


		testArrayFormula2(assert, "GAMMA", 1, 1);
	});

	QUnit.test("Test: \"GAMMADIST\"", function (assert) {
		ws.getRange2("A2").setValue("10.00001131");
		ws.getRange2("A3").setValue("9");
		ws.getRange2("A4").setValue("2");

		oParser = new parserFormula("GAMMADIST(A2,A3,A4,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "GAMMADIST(A2,A3,A4,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.032639, "GAMMADIST(A2,A3,A4,FALSE)");

		oParser = new parserFormula("GAMMADIST(A2,A3,A4,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "GAMMADIST(A2,A3,A4,TRUE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.068094, "GAMMADIST(A2,A3,A4,TRUE)");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: x ? 0, alpha = 1 (exponential distribution), beta > 0, cumulative = TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Number. Basic valid input: x ? 0, alpha = 1 (exponential distribution), beta > 0, cumulative = TRUE. 4 of 4 arguments used.');
		// Case #1: Number. Valid input: positive float x, alpha > 0, beta > 0, cumulative = FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(1.5,2,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(1.5,2,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.33469524022264474, 'Test: Positive case: Number. Valid input: positive float x, alpha > 0, beta > 0, cumulative = FALSE. 4 of 4 arguments used.');
		// Case #2: Number. Boundary x = 0, alpha = 1, beta > 0, cumulative = TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(0,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(0,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Boundary x = 0, alpha = 1, beta > 0, cumulative = TRUE. 4 of 4 arguments used.');
		// Case #3: String. Strings convertible to valid numbers and TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST("2","1","1","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST("2","1","1","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.864664717, 'Test: Positive case: String. Strings convertible to valid numbers and TRUE. 4 of 4 arguments used.');
		// Case #4: Formula. Nested formulas returning valid numbers, cumulative = TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(SQRT(4),ABS(1),ABS(1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(SQRT(4),ABS(1),ABS(1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Formula. Nested formulas returning valid numbers, cumulative = TRUE. 4 of 4 arguments used.');
		// Case #5: Reference link. References to cells with valid numbers (2, 1.5, 0.5, TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8298126213987767, 'Test: Positive case: Reference link. References to cells with valid numbers (2, 1.5, 0.5, TRUE). 4 of 4 arguments used.');
		// Case #6: Area. Single-cell ranges with valid numbers (2, 1.5, 0.5, TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8298126213987767, 'Test: Positive case: Area. Single-cell ranges with valid numbers (2, 1.5, 0.5, TRUE). 4 of 4 arguments used.');
		// Case #7: Array. Arrays with single valid elements. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST({2},{1},{1},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST({2},{1},{1},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Array. Arrays with single valid elements. 4 of 4 arguments used.');
		// Case #8: Name. Named ranges with valid numbers (2, 1.5, 0.5, 0.5). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers (2, 1.5, 0.5, 0.5). 4 of 4 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid numbers (3, 1, 0.5, TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers (3, 1, 0.5, TRUE). 4 of 4 arguments used.');
		// Case #10: Ref3D. 3D references to cells with valid numbers (2, 3, TRUE, 1). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells with valid numbers (2, 3, TRUE, 1). 4 of 4 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges with valid numbers (2, 3, TRUE, 1). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers (2, 3, TRUE, 1). 4 of 4 arguments used.');
		// Case #12: Table. Table structured references with valid numbers (2, TRUE, 1, TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6299623388962401, 'Test: Positive case: Table. Table structured references with valid numbers (2, TRUE, 1, TRUE). 4 of 4 arguments used.');
		// Case #13: Date. Date as serial number for x (> 0), valid alpha, beta, cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(DATE(2025,1,1),1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(DATE(2025,1,1),1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number for x (> 0), valid alpha, beta, cumulative. 4 of 4 arguments used.');
		// Case #14: Time. Time adjusted to valid x (>= 1), valid alpha, beta, cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(TIME(12,0,0)+1,1,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(TIME(12,0,0)+1,1,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22313016014842982, 'Test: Positive case: Time. Time adjusted to valid x (>= 1), valid alpha, beta, cumulative. 4 of 4 arguments used.');
		// Case #15: Formula. GAMMA.DIST inside SUM formula, valid inputs. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(GAMMADIST(2,1,1,TRUE),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GAMMADIST(2,1,1,TRUE),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8646647167633872, 'Test: Positive case: Formula. GAMMA.DIST inside SUM formula, valid inputs. 4 of 4 arguments used.');
		// Case #16: Number. Alpha = 0.5 (non-integer), beta = 2, cumulative = TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(1,0.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(1,0.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.682689492137086, 'Test: Positive case: Number. Alpha = 0.5 (non-integer), beta = 2, cumulative = TRUE. 4 of 4 arguments used.');
		// Case #17: String. Strings convertible to valid numbers and FALSE (0). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST("1","2","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST("1","2","1","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String. Strings convertible to valid numbers and FALSE (0). 4 of 4 arguments used.');
		// Case #18: Array. Arrays with single valid elements, cumulative as 1 (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST({1},{2},{1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST({1},{2},{1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2642411176571153, 'Test: Positive case: Array. Arrays with single valid elements, cumulative as 1 (TRUE). 4 of 4 arguments used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(IF(TRUE,2,1),IF(TRUE,1,0.5),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(IF(TRUE,2,1),IF(TRUE,1,0.5),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 4 of 4 arguments used.');
		// Case #20: Number. Alpha = n/2, beta = 2, cumulative = TRUE (relates to chi-squared distribution). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,2,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,2,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2642411176571153, 'Test: Positive case: Number. Alpha = n/2, beta = 2, cumulative = TRUE (relates to chi-squared distribution). 4 of 4 arguments used.');
		// Case #21: Number. Alpha as positive integer (Erlang distribution), cumulative = FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(1,3,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(1,3,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.18393972058572117, 'Test: Positive case: Number. Alpha as positive integer (Erlang distribution), cumulative = FALSE. 4 of 4 arguments used.');
		// Case #22: Formula. Nested formula converting negative x to positive. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(ABS(-2),1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(ABS(-2),1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Formula. Nested formula converting negative x to positive. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number. x < 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(-1,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(-1,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. x < 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number. Alpha ? 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Alpha ? 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number. Beta ? 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,1,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,1,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Beta ? 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #4: String. Non-numeric x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST("abc",1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST("abc",1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric x returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: String. Non-numeric alpha returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,"abc",1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,"abc",1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric alpha returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: String. Non-numeric beta returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,1,"abc",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,1,"abc",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric beta returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: Error. Propagates #N/A error for x. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(NA(),1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(NA(),1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for x. 4 of 4 arguments used.');
		// Case #8: Empty. Empty x reference returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(A104,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(A104,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3934693402873665, 'Test: Negative case: Empty. Empty x reference returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Area. Multi-cell range for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(A100:A101,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(A100:A101,1,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.095162582, 'Test: Negative case: Area. Multi-cell range for x returns #NUM!. 4 of 4 arguments used.');
		// Case #10: Area. Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,A100:A101,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,A100:A101,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.994326176, 'Test: Negative case: Area. Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #11: Area. Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,1,A100:A101,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,1,A100:A101,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.999999998, 'Test: Negative case: Area. Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.');
		// Case #12: Ref3D. 3D reference to text (abc) for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(Sheet2!A3,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(Sheet2!A3,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text (abc) for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #13: Name. Named range with text (invalid) for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(TestNameArea2,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(TestNameArea2,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5506710358827783, 'Test: Negative case: Name. Named range with text (invalid) for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #14: Table. Table column with text (error) for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(Table1[Column2],1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(Table1[Column2],1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text (error) for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! for x. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(SQRT(-1),1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(SQRT(-1),1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! for x. 4 of 4 arguments used.');
		// Case #16: Array. Array with boolean for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST({FALSE},1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST({FALSE},1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with boolean for x returns #NUM!. 4 of 4 arguments used.');
		// Case #17: Number. Negative alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,-1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,-1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #18: Number. Negative beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,1,-1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,1,-1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative beta returns #NUM!. 4 of 4 arguments used.');
		// Case #19: Area3D. 3D multi-cell range for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(Sheet2!A4:A5,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(Sheet2!A4:A5,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range for x returns #NUM!. 4 of 4 arguments used.');
		// Case #20: Name3D. 3D named range with text (invalid) for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(TestNameArea3D2,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(TestNameArea3D2,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5506710358827783, 'Test: Negative case: Name3D. 3D named range with text (invalid) for x returns #VALUE!. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers for x, alpha, beta accepted by Excel. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(1E-307,1E-307,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(1E-307,1E-307,1E-307,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum positive numbers for x, alpha, beta accepted by Excel. 4 of 4 arguments used.');
		// Case #2: Number. Maximum positive x accepted by Excel. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(1.7E307,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(1.7E307,1,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum positive x accepted by Excel. 4 of 4 arguments used.');
		// Case #3: Number. Maximum positive alpha accepted by Excel. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,1.7E307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,1.7E307,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum positive alpha accepted by Excel. 4 of 4 arguments used.');
		// Case #4: Number. Maximum positive beta accepted by Excel. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMADIST(2,1,1.7E307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMADIST(2,1,1.7E307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1764705882352546e-307, 'Test: Bounded case: Number. Maximum positive beta accepted by Excel. 4 of 4 arguments used.');

		// Need to fix: different result from MS
		// Case #3: String. Strings convertible to valid numbers and TRUE. 4 of 4 arguments used.
		// Case #17: String. Strings convertible to valid numbers and FALSE (0). 4 of 4 arguments used.
		// Case #9: Area. Multi-cell range for x returns #NUM!. 4 of 4 arguments used
		// Case #10: Area. Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.
		// Case #11: Area. Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.
		// Case #1: Number. Minimum positive numbers for x, alpha, beta accepted by Excel. 4 of 4 arguments used.
		// Case #2: Number. Maximum positive x accepted by Excel. 4 of 4 arguments used.
		// Case #3: Number. Maximum positive alpha accepted by Excel. 4 of 4 arguments used.


	});

	QUnit.test("Test: \"GAMMA.DIST\"", function (assert) {
		ws.getRange2("A2").setValue("10.00001131");
		ws.getRange2("A3").setValue("9");
		ws.getRange2("A4").setValue("2");

		oParser = new parserFormula("GAMMA.DIST(A2,A3,A4,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "GAMMA.DIST(A2,A3,A4,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.032639, "GAMMA.DIST(A2,A3,A4,FALSE)");

		oParser = new parserFormula("GAMMA.DIST(A2,A3,A4,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "GAMMA.DIST(A2,A3,A4,TRUE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.068094, "GAMMA.DIST(A2,A3,A4,TRUE)");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: x ? 0, alpha = 1 (exponential distribution), beta > 0, cumulative = TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Number. Basic valid input: x ? 0, alpha = 1 (exponential distribution), beta > 0, cumulative = TRUE. 4 of 4 arguments used.');
		// Case #1: Number. Valid input: positive float x, alpha > 0, beta > 0, cumulative = FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(1.5,2,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(1.5,2,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.33469524022264474, 'Test: Positive case: Number. Valid input: positive float x, alpha > 0, beta > 0, cumulative = FALSE. 4 of 4 arguments used.');
		// Case #2: Number. Boundary x = 0, alpha = 1, beta > 0, cumulative = TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(0,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(0,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Boundary x = 0, alpha = 1, beta > 0, cumulative = TRUE. 4 of 4 arguments used.');
		// Case #3: String. Strings convertible to valid numbers and TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST("2","1","1","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST("2","1","1","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.864664717, 'Test: Positive case: String. Strings convertible to valid numbers and TRUE. 4 of 4 arguments used.');
		// Case #4: Formula. Nested formulas returning valid numbers, cumulative = TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(SQRT(4),ABS(1),ABS(1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(SQRT(4),ABS(1),ABS(1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Formula. Nested formulas returning valid numbers, cumulative = TRUE. 4 of 4 arguments used.');
		// Case #5: Reference link. References to cells with valid numbers (2, 1.5, 0.5, TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8298126213987767, 'Test: Positive case: Reference link. References to cells with valid numbers (2, 1.5, 0.5, TRUE). 4 of 4 arguments used.');
		// Case #6: Area. Single-cell ranges with valid numbers (2, 1.5, 0.5, TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8298126213987767, 'Test: Positive case: Area. Single-cell ranges with valid numbers (2, 1.5, 0.5, TRUE). 4 of 4 arguments used.');
		// Case #7: Array. Arrays with single valid elements. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST({2},{1},{1},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST({2},{1},{1},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Array. Arrays with single valid elements. 4 of 4 arguments used.');
		// Case #8: Name. Named ranges with valid numbers (2, 1.5, 0.5, 0.5). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers (2, 1.5, 0.5, 0.5). 4 of 4 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid numbers (3, 1, 0.5, TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers (3, 1, 0.5, TRUE). 4 of 4 arguments used.');
		// Case #10: Ref3D. 3D references to cells with valid numbers (2, 3, TRUE, 1). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells with valid numbers (2, 3, TRUE, 1). 4 of 4 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges with valid numbers (2, 3, TRUE, 1). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers (2, 3, TRUE, 1). 4 of 4 arguments used.');
		// Case #12: Table. Table structured references with valid numbers (2, TRUE, 1, TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6299623388962401, 'Test: Positive case: Table. Table structured references with valid numbers (2, TRUE, 1, TRUE). 4 of 4 arguments used.');
		// Case #13: Date. Date as serial number for x (> 0), valid alpha, beta, cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(DATE(2025,1,1),1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(DATE(2025,1,1),1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number for x (> 0), valid alpha, beta, cumulative. 4 of 4 arguments used.');
		// Case #14: Time. Time adjusted to valid x (>= 1), valid alpha, beta, cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(TIME(12,0,0)+1,1,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(TIME(12,0,0)+1,1,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22313016014842982, 'Test: Positive case: Time. Time adjusted to valid x (>= 1), valid alpha, beta, cumulative. 4 of 4 arguments used.');
		// Case #15: Formula. GAMMA.DIST inside SUM formula, valid inputs. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(GAMMA.DIST(2,1,1,TRUE),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GAMMA.DIST(2,1,1,TRUE),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8646647167633872, 'Test: Positive case: Formula. GAMMA.DIST inside SUM formula, valid inputs. 4 of 4 arguments used.');
		// Case #16: Number. Alpha = 0.5 (non-integer), beta = 2, cumulative = TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(1,0.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(1,0.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.682689492137086, 'Test: Positive case: Number. Alpha = 0.5 (non-integer), beta = 2, cumulative = TRUE. 4 of 4 arguments used.');
		// Case #17: String. Strings convertible to valid numbers and FALSE (0). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST("1","2","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST("1","2","1","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String. Strings convertible to valid numbers and FALSE (0). 4 of 4 arguments used.');
		// Case #18: Array. Arrays with single valid elements, cumulative as 1 (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST({1},{2},{1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST({1},{2},{1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2642411176571153, 'Test: Positive case: Array. Arrays with single valid elements, cumulative as 1 (TRUE). 4 of 4 arguments used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(IF(TRUE,2,1),IF(TRUE,1,0.5),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(IF(TRUE,2,1),IF(TRUE,1,0.5),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 4 of 4 arguments used.');
		// Case #20: Number. Alpha = n/2, beta = 2, cumulative = TRUE (relates to chi-squared distribution). 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,2,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,2,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2642411176571153, 'Test: Positive case: Number. Alpha = n/2, beta = 2, cumulative = TRUE (relates to chi-squared distribution). 4 of 4 arguments used.');
		// Case #21: Number. Alpha as positive integer (Erlang distribution), cumulative = FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(1,3,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(1,3,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.18393972058572117, 'Test: Positive case: Number. Alpha as positive integer (Erlang distribution), cumulative = FALSE. 4 of 4 arguments used.');
		// Case #22: Formula. Nested formula converting negative x to positive. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(ABS(-2),1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(ABS(-2),1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8646647167633872, 'Test: Positive case: Formula. Nested formula converting negative x to positive. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number. x < 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(-1,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(-1,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. x < 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number. Alpha ? 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Alpha ? 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number. Beta ? 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,1,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,1,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Beta ? 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #4: String. Non-numeric x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST("abc",1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST("abc",1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric x returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: String. Non-numeric alpha returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,"abc",1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,"abc",1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric alpha returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: String. Non-numeric beta returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,1,"abc",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,1,"abc",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric beta returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: Error. Propagates #N/A error for x. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(NA(),1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(NA(),1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for x. 4 of 4 arguments used.');
		// Case #8: Empty. Empty x reference returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(A104,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(A104,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3934693402873665, 'Test: Negative case: Empty. Empty x reference returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Area. Multi-cell range for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(A100:A101,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(A100:A101,1,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.095162582, 'Test: Negative case: Area. Multi-cell range for x returns #NUM!. 4 of 4 arguments used.');
		// Case #10: Area. Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,A100:A101,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,A100:A101,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.994326176, 'Test: Negative case: Area. Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #11: Area. Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,1,A100:A101,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,1,A100:A101,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.999999998, 'Test: Negative case: Area. Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.');
		// Case #12: Ref3D. 3D reference to text (abc) for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(Sheet2!A3,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(Sheet2!A3,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text (abc) for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #13: Name. Named range with text (invalid) for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(TestNameArea2,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(TestNameArea2,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5506710358827783, 'Test: Negative case: Name. Named range with text (invalid) for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #14: Table. Table column with text (error) for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(Table1[Column2],1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(Table1[Column2],1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text (error) for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! for x. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(SQRT(-1),1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(SQRT(-1),1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! for x. 4 of 4 arguments used.');
		// Case #16: Array. Array with boolean for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST({FALSE},1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST({FALSE},1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with boolean for x returns #NUM!. 4 of 4 arguments used.');
		// Case #17: Number. Negative alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,-1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,-1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #18: Number. Negative beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,1,-1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,1,-1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative beta returns #NUM!. 4 of 4 arguments used.');
		// Case #19: Area3D. 3D multi-cell range for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(Sheet2!A4:A5,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(Sheet2!A4:A5,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range for x returns #NUM!. 4 of 4 arguments used.');
		// Case #20: Name3D. 3D named range with text (invalid) for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(TestNameArea3D2,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(TestNameArea3D2,1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5506710358827783, 'Test: Negative case: Name3D. 3D named range with text (invalid) for x returns #VALUE!. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers for x, alpha, beta accepted by Excel. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(1E-307,1E-307,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(1E-307,1E-307,1E-307,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum positive numbers for x, alpha, beta accepted by Excel. 4 of 4 arguments used.');
		// Case #2: Number. Maximum positive x accepted by Excel. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(1.7E307,1,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(1.7E307,1,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum positive x accepted by Excel. 4 of 4 arguments used.');
		// Case #3: Number. Maximum positive alpha accepted by Excel. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,1.7E307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,1.7E307,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum positive alpha accepted by Excel. 4 of 4 arguments used.');
		// Case #4: Number. Maximum positive beta accepted by Excel. 4 of 4 arguments used.
		oParser = new parserFormula('GAMMA.DIST(2,1,1.7E307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.DIST(2,1,1.7E307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1764705882352546e-307, 'Test: Bounded case: Number. Maximum positive beta accepted by Excel. 4 of 4 arguments used.');

		// Need to fix: different result from MS
		// Case #3: String. Strings convertible to valid numbers and TRUE. 4 of 4 arguments used.
		// Case #17: String. Strings convertible to valid numbers and FALSE (0). 4 of 4 arguments used.
		// Case #9: Area. Multi-cell range for x returns #NUM!. 4 of 4 arguments used
		// Case #10: Area. Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.
		// Case #11: Area. Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.
		// Case #1: Number. Minimum positive numbers for x, alpha, beta accepted by Excel. 4 of 4 arguments used.
		// Case #2: Number. Maximum positive x accepted by Excel. 4 of 4 arguments used.
		// Case #3: Number. Maximum positive alpha accepted by Excel. 4 of 4 arguments used.


		testArrayFormula2(assert, "GAMMA.DIST", 4, 4);
	});

	QUnit.test("Test: \"GAMMAINV\"", function (assert) {
		ws.getRange2("A2").setValue("0.068094");
		ws.getRange2("A3").setValue("9");
		ws.getRange2("A4").setValue("2");

		oParser = new parserFormula("GAMMAINV(A2,A3,A4)", "A1", ws);
		assert.ok(oParser.parse(), "GAMMAINV(A2,A3,A4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 10.0000112, "GAMMAINV(A2,A3,A4)");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: probability = 0.5, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: Number. Basic valid input: probability = 0.5, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #1: Number. Valid input: probability < 0.5, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.25,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.25,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9612787631147771, 'Test: Positive case: Number. Valid input: probability < 0.5, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #2: Number. Boundary probability = 0, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Boundary probability = 0, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #3: Number. Boundary probability = 1, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Boundary probability = 1, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #4: String. Strings convertible to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV("0.5","1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV("0.5","1","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: String. Strings convertible to valid numbers. 3 of 3 arguments used.');
		// Case #5: Formula. Nested formulas returning valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(ABS(0.5),SQRT(4),ABS(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(ABS(0.5),SQRT(4),ABS(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6783469900166608, 'Test: Positive case: Formula. Nested formulas returning valid numbers. 3 of 3 arguments used.');
		// Case #6: Reference link. References to cells with valid numbers (0.5, 2, 0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0000019576548985859113, 'Test: Positive case: Reference link. References to cells with valid numbers (0.5, 2, 0.5). 3 of 3 arguments used.');
		// Case #7: Area. Single-cell ranges with valid numbers (0.5, 2, 0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0000019576548985859113, 'Test: Positive case: Area. Single-cell ranges with valid numbers (0.5, 2, 0.5). 3 of 3 arguments used.');
		// Case #8: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV({0.5},{1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV({0.5},{1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');
		// Case #9: Name. Named ranges with valid numbers (2, 0.5, 0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers (2, 0.5, 0.5). 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named ranges with valid numbers (3, 1, 0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers (3, 1, 0.5). 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D references to cells with valid numbers (2, 3, TRUE). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells with valid numbers (2, 3, TRUE). 3 of 3 arguments used.');
		// Case #12: Area3D. 3D single-cell ranges with valid numbers (2, 3, TRUE). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers (2, 3, TRUE). 3 of 3 arguments used.');
		// Case #13: Table. Table structured references with valid numbers (0.5, TRUE, 1). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Table. Table structured references with valid numbers (0.5, TRUE, 1). 3 of 3 arguments used.');
		// Case #14: Date. Date as serial number divided to valid probability (< 1). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(DATE(2025,1,1)/100000,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(DATE(2025,1,1)/100000,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6098727773672249, 'Test: Positive case: Date. Date as serial number divided to valid probability (< 1). 3 of 3 arguments used.');
		// Case #15: Time. Time as valid probability (0.5), alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(TIME(12,0,0),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(TIME(12,0,0),1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: Time. Time as valid probability (0.5), alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #16: Formula. GAMMAINV inside SUM formula, valid inputs. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(GAMMAINV(0.5,1,1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GAMMAINV(0.5,1,1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6931471805599454, 'Test: Positive case: Formula. GAMMAINV inside SUM formula, valid inputs. 3 of 3 arguments used.');
		// Case #17: Number. Probability close to 1, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.999,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.999,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.233413476451585, 'Test: Positive case: Number. Probability close to 1, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #18: String. Strings convertible to valid numbers, probability close to 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV("0.001","2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV("0.001","2","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.045402017769489544, 'Test: Positive case: String. Strings convertible to valid numbers, probability close to 0. 3 of 3 arguments used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(IF(TRUE,0.5,0.1),IF(TRUE,1,0.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(IF(TRUE,0.5,0.1),IF(TRUE,1,0.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 3 of 3 arguments used.');
		// Case #20: Number. Alpha as non-integer positive number. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,0.5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,0.5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4549364231195724, 'Test: Positive case: Number. Alpha as non-integer positive number. 3 of 3 arguments used.');
		// Case #21: Formula. Nested formula adjusting probability to valid range (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(ABS(-0.5)+1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(ABS(-0.5)+1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Nested formula adjusting probability to valid range (0.5). 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability < 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(-0.1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(-0.1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability < 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Probability > 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(1.1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(1.1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability > 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Alpha â?¤ 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Alpha â?¤ 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. Beta â?¤ 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Beta â?¤ 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #5: String. Non-numeric probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV("abc",1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV("abc",1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: String. Non-numeric alpha returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,"abc",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,"abc",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric alpha returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: String. Non-numeric beta returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,1,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric beta returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Error. Propagates #N/A error for probability. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(NA(),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(NA(),1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for probability. 3 of 3 arguments used.');
		// Case #9: Empty. Empty probability reference returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(A103,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(A103,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5108256237659908, 'Test: Negative case: Empty. Empty probability reference returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(A100:A101,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(A100:A101,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.105360516, 'Test: Negative case: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.');
		// Case #11: Area. Multi-cell range for alpha returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,A100:A101,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.000593391, 'Test: Negative case: Area. Multi-cell range for alpha returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Area. Multi-cell range for beta returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,1,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,1,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.069314718, 'Test: Negative case: Area. Multi-cell range for beta returns #NUM!. 3 of 3 arguments used.');
		// Case #13: Ref3D. 3D reference to text (abc) for probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(Sheet2!A3,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(Sheet2!A3,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text (abc) for probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Name. Named range with text (invalid) for probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(TestNameArea2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(TestNameArea2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6094379124341007, 'Test: Negative case: Name. Named range with text (invalid) for probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Table. Table column with text (error) for probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(Table1[Column2],1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(Table1[Column2],1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text (error) for probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Formula. Formula resulting in #NUM! for probability. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(SQRT(-1),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(SQRT(-1),1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! for probability. 3 of 3 arguments used.');
		// Case #17: Array. Array with boolean for probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV({FALSE},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV({FALSE},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with boolean for probability returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Area3D. 3D multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(Sheet2!A4:A5,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(Sheet2!A4:A5,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range for probability returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Name3D. 3D named range with text (invalid) for probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(TestNameArea3D2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(TestNameArea3D2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6094379124341007, 'Test: Negative case: Name3D. 3D named range with text (invalid) for probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Number. Extreme values testing potential #N/A due to non-convergence. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.999999999999999,1.7E307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.999999999999999,1.7E307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.7005e+307, 'Test: Negative case: Number. Extreme values testing potential #N/A due to non-convergence. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers for probability, alpha, beta accepted by Excel. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(1E-307,1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(1E-307,1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive numbers for probability, alpha, beta accepted by Excel. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability close to 1. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.999999999999999,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.999999999999999,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 34.59358974358975, 'Test: Bounded case: Number. Maximum valid probability close to 1. 3 of 3 arguments used.');
		// Case #3: Number. Maximum positive alpha accepted by Excel. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,1.7E307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,1.7E307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.7005e+307, 'Test: Bounded case: Number. Maximum positive alpha accepted by Excel. 3 of 3 arguments used.');
		// Case #4: Number. Maximum positive beta accepted by Excel. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMAINV(0.5,1,1.7E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMAINV(0.5,1,1.7E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.178350206951907e+307, 'Test: Bounded case: Number. Maximum positive beta accepted by Excel. 3 of 3 arguments used.');

		// Need to fix: area handle, diff result in boundary case
		// Case #10: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		// Case #11: Area. Multi-cell range for alpha returns #NUM!. 3 of 3 arguments used.
		// Case #12: Area. Multi-cell range for beta returns #NUM!. 3 of 3 arguments used.
		// Case #20: Number. Extreme values testing potential #N/A due to non-convergence. 3 of 3 arguments used.
		// Case #3: Number. Maximum positive alpha accepted by Excel. 3 of 3 arguments used.

	});

	QUnit.test("Test: \"GAMMA.INV\"", function (assert) {
		ws.getRange2("A2").setValue("0.068094");
		ws.getRange2("A3").setValue("9");
		ws.getRange2("A4").setValue("2");

		oParser = new parserFormula("GAMMA.INV(A2,A3,A4)", "A1", ws);
		assert.ok(oParser.parse(), "GAMMA.INV(A2,A3,A4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 10.0000112, "GAMMA.INV(A2,A3,A4)");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: probability = 0.5, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: Number. Basic valid input: probability = 0.5, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #1: Number. Valid input: probability < 0.5, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.25,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.25,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9612787631147771, 'Test: Positive case: Number. Valid input: probability < 0.5, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #2: Number. Boundary probability = 0, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Boundary probability = 0, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #3: Number. Boundary probability = 1, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Boundary probability = 1, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #4: String. Strings convertible to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV("0.5","1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV("0.5","1","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: String. Strings convertible to valid numbers. 3 of 3 arguments used.');
		// Case #5: Formula. Nested formulas returning valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(ABS(0.5),SQRT(4),ABS(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(ABS(0.5),SQRT(4),ABS(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6783469900166608, 'Test: Positive case: Formula. Nested formulas returning valid numbers. 3 of 3 arguments used.');
		// Case #6: Reference link. References to cells with valid numbers (0.5, 2, 0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0000019576548985859113, 'Test: Positive case: Reference link. References to cells with valid numbers (0.5, 2, 0.5). 3 of 3 arguments used.');
		// Case #7: Area. Single-cell ranges with valid numbers (0.5, 2, 0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0000019576548985859113, 'Test: Positive case: Area. Single-cell ranges with valid numbers (0.5, 2, 0.5). 3 of 3 arguments used.');
		// Case #8: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV({0.5},{1},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV({0.5},{1},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');
		// Case #9: Name. Named ranges with valid numbers (2, 0.5, 0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers (2, 0.5, 0.5). 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named ranges with valid numbers (3, 1, 0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers (3, 1, 0.5). 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D references to cells with valid numbers (2, 3, TRUE). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells with valid numbers (2, 3, TRUE). 3 of 3 arguments used.');
		// Case #12: Area3D. 3D single-cell ranges with valid numbers (2, 3, TRUE). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers (2, 3, TRUE). 3 of 3 arguments used.');
		// Case #13: Table. Table structured references with valid numbers (0.5, TRUE, 1). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Table. Table structured references with valid numbers (0.5, TRUE, 1). 3 of 3 arguments used.');
		// Case #14: Date. Date as serial number divided to valid probability (< 1). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(DATE(2025,1,1)/100000,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(DATE(2025,1,1)/100000,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6098727773672249, 'Test: Positive case: Date. Date as serial number divided to valid probability (< 1). 3 of 3 arguments used.');
		// Case #15: Time. Time as valid probability (0.5), alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(TIME(12,0,0),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(TIME(12,0,0),1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: Time. Time as valid probability (0.5), alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #16: Formula. GAMMA.INV inside SUM formula, valid inputs. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(GAMMA.INV(0.5,1,1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GAMMA.INV(0.5,1,1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6931471805599454, 'Test: Positive case: Formula. GAMMA.INV inside SUM formula, valid inputs. 3 of 3 arguments used.');
		// Case #17: Number. Probability close to 1, alpha > 0, beta > 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.999,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.999,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.233413476451585, 'Test: Positive case: Number. Probability close to 1, alpha > 0, beta > 0. 3 of 3 arguments used.');
		// Case #18: String. Strings convertible to valid numbers, probability close to 0. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV("0.001","2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV("0.001","2","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.045402017769489544, 'Test: Positive case: String. Strings convertible to valid numbers, probability close to 0. 3 of 3 arguments used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(IF(TRUE,0.5,0.1),IF(TRUE,1,0.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(IF(TRUE,0.5,0.1),IF(TRUE,1,0.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6931471805599453, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 3 of 3 arguments used.');
		// Case #20: Number. Alpha as non-integer positive number. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,0.5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,0.5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4549364231195724, 'Test: Positive case: Number. Alpha as non-integer positive number. 3 of 3 arguments used.');
		// Case #21: Formula. Nested formula adjusting probability to valid range (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(ABS(-0.5)+1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(ABS(-0.5)+1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Nested formula adjusting probability to valid range (0.5). 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability < 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(-0.1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(-0.1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability < 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Probability > 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(1.1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(1.1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability > 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Alpha â?¤ 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Alpha â?¤ 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. Beta â?¤ 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Beta â?¤ 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #5: String. Non-numeric probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV("abc",1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV("abc",1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: String. Non-numeric alpha returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,"abc",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,"abc",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric alpha returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: String. Non-numeric beta returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,1,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric beta returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Error. Propagates #N/A error for probability. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(NA(),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(NA(),1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for probability. 3 of 3 arguments used.');
		// Case #9: Empty. Empty probability reference returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(A103,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(A103,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5108256237659908, 'Test: Negative case: Empty. Empty probability reference returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(A100:A101,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(A100:A101,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.105360516, 'Test: Negative case: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.');
		// Case #11: Area. Multi-cell range for alpha returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,A100:A101,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.000593391, 'Test: Negative case: Area. Multi-cell range for alpha returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Area. Multi-cell range for beta returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,1,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,1,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.069314718, 'Test: Negative case: Area. Multi-cell range for beta returns #NUM!. 3 of 3 arguments used.');
		// Case #13: Ref3D. 3D reference to text (abc) for probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(Sheet2!A3,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(Sheet2!A3,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text (abc) for probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Name. Named range with text (invalid) for probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(TestNameArea2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(TestNameArea2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6094379124341007, 'Test: Negative case: Name. Named range with text (invalid) for probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Table. Table column with text (error) for probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(Table1[Column2],1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(Table1[Column2],1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text (error) for probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Formula. Formula resulting in #NUM! for probability. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(SQRT(-1),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(SQRT(-1),1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! for probability. 3 of 3 arguments used.');
		// Case #17: Array. Array with boolean for probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV({FALSE},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV({FALSE},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with boolean for probability returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Area3D. 3D multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(Sheet2!A4:A5,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(Sheet2!A4:A5,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range for probability returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Name3D. 3D named range with text (invalid) for probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(TestNameArea3D2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(TestNameArea3D2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6094379124341007, 'Test: Negative case: Name3D. 3D named range with text (invalid) for probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Number. Extreme values testing potential #N/A due to non-convergence. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.999999999999999,1.7E307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.999999999999999,1.7E307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.7005e+307, 'Test: Negative case: Number. Extreme values testing potential #N/A due to non-convergence. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers for probability, alpha, beta accepted by Excel. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(1E-307,1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(1E-307,1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive numbers for probability, alpha, beta accepted by Excel. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability close to 1. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.999999999999999,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.999999999999999,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 34.59358974358975, 'Test: Bounded case: Number. Maximum valid probability close to 1. 3 of 3 arguments used.');
		// Case #3: Number. Maximum positive alpha accepted by Excel. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,1.7E307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,1.7E307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.7005e+307, 'Test: Bounded case: Number. Maximum positive alpha accepted by Excel. 3 of 3 arguments used.');
		// Case #4: Number. Maximum positive beta accepted by Excel. 3 of 3 arguments used.
		oParser = new parserFormula('GAMMA.INV(0.5,1,1.7E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMA.INV(0.5,1,1.7E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.178350206951907e+307, 'Test: Bounded case: Number. Maximum positive beta accepted by Excel. 3 of 3 arguments used.');

		// Need to fix: area handle, diff result in boundary case
		// Case #10: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		// Case #11: Area. Multi-cell range for alpha returns #NUM!. 3 of 3 arguments used.
		// Case #12: Area. Multi-cell range for beta returns #NUM!. 3 of 3 arguments used.
		// Case #20: Number. Extreme values testing potential #N/A due to non-convergence. 3 of 3 arguments used.
		// Case #3: Number. Maximum positive alpha accepted by Excel. 3 of 3 arguments used.

		testArrayFormula2(assert, "GAMMA.INV", 3, 3);
	});

	QUnit.test("Test: \"GAMMALN\"", function (assert) {

		oParser = new parserFormula("GAMMALN(4.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 2.45373657084244);

		oParser = new parserFormula("GAMMALN(-4.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		testArrayFormula(assert, "GAMMALN");


		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: integer > 0. 1 argument used.
		oParser = new parserFormula('GAMMALN(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.801827480081469, 'Test: Positive case: Number. Basic valid input: integer > 0. 1 argument used.');
		// Case #1: Number. Basic valid input: positive float. 1 argument used.
		oParser = new parserFormula('GAMMALN(2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2846828704729192, 'Test: Positive case: Number. Basic valid input: positive float. 1 argument used.');
		// Case #2: Number. Small positive number close to 1. 1 argument used.
		oParser = new parserFormula('GAMMALN(1.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(1.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -5.7721558755496383e-8, 'Test: Positive case: Number. Small positive number close to 1. 1 argument used.');
		// Case #3: String. String convertible to positive number. 1 argument used.
		oParser = new parserFormula('GAMMALN("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String convertible to positive number. 1 argument used.');
		// Case #4: Formula. Nested formula returning valid number. 1 argument used.
		oParser = new parserFormula('GAMMALN(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula. Nested formula returning valid number. 1 argument used.');
		// Case #5: Reference link. Reference to cell with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMALN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2527126517342064, 'Test: Positive case: Reference link. Reference to cell with valid number (2). 1 argument used.');
		// Case #6: Area. Single-cell range with valid number (1.5). 1 argument used.
		oParser = new parserFormula('GAMMALN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5240638224307845, 'Test: Positive case: Area. Single-cell range with valid number (1.5). 1 argument used.');
		// Case #7: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('GAMMALN({2.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN({2.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.2846828704729192, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #8: Name. Named range with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMALN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid number (2). 1 argument used.');
		// Case #9: Name3D. 3D named range with valid number (3). 1 argument used.
		oParser = new parserFormula('GAMMALN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid number (3). 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMALN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5723649429247, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (2). 1 argument used.');
		// Case #11: Area3D. 3D single-cell range with valid number (3). 1 argument used.
		oParser = new parserFormula('GAMMALN(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.1207822376352453, 'Test: Positive case: Area3D. 3D single-cell range with valid number (3). 1 argument used.');
		// Case #12: Table. Table structured reference with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMALN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.0028655665659086597, 'Test: Positive case: Table. Table structured reference with valid number (2). 1 argument used.');
		// Case #13: Date. Date as serial number (> 0). 1 argument used.
		oParser = new parserFormula('GAMMALN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 444199.228392288, 'Test: Positive case: Date. Date as serial number (> 0). 1 argument used.');
		// Case #14: Time. Time adjusted to valid number (>= 1). 1 argument used.
		oParser = new parserFormula('GAMMALN(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.1207822376352453, 'Test: Positive case: Time. Time adjusted to valid number (>= 1). 1 argument used.');
		// Case #15: Formula. GAMMA inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(GAMMALN(2.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GAMMALN(2.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.2846828704729192, 'Test: Positive case: Formula. GAMMA inside SUM formula. 1 argument used.');
		// Case #16: Number. Very small positive number. 1 argument used.
		oParser = new parserFormula('GAMMALN(0.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(0.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16.11809559323676, 'Test: Positive case: Number. Very small positive number. 1 argument used.');
		// Case #17: String. Short date string convertible to number. 1 argument used.
		oParser = new parserFormula('GAMMALN("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN("12/12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 447902.0070689264, 'Test: Positive case: String. Short date string convertible to number. 1 argument used.');
		// Case #18: Array. Array with single valid element (duplicate for coverage). 1 argument used.
		oParser = new parserFormula('GAMMALN({2.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN({2.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.2846828704729192, 'Test: Positive case: Array. Array with single valid element (duplicate for coverage). 1 argument used.');
		// Case #19: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('GAMMALN(IF(TRUE, 2.5, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(IF(TRUE, 2.5, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2846828704729192, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');
		// Case #20: Number. Negative non-integer number (valid). 1 argument used.
		oParser = new parserFormula('GAMMALN(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Negative non-integer number (valid). 1 argument used.');
		// Case #21: String. String convertible to negative non-integer number. 1 argument used.
		oParser = new parserFormula('GAMMALN("-0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN("-0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. String convertible to negative non-integer number. 1 argument used.');
		// Case #22: Formula. Nested formula converting negative to positive number. 1 argument used.
		oParser = new parserFormula('GAMMALN(ABS(-2.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(ABS(-2.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2846828704729192, 'Test: Positive case: Formula. Nested formula converting negative to positive number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative integer returns #NUM!. 1 argument used.');
		// Case #2: Number. Zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero returns #NUM!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('GAMMALN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0957979948180758, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.796677818, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Boolean. Boolean FALSE (0) returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!. 1 argument used.');
		// Case #9: Boolean. Boolean TRUE (1) returns valid result, but testing for clarity. 1 argument used.
		oParser = new parserFormula('GAMMALN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result, but testing for clarity. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with text (abc) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with text (abc) returns #VALUE!. 1 argument used.');
		// Case #11: Name. Named range with text (invalid) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1520596783998375, 'Test: Negative case: Name. Named range with text (invalid) returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text (error) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text (error) returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('GAMMALN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #14: Array. Array with boolean returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!. 1 argument used.');
		// Case #15: Number. Negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative integer returns #NUM!. 1 argument used.');
		// Case #16: String. String convertible to zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to zero returns #NUM!. 1 argument used.');
		// Case #17: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.');
		// Case #18: Name3D. 3D named range with text (invalid) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1520596783998375, 'Test: Negative case: Name3D. 3D named range with text (invalid) returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN(DATE(2025,1,1)-DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(DATE(2025,1,1)-DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in zero returns #NUM!. 1 argument used.');
		// Case #20: Number. Large negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN(-1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(-1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large negative integer returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive number accepted by Excel. 1 argument used.
		oParser = new parserFormula('GAMMALN(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 706.8936235, 'Test: Bounded case: Number. Minimum positive number accepted by Excel. 1 argument used.');
		// Case #2: Number. Maximum positive number accepted by Excel. 1 argument used.
		oParser = new parserFormula('GAMMALN(1.7E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(1.7E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum positive number accepted by Excel. 1 argument used.');
		// Case #3: Number. Negative number close to -1 but non-integer. 1 argument used.
		oParser = new parserFormula('GAMMALN(-0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN(-0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Negative number close to -1 but non-integer. 1 argument used.');

		// Need to fix: diff results
		// Case #6: Area. Multi-cell range returns #NUM!. 1 argument used.
		// Case #1: Number. Minimum positive number accepted by Excel. 1 argument used.


	});

	QUnit.test("Test: \"GAMMALN.PRECISE\"", function (assert) {

		oParser = new parserFormula("GAMMALN.PRECISE(4)", "A1", ws);
		assert.ok(oParser.parse(), "GAMMALN.PRECISE(4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 1.7917595, "GAMMALN.PRECISE(4)");

		oParser = new parserFormula("GAMMALN.PRECISE(-4.5)", "A1", ws);
		assert.ok(oParser.parse(), "GAMMALN.PRECISE(-4.5)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "GAMMALN.PRECISE(-4.5)");
		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: integer > 0. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.801827480081469, 'Test: Positive case: Number. Basic valid input: integer > 0. 1 argument used.');
		// Case #1: Number. Basic valid input: positive float. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2846828704729192, 'Test: Positive case: Number. Basic valid input: positive float. 1 argument used.');
		// Case #2: Number. Small positive number close to 1. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(1.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(1.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -5.7721558755496383e-8, 'Test: Positive case: Number. Small positive number close to 1. 1 argument used.');
		// Case #3: String. String convertible to positive number. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String convertible to positive number. 1 argument used.');
		// Case #4: Formula. Nested formula returning valid number. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula. Nested formula returning valid number. 1 argument used.');
		// Case #5: Reference link. Reference to cell with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2527126517342064, 'Test: Positive case: Reference link. Reference to cell with valid number (2). 1 argument used.');
		// Case #6: Area. Single-cell range with valid number (1.5). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5240638224307845, 'Test: Positive case: Area. Single-cell range with valid number (1.5). 1 argument used.');
		// Case #7: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE({2.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE({2.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2846828704729192, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #8: Name. Named range with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid number (2). 1 argument used.');
		// Case #9: Name3D. 3D named range with valid number (3). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid number (3). 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5723649429247, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (2). 1 argument used.');
		// Case #11: Area3D. 3D single-cell range with valid number (3). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.1207822376352453, 'Test: Positive case: Area3D. 3D single-cell range with valid number (3). 1 argument used.');
		// Case #12: Table. Table structured reference with valid number (2). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.0028655665659086597, 'Test: Positive case: Table. Table structured reference with valid number (2). 1 argument used.');
		// Case #13: Date. Date as serial number (> 0). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 444199.228392288, 'Test: Positive case: Date. Date as serial number (> 0). 1 argument used.');
		// Case #14: Time. Time adjusted to valid number (>= 1). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.1207822376352453, 'Test: Positive case: Time. Time adjusted to valid number (>= 1). 1 argument used.');
		// Case #15: Formula. GAMMA inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(GAMMALN.PRECISE(2.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GAMMALN.PRECISE(2.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.2846828704729192, 'Test: Positive case: Formula. GAMMA inside SUM formula. 1 argument used.');
		// Case #16: Number. Very small positive number. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(0.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(0.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16.11809559323676, 'Test: Positive case: Number. Very small positive number. 1 argument used.');
		// Case #17: String. Short date string convertible to number. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE("12/12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 447902.0070689264, 'Test: Positive case: String. Short date string convertible to number. 1 argument used.');
		// Case #18: Array. Array with single valid element (duplicate for coverage). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE({2.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE({2.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2846828704729192, 'Test: Positive case: Array. Array with single valid element (duplicate for coverage). 1 argument used.');
		// Case #19: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(IF(TRUE, 2.5, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(IF(TRUE, 2.5, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2846828704729192, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');
		// Case #20: Number. Negative non-integer number (valid). 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Negative non-integer number (valid). 1 argument used.');
		// Case #21: String. String convertible to negative non-integer number. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE("-0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE("-0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. String convertible to negative non-integer number. 1 argument used.');
		// Case #22: Formula. Nested formula converting negative to positive number. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(ABS(-2.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(ABS(-2.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2846828704729192, 'Test: Positive case: Formula. Nested formula converting negative to positive number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative integer returns #NUM!. 1 argument used.');
		// Case #2: Number. Zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero returns #NUM!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0957979948180758, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.796677818, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Boolean. Boolean FALSE (0) returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!. 1 argument used.');
		// Case #9: Boolean. Boolean TRUE (1) returns valid result, but testing for clarity. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result, but testing for clarity. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with text (abc) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with text (abc) returns #VALUE!. 1 argument used.');
		// Case #11: Name. Named range with text (invalid) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1520596783998375, 'Test: Negative case: Name. Named range with text (invalid) returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text (error) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text (error) returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #14: Array. Array with boolean returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!. 1 argument used.');
		// Case #15: Number. Negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative integer returns #NUM!. 1 argument used.');
		// Case #16: String. String convertible to zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to zero returns #NUM!. 1 argument used.');
		// Case #17: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.');
		// Case #18: Name3D. 3D named range with text (invalid) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1520596783998375, 'Test: Negative case: Name3D. 3D named range with text (invalid) returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(DATE(2025,1,1)-DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(DATE(2025,1,1)-DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in zero returns #NUM!. 1 argument used.');
		// Case #20: Number. Large negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(-1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(-1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large negative integer returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive number accepted by Excel. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 706.8936235, 'Test: Bounded case: Number. Minimum positive number accepted by Excel. 1 argument used.');
		// Case #2: Number. Maximum positive number accepted by Excel. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(1.7E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(1.7E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum positive number accepted by Excel. 1 argument used.');
		// Case #3: Number. Negative number close to -1 but non-integer. 1 argument used.
		oParser = new parserFormula('GAMMALN.PRECISE(-0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAMMALN.PRECISE(-0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Negative number close to -1 but non-integer. 1 argument used.');

		// Need to fix:
		// Case #6: Area. Multi-cell range returns #NUM!. 1 argument used.
		// Case #1: Number. Minimum positive number accepted by Excel. 1 argument used.

		testArrayFormula2(assert, "GAMMALN.PRECISE", 1, 1);
	});

	QUnit.test("Test: \"GAUSS\"", function (assert) {
		oParser = new parserFormula("GAUSS(2)", "A1", ws);
		assert.ok(oParser.parse(), "GAUSS(2)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 0.47725, "GAUSS(2)");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: integer > 0. 1 argument used.
		oParser = new parserFormula('GAUSS(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Basic valid input: integer > 0. 1 argument used.');
		// Case #1: Number. Basic valid input: positive float. 1 argument used.
		oParser = new parserFormula('GAUSS(2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.49379033467422384, 'Test: Positive case: Number. Basic valid input: positive float. 1 argument used.');
		// Case #2: Number. Small positive number close to 1. 1 argument used.
		oParser = new parserFormula('GAUSS(1.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(1.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3413447702656143, 'Test: Positive case: Number. Small positive number close to 1. 1 argument used.');
		// Case #3: String. String convertible to positive number. 1 argument used.
		oParser = new parserFormula('GAUSS("2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS("2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4772498680518208, 'Test: Positive case: String. String convertible to positive number. 1 argument used.');
		// Case #4: Formula. Nested formula returning valid number. 1 argument used.
		oParser = new parserFormula('GAUSS(SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4772498680518208, 'Test: Positive case: Formula. Nested formula returning valid number. 1 argument used.');
		// Case #5: Reference link. Reference to cell with valid number (2). 1 argument used.
		oParser = new parserFormula('GAUSS(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03982783727702899, 'Test: Positive case: Reference link. Reference to cell with valid number (2). 1 argument used.');
		// Case #6: Area. Single-cell range with valid number (1.5). 1 argument used.
		oParser = new parserFormula('GAUSS(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07925970943910304, 'Test: Positive case: Area. Single-cell range with valid number (1.5). 1 argument used.');
		// Case #7: Array. Array with single valid element. 1 argument used.
		oParser = new parserFormula('GAUSS({2.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS({2.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.49379033467422384, 'Test: Positive case: Array. Array with single valid element. 1 argument used.');
		// Case #8: Name. Named range with valid number (2). 1 argument used.
		oParser = new parserFormula('GAUSS(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.19146246127401353, 'Test: Positive case: Name. Named range with valid number (2). 1 argument used.');
		// Case #9: Name3D. 3D named range with valid number (3). 1 argument used.
		oParser = new parserFormula('GAUSS(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.19146246127401353, 'Test: Positive case: Name3D. 3D named range with valid number (3). 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with valid number (2). 1 argument used.
		oParser = new parserFormula('GAUSS(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.19146246127401353, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (2). 1 argument used.');
		// Case #11: Area3D. 3D single-cell range with valid number (3). 1 argument used.
		oParser = new parserFormula('GAUSS(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4331927987311419, 'Test: Positive case: Area3D. 3D single-cell range with valid number (3). 1 argument used.');
		// Case #12: Table. Table structured reference with valid number (2). 1 argument used.
		oParser = new parserFormula('GAUSS(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.34255157506967226, 'Test: Positive case: Table. Table structured reference with valid number (2). 1 argument used.');
		// Case #13: Date. Date as serial number (> 0). 1 argument used.
		oParser = new parserFormula('GAUSS(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Date. Date as serial number (> 0). 1 argument used.');
		// Case #14: Time. Time adjusted to valid number (>= 1). 1 argument used.
		oParser = new parserFormula('GAUSS(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4331927987311419, 'Test: Positive case: Time. Time adjusted to valid number (>= 1). 1 argument used.');
		// Case #15: Formula. GAMMA inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(GAUSS(2.5),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GAUSS(2.5),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4937903346742238, 'Test: Positive case: Formula. GAMMA inside SUM formula. 1 argument used.');
		// Case #16: Number. Very small positive number. 1 argument used.
		oParser = new parserFormula('GAUSS(0.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(0.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.98942280401432e-8, 'Test: Positive case: Number. Very small positive number. 1 argument used.');
		// Case #17: String. Short date string convertible to number. 1 argument used.
		oParser = new parserFormula('GAUSS("12/12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS("12/12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Short date string convertible to number. 1 argument used.');
		// Case #18: Array. Array with single valid element (duplicate for coverage). 1 argument used.
		oParser = new parserFormula('GAUSS({2.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS({2.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.49379033467422384, 'Test: Positive case: Array. Array with single valid element (duplicate for coverage). 1 argument used.');
		// Case #19: Formula. Nested IF returning valid number. 1 argument used.
		oParser = new parserFormula('GAUSS(IF(TRUE, 2.5, 0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(IF(TRUE, 2.5, 0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.49379033467422384, 'Test: Positive case: Formula. Nested IF returning valid number. 1 argument used.');
		// Case #20: Number. Negative non-integer number (valid). 1 argument used.
		oParser = new parserFormula('GAUSS(-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.19146246127401353, 'Test: Positive case: Number. Negative non-integer number (valid). 1 argument used.');
		// Case #21: String. String convertible to negative non-integer number. 1 argument used.
		oParser = new parserFormula('GAUSS("-0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS("-0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.19146246127401353, 'Test: Positive case: String. String convertible to negative non-integer number. 1 argument used.');
		// Case #22: Formula. Nested formula converting negative to positive number. 1 argument used.
		oParser = new parserFormula('GAUSS(ABS(-2.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(ABS(-2.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.49379033467422384, 'Test: Positive case: Formula. Nested formula converting negative to positive number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.34134474606854304, 'Test: Negative case: Number. Negative integer returns #NUM!. 1 argument used.');
		// Case #2: Number. Zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Zero returns #NUM!. 1 argument used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAUSS("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('GAUSS(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAUSS(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.11791142218895263, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.155421742, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAUSS("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Boolean. Boolean FALSE (0) returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!. 1 argument used.');
		// Case #9: Boolean. Boolean TRUE (1) returns valid result, but testing for clarity. 1 argument used.
		oParser = new parserFormula('GAUSS(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.34134474606854304, 'Test: Negative case: Boolean. Boolean TRUE (1) returns valid result, but testing for clarity. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with text (abc) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAUSS(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to cell with text (abc) returns #VALUE!. 1 argument used.');
		// Case #11: Name. Named range with text (invalid) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAUSS(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.28814460141986065, 'Test: Negative case: Name. Named range with text (invalid) returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text (error) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAUSS(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text (error) returns #VALUE!. 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('GAUSS(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #14: Array. Array with boolean returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Array with boolean returns #NUM!. 1 argument used.');
		// Case #15: Number. Negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS(-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.4772498680518208, 'Test: Negative case: Number. Negative integer returns #NUM!. 1 argument used.');
		// Case #16: String. String convertible to zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String. String convertible to zero returns #NUM!. 1 argument used.');
		// Case #17: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.');
		// Case #18: Name3D. 3D named range with text (invalid) returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GAUSS(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.28814460141986065, 'Test: Negative case: Name3D. 3D named range with text (invalid) returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in zero returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS(DATE(2025,1,1)-DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(DATE(2025,1,1)-DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Formula. Formula resulting in zero returns #NUM!. 1 argument used.');
		// Case #20: Number. Large negative integer returns #NUM!. 1 argument used.
		oParser = new parserFormula('GAUSS(-1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(-1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Negative case: Number. Large negative integer returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive number accepted by Excel. 1 argument used.
		oParser = new parserFormula('GAUSS(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.989422804014327e-308, 'Test: Bounded case: Number. Minimum positive number accepted by Excel. 1 argument used.');
		// Case #2: Number. Maximum positive number accepted by Excel. 1 argument used.
		oParser = new parserFormula('GAUSS(1.7E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(1.7E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Maximum positive number accepted by Excel. 1 argument used.');
		// Case #3: Number. Negative number close to -1 but non-integer. 1 argument used.
		oParser = new parserFormula('GAUSS(-0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GAUSS(-0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.3413447462945583, 'Test: Bounded case: Number. Negative number close to -1 but non-integer. 1 argument used.');

		// Need to fix: area handle
		// Case #6: Area. Multi-cell range returns #NUM!. 1 argument used.


		testArrayFormula2(assert, "GAUSS", 1, 1);
	});

	QUnit.test("Test: \"GEOMEAN\"", function (assert) {

		function geommean(x) {

			var s1 = 0, _x = 1, xLength = 0, _tx;
			for (var i = 0; i < x.length; i++) {
				_x *= x[i];
			}

			return Math.pow(_x, 1 / x.length)
		}

		oParser = new parserFormula("GEOMEAN(10.5,5.3,2.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), geommean([10.5, 5.3, 2.9]));

		oParser = new parserFormula("GEOMEAN(10.5,{5.3,2.9},\"12\")", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), geommean([10.5, 5.3, 2.9, 12]));

		oParser = new parserFormula("GEOMEAN(10.5,{5.3,2.9},\"12\",0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: two positive integers. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(12,18)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(12,18) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.696938456699069, 'Test: Positive case: Number. Basic valid input: two positive integers. 2 of 255 arguments used.');
		// Case #1: Number. Single positive integer. 1 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number. Single positive integer. 1 of 255 arguments used.');
		// Case #2: Number. One divides any number evenly, returns 1. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(1,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(1,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.4641016151377544, 'Test: Positive case: Number. One divides any number evenly, returns 1. 2 of 255 arguments used.');
		// Case #3: Number. Prime numbers, returns 1. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(7,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(7,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.774964387392123, 'Test: Positive case: Number. Prime numbers, returns 1. 2 of 255 arguments used.');
		// Case #4: Number. Non-integer truncated to integer (2.5 ? 2). 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(2.5,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(2.5,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.872983346207417, 'Test: Positive case: Number. Non-integer truncated to integer (2.5 ? 2). 2 of 255 arguments used.');
		// Case #5: String. Strings convertible to positive integers. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN("12","18")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN("12","18") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.696938456699069, 'Test: Positive case: String. Strings convertible to positive integers. 2 of 255 arguments used.');
		// Case #6: Formula. Nested formulas returning valid integers. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(SQRT(36),ABS(18))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(SQRT(36),ABS(18)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.392304845413264, 'Test: Positive case: Formula. Nested formulas returning valid integers. 2 of 255 arguments used.');
		// Case #7: Reference link. References to cells with valid numbers (6, 12). 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.14142135623730953, 'Test: Positive case: Reference link. References to cells with valid numbers (6, 12). 2 of 255 arguments used.');
		// Case #8: Area. Single-cell ranges with valid numbers (6, 12). 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.14142135623730953, 'Test: Positive case: Area. Single-cell ranges with valid numbers (6, 12). 2 of 255 arguments used.');
		// Case #9: Array. Arrays with single valid integers. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN({6},{12})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN({6},{12}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.48528137423857, 'Test: Positive case: Array. Arrays with single valid integers. 2 of 255 arguments used.');
		// Case #10: Name. Named ranges with valid numbers (6, 1). 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers (6, 1). 2 of 255 arguments used.');
		// Case #11: Name3D. 3D named ranges with valid numbers (18, 1). 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name3D. 3D named ranges with valid numbers (18, 1). 2 of 255 arguments used.');
		// Case #12: Ref3D. 3D references to cells with valid numbers (12, 18). 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8660254037844386, 'Test: Positive case: Ref3D. 3D references to cells with valid numbers (12, 18). 2 of 255 arguments used.');
		// Case #13: Area3D. 3D single-cell ranges with valid numbers (12, 18). 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8660254037844386, 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers (12, 18). 2 of 255 arguments used.');
		// Case #14: Table. Table structured references with valid numbers (6, 1). 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.005, 'Test: Positive case: Table. Table structured references with valid numbers (6, 1). 2 of 255 arguments used.');
		// Case #15: Date. Date as serial number truncated to integer. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(DATE(2025,1,1),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(DATE(2025,1,1),12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 740.1999729802751, 'Test: Positive case: Date. Date as serial number truncated to integer. 2 of 255 arguments used.');
		// Case #16: Time. Time adjusted to valid integer (0.5*1000 = 500). 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(TIME(12,0,0)*1000,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(TIME(12,0,0)*1000,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 54.772255750516614, 'Test: Positive case: Time. Time adjusted to valid integer (0.5*1000 = 500). 2 of 255 arguments used.');
		// Case #17: Formula. GCD inside SUM formula, valid inputs. 2 of 255 arguments used.
		oParser = new parserFormula('SUM(GEOMEAN(12,18),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GEOMEAN(12,18),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15.696938456699069, 'Test: Positive case: Formula. GCD inside SUM formula, valid inputs. 2 of 255 arguments used.');
		// Case #18: Number. Multiple positive integers (four arguments). 4 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(12,18,24,36)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(12,18,24,36) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20.784609690826528, 'Test: Positive case: Number. Multiple positive integers (four arguments). 4 of 255 arguments used.');
		// Case #19: Formula. Nested IF formulas returning valid integers. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(IF(TRUE,12,6),IF(TRUE,18,6))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(IF(TRUE,12,6),IF(TRUE,18,6)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.696938456699069, 'Test: Positive case: Formula. Nested IF formulas returning valid integers. 2 of 255 arguments used.');
		// Case #20: Number. Distinct primes, returns 1. 3 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(2,3,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(2,3,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.1072325059538586, 'Test: Positive case: Number. Distinct primes, returns 1. 3 of 255 arguments used.');
		// Case #21: String. Strings convertible to valid integers, three arguments. 3 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN("6","12","18")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN("6","12","18") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.902723556992836, 'Test: Positive case: String. Strings convertible to valid integers, three arguments. 3 of 255 arguments used.');
		// Case #22: Reference link. References to cells with valid numbers (6, 12, 1, 2, 6). 5 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2605171084697352, 'Test: Positive case: Reference link. References to cells with valid numbers (6, 12, 1, 2, 6). 5 of 255 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative number returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(-6,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(-6,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number returns #NUM!. 2 of 255 arguments used.');
		// Case #2: Number. Number ? 2^53 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(2^53,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(2^53,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 328764948.03566253, 'Test: Negative case: Number. Number ? 2^53 returns #NUM!. 2 of 255 arguments used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN("abc",12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN("abc",12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 2 of 255 arguments used.');
		// Case #4: String. Non-numeric string for second argument returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(12,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(12,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for second argument returns #VALUE!. 2 of 255 arguments used.');
		// Case #5: Error. Propagates #N/A error. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(NA(),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(NA(),12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 of 255 arguments used.');
		// Case #6: Empty. Empty reference returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(A105,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(A105,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.6832815729997477, 'Test: Negative case: Empty. Empty reference returns #VALUE!. 2 of 255 arguments used.');
		// Case #7: Area. Multi-cell range returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(A100:A101,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(A100:A101,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6214465011907718, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 2 of 255 arguments used.');
		// Case #8: Area. Multi-cell range for second argument returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(12,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(12,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6214465011907718, 'Test: Negative case: Area. Multi-cell range for second argument returns #NUM!. 2 of 255 arguments used.');
		// Case #9: Ref3D. 3D reference to text (abc) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(Sheet2!A3,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(Sheet2!A3,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Ref3D. 3D reference to text (abc) returns #VALUE!. 2 of 255 arguments used.');
		// Case #10: Name. Named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(TestNameArea2,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(TestNameArea2,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9729696594643762, 'Test: Negative case: Name. Named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.');
		// Case #11: Table. Table column with text (error) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(Table1[Column2],12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(Table1[Column2],12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Table. Table column with text (error) returns #VALUE!. 2 of 255 arguments used.');
		// Case #12: Formula. Formula resulting in #NUM! error. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(SQRT(-1),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(SQRT(-1),12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 of 255 arguments used.');
		// Case #13: Array. Array with boolean returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN({FALSE},12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN({FALSE},12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Array. Array with boolean returns #NUM!. 2 of 255 arguments used.');
		// Case #14: Area3D. 3D multi-cell range returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(Sheet2!A4:A5,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(Sheet2!A4:A5,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 2 of 255 arguments used.');
		// Case #15: Name3D. 3D named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(TestNameArea3D2,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(TestNameArea3D2,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9729696594643762, 'Test: Negative case: Name3D. 3D named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.');
		// Case #16: Number. Negative number in first argument returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(-12,18)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(-12,18) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number in first argument returns #NUM!. 2 of 255 arguments used.');
		// Case #17: Number. Number = 2^53 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(9007199254740992,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(9007199254740992,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 328764948.03566253, 'Test: Negative case: Number. Number = 2^53 returns #NUM!. 2 of 255 arguments used.');
		// Case #18: String. String convertible to 0 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN("0",12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN("0",12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to 0 returns #NUM!. 2 of 255 arguments used.');
		// Case #19: Boolean. Boolean TRUE (1) is valid, but testing for clarity. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(TRUE,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(TRUE,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.4641016151377544, 'Test: Negative case: Boolean. Boolean TRUE (1) is valid, but testing for clarity. 2 of 255 arguments used.');
		// Case #20: Number. Number > 2^53 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(2^53+1,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(2^53+1,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 328764948.03566253, 'Test: Negative case: Number. Number > 2^53 returns #NUM!. 2 of 255 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive integer. 1 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum positive integer. 1 of 255 arguments used.');
		// Case #2: Number. Maximum integer < 2^53. 1 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(9007199254740991)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(9007199254740991) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 9007200000000000, 'Test: Bounded case: Number. Maximum integer < 2^53. 1 of 255 arguments used.');
		// Case #3: Number. Maximum integer < 2^53 with another number. 2 of 255 arguments used.
		oParser = new parserFormula('GEOMEAN(2,9007199254740991)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GEOMEAN(2,9007199254740991) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '134217728', 'Test: Bounded case: Number. Maximum integer < 2^53 with another number. 2 of 255 arguments used.');

		// Need to fix: error handle, boundary case diff
		// Case #5: Error. Propagates #N/A error. 2 of 255 arguments used.
		// Case #12: Formula. Formula resulting in #NUM! error. 2 of 255 arguments used.
		// Case #2: Number. Maximum integer < 2^53. 1 of 255 arguments used.

	});

	QUnit.test("Test: \"GROWTH\"", function (assert) {

		ws.getRange2("A102").setValue("11");
		ws.getRange2("A103").setValue("12");
		ws.getRange2("A104").setValue("13");
		ws.getRange2("A105").setValue("14");
		ws.getRange2("A106").setValue("15");
		ws.getRange2("A107").setValue("16");

		ws.getRange2("B102").setValue("33100");
		ws.getRange2("B103").setValue("47300");
		ws.getRange2("B104").setValue("69000");
		ws.getRange2("B105").setValue("102000");
		ws.getRange2("B106").setValue("150000");
		ws.getRange2("B107").setValue("220000");

		ws.getRange2("C102").setValue("32618");
		ws.getRange2("C103").setValue("47729");
		ws.getRange2("C104").setValue("69841");
		ws.getRange2("C105").setValue("102197");
		ws.getRange2("C106").setValue("149542");
		ws.getRange2("C107").setValue("218822");

		ws.getRange2("A109").setValue("17");
		ws.getRange2("A110").setValue("18");

		oParser = new parserFormula("GROWTH(B102:B107,A102:A107,A109:A110)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(4) - 0, 320196.7184);

		oParser = new parserFormula("GROWTH(B102:B107,A102:A107)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(5) - 0, 32618.20377);

		oParser = new parserFormula("GROWTH(A102:C102,A103:C104,A105:C106,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 11.00782679);

		oParser = new parserFormula("GROWTH(A102:C102,A103:C104,A105:C106,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 11.00782679);

		oParser = new parserFormula("GROWTH(A103:C103,A104:C105,A106:C107,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 12.00187209);

		oParser = new parserFormula("GROWTH(A103:C103,A104:C105,A106:C107,10)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 12.00187209);

		oParser = new parserFormula("GROWTH(A103:C103,A104:C105,A106:C107,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.0017632);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(3) - 0, 12047829814.167);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 2).getValue().toFixed(3) - 0, 10705900594.962);

		oParser = new parserFormula("GROWTH({1,2,3},A104:C105,A106:C107,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.00038318);

		oParser = new parserFormula("GROWTH({1,2,3},A104:C105,A106:C107,A106:C107)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		oParser = new parserFormula("GROWTH(A103:C103,A104:C105,A106:C107,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 12.00187209);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(3) - 0, 676231620.297);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 2).getValue().toFixed(3) - 0, 612512904.254)

		ws.getRange2("A120").setValue("1");
		ws.getRange2("B120").setValue("2");

		oParser = new parserFormula("GROWTH(A120:B120)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1);

		oParser = new parserFormula("GROWTH({1;2})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1);

		oParser = new parserFormula("GROWTH({1,2})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1);

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("11");
		ws.getRange2("A101").setValue("12");
		ws.getRange2("A104").setValue("15");
		// For area
		ws.getRange2("A102").setValue("13");
		ws.getRange2("A103").setValue("14");
		ws.getRange2("A105").setValue("16");

		ws.getRange2("B100").setValue("33100");
		ws.getRange2("B101").setValue("47,300");
		ws.getRange2("B102").setValue("69000");
		ws.getRange2("B103").setValue("102000");
		ws.getRange2("B104").setValue("150000");
		ws.getRange2("B105").setValue("220000");

		ws.getRange2("C100").setValue("32618");
		ws.getRange2("C101").setValue("47729");
		ws.getRange2("C102").setValue("69841");
		ws.getRange2("C103").setValue("102197");
		ws.getRange2("C104").setValue("149542");
		ws.getRange2("C105").setValue("218822");

		// ws.getRange2("A106").setValue("0.7");
		// ws.getRange2("A107").setValue("0.8");
		// ws.getRange2("A108").setValue("0.9");
		// ws.getRange2("A109").setValue("1");
		// ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // NumberText (Column2)
		ws.getRange2("C601").setValue("str"); // Text (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Array. Basic valid array input for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH({2;4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Array. Basic valid array input for known_y\'s. 1 argument used.');
		// Case #1: Array, Array. Arrays for known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{1;2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{1;2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Array, Array. Arrays for known_y\'s and known_x\'s. 2 arguments used.');
		// Case #2: Array, Array, Array. Arrays for known_y\'s, known_x\'s, new_x\'s. 3 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{1;2},{3;4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{1;2},{3;4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(), '8', 'Test: Positive case: Array, Array, Array. Arrays for known_y\'s, known_x\'s, new_x\'s. 3 arguments used.');
		// Case #3: Array, Array, Array, Boolean. All arguments with arrays and const TRUE. 4 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{1;2},{3;4},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{1;2},{3;4},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(), "8", 'Test: Positive case: Array, Array, Array, Boolean. All arguments with arrays and const TRUE. 4 arguments used.');
		// Case #4: Area. Single-column range for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(), '11', 'Test: Positive case: Area. Single-column range for known_y\'s. 1 argument used.');
		// Case #5: Area, Area. Ranges for known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(), '11', 'Test: Positive case: Area, Area. Ranges for known_y\'s and known_x\'s. 2 arguments used.');
		// Case #6: Area, Area, Area. Ranges for known_y\'s, known_x\'s, new_x\'s. 3 arguments used.
		oParser = new parserFormula('GROWTH(A100:A101,A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(A100:A101,A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 13.09090909090909, 'Test: Positive case: Area, Area, Area. Ranges for known_y\'s, known_x\'s, new_x\'s. 3 arguments used.');
		// Case #7: Reference link. Single-cell reference for known_y\'s (array formula). 1 argument used.
		oParser = new parserFormula('GROWTH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Reference link. Single-cell reference for known_y\'s (array formula). 1 argument used.');
		// Case #8: Reference link, Reference link. Single-cell references for known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(A100,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Reference link, Reference link. Single-cell references for known_y\'s and known_x\'s. 2 arguments used.');
		// Case #9: Name. Named range for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range for known_y\'s. 1 argument used.');
		// Case #10: Name, Name. Named ranges for known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH(TestName,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(TestName,TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Name. Named ranges for known_y\'s and known_x\'s. 2 arguments used.');
		// Case #11: Name3D. 3D named range for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range for known_y\'s. 1 argument used.');
		// Case #12: Name3D, Name3D. 3D named ranges for known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH(TestName3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(TestName3D,TestNameArea3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Name3D. 3D named ranges for known_y\'s and known_x\'s. 2 arguments used.');
		// Case #13: Ref3D. 3D reference range for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(1), '0.5', 'Test: Positive case: Ref3D. 3D reference range for known_y\'s. 1 argument used.');
		// Case #14: Ref3D, Ref3D. 3D reference ranges for known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D, Ref3D. 3D reference ranges for known_y\'s and known_x\'s. 2 arguments used.');
		// Case #15: Area3D. 3D single-column range for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(1), '0.5', 'Test: Positive case: Area3D. 3D single-column range for known_y\'s. 1 argument used.');
		// Case #16: Area3D, Area3D. 3D ranges for known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D, Area3D. 3D ranges for known_y\'s and known_x\'s. 2 arguments used.');
		// Case #17: Table. Table structured reference for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Positive case: Table. Table structured reference for known_y\'s. 1 argument used.');
		// Case #18: Table, Table. Table references for known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Positive case: Table, Table. Table references for known_y\'s and known_x\'s. 2 arguments used.');
		// Case #19: Formula. Nested formula in array for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH(EXP(1),EXP(2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(EXP(1),EXP(2)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.718281828, 'Test: Positive case: Formula. Nested formula in array for known_y\'s. 1 argument used.');
		// Case #20: Formula, Formula. Nested formulas in arrays for known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH({2.7;7.3},{0.7;1.3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2.7;7.3},{0.7;1.3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2.7, 'Test: Positive case: Formula, Formula. Nested formulas in arrays for known_y\'s and known_x\'s. 2 arguments used.');
		// Case #21: Array, Array, Array, Number. Number for const instead of boolean. 4 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{1;2},{3;4},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{1;2},{3;4},1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(), '8', 'Test: Positive case: Array, Array, Array, Number. Number for const instead of boolean. 4 arguments used.');
		// Case #22: Formula. GROWTH inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(GROWTH({2;4},{1;2}))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GROWTH({2;4},{1;2})) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. GROWTH inside SUM formula. 2 arguments used.');
		// Case #23: String. String array convertible to numbers for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH({"2";"4"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({"2";"4"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Positive case: String. String array convertible to numbers for known_y\'s. 1 argument used.');
		// Case #24: Date. Date serial numbers for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH(DATE(2025,1,1),DATE(2025,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(DATE(2025,1,1),DATE(2025,1,2)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date. Date serial numbers for known_y\'s. 1 argument used.');
		// Case #25: Time. Time serial numbers for known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH({0.5;0.55})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({0.5;0.55}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.5, 'Test: Positive case: Time. Time serial numbers for known_y\'s. 1 argument used.');

		// Negative cases:
		// Case #1: Array. Non-positive known_y\'s returns #NUM!. 1 argument used.
		oParser = new parserFormula('GROWTH({0;4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({0;4}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Non-positive known_y\'s returns #NUM!. 1 argument used.');
		// Case #2: Array. Single data point for known_y\'s returns #NUM!. 1 argument used.
		oParser = new parserFormula('GROWTH({2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Array. Single data point for known_y\'s returns #NUM!. 1 argument used.');
		// Case #3: String. Non-numeric string array returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GROWTH({"abc";"def"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({"abc";"def"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string array returns #VALUE!. 1 argument used.');
		// Case #4: Error. Error in known_y\'s propagates #N/A. 1 argument used.
		oParser = new parserFormula('GROWTH(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in known_y\'s propagates #N/A. 1 argument used.');
		// Case #5: Empty. Empty reference for known_y\'s returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GROWTH(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Negative case: Empty. Empty reference for known_y\'s returns #VALUE!. 1 argument used.');
		// Case #6: Area. Valid range but non-positive values in F1:F2 return #NUM!. 1 argument used.
		oParser = new parserFormula('GROWTH(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(), '11', 'Test: Negative case: Area. Valid range but non-positive values in F1:F2 return #NUM!. 1 argument used.');
		// Case #7: Array, Array. Mismatched array sizes for known_y\'s and known_x\'s returns #NUM!. 2 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{1}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Array, Array. Mismatched array sizes for known_y\'s and known_x\'s returns #NUM!. 2 arguments used.');
		// Case #8: Reference link. Empty single-cell reference returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GROWTH(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Negative case: Reference link. Empty single-cell reference returns #VALUE!. 1 argument used.');
		// Case #9: Area, Area. Mismatched range sizes returns #NUM!. 2 arguments used.
		oParser = new parserFormula('GROWTH(A100:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(A100:A101,A102:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Area, Area. Mismatched range sizes returns #NUM!. 2 arguments used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GROWTH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.8, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GROWTH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.8, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #12: Ref3D. 3D reference to text cells returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GROWTH(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text cells returns #VALUE!. 1 argument used.');
		// Case #13: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GROWTH(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(Table1[Column3]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #14: Formula. Formula resulting in #NUM! error in known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error in known_y\'s. 1 argument used.');
		// Case #15: Array, Array. Non-numeric string in known_x\'s returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{"1";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{"1";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Array. Non-numeric string in known_x\'s returns #VALUE!. 2 arguments used.');
		// Case #16: Array, Array, Array. Non-numeric string in new_x\'s returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{1;2},{"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{1;2},{"abc"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: Array, Array, Array. Non-numeric string in new_x\'s returns #VALUE!. 3 arguments used.');
		// Case #17: Array, Array, Array, String. Non-boolean string for const returns #VALUE!. 4 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{1;2},{3;4},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{1;2},{3;4},"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Array, Array, String. Non-boolean string for const returns #VALUE!. 4 arguments used.');
		// Case #18: Array. Negative known_y\'s returns #NUM!. 1 argument used.
		oParser = new parserFormula('GROWTH({-2;4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({-2;4}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Negative known_y\'s returns #NUM!. 1 argument used.');
		// Case #19: Array, Empty. Empty reference for known_x\'s returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('GROWTH({2;4},A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Array, Empty. Empty reference for known_x\'s returns #VALUE!. 2 arguments used.');
		// Case #20: Array, Array, Empty. Empty reference for new_x\'s returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{1;2},A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{1;2},A102) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(), '8192', 'Test: Negative case: Array, Array, Empty. Empty reference for new_x\'s returns #VALUE!. 3 arguments used.');

		// Bounded cases:
		// Case #1: Array. Smallest positive number in known_y\'s. 1 argument used.
		oParser = new parserFormula('GROWTH({1E-307;2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({1E-307;2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Bounded case: Array. Smallest positive number in known_y\'s. 1 argument used.');
		// Case #2: Array, Array. Maximum valid Excel number in known_y\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH({1.7976931348623157E+307;2},{1;2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({1.7976931348623157E+307;2},{1;2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Bounded case: Array, Array. Maximum valid Excel number in known_y\'s. 2 arguments used.');
		// Case #3: Array, Array, Array. Maximum valid Excel number in new_x\'s. 3 arguments used.
		oParser = new parserFormula('GROWTH({2;4},{1;2},{1.7976931348623157E+307;2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({2;4},{1;2},{1.7976931348623157E+307;2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#NUM!', 'Test: Bounded case: Array, Array, Array. Maximum valid Excel number in new_x\'s. 3 arguments used.');
		// Case #4: Array, Array. Smallest positive numbers in known_y\'s and known_x\'s. 2 arguments used.
		oParser = new parserFormula('GROWTH({1E-307;2},{1E-307;2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GROWTH({1E-307;2},{1E-307;2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1e-307, 'Test: Bounded case: Array, Array. Smallest positive numbers in known_y\'s and known_x\'s. 2 arguments used.');

		// TODO many problems in this formula (critical in tests but can be done in app)
		// Need to fix: error types difference, arguments types handle, boundary case problem, ms result diff
		// Case #7: Reference link. Single-cell reference for known_y\'s (array formula). 1 argument used.
		// Case #8: Reference link, Reference link. Single-cell references for known_y\'s and known_x\'s. 2 arguments used.
		// Case #9: Name. Named range for known_y\'s. 1 argument used.
		// Case #10: Name, Name. Named ranges for known_y\'s and known_x\'s. 2 arguments used.
		// Case #12: Name3D, Name3D. 3D named ranges for known_y\'s and known_x\'s. 2 arguments used.
		// Case #17: Table. Table structured reference for known_y\'s. 1 argument used.
		// Case #19: Formula. Nested formula in array for known_y\'s. 1 argument used.
		// Case #23: String. String array convertible to numbers for known_y\'s. 1 argument used.
		// Case #24: Date. Date serial numbers for known_y\'s. 1 argument used.
		// Case #1: Array. Non-positive known_y\'s returns #NUM!. 1 argument used.
		// Case #2: Array. Single data point for known_y\'s returns #NUM!. 1 argument used.
		// Case #3: String. Non-numeric string array returns #VALUE!. 1 argument used.
		// Case #5: Empty. Empty reference for known_y\'s returns #VALUE!. 1 argument used.
		// Case #7: Array, Array. Mismatched array sizes for known_y\'s and known_x\'s returns #NUM!. 2 arguments used.
		// Case #9: Area, Area. Mismatched range sizes returns #NUM!. 2 arguments used.
		// Case #8: Reference link. Empty single-cell reference returns #VALUE!. 1 argument used.
		// Case #16: Array, Array, Array. Non-numeric string in new_x\'s returns #VALUE!. 3 arguments used.
		// !Case #17: Array, Array, Array, String. Non-boolean string for const returns #VALUE!. 4 arguments used. - critical in tests
		// Case #18: Array. Negative known_y\'s returns #NUM!. 1 argument used.
		// Case #19: Array, Empty. Empty reference for known_x\'s returns #VALUE!. 2 arguments used.


		ws.getRange2("A200").setValue("1");
		ws.getRange2("A201").setValue("2");
		ws.getRange2("A202").setValue("3");
		ws.getRange2("B200").setValue("1");
		ws.getRange2("B201").setValue("2");
		ws.getRange2("B202").setValue("3");
		ws.getRange2("C200").setValue("1");
		ws.getRange2("C201").setValue("2");
		ws.getRange2("C202").setValue("3");

		// different matrix length tests
		oParser = new parserFormula("GROWTH(A200:A201,A200:C200)", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH(A200:A201,A200:C200)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of GROWTH(A200:A201,A200:C200)");

		oParser = new parserFormula("GROWTH(A200:A202,A200:C200)", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH(A200:A202,A200:C200)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of GROWTH(A200:A202,A200:C200)");

		oParser = new parserFormula("GROWTH(A200:B201,A200:C201)", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH(A200:B201,A200:C201)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of GROWTH(A200:B201,A200:C201)");

		oParser = new parserFormula("GROWTH({1,2,3},{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH({1,2,3},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of GROWTH({1,2,3},{1,2})");

		oParser = new parserFormula("GROWTH({1,2,3},{1,2,3,4})", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH({1,2,3},{1,2,3,4})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of GROWTH({1,2,3},{1,2,3,4})");

		oParser = new parserFormula("GROWTH({1,2;1,2},{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH({1,2;1,2},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of GROWTH({1,2;1,2},{1,2})");

		oParser = new parserFormula("GROWTH(A200:B200,{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH(A200:B200,{1,2})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, "Result of GROWTH(A200:B200,{1,2})[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 1, "Result of GROWTH(A200:B200,{1,2})[0,1]");

		// identical X-trend tests
		oParser = new parserFormula("GROWTH({1,1},{0,0})", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH({1,1},{0,0})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1, "Result of GROWTH({1,1},{0,0}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 1, "Result of GROWTH({1,1},{0,0}) [0,1]");

		oParser = new parserFormula("GROWTH({123,123},{123,123})", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH({123,123},{123,123})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 123, "Result of GROWTH({123,123},{123,123}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 123, "Result of GROWTH({123,123},{123,123}) [0,1]");

		oParser = new parserFormula("GROWTH({2,8},{1,1})", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH({2,8},{1,1})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 4, "Result of GROWTH({2,8},{1,1}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 4, "Result of GROWTH({2,8},{1,1}) [0,1]");

		oParser = new parserFormula("GROWTH({2,8;1,1},{1,1;1,1})", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH({2,8;1,1},{1,1;1,1})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 2, "Result of GROWTH({2,8;1,1},{1,1;1,1}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 2, "Result of GROWTH({2,8;1,1},{1,1;1,1}) [0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(8) - 0, 2, "Result of GROWTH({2,8;1,1},{1,1;1,1}) [1,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue().toFixed(4) - 0, 2, "Result of GROWTH({2,8;1,1},{1,1;1,1}) [1,1]");

		oParser = new parserFormula("GROWTH({2,8;2,2;10,10},{1,1;1,1;1,1})", "A2", ws);
		assert.ok(oParser.parse(), "GROWTH({2,8;2,2;10,10},{1,1;1,1;1,1})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 4.30886938, "Result of GROWTH({2,8;2,2;10,10},{1,1;1,1;1,1}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(8) - 0, 4.30886938, "Result of GROWTH({2,8;2,2;10,10},{1,1;1,1;1,1}) [0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(8) - 0, 4.30886938, "Result of GROWTH({2,8;2,2;10,10},{1,1;1,1;1,1}) [1,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue().toFixed(8) - 0, 4.30886938, "Result of GROWTH({2,8;2,2;10,10},{1,1;1,1;1,1}) [1,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue().toFixed(8) - 0, 4.30886938, "Result of GROWTH({2,8;2,2;10,10},{1,1;1,1;1,1}) [2,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 1).getValue().toFixed(8) - 0, 4.30886938, "Result of GROWTH({2,8;2,2;10,10},{1,1;1,1;1,1}) [2,1]");


	});

	QUnit.test("Test: \"HARMEAN\"", function (assert) {

		function harmmean(x) {

			var _x = 0, xLength = 0;
			for (var i = 0; i < x.length; i++) {
				_x += 1 / x[i];
				xLength++;
			}
			return xLength / _x;
		}

		oParser = new parserFormula("HARMEAN(10.5,5.3,2.9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), harmmean([10.5, 5.3, 2.9]));

		oParser = new parserFormula("HARMEAN(10.5,{5.3,2.9},\"12\")", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), harmmean([10.5, 5.3, 2.9, 12]));

		oParser = new parserFormula("HARMEAN(10.5,{5.3,2.9},\"12\",0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: two positive integers. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(12,18)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(12,18) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '14.4', 'Test: Positive case: Number. Basic valid input: two positive integers. 2 of 255 arguments used.');
		// Case #1: Number. Single positive integer. 1 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number. Single positive integer. 1 of 255 arguments used.');
		// Case #2: Number. One divides any number evenly, returns 1. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(1,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(1,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8461538461538463, 'Test: Positive case: Number. One divides any number evenly, returns 1. 2 of 255 arguments used.');
		// Case #3: Number. Prime numbers, returns 1. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(7,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(7,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.555555555555555, 'Test: Positive case: Number. Prime numbers, returns 1. 2 of 255 arguments used.');
		// Case #4: Number. Non-integer truncated to integer (2.5 ? 2). 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(2.5,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(2.5,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5294117647058822, 'Test: Positive case: Number. Non-integer truncated to integer (2.5 ? 2). 2 of 255 arguments used.');
		// Case #5: String. Strings convertible to positive integers. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN("12","18")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN("12","18") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '14.4', 'Test: Positive case: String. Strings convertible to positive integers. 2 of 255 arguments used.');
		// Case #6: Formula. Nested formulas returning valid integers. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(SQRT(36),ABS(18))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(SQRT(36),ABS(18)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Formula. Nested formulas returning valid integers. 2 of 255 arguments used.');
		// Case #7: Reference link. References to cells with valid numbers (6, 12). 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.13333333333333333, 'Test: Positive case: Reference link. References to cells with valid numbers (6, 12). 2 of 255 arguments used.');
		// Case #8: Area. Single-cell ranges with valid numbers (6, 12). 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.13333333333333333, 'Test: Positive case: Area. Single-cell ranges with valid numbers (6, 12). 2 of 255 arguments used.');
		// Case #9: Array. Arrays with single valid integers. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN({6},{12})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN({6},{12}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Array. Arrays with single valid integers. 2 of 255 arguments used.');
		// Case #10: Name. Named ranges with valid numbers (6, 1). 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers (6, 1). 2 of 255 arguments used.');
		// Case #11: Name3D. 3D named ranges with valid numbers (18, 1). 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers (18, 1). 2 of 255 arguments used.');
		// Case #12: Ref3D. 3D references to cells with valid numbers (12, 18). 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Ref3D. 3D references to cells with valid numbers (12, 18). 2 of 255 arguments used.');
		// Case #13: Area3D. 3D single-cell ranges with valid numbers (12, 18). 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers (12, 18). 2 of 255 arguments used.');
		// Case #14: Table. Table structured references with valid numbers (6, 1). 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.005, 'Test: Positive case: Table. Table structured references with valid numbers (6, 1). 2 of 255 arguments used.');
		// Case #15: Date. Date as serial number truncated to integer. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(DATE(2025,1,1),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(DATE(2025,1,1),12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 23.993693890956866, 'Test: Positive case: Date. Date as serial number truncated to integer. 2 of 255 arguments used.');
		// Case #16: Time. Time adjusted to valid integer (0.5*1000 = 500). 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(TIME(12,0,0)*1000,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(TIME(12,0,0)*1000,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11.857707509881424, 'Test: Positive case: Time. Time adjusted to valid integer (0.5*1000 = 500). 2 of 255 arguments used.');
		// Case #17: Formula. GCD inside SUM formula, valid inputs. 2 of 255 arguments used.
		oParser = new parserFormula('SUM(HARMEAN(12,18),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(HARMEAN(12,18),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '15.4', 'Test: Positive case: Formula. GCD inside SUM formula, valid inputs. 2 of 255 arguments used.');
		// Case #18: Number. Multiple positive integers (four arguments). 4 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(12,18,24,36)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(12,18,24,36) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '19.2', 'Test: Positive case: Number. Multiple positive integers (four arguments). 4 of 255 arguments used.');
		// Case #19: Formula. Nested IF formulas returning valid integers. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(IF(TRUE,12,6),IF(TRUE,18,6))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(IF(TRUE,12,6),IF(TRUE,18,6)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '14.4', 'Test: Positive case: Formula. Nested IF formulas returning valid integers. 2 of 255 arguments used.');
		// Case #20: Number. Distinct primes, returns 1. 3 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(2,3,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(2,3,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.9032258064516134, 'Test: Positive case: Number. Distinct primes, returns 1. 3 of 255 arguments used.');
		// Case #21: String. Strings convertible to valid integers, three arguments. 3 of 255 arguments used.
		oParser = new parserFormula('HARMEAN("6","12","18")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN("6","12","18") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.818181818181817, 'Test: Positive case: String. Strings convertible to valid integers, three arguments. 3 of 255 arguments used.');
		// Case #22: Reference link. References to cells with valid numbers (6, 12, 1, 2, 6). 5 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.21897810218978103, 'Test: Positive case: Reference link. References to cells with valid numbers (6, 12, 1, 2, 6). 5 of 255 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative number returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(-6,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(-6,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number returns #NUM!. 2 of 255 arguments used.');
		// Case #2: Number. Number ? 2^53 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(2^53,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(2^53,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '24', 'Test: Negative case: Number. Number ? 2^53 returns #NUM!. 2 of 255 arguments used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN("abc",12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN("abc",12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 2 of 255 arguments used.');
		// Case #4: String. Non-numeric string for second argument returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(12,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(12,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for second argument returns #VALUE!. 2 of 255 arguments used.');
		// Case #5: Error. Propagates #N/A error. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(NA(),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(NA(),12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 of 255 arguments used.');
		// Case #6: Empty. Empty reference returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(A105,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(A105,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1428571428571428, 'Test: Negative case: Empty. Empty reference returns #VALUE!. 2 of 255 arguments used.');
		// Case #7: Area. Multi-cell range returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(A100:A101,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(A100:A101,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.19889502762430938, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 2 of 255 arguments used.');
		// Case #8: Area. Multi-cell range for second argument returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(12,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(12,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.19889502762430938, 'Test: Negative case: Area. Multi-cell range for second argument returns #NUM!. 2 of 255 arguments used.');
		// Case #9: Ref3D. 3D reference to text (abc) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(Sheet2!A3,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(Sheet2!A3,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Ref3D. 3D reference to text (abc) returns #VALUE!. 2 of 255 arguments used.');
		// Case #10: Name. Named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(TestNameArea2,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(TestNameArea2,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.161290322580645, 'Test: Negative case: Name. Named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.');
		// Case #11: Table. Table column with text (error) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(Table1[Column2],12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(Table1[Column2],12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Table. Table column with text (error) returns #VALUE!. 2 of 255 arguments used.');
		// Case #12: Formula. Formula resulting in #NUM! error. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(SQRT(-1),12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(SQRT(-1),12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 of 255 arguments used.');
		// Case #13: Array. Array with boolean returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN({FALSE},12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN({FALSE},12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Array. Array with boolean returns #NUM!. 2 of 255 arguments used.');
		// Case #14: Area3D. 3D multi-cell range returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(Sheet2!A4:A5,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(Sheet2!A4:A5,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 2 of 255 arguments used.');
		// Case #15: Name3D. 3D named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(TestNameArea3D2,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(TestNameArea3D2,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.161290322580645, 'Test: Negative case: Name3D. 3D named range with text (invalid) returns #VALUE!. 2 of 255 arguments used.');
		// Case #16: Number. Negative number in first argument returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(-12,18)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(-12,18) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number in first argument returns #NUM!. 2 of 255 arguments used.');
		// Case #17: Number. Number = 2^53 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(9007199254740992,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(9007199254740992,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '24', 'Test: Negative case: Number. Number = 2^53 returns #NUM!. 2 of 255 arguments used.');
		// Case #18: String. String convertible to 0 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN("0",12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN("0",12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to 0 returns #NUM!. 2 of 255 arguments used.');
		// Case #19: Boolean. Boolean TRUE (1) is valid, but testing for clarity. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(TRUE,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(TRUE,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8461538461538463, 'Test: Negative case: Boolean. Boolean TRUE (1) is valid, but testing for clarity. 2 of 255 arguments used.');
		// Case #20: Number. Number > 2^53 returns #NUM!. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(2^53+1,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(2^53+1,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '24', 'Test: Negative case: Number. Number > 2^53 returns #NUM!. 2 of 255 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive integer. 1 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum positive integer. 1 of 255 arguments used.');
		// Case #2: Number. Maximum integer < 2^53. 1 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(9007199254740991)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(9007199254740991) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 9007200000000000, 'Test: Bounded case: Number. Maximum integer < 2^53. 1 of 255 arguments used.');
		// Case #3: Number. Maximum integer < 2^53 with another number. 2 of 255 arguments used.
		oParser = new parserFormula('HARMEAN(2,9007199254740991)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HARMEAN(2,9007199254740991) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '4', 'Test: Bounded case: Number. Maximum integer < 2^53 with another number. 2 of 255 arguments used.');

		// Need to fix: error handle, error types diff
		// Case #5: Error. Propagates #N/A error. 2 of 255 arguments used.
		// Case #12: Formula. Formula resulting in #NUM! error. 2 of 255 arguments used.
		// Case #2: Number. Maximum integer < 2^53. 1 of 255 arguments used.

		testArrayFormula2(assert, "HARMEAN", 1, 8, null, true);
	});

	QUnit.test("Test: \"HYPGEOMDIST\"", function (assert) {

		function hypgeomdist(x, n, M, N) {
			return toFixed(Math.binomCoeff(M, x) * Math.binomCoeff(N - M, n - x) / Math.binomCoeff(N, n));
		}

		oParser = new parserFormula("HYPGEOMDIST(1,4,8,20)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.3632610939112495);

		oParser = new parserFormula("HYPGEOMDIST(-1,4,8,20)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("HYPGEOMDIST(5,4,8,20)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(4). All arguments are integers. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(2,10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(2,10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: Number(4). All arguments are integers. 4 of 4 arguments used.');
		// Case #2: Number(4). All arguments are integers, different valid values. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(1,5,3,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(1,5,3,15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4945054945054937, 'Test: Positive case: Number(4). All arguments are integers, different valid values. 4 of 4 arguments used.');
		// Case #3: String(4). All arguments as strings convertible to valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST("2","10","5","20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST("2","10","5","20") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: String(4). All arguments as strings convertible to valid numbers. 4 of 4 arguments used.');
		// Case #4: Formula(4). All arguments filled with formulas resolving to valid values. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(ABS(-2),SUM(5,5),MIN(10,5),MAX(10,20))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(ABS(-2),SUM(5,5),MIN(10,5),MAX(10,20)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: Formula(4). All arguments filled with formulas resolving to valid values. 4 of 4 arguments used.');
		// Case #5: Reference link(4). All arguments as cell references to valid values. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link(4). All arguments as cell references to valid values. 4 of 4 arguments used.');
		// Case #6: Area(4). All arguments as single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area(4). All arguments as single-cell ranges. 4 of 4 arguments used.');
		// Case #7: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST({2},{10},{5},{20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST({2},{10},{5},{20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #8: Name(4). All arguments as named ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(TestName,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(TestName,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(4). All arguments as named ranges with valid values. 4 of 4 arguments used.');
		// Case #9: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #10: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.');
		// Case #11: Area3D(4). All arguments as 3D single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(4). All arguments as 3D single-cell ranges. 4 of 4 arguments used.');
		// Case #12: Table(4). All arguments as table structured references. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table(4). All arguments as table structured references. 4 of 4 arguments used.');
		// Case #13: Formula,Number(3). sample_s filled with IF formula. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(IF(TRUE,2,1),10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(IF(TRUE,2,1),10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: Formula,Number(3). sample_s filled with IF formula. 4 of 4 arguments used.');
		// Case #14: Date(4). Date arguments truncated to integers. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(DATE(2025,1,1),DATE(2025,2,1),DATE(2025,3,1),DATE(2025,4,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(DATE(2025,1,1),DATE(2025,2,1),DATE(2025,3,1),DATE(2025,4,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9607713533224601, 'Test: Positive case: Date(4). Date arguments truncated to integers. 4 of 4 arguments used.');
		// Case #15: Time(4). Time arguments adjusted to valid integers. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(TIME(1,0,0)+2,TIME(2,0,0)+10,TIME(3,0,0)+5,TIME(4,0,0)+20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(TIME(1,0,0)+2,TIME(2,0,0)+10,TIME(3,0,0)+5,TIME(4,0,0)+20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: Time(4). Time arguments adjusted to valid integers. 4 of 4 arguments used.');
		// Case #16: Formula,Number(3). HYPGEOMDIST inside SUM formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(HYPGEOMDIST(2,10,5,20),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(HYPGEOMDIST(2,10,5,20),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.44829721362229036, 'Test: Positive case: Formula,Number(3). HYPGEOMDIST inside SUM formula. 4 of 4 arguments used.');
		// Case #17: String(3),Number. Numeric strings converted to numbers. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST("2","10","5",20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST("2","10","5",20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: String(3),Number. Numeric strings converted to numbers. 4 of 4 arguments used.');
		// Case #18: Array(4). Multi-element arrays with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST({2,3},{10,15},{5,7},{20,25})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST({2,3},{10,15},{5,7},{20,25}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: Array(4). Multi-element arrays with valid values. 4 of 4 arguments used.');
		// Case #19: Number(4). All arguments as floats, truncated to integers. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(2.7,10.8,5.6,20.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(2.7,10.8,5.6,20.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: Number(4). All arguments as floats, truncated to integers. 4 of 4 arguments used.');
		// Case #20: Number(4). Minimum valid integers for all arguments. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(0,1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(0,1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(4). Minimum valid integers for all arguments. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number(4). sample_s < 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(-1,10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(-1,10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). sample_s < 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number(4). number_sample ? 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(2,-10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(2,-10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). number_sample ? 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number(4). population_s ? 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(2,10,-5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(2,10,-5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). population_s ? 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #4: Number(4). number_pop ? 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(2,10,5,-20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(2,10,5,-20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). number_pop ? 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #5: Number(4). sample_s > number_sample returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(11,10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(11,10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(4). sample_s > number_sample returns #NUM!. 4 of 4 arguments used.');
		// Case #6: Number(4). sample_s > population_s returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(6,10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(6,10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(4). sample_s > population_s returns #NUM!. 4 of 4 arguments used.');
		// Case #7: Number(4). number_sample > number_pop returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(6,10,5,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(6,10,5,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). number_sample > number_pop returns #NUM!. 4 of 4 arguments used.');
		// Case #8: Number(4). population_s > number_pop returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(2,10,21,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(2,10,21,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). population_s > number_pop returns #NUM!. 4 of 4 arguments used.');
		// Case #9: Number(4). sample_s < (number_sample - number_pop + population_s) returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(8,10,2,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(8,10,2,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(4). sample_s < (number_sample - number_pop + population_s) returns #NUM!. 4 of 4 arguments used.');
		// Case #10: String(4). Non-numeric string returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST("abc","10","5","20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST("abc","10","5","20") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Empty,Number(3). sample_s empty returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(,10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(,10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.016253869969040196, 'Test: Negative case: Empty,Number(3). sample_s empty returns #VALUE!. 4 of 4 arguments used.');
		// Case #12: Number,Empty,Number(2). number_sample empty returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(2,,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(2,,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number,Empty,Number(2). number_sample empty returns #VALUE!. 4 of 4 arguments used.');
		// Case #13: Number(2),Empty,Number. population_s empty returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(2,10,,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(2,10,,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(2),Empty,Number. population_s empty returns #VALUE!. 4 of 4 arguments used.');
		// Case #14: Number(3),Empty. number_pop empty returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(2,10,5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(2,10,5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3),Empty. number_pop empty returns #VALUE!. 4 of 4 arguments used.');
		// Case #15: Error,Number(3). sample_s as error propagates #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(NA(),10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(NA(),10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(3). sample_s as error propagates #N/A. 4 of 4 arguments used.');
		// Case #16: Area,Number(3). sample_s as multi-cell range returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(A100:A101,10,5,20)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("B1:C2").bbox);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(A100:A101,10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(8) - 0, 0.01625387, 'Test: Negative case: Area,Number(3). sample_s as multi-cell range returns #NUM!. 4 of 4 arguments used.');
		// Case #17: Array,Number(3). sample_s as multi-element array returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST({2,3},10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST({2,3},10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Negative case: Array,Number(3). sample_s as multi-element array returns #NUM!. 4 of 4 arguments used.');
		// Case #18: Name,Number(3). sample_s as named range with area returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(TestNameArea2,10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(TestNameArea2,10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.016253869969040196, 'Test: Negative case: Name,Number(3). sample_s as named range with area returns #VALUE!. 4 of 4 arguments used.');
		// Case #19: Name3D,Number(3). sample_s as 3D named range with area returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(TestNameArea3D2,10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(TestNameArea3D2,10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.016253869969040196, 'Test: Negative case: Name3D,Number(3). sample_s as 3D named range with area returns #VALUE!. 4 of 4 arguments used.');
		// Case #20: Formula,Number(3). sample_s as formula resulting in #NUM! propagates error. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(SQRT(-1),10,5,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(SQRT(-1),10,5,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Number(3). sample_s as formula resulting in #NUM! propagates error. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number(4). Minimum valid values for sample_s, number_sample, population_s, number_pop. 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(0,1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(0,1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(4). Minimum valid values for sample_s, number_sample, population_s, number_pop. 4 of 4 arguments used.');
		// Case #2: Number(4). Maximum valid Excel numbers (truncated to integers). 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(1E+307,1E+307,1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(1E+307,1E+307,1E+307,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(4). Maximum valid Excel numbers (truncated to integers). 4 of 4 arguments used.');
		// Case #3: Number(4). Smallest positive number for sample_s (truncates to 0). 4 of 4 arguments used.
		oParser = new parserFormula('HYPGEOMDIST(1E-307,2,1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOMDIST(1E-307,2,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.33, 'Test: Bounded case: Number(4). Smallest positive number for sample_s (truncates to 0). 4 of 4 arguments used.');


		testArrayFormula2(assert, "HYPGEOMDIST", 4, 4);
	});

	QUnit.test("Test: \"HYPGEOM.DIST\"", function (assert) {

		oParser = new parserFormula("HYPGEOM.DIST(1,4,8,20,TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 0.4654);

		oParser = new parserFormula("HYPGEOM.DIST(1,4,8,20,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 0.3633);

		oParser = new parserFormula("HYPGEOM.DIST(2,2,3,40,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.003846154);

		oParser = new parserFormula("HYPGEOM.DIST(2,3,3,40,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.999898785);

		oParser = new parserFormula("HYPGEOM.DIST(1,2,3,4,5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases
		// Case #1: Number(5). All arguments are integers, cumulative TRUE. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Positive case: Number(5). All arguments are integers, cumulative TRUE. 5 of 5 arguments used.');
		// Case #2: Number(5). All arguments are integers, cumulative FALSE. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,5,20,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,5,20,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3482972136222904, 'Test: Positive case: Number(5). All arguments are integers, cumulative FALSE. 5 of 5 arguments used.');
		// Case #3: Number(4),Boolean. Cumulative as numeric 1 (converts to TRUE). 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,5,20,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,5,20,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Positive case: Number(4),Boolean. Cumulative as numeric 1 (converts to TRUE). 5 of 5 arguments used.');
		// Case #4: String(5). All arguments as strings convertible to valid numbers/boolean. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST("2","10","5","20","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST("2","10","5","20","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Positive case: String(5). All arguments as strings convertible to valid numbers/boolean. 5 of 5 arguments used.');
		// Case #5: Formula(5). All arguments filled with formulas resolving to valid values. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(ABS(-2),SUM(5,5),MIN(10,5),MAX(10,20),IF(TRUE,1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(ABS(-2),SUM(5,5),MIN(10,5),MAX(10,20),IF(TRUE,1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Positive case: Formula(5). All arguments filled with formulas resolving to valid values. 5 of 5 arguments used.');
		// Case #6: Reference link(5). All arguments as cell references to valid values. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link(5). All arguments as cell references to valid values. 5 of 5 arguments used.');
		// Case #7: Area(5). All arguments as single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area(5). All arguments as single-cell ranges. 5 of 5 arguments used.');
		// Case #8: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST({2},{10},{5},{20},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST({2},{10},{5},{20},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Positive case: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.');
		// Case #9: Name(5). All arguments as named ranges with valid values. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(TestName,TestName1,TestName2,TestName,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(TestName,TestName1,TestName2,TestName,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(5). All arguments as named ranges with valid values. 5 of 5 arguments used.');
		// Case #10: Name3D(5). All arguments as 3D named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(5). All arguments as 3D named ranges. 5 of 5 arguments used.');
		// Case #11: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.');
		// Case #12: Area3D(5). All arguments as 3D single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(5). All arguments as 3D single-cell ranges. 5 of 5 arguments used.');
		// Case #13: Table(5). All arguments as table structured references. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table(5). All arguments as table structured references. 5 of 5 arguments used.');
		// Case #14: Number(4),Formula. Cumulative filled with IF formula. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,5,20,IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,5,20,IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Positive case: Number(4),Formula. Cumulative filled with IF formula. 5 of 5 arguments used.');
		// Case #15: Date(4),Boolean. Date arguments truncated to integers. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(DATE(2025,1,1),DATE(2025,2,1),DATE(2025,3,1),DATE(2025,4,1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(DATE(2025,1,1),DATE(2025,2,1),DATE(2025,3,1),DATE(2025,4,1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.960771353, 'Test: Positive case: Date(4),Boolean. Date arguments truncated to integers. 5 of 5 arguments used.');
		// Case #16: Time(4),Boolean. Time arguments adjusted to valid integers. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(TIME(1,0,0)+1,TIME(2,0,0)+10,TIME(3,0,0)+5,TIME(4,0,0)+20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(TIME(1,0,0)+1,TIME(2,0,0)+10,TIME(3,0,0)+5,TIME(4,0,0)+20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.151702786, 'Test: Positive case: Time(4),Boolean. Time arguments adjusted to valid integers. 5 of 5 arguments used.');
		// Case #17: Formula,Number(4). HYPGEOM.DIST inside SUM formula. 5 of 5 arguments used.
		oParser = new parserFormula('SUM(HYPGEOM.DIST(2,10,5,20,TRUE),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(HYPGEOM.DIST(2,10,5,20,TRUE),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.6, 'Test: Positive case: Formula,Number(4). HYPGEOM.DIST inside SUM formula. 5 of 5 arguments used.');
		// Case #18: String(4),Number. Numeric strings converted to numbers, cumulative as 1. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST("2","10","5","20",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST("2","10","5","20",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Positive case: String(4),Number. Numeric strings converted to numbers, cumulative as 1. 5 of 5 arguments used.');
		// Case #19: Array(5). Multi-element arrays with valid values. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST({2,3},{10,15},{5,7},{20,25},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST({2,3},{10,15},{5,7},{20,25},{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Positive case: Array(5). Multi-element arrays with valid values. 5 of 5 arguments used.');
		// Case #20: Number(5). All arguments as floats, truncated to integers. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2.7,10.8,5.6,20.4,0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2.7,10.8,5.6,20.4,0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Positive case: Number(5). All arguments as floats, truncated to integers. 5 of 5 arguments used.');

		// Negative cases:
		// Case #1: Number(5). sample_s < 0 returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(-1,10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(-1,10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). sample_s < 0 returns #NUM!. 5 of 5 arguments used.');
		// Case #2: Number(5). number_sample â?¤ 0 returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,-10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,-10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). number_sample â?¤ 0 returns #NUM!. 5 of 5 arguments used.');
		// Case #3: Number(5). population_s â?¤ 0 returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,-5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,-5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). population_s â?¤ 0 returns #NUM!. 5 of 5 arguments used.');
		// Case #4: Number(5). number_pop â?¤ 0 returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,5,-20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,5,-20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). number_pop â?¤ 0 returns #NUM!. 5 of 5 arguments used.');
		// Case #5: Number(5). sample_s > number_sample returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(11,10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(11,10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number(5). sample_s > number_sample returns #NUM!. 5 of 5 arguments used.');
		// Case #6: Number(5). sample_s > population_s returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(6,10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(6,10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number(5). sample_s > population_s returns #NUM!. 5 of 5 arguments used.');
		// Case #7: Number(5). number_sample > number_pop returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(6,10,5,4,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(6,10,5,4,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). number_sample > number_pop returns #NUM!. 5 of 5 arguments used.');
		// Case #8: Number(5). population_s > number_pop returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,21,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,21,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). population_s > number_pop returns #NUM!. 5 of 5 arguments used.');
		// Case #9: Number(5). sample_s < (number_sample - number_pop + population_s) returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(8,10,2,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(8,10,2,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number(5). sample_s < (number_sample - number_pop + population_s) returns #NUM!. 5 of 5 arguments used.');
		// Case #10: String(5). Non-numeric string returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST("abc","10","5","20","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST("abc","10","5","20","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Non-numeric string returns #VALUE!. 5 of 5 arguments used.');
		// Case #11: Empty,Number(4). sample_s empty returns number. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(,10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(,10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.01625387, 'Test: Negative case: Empty,Number(4). sample_s empty returns number. 5 of 5 arguments used.');
		// Case #12: Number,Empty,Number(3). number_sample empty returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number,Empty,Number(3). number_sample empty returns #VALUE!. 5 of 5 arguments used.');
		// Case #13: Number(2),Empty,Number(2). population_s empty returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number(2),Empty,Number(2). population_s empty returns #VALUE!. 5 of 5 arguments used.');
		// Case #14: Number(3),Empty,Boolean. number_pop empty returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,5,,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,5,,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3),Empty,Boolean. number_pop empty returns #VALUE!. 5 of 5 arguments used.');
		// Case #15: Number(4),String. cumulative as non-boolean string returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(2,10,5,20,"Str")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(2,10,5,20,"Str") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4),String. cumulative as non-boolean string returns #VALUE!. 5 of 5 arguments used.');
		// Case #16: Error,Number(4). sample_s as error propagates #N/A. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(NA(),10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(NA(),10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(4). sample_s as error propagates #N/A. 5 of 5 arguments used.');
		// Case #17: Area,Number(4). sample_s as multi-cell range returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(A100:A101,10,5,20,TRUE)', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("B1:C2").bbox);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(A100:A101,10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.016253869969040196, 'Test: Negative case: Area,Number(4). sample_s as multi-cell range returns #NUM!. 5 of 5 arguments used.');
		// Case #18: Array,Number(4). sample_s as multi-element array returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST({2,3},10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST({2,3},10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.5, 'Test: Negative case: Array,Number(4). sample_s as multi-element array returns #NUM!. 5 of 5 arguments used.');
		// Case #19: Name,Number(4). sample_s as named range with area returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(TestNameArea2,10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(TestNameArea2,10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.016253869969040196, 'Test: Negative case: Name,Number(4). sample_s as named range with area returns #VALUE!. 5 of 5 arguments used.');
		// Case #20: Name3D,Number(4). sample_s as 3D named range with area returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(TestNameArea3D2,10,5,20,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(TestNameArea3D2,10,5,20,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.016253869969040196, 'Test: Negative case: Name3D,Number(4). sample_s as 3D named range with area returns #VALUE!. 5 of 5 arguments used.');

		// Bounded cases:
		// Case #1: Number(5). Minimum valid values for sample_s, number_sample, population_s, number_pop. 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(0,1,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(0,1,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(5). Minimum valid values for sample_s, number_sample, population_s, number_pop. 5 of 5 arguments used.');
		// Case #2: Number(5). Maximum valid Excel numbers (truncated to integers). 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(1E+307,1E+307,1E+307,1E+307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(1E+307,1E+307,1E+307,1E+307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(5). Maximum valid Excel numbers (truncated to integers). 5 of 5 arguments used.');
		// Case #3: Number(5). Smallest positive number for sample_s (truncates to 0). 5 of 5 arguments used.
		oParser = new parserFormula('HYPGEOM.DIST(1E-307,2,1,3,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HYPGEOM.DIST(1E-307,2,1,3,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.33333333333333337, 'Test: Bounded case: Number(5). Smallest positive number for sample_s (truncates to 0). 5 of 5 arguments used.');



		testArrayFormula2(assert, "HYPGEOM.DIST", 5, 5);
	});

	QUnit.test("Test: \"INTERCEPT\"", function (assert) {

		function intercept(y, x) {

			var fSumDeltaXDeltaY = 0, fSumSqrDeltaX = 0, _x = 0, _y = 0, xLength = 0;
			for (var i = 0; i < x.length; i++) {
				_x += x[i];
				_y += y[i];
				xLength++;
			}

			_x /= xLength;
			_y /= xLength;

			for (var i = 0; i < x.length; i++) {

				var fValX = x[i];
				var fValY = y[i];

				fSumDeltaXDeltaY += (fValX - _x) * (fValY - _y);
				fSumSqrDeltaX += (fValX - _x) * (fValX - _x);

			}

			return toFixed(_y - fSumDeltaXDeltaY / fSumSqrDeltaX * _x);

		}

		oParser = new parserFormula("INTERCEPT({6,7,9,15,21},{20,28,31,38,40})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), intercept([6, 7, 9, 15, 21], [20, 28, 31, 38, 40]));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A104").setValue("4");
		// For area
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("3");
		ws.getRange2("A105").setValue("5");
		ws.getRange2("A106").setValue("6");
		ws.getRange2("A107").setValue("7");
		ws.getRange2("A108").setValue("8");
		ws.getRange2("A109").setValue("9");
		ws.getRange2("A110").setValue("10");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123"); // Num (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("A4").setValue("");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: arrays with numbers. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Positive case: Number. Basic valid input: arrays with numbers. 2 arguments used.');
		// Case #2: Number. Float numbers in arrays. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1.5,2.5,3.5},{4.5,5.5,6.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1.5,2.5,3.5},{4.5,5.5,6.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Positive case: Number. Float numbers in arrays. 2 arguments used.');
		// Case #3: String. String convertible to numbers. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({"1","2","3"},{"4","5","6"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({"1","2","3"},{"4","5","6"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String convertible to numbers. 2 arguments used.');
		// Case #4: Formula. Nested formula in arrays. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1.5,2.5,3.5},{40.5,5.5,60.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1.5,2.5,3.5},{40.5,5.5,60.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.041935483870968, 'Test: Positive case: Formula. Nested formula in arrays. 2 arguments used.');
		// Case #5: Reference link. Reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference to cells with valid numbers. 2 arguments used.');
		// Case #6: Area. Single-cell ranges. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Area. Single-cell ranges. 2 arguments used.');
		// Case #7: Array. Arrays with two elements. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Array. Arrays with two elements. 2 arguments used.');
		// Case #8: Name. Named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Named ranges with valid numbers. 2 arguments used.');
		// Case #9: Name3D. 3D named ranges. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named ranges. 2 arguments used.');
		// Case #10: Ref3D. 3D reference to cells. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D. 3D reference to cells. 2 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D single-cell ranges. 2 arguments used.');
		// Case #12: Table. Table structured references. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(Table1[Column1],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(Table1[Column1],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured references. 2 arguments used.');
		// Case #13: Formula. Nested IF formulas in arrays. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(IF(TRUE,{1,2,3},{-1,0,1}),{20,25,35})', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A1:B2").bbox);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(IF(TRUE,{1,2,3},{-1,0,1}),{20,25,35}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.4285714285714293, 'Test: Positive case: Formula. Nested IF formulas in arrays. 2 arguments used.');
		// Case #14: Number. Arrays with ignored text and logical values. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1,2,3,TRUE,"text"},{4,5,6,FALSE,"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1,2,3,TRUE,"text"},{4,5,6,FALSE,"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Positive case: Number. Arrays with ignored text and logical values. 2 arguments used.');
		// Case #15: Formula. INTERCEPT as parent formula in SUM. 2 arguments used.
		oParser = new parserFormula('SUM(INTERCEPT({1,2},{3,4}),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(INTERCEPT({1,2},{3,4}),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Formula. INTERCEPT as parent formula in SUM. 2 arguments used.');
		// Case #16: Number. Slightly above minimum value. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1,2,3},{4,5,6.0005})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1,2,3},{4,5,6.0005}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.9989168333402594, 'Test: Positive case: Number. Slightly above minimum value. 2 arguments used.');
		// Case #17: String. Numeric strings converted to floats. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({"1.5","2.5","3.5"},{"4.5","5.5","6.5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({"1.5","2.5","3.5"},{"4.5","5.5","6.5"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Numeric strings converted to floats. 2 arguments used.');
		// Case #18: Array. Larger arrays with valid numbers. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1,2,3,4},{5,6,7,8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1,2,3,4},{5,6,7,8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: Array. Larger arrays with valid numbers. 2 arguments used.');
		// Case #19: Array, Array. Two arrays with numbers. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({2,2,2},{4,6,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({2,2,2},{4,6,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array, Array. Two arrays with numbers. 2 arguments used.');
		// Case #20: Reference link. Reference to cells with mixed data (text ignored). 2 arguments used.
		oParser = new parserFormula('INTERCEPT(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference to cells with mixed data (text ignored). 2 arguments used.');
		// Case #21: Area. Multi-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(A100:A102,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Positive case: Area. Multi-cell ranges with valid numbers. 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Mismatched array sizes return #N/A. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1,2},{3,4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1,2},{3,4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Mismatched array sizes return #N/A. 2 arguments used.');
		// Case #2: Number. Collinear data (all y’s = 0) returns #DIV/0!. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({0,0,0},{1,1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({0,0,0},{1,1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Collinear data (all ys = 0) returns #DIV/0!. 2 arguments used.');
		// Case #3: String. Non-numeric strings return #DIV/0!. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({"abc","def"},{"ghi","jkl"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({"abc","def"},{"ghi","jkl"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-numeric strings return #DIV/0!. 2 arguments used.');
		// Case #4: Error. Propagates #DIV/0 error. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(1/0,{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(1/0,{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Propagates #DIV/0 error. 2 arguments used.');
		// Case #5: Area. Mismatched range sizes return #N/A. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(A100:A102,A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area. Mismatched range sizes return #N/A. 2 arguments used.');
		// Case #6: Cell. Cell references. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Cell references. 2 arguments used.');
		// Case #7: Boolean. Boolean values ignored, no valid data returns #DIV/0. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({TRUE,FALSE},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({TRUE,FALSE},{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean values ignored, no valid data returns #DIV/0. 2 arguments used.');
		// Case #8: String. Empty strings ignored, no valid data returns #DIV/0. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({"",""},{"",""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({"",""},{"",""}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Empty strings ignored, no valid data returns #DIV/0. 2 arguments used.');
		// Case #9: Ref3D. 3D ref to text cells returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text cells returns #VALUE!. 2 arguments used.');
		// Case #10: Name. Named ranges. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named ranges. 2 arguments used.');
		// Case #11: Table. Table columns with text/logical values. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Table. Table columns with text/logical values. 2 arguments used.');
		// Case #12: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({4,5,6},SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({4,5,6},SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.');
		// Case #13: Number. All zeros return #DIV/0!. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({0,0,0},{0,0,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({0,0,0},{0,0,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. All zeros return #DIV/0!. 2 arguments used.');
		// Case #14: Array. Single-element arrays. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Single-element arrays. 2 arguments used.');
		// Case #15: Number. Logical values. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1,2,3},{TRUE,TRUE,TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1,2,3},{TRUE,TRUE,TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Logical values. 2 arguments used.');
		// Case #16: Area3D. 3D ranges. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D ranges. 2 arguments used.');
		// Case #17: Date. Valid dates as numbers, but testing large values. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({45658,45659},{45717,45748})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({45658,45659},{45717,45748}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 44183.25806451613, 'Test: Negative case: Date. Valid dates as numbers, but testing large values. 2 arguments used.');
		// Case #18: Time. Time values (fractional) are valid but small, testing precision. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({0.5,0.541},{0.583,0.625})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({0.5,0.541},{0.583,0.625}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.06911904761904764, 'Test: Negative case: Time. Time values (fractional) are valid but small, testing precision. 2 arguments used.');
		// Case #19: Number. Near-zero x’s cause #DIV/0!. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1,2},{0,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1,2},{0,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Near-zero x’s cause #DIV/0!. 2 arguments used.');
		// Case #20: Formula. Nested IF with #N/A propagates error. 2 arguments used.
		oParser = new parserFormula('INTERCEPT(IF(FALSE,1,NA()),{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT(IF(FALSE,1,NA()),{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Nested IF with #N/A propagates error. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive values supported by Excel. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1E-307,2E-307,3E-307},{4E-307,5E-307,6E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1E-307,2E-307,3E-307},{4E-307,5E-307,6E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Minimum positive values supported by Excel. 2 arguments used.');
		// Case #2: Number. Maximum Excel values, collinear case. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({9.99999999999999E+307,9.99999999999999E+307},{9.99999999999999E+307,9.99999999999999E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({9.99999999999999E+307,9.99999999999999E+307},{9.99999999999999E+307,9.99999999999999E+307}) is parsed.');debugger
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum Excel values, collinear case. 2 arguments used.');
		// Case #3: Number. Collinear x’s (all same) return #DIV/0!. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1,2,3},{1,1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1,2,3},{1,1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Collinear x (all same) return #DIV/0!. 2 arguments used.');
		// Case #4: Array, Array. Maximum number boundary check. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1E+154,1E+154},{1E+154,2E+154})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1E+154,1E+154},{1E+154,2E+154}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+154, 'Test: Bounded case: Array, Array. Maximum number boundary check. 2 arguments used.');
		// Case #5: Array, Array. Maximum number boundary check. 2 arguments used.
		oParser = new parserFormula('INTERCEPT({1E+155,1E+155},{1E+155,2E+155})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTERCEPT({1E+155,1E+155},{1E+155,2E+155}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array, Array. Maximum number boundary check. 2 arguments used.');


		testArrayFormula2(assert, "INTERCEPT", 2, 2, null, true);
	});

	QUnit.test("Test: \"KURT\"", function (assert) {

		function kurt(x) {

			var sumSQRDeltaX = 0, _x = 0, xLength = 0, standDev = 0, sumSQRDeltaXDivstandDev = 0;
			for (var i = 0; i < x.length; i++) {
				_x += x[i];
				xLength++;
			}

			_x /= xLength;

			for (var i = 0; i < x.length; i++) {
				sumSQRDeltaX += Math.pow(x[i] - _x, 2);
			}

			standDev = Math.sqrt(sumSQRDeltaX / (xLength - 1));

			for (var i = 0; i < x.length; i++) {
				sumSQRDeltaXDivstandDev += Math.pow((x[i] - _x) / standDev, 4);
			}

			return toFixed(xLength * (xLength + 1) / (xLength - 1) / (xLength - 2) / (xLength - 3) * sumSQRDeltaXDivstandDev - 3 * (xLength - 1) * (xLength - 1) / (xLength - 2) /
				(xLength - 3))

		}

		oParser = new parserFormula("KURT(10.5,12.4,19.4,23.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), kurt([10.5, 12.4, 19.4, 23.2]));

		oParser = new parserFormula("KURT(10.5,{12.4,19.4},23.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), kurt([10.5, 12.4, 19.4, 23.2]));

		oParser = new parserFormula("KURT(10.5,12.4,19.4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");


		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(4). Basic kurtosis calculation. 4 of 254 arguments used.
		oParser = new parserFormula('KURT(1,2,3,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(1,2,3,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed("1"), "-1.2", 'Test: Positive case: Number(4). Basic kurtosis calculation. 4 of 254 arguments used.');
		// Case #2: Number(3), Empty. 3 numbers + empty. 3 of 254 args used.
		oParser = new parserFormula('KURT(1.5,2.5,3.5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(1.5,2.5,3.5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), "-0.4161062", 'Test: Positive case: Number(3), Empty. 3 numbers + empty. 3 of 254 args used.');
		// Case #3: Number(100). Test with 100 arguments. 100 of 254 args used.
		oParser = new parserFormula('KURT(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), "-1.2", 'Test: Positive case: Number(100). Test with 100 arguments. 100 of 254 args used.');
		// Case #5: Array(3). Array input. 1 of 254 args used.
		oParser = new parserFormula('KURT({1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT({1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Array(3). Array input. 1 of 254 args used.');	//'#DIV/0!'
		// Case #6: Formula(3). Formula arguments. 3 of 254 args used.
		oParser = new parserFormula('KURT(SQRT(1),SQRT(4),SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(SQRT(1),SQRT(4),SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula(3). Formula arguments. 3 of 254 args used.');	// '#DIV/0!'
		// Case #7: Number(3). Decimal numbers. 3 of 254 args used.
		oParser = new parserFormula('KURT(1.1,2.2,3.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(1.1,2.2,3.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number(3). Decimal numbers. 3 of 254 args used.');	//'#DIV/0!'
		// Case #8: Number(3). Negative numbers. 3 of 254 args used.
		oParser = new parserFormula('KURT(-1,-2,-3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(-1,-2,-3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number(3). Negative numbers. 3 of 254 args used.');	// '#DIV/0!'
		// Case #11: Array(1). Single value kurtosis calculation. Note: Excel requires minimum 4 values for proper kurtosis calculation, but accepts single value input.
		oParser = new parserFormula('KURT({1;2;3;4;5;6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT({1;2;3;4;5;6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), "-1.2", 'Test: Positive case: Array(1). Single value kurtosis calculation. Note: Excel requires minimum 4 values for proper kurtosis calculation, but accepts single value input.');
		// Case #12: Defname. Defname link kurtosis calculation.
		oParser = new parserFormula('KURT(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Defname(1). Defname link kurtosis calculation.');// '#DIV/0!'

		// Negative cases:
		// Case #1: String(3). #VALUE! for non-coercible text. 3 of 254 args used.
		oParser = new parserFormula('KURT("a","b","c")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT("a","b","c") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). #VALUE! for non-coercible text. 3 of 254 args used.');
		// Case #2: Error(3). #DIV/0! error propagation. 3 of 254 args used.
		oParser = new parserFormula('KURT(1/0,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(1/0,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error(3). #DIV/0! error propagation. 3 of 254 args used.');
		// Case #3: Boolean(3). #VALUE! for booleans. 3 of 254 args used.
		oParser = new parserFormula('KURT(TRUE,FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(TRUE,FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean(3). #VALUE! for booleans. 3 of 254 args used.');	// '#DIV/0!'
		// Case #4: Empty. #NUM! for insufficient data (needs ?4). 0 of 254 args used.
		oParser = new parserFormula('KURT(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. #NUM! for insufficient data (needs ?4). 0 of 254 args used.'); //#DIV/0!
		// Case #5: Number(3). #DIV/0! for zero standard deviation. 3 of 254 args used.
		oParser = new parserFormula('KURT(1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). #DIV/0! for zero standard deviation. 3 of 254 args used.');//#DIV/0!

		// Bounded cases:
		// Case #1: Number(4). Max double-precision values. 4 of 254 args used.
		oParser = new parserFormula('KURT(1E+307,1E+307,1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(1E+307,1E+307,1E+307,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(4). Max double-precision values. 4 of 254 args used.');//#DIV/0!
		// Case #2: Number(4). Min double-precision values. 4 of 254 args used.
		oParser = new parserFormula('KURT(-1E+307,-1E+307,-1E+307,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(-1E+307,-1E+307,-1E+307,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(4). Min double-precision values. 4 of 254 args used.');//#DIV/0!
		// Case #3: Number(3). Smallest positive numbers. 3 of 254 args used.
		oParser = new parserFormula('KURT(2.22507E-308,2.22507E-308,2.22507E-308)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: KURT(2.22507E-308,2.22507E-308,2.22507E-308) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(3). Smallest positive numbers. 3 of 254 args used.');//#DIV/0!

		// Need to fix:
		// Different result with MS
		// Case #5: Array(3) - error should be #DIV/0
		// Case #6: Formula(3)
		// Case #7: Number(3).
		// Case #8: Number(3)
		// Case #1: String(3) - string values problem
		// Case #3: Boolean(3)
		// Case #4: Empty. #NUM!
		// Case #5: Number(3). #DIV/0!
		// All bounded cases



		testArrayFormula2(assert, "KURT", 1, 8, null, true);
	});

	QUnit.test("Test: \"LARGE\"", function (assert) {

		oParser = new parserFormula("LARGE({3,5,3,5,4;4,2,4,6,7},3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 5);

		oParser = new parserFormula("LARGE({3,5,3,5,4;4,2,4,6,7},7)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Array, Number. Basic array with numbers. Returns largest value. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({10,20,30},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({10,20,30},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Array, Number. Basic array with numbers. Returns largest value. 2 of 2 arguments used.');
		// Case #2: Array, Number. Array with numbers. Returns second largest value. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({5,3,9,1},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({5,3,9,1},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array, Number. Array with numbers. Returns second largest value. 2 of 2 arguments used.');
		// Case #3: Array, Number. Array with negative numbers. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({-5,-3,-1},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({-5,-3,-1},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Array, Number. Array with negative numbers. 2 of 2 arguments used.');
		// Case #4: Array, Number. Array with decimal numbers. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1.5,2.5,3.5},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1.5,2.5,3.5},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Positive case: Array, Number. Array with decimal numbers. 2 of 2 arguments used.');
		// Case #5: Array, Number. Array with mixed boolean and number. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({TRUE,FALSE,1},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({TRUE,FALSE,1},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array, Number. Array with mixed boolean and number. 2 of 2 arguments used.');
		// Case #6: Reference link, Number. Range reference with numbers. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE(A100:A102,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE(A100:A102,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number. Range reference with numbers. 2 of 2 arguments used.');
		// Case #7: Area, Number. Area with two cells. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE(A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE(A100:A101,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Area, Number. Area with two cells. 2 of 2 arguments used.');
		// Case #8: Array, Number. Array with numbers as strings. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({"10","20","30"},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({"10","20","30"},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Array, Number. Array with numbers as strings. 2 of 2 arguments used.');
		// Case #9: Name, Number. Named range. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE(TestName1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE(TestName1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name, Number. Named range. 2 of 2 arguments used.');
		// Case #11: Array, Number. Array operation as argument. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3}+{4,5,6},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3}+{4,5,6},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Array, Number. Array operation as argument. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Array, String. Non-numeric k argument. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3},"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3},"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, String. Non-numeric k argument. 2 of 2 arguments used.');
		// Case #2: String, Number. Non-array text argument. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE("text",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE("text",1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-array text argument. 2 of 2 arguments used.');
		// Case #3: Array, Number. Empty array. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({""},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({""},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Empty array. 2 of 2 arguments used.');
		// Case #4: Array, Number. k argument is zero. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3},0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. k argument is zero. 2 of 2 arguments used.');
		// Case #5: Array, Number. k argument larger than array size. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. k argument larger than array size. 2 of 2 arguments used.');
		// Case #6: Array, Number. Negative k argument. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3},-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Negative k argument. 2 of 2 arguments used.');
		// Case #7: Error, Number. Error value as array. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE(#N/A,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE(#N/A,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error value as array. 2 of 2 arguments used.');
		// Case #8: Array, Error. Error value as k. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3},#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3},#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Error. Error value as k. 2 of 2 arguments used.');
		// Case #9: Empty, Number. Empty first argument. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE(,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE(,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty, Number. Empty first argument. 2 of 2 arguments used.');
		// Case #10: Array, Empty. Empty k argument. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3},) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Empty. Empty k argument. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Array, Number. Minimum valid k value. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Bounded case: Array, Number. Minimum valid k value. 2 of 2 arguments used.');
		// Case #2: Array, Number. Maximum valid k value for array size. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array, Number. Maximum valid k value for array size. 2 of 2 arguments used.');
		// Case #3: Array, Number. Maximum numeric value. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1E+306},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1E+306},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+306, 'Test: Bounded case: Array, Number. Maximum numeric value. 2 of 2 arguments used.');
		// Case #4: Array, Number. Minimum numeric value. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1E-306},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1E-306},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-306, 'Test: Bounded case: Array, Number. Minimum numeric value. 2 of 2 arguments used.');
		// Case #5: Array, Number. Fractional k that truncates to valid value. 2 of 2 arguments used.
		oParser = new parserFormula('LARGE({1,2,3},2.999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LARGE({1,2,3},2.999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array, Number. Fractional k that truncates to valid value. 2 of 2 arguments used.');

		// Need to fix:
		// Different result with MS
		// Case #9: Name, Number - #NUM error while enter defname as argument,
		// Case #2: String, Number - different error type when facing the string arg
		// Case #4: Array, Number. k argument is zero
		// Case #6: Array, Number. Negative k argument
		// Case #9: Empty, Number. Empty first argument - add empty args processing
		// Case #10: Array, Empty. Empty k argument - - add empty args processing

		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "LARGE", 2, 2)
	});

	QUnit.test("Test: \"LINEST\"", function (assert) {
		let array;

		ws.getRange2("A202").setValue("1");
		ws.getRange2("A203").setValue("2");
		ws.getRange2("A204").setValue("3");

		ws.getRange2("B202").setValue("2");
		ws.getRange2("B203").setValue("3");
		ws.getRange2("B204").setValue("4");


		oParser = new parserFormula("LINEST(A202:B204)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 0.54285714);

		oParser = new parserFormula("LINEST(A202:B204, A202:B204)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1);

		oParser = new parserFormula("LINEST(A202:B204, A202:B204, 1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1);

		oParser = new parserFormula("LINEST(A202:B204, A202:B204, 1, 1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1);

		ws.getRange2("A202").setValue("1");
		ws.getRange2("A203").setValue("9");
		ws.getRange2("A204").setValue("5");
		ws.getRange2("A205").setValue("7");

		ws.getRange2("B202").setValue("0");
		ws.getRange2("B203").setValue("4");
		ws.getRange2("B204").setValue("2");
		ws.getRange2("B205").setValue("3");

		oParser = new parserFormula("LINEST(A202:A205,B202:B205,,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 2);

		oParser = new parserFormula("LINEST(A202:A205,B202:B205,FALSE,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 2.31034483);

		oParser = new parserFormula("LINEST(A202:A205,B202:B205,FALSE,TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 2.31034483);

		ws.getRange2("A102").setValue("1");
		ws.getRange2("A103").setValue("9");
		ws.getRange2("A104").setValue("5");
		ws.getRange2("A105").setValue("7");

		ws.getRange2("B102").setValue("0");
		ws.getRange2("B103").setValue("4");
		ws.getRange2("B104").setValue("2");
		ws.getRange2("B105").setValue("3");

		oParser = new parserFormula("LINEST(A102:A105,B102:B105,,FALSE)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse());
		array = oParser.calculate();
		if (AscCommonExcel.cElementType.array === array.type) {
			assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2);
			assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1);
		}


		ws.getRange2("A102").setValue("2310");
		ws.getRange2("A103").setValue("2333");
		ws.getRange2("A104").setValue("2356");
		ws.getRange2("A105").setValue("2379");
		ws.getRange2("A106").setValue("2402");
		ws.getRange2("A107").setValue("2425");
		ws.getRange2("A108").setValue("2448");
		ws.getRange2("A109").setValue("2471");
		ws.getRange2("A110").setValue("2494");
		ws.getRange2("A111").setValue("2517");
		ws.getRange2("A112").setValue("2540");

		ws.getRange2('B102').setValue('2');
		ws.getRange2('B103').setValue('2');
		ws.getRange2('B104').setValue('3');
		ws.getRange2('B105').setValue('3');
		ws.getRange2('B106').setValue('2');
		ws.getRange2('B107').setValue('4');
		ws.getRange2('B108').setValue('2');
		ws.getRange2('B109').setValue('2');
		ws.getRange2('B110').setValue('3');
		ws.getRange2('B111').setValue('4');
		ws.getRange2('B112').setValue('2');

		ws.getRange2('C102').setValue('2');
		ws.getRange2('C103').setValue('2');
		ws.getRange2('C104').setValue('1.5');
		ws.getRange2('C105').setValue('2');
		ws.getRange2('C106').setValue('3');
		ws.getRange2('C107').setValue('2');
		ws.getRange2('C108').setValue('1.5');
		ws.getRange2('C109').setValue('2');
		ws.getRange2('C110').setValue('3');
		ws.getRange2('C111').setValue('4');
		ws.getRange2('C112').setValue('3');

		ws.getRange2('D102').setValue('20');
		ws.getRange2('D103').setValue('12');
		ws.getRange2('D104').setValue('33');
		ws.getRange2('D105').setValue('43');
		ws.getRange2('D106').setValue('53');
		ws.getRange2('D107').setValue('23');
		ws.getRange2('D108').setValue('99');
		ws.getRange2('D109').setValue('34');
		ws.getRange2('D110').setValue('23');
		ws.getRange2('D111').setValue('55');
		ws.getRange2('D112').setValue('22');

		ws.getRange2('E102').setValue('142000');
		ws.getRange2('E103').setValue('144000');
		ws.getRange2('E104').setValue('151000');
		ws.getRange2('E105').setValue('150000');
		ws.getRange2('E106').setValue('139000');
		ws.getRange2('E107').setValue('169000');
		ws.getRange2('E108').setValue('126000');
		ws.getRange2('E109').setValue('142900');
		ws.getRange2('E110').setValue('163000');
		ws.getRange2('E111').setValue('169000');
		ws.getRange2('E112').setValue('149000');

		oParser = new parserFormula("LINEST(E102:E112,A102:D112,TRUE,TRUE)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E120:E123").bbox);
		assert.ok(oParser.parse());
		array = oParser.calculate();
		// if (AscCommonExcel.cElementType.array === array.type) {
		// 	assert.strictEqual(array.getElementRowCol(0, 0).getValue().toFixed(7) - 0, -234.2371645);
		// 	assert.strictEqual(array.getElementRowCol(1, 0).getValue().toFixed(8) - 0, 13.26801148);
		// 	assert.strictEqual(array.getElementRowCol(2, 0).getValue().toFixed(9) - 0, 0.996747993);
		// 	assert.strictEqual(array.getElementRowCol(3, 0).getValue().toFixed(7) - 0, 459.7536742);
		// }

		ws.getRange2("A120").setValue("1");
		ws.getRange2("B120").setValue("2");

		oParser = new parserFormula("LINEST(A120:B120)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1);

		oParser = new parserFormula("LINEST({1;2})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1);

		oParser = new parserFormula("LINEST({1,2})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1);

		// for bug 65316
		ws.getRange2("A150").setValue("1");
		ws.getRange2("B150").setValue("2");
		ws.getRange2("C150").setValue("3");
		ws.getRange2("D150").setValue("4");
		ws.getRange2("E150").setValue("5");

		ws.getRange2("A151").setValue("5.3");
		ws.getRange2("B151").setValue("6.3");
		ws.getRange2("C151").setValue("4.8");
		ws.getRange2("D151").setValue("3.8");
		ws.getRange2("E151").setValue("3.3");

		oParser = new parserFormula("LINEST(A151:E151,A150:E150)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "LINEST(A151:E151,A150:E150)");
		array = oParser.calculate();
		assert.ok(1, "LINEST(A151:E151,A150:E150) => y = -0.65x + 6.65");
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), -0.65, "Result of LINEST(A151:E151,A150:E150) [0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 6.65, "Result of LINEST(A151:E151,A150:E150) [0,1]");

		oParser = new parserFormula("LINEST(A151:E151,A150:E150^{1;2;3})", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "LINEST(A151:E151,A150:E150^{1;2;3})");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue().toFixed(2), "0.25", "Result of LINEST(A151:E151,A150:E150)^{1;2;3} [0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue().toFixed(2), "-2.43", "Result of LINEST(A151:E151,A150:E150)^{1;2;3} [0,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue().toFixed(2), "6.32", "Result of LINEST(A151:E151,A150:E150)^{1;2;3} [0,2]");
		assert.strictEqual(array.getElementRowCol(0, 3).getValue().toFixed(1), "1.2", "Result of LINEST(A151:E151,A150:E150)^{1;2;3} [0,3]");

		oParser = new parserFormula("LINEST(A151:E151,A150:E150^{1,2,3})", "A2", ws);
		assert.ok(oParser.parse(), "LINEST(A151:E151,A150:E150^{1,2,3})");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of LINEST(A151:E151,A150:E150)^{1,2,3}");

		oParser = new parserFormula("LINEST(A151:E151,{1;2;3;4;5})", "A2", ws);
		assert.ok(oParser.parse(), "LINEST(A151:E151,{1;2;3;4;5})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LINEST(A151:E151,{1;2;3;4;5})");

		oParser = new parserFormula("LINEST(A151:E151,{1,2,3,4,5})", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "LINEST(A151:E151,{1,2,3,4,5})");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), -0.65, "Result of LINEST(A151:E151,{1,2,3,4,5}) [0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 6.65, "Result of LINEST(A151:E151,{1,2,3,4,5}) [0,1]");

		oParser = new parserFormula('LINEST(A151:E151,{"1",2,3,4,5})', "A2", ws);
		assert.ok(oParser.parse(), 'LINEST(A151:E151,{"1",2,3,4,5})');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of LINEST(A151:E151,{"1",2,3,4,5})');

		oParser = new parserFormula('LINEST(A151:E151,{#N/A,2,3,4,5})', "A2", ws);
		assert.ok(oParser.parse(), 'LINEST(A151:E151,{#N/A,2,3,4,5})');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of LINEST(A151:E151,{#N/A,2,3,4,5})');

		oParser = new parserFormula('LINEST(A151:E151,{"string",2,3,4,5})', "A2", ws);
		assert.ok(oParser.parse(), 'LINEST(A151:E151,{"string",2,3,4,5})');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of LINEST(A151:E151,{"string",2,3,4,5})');

		oParser = new parserFormula('LINEST(A151:E151,{TRUE,2,3,4,5})', "A2", ws);
		assert.ok(oParser.parse(), 'LINEST(A151:E151,{TRUE,2,3,4,5})');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of LINEST(A151:E151,{TRUE,2,3,4,5})');

		oParser = new parserFormula("LINEST({5.3,6.3,4.8,3.8,3.3},A150:E150)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:F106").bbox);
		assert.ok(oParser.parse(), "LINEST({5.3,6.3,4.8,3.8,3.3},A150:E150)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), -0.65, "Result of LINEST({5.3,6.3,4.8,3.8,3.3},A150:E150) [0,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 6.65, "Result of LINEST({5.3,6.3,4.8,3.8,3.3},A150:E150) [0,1]");

		oParser = new parserFormula('LINEST({"5.3",6.3,4.8,3.8,3.3},A150:E150)', "A2", ws);
		assert.ok(oParser.parse(), 'LINEST({"5.3",6.3,4.8,3.8,3.3},A150:E150)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of LINEST({"5.3",6.3,4.8,3.8,3.3},A150:E150)');

		oParser = new parserFormula('LINEST({#N/A,6.3,4.8,3.8,3.3},A150:E150)', "A2", ws);
		assert.ok(oParser.parse(), 'LINEST({#N/A,6.3,4.8,3.8,3.3},A150:E150)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of LINEST({#N/A,6.3,4.8,3.8,3.3},A150:E150)');

		oParser = new parserFormula('LINEST({"string",6.3,4.8,3.8,3.3},A150:E150)', "A2", ws);
		assert.ok(oParser.parse(), 'LINEST({"string",6.3,4.8,3.8,3.3},A150:E150)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of LINEST({"string",6.3,4.8,3.8,3.3},A150:E150)');

		oParser = new parserFormula('LINEST({TRUE,6.3,4.8,3.8,3.3},A150:E150)', "A2", ws);
		assert.ok(oParser.parse(), 'LINEST({TRUE,6.3,4.8,3.8,3.3},A150:E150)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of LINEST({TRUE,6.3,4.8,3.8,3.3},A150:E150)');

		ws.getRange2("A200").setValue("1");
		ws.getRange2("A201").setValue("2");
		ws.getRange2("A202").setValue("3");
		ws.getRange2("B200").setValue("1");
		ws.getRange2("B201").setValue("2");
		ws.getRange2("B202").setValue("3");
		ws.getRange2("C200").setValue("1");
		ws.getRange2("C201").setValue("2");
		ws.getRange2("C202").setValue("3");

		// different matrix length tests
		oParser = new parserFormula("LINEST(A200:A201,A200:C200)", "A2", ws);
		assert.ok(oParser.parse(), "LINEST(A200:A201,A200:C200)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LINEST(A200:A201,A200:C200)");

		oParser = new parserFormula("LINEST(A200:A202,A200:C200)", "A2", ws);
		assert.ok(oParser.parse(), "LINEST(A200:A202,A200:C200)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LINEST(A200:A202,A200:C200)");

		oParser = new parserFormula("LINEST(A200:B201,A200:C201)", "A2", ws);
		assert.ok(oParser.parse(), "LINEST(A200:B201,A200:C201)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LINEST(A200:B201,A200:C201)");

		oParser = new parserFormula("LINEST({1,2,3},{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "LINEST({1,2,3},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LINEST({1,2,3},{1,2})");

		oParser = new parserFormula("LINEST({1,2,3},{1,2,3,4})", "A2", ws);
		assert.ok(oParser.parse(), "LINEST({1,2,3},{1,2,3,4})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LINEST({1,2,3},{1,2,3,4})");

		oParser = new parserFormula("LINEST({1,2;1,2},{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "LINEST({1,2;1,2},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LINEST({1,2;1,2},{1,2})");

		oParser = new parserFormula("LINEST(A200:B200,{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "LINEST(A200:B200,{1,2})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 0, "Result of LINEST(A200:B200,{1,2})[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 1, "Result of LINEST(A200:B200,{1,2})[0,1]");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		ws.getRange2("B100").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number(2), Array. Basic valid input: two numeric ranges. 2 arguments used.
		oParser = new parserFormula('LINEST(A100:A101,B100:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(A100:A101,B100:B101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number(2), Array. Basic valid input: two numeric ranges. 2 arguments used.');
		// Case #1: Number(2), Array, Boolean, Boolean. All arguments with const and stats. 4 arguments used.
		oParser = new parserFormula('LINEST(A100:A101,B100:B101,TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(A100:A101,B100:B101,TRUE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number(2), Array, Boolean, Boolean. All arguments with const and stats. 4 arguments used.');
		// Case #2: Formula(2). Nested formulas as arguments. 2 arguments used.
		oParser = new parserFormula('LINEST(SQRT(A100:A101),LOG(B100:B101))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(SQRT(A100:A101),LOG(B100:B101)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula(2). Nested formulas as arguments. 2 arguments used.');
		// Case #3: String(2). String convertible to number. 2 arguments used.
		oParser = new parserFormula('LINEST("1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST("1","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String(2). String convertible to number. 2 arguments used.');
		// Case #4: Reference link(2). Reference links to single cells. 2 arguments used.
		oParser = new parserFormula('LINEST(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link(2). Reference links to single cells. 2 arguments used.');
		// Case #5: Area(2). Single-cell ranges. 2 arguments used.
		oParser = new parserFormula('LINEST(A100:A100,B100:B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(A100:A100,B100:B100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area(2). Single-cell ranges. 2 arguments used.');
		// Case #6: Array(2). Arrays with multiple elements. 2 arguments used.
		oParser = new parserFormula('LINEST({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array(2). Arrays with multiple elements. 2 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), -2, 'Test: Positive case: Array(2). Arrays with multiple elements. 2 arguments used.');
		// Case #7: Name(2). Named ranges. 2 arguments used.
		oParser = new parserFormula('LINEST(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name(2). Named ranges. 2 arguments used.');
		// Case #8: Name3D(2). 3D named ranges. 2 arguments used.
		oParser = new parserFormula('LINEST(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D(2). 3D named ranges. 2 arguments used.');
		// Case #9: Ref3D(2). 3D references. 2 arguments used.
		oParser = new parserFormula('LINEST(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(2). 3D references. 2 arguments used.');
		// Case #10: Area3D(2). 3D single-cell ranges. 2 arguments used.
		oParser = new parserFormula('LINEST(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(2). 3D single-cell ranges. 2 arguments used.');
		// Case #11: Table. Table structured references. 2 arguments used.
		oParser = new parserFormula('LINEST(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Table. Table structured references. 2 arguments used.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 1, 'Test: Positive case: Table. Table structured references. 2 arguments used.');
		// Case #12: Date, Time. Date and time as arguments. 2 arguments used.
		oParser = new parserFormula('LINEST(DATE(2025,1,1),TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(DATE(2025,1,1),TIME(0,0,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Date, Time. Date and time as arguments. 2 arguments used.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 45658, 'Test: Positive case: Date, Time. Date and time as arguments. 2 arguments used.');
		// Case #13: Formula. LINEST inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(LINEST(A100:A101,B100:B101),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(LINEST(A100:A101,B100:B101),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. LINEST inside SUM formula. 2 arguments used.');
		// Case #14: Array. Multi-element arrays with const. 3 arguments used.
		oParser = new parserFormula('LINEST({1,2,3},{4,5,6},FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST({1,2,3},{4,5,6},FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(9), "0.415584416", 'Test: Positive case: Array. Multi-element arrays with const. 3 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 0, 'Test: Positive case: Array. Multi-element arrays with const. 3 arguments used.');
		// Case #15: Number, Array, Boolean. Mixed number and array. 3 arguments used.
		oParser = new parserFormula('LINEST(1,{2,3},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(1,{2,3},TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Array, Boolean. Mixed number and array. 3 arguments used.');
		// Case #16: Reference link, Area. Mixed reference and range. 2 arguments used.
		oParser = new parserFormula('LINEST(A100,B100:B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(A100,B100:B100) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Reference link, Area. Mixed reference and range. 2 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 0.5, 'Test: Positive case: Reference link, Area. Mixed reference and range. 2 arguments used.');
		// Case #17: Name, Name3D. Mixed name types. 2 arguments used.
		oParser = new parserFormula('LINEST(TestName,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(TestName,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Name, Name3D. Mixed name types. 2 arguments used.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), -0.5, 'Test: Positive case: Name, Name3D. Mixed name types. 2 arguments used.');
		// Case #18: Ref3D, Area3D. Mixed 3D types. 2 arguments used.
		oParser = new parserFormula('LINEST(Sheet2!A1,Sheet2!B1:B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(Sheet2!A1,Sheet2!B1:B1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Ref3D, Area3D. Mixed 3D types. 2 arguments used.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 0.5, 'Test: Positive case: Ref3D, Area3D. Mixed 3D types. 2 arguments used.');
		// Case #19: Table, Array. Mixed table and array. 2 arguments used.
		oParser = new parserFormula('LINEST(Table1[Column1],{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(Table1[Column1],{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Table, Array. Mixed table and array. 2 arguments used.');
		// Case #20: Formula, String. Mixed formula and string. 2 arguments used.
		oParser = new parserFormula('LINEST(SQRT(A100:A101),"1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(SQRT(A100:A101),"1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Positive case: Formula, String. Mixed formula and string. 2 arguments used.');

		// Negative cases:
		// Case #0: String(2). Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('LINEST("text","text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST("text","text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #1: Boolean(2). Boolean values return #VALUE!. 2 arguments used.
		oParser = new parserFormula('LINEST(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Boolean values return #VALUE!. 2 arguments used.');
		// Case #2: Empty(2). Empty arguments return #NUM!. 2 arguments used.
		oParser = new parserFormula('LINEST(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty(2). Empty arguments return #NUM!. 2 arguments used.');
		// Case #3: Error. Error propagation. 2 arguments used.
		oParser = new parserFormula('LINEST(NA(),NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(NA(),NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error propagation. 2 arguments used.');
		// Case #4: Number, Empty. One empty argument returns #NUM!. 2 arguments used.
		oParser = new parserFormula('LINEST(1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(1,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Number, Empty. One empty argument returns #NUM!. 2 arguments used.');
		// Case #5: Area(2). Mismatched range sizes return #REF!. 2 arguments used.
		oParser = new parserFormula('LINEST(A100:A102,B100:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(A100:A102,B100:B101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Area(2). Mismatched range sizes return #REF!. 2 arguments used.');
		// Case #6: Array(2). Mismatched array sizes. 2 arguments used.
		oParser = new parserFormula('LINEST({1},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST({1},{2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Array(2). Mismatched array sizes return #REF!. 2 arguments used.');
		// Case #7: Number. Single argument. 1 argument used.
		oParser = new parserFormula('LINEST(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Number. Single argument returns #N/A. 1 argument used.');
		// Case #8: Time, Boolean. Invalid combination returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('LINEST(TIME(1,0,0),FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(TIME(1,0,0),FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Time, Boolean. Invalid combination returns #VALUE!. 2 arguments used.');
		// Case #9: Date, String. Invalid combination returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('LINEST(DATE(2025,1,1),"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(DATE(2025,1,1),"text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Date, String. Invalid combination returns #VALUE!. 2 arguments used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LINEST(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LINEST(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LINEST(Table1[Text])', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: LINEST(Table1[Text]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #13: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LINEST({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST({TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');
		// Case #14: Number(2). Zero values return 0. 2 arguments used.
		oParser = new parserFormula('LINEST(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Negative case: Number(2). Zero values return 0. 2 arguments used.');

		// Bounded cases:
		// Case #0: Number(2). Maximum valid numbers. 2 arguments used.
		oParser = new parserFormula('LINEST(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Bounded case: Number(2). Maximum valid numbers. 2 arguments used.');
		// Case #1: Number(2). Minimum valid numbers. 2 arguments used.
		oParser = new parserFormula('LINEST(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(1E-307,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Bounded case: Number(2). Minimum valid numbers. 2 arguments used.');
		// Case #2: Date, Number. Maximum valid date. 2 arguments used.
		oParser = new parserFormula('LINEST(DATE(9999,12,31),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(DATE(9999,12,31),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Date, Number. Maximum valid date. 2 arguments used.');
		// Case #3: Time, Number. Maximum valid time. 2 arguments used.
		oParser = new parserFormula('LINEST(TIME(23,59,59),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LINEST(TIME(23,59,59),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Time, Number. Maximum valid time. 2 arguments used.');

		// Need to fix: error check, cellsRange check, Name check, DATE and TIME check, different error return, strings
		// Different result with MS
		// Case #3: String(2). String convertible to number.
		// Case #5: Area(2). Single-cell ranges. 2 arguments used.
		// Case #7: Name(2). Named ranges.
		// Case #8: Name3D(2). 3D named ranges.
		// Case #11: Table. Table structured references
		// Case #12: Date, Time. Date and time as arguments
		// Case #15: Number, Array, Boolean
		// Case #17: Name, Name3D. Mixed name types
		// Case #18: Ref3D, Area3D. Mixed 3D types
		// Case #19: Table, Array. Mixed table and array
		// Case #20: Formula, String. Mixed formula and string.
		// Case #0: String(2). Non-numeric strings return #VALUE!
		// Case #1: Boolean(2). Boolean values return #VALUE!.
		// Case #2: Empty(2). Empty arguments return #NUM!.
		// Case #4: Number, Empty. One empty argument returns #NUM!.
		// Case #5: Area(2). Mismatched range sizes return #REF!
		// Case #6: Array(2). Mismatched array sizes.
		// Case #7: Number. Single argument.
		// Case #8: Time, Boolean. Invalid combination returns #VALUE!.

	});

	QUnit.test("Test: \"LOGEST\"", function (assert) {

		ws.getRange2("A101").setValue("1");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("3");
		ws.getRange2("A104").setValue("4");
		ws.getRange2("A105").setValue("5");
		ws.getRange2("A106").setValue("6");
		ws.getRange2("A107").setValue("7");
		ws.getRange2("A108").setValue("8");
		ws.getRange2("A109").setValue("9");
		ws.getRange2("A110").setValue("10");
		ws.getRange2("A111").setValue("11");
		ws.getRange2("A112").setValue("12");


		ws.getRange2("B101").setValue("133890");
		ws.getRange2("B102").setValue("135000");
		ws.getRange2("B103").setValue("135790");
		ws.getRange2("B104").setValue("137300");
		ws.getRange2("B105").setValue("138130");
		ws.getRange2("B106").setValue("139100");
		ws.getRange2("B107").setValue("139900");
		ws.getRange2("B108").setValue("141120");
		ws.getRange2("B109").setValue("141890");
		ws.getRange2("B110").setValue("143230");
		ws.getRange2("B111").setValue("144000");
		ws.getRange2("B112").setValue("145290");

		ws.getRange2("A115").setValue("13");
		ws.getRange2("A116").setValue("14");
		ws.getRange2("A117").setValue("15");
		ws.getRange2("A118").setValue("16");
		ws.getRange2("A119").setValue("17");

		oParser = new parserFormula("LOGEST(B101:B112,A101:A112)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.00732561);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 133044.8167);

		oParser = new parserFormula("LOGEST(B101:B112,A101:A112,,false)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.00732561);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 133044.8167);

		//todo необходимо перепроверить остальные значения в данном случае
		oParser = new parserFormula("LOGEST(B101:B112,A101:A112,,true)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.00732561);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 133044.8167);

		oParser = new parserFormula("LOGEST(B101:B112,A101:A112,true,true)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.00732561);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 133044.8167);

		//todo необходимо перепроверить остальные значения в данном случае
		oParser = new parserFormula("LOGEST(B101:B112,A101:A112,false,true)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 4.15001464);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 1);

		oParser = new parserFormula("LOGEST(A101:B105,A106:B110,FALSE,TRUE)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.0000838);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 1);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(8) - 0, 0.00000264);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue().toFixed(4) - 0, 0.9911);
		assert.strictEqual(oParser.calculate().getElementRowCol(3, 0).getValue().toFixed(4) - 0, 1005.3131);
		assert.strictEqual(oParser.calculate().getElementRowCol(4, 0).getValue().toFixed(4) - 0, 698.5684);

		oParser = new parserFormula("LOGEST(A101:B105,A106:B110,,)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.00007701);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 2.6063);

		oParser = new parserFormula("LOGEST(A101:B105,A106:B110,false,false)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.0000838);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 1);

		//todo необходимо перепроверить остальные значения в данном случае
		oParser = new parserFormula("LOGEST(A101:B105,A106:B110,true,true)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1.00007701);
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 2.6063);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(8) - 0, 0.00000205);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue().toFixed(4) - 0, 0.9944);
		assert.strictEqual(oParser.calculate().getElementRowCol(3, 0).getValue().toFixed(4) - 0, 1416.4887);
		assert.strictEqual(oParser.calculate().getElementRowCol(4, 0).getValue().toFixed(4) - 0, 294.9627);

		ws.getRange2("A120").setValue("1");
		ws.getRange2("B120").setValue("2");

		oParser = new parserFormula("LOGEST(A120:B120)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 2);

		oParser = new parserFormula("LOGEST({1;2})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 2);

		oParser = new parserFormula("LOGEST({1,2})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 2);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A104").setValue("-1");
		ws.getRange2("B100").setValue("0.5");
		ws.getRange2("B100").setValue("1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number(2), Array. Basic valid input: two numeric ranges. 2 arguments used.
		oParser = new parserFormula('LOGEST(A100:A101,B100:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(A100:A101,B100:B101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 4, 'Test: Positive case: Number(2), Array. Basic valid input: two numeric ranges. 2 arguments used.');
		// Case #1: Number(2), Array, Boolean, Boolean. All arguments with const and stats. 4 arguments used.
		oParser = new parserFormula('LOGEST(A100:A101,B100:B101,TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(A100:A101,B100:B101,TRUE,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 4, 'Test: Positive case: Number(2), Array, Boolean, Boolean. All arguments with const and stats. 4 arguments used.');
		// Case #2: Formula(2). Nested formulas as arguments. 2 arguments used.
		oParser = new parserFormula('LOGEST(SQRT(A100:A101),LOG(B100:B101))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(SQRT(A100:A101),LOG(B100:B101)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3.16227766, 'Test: Positive case: Formula(2). Nested formulas as arguments. 2 arguments used.');
		// Case #3: String(2). String convertible to number. 2 arguments used.
		oParser = new parserFormula('LOGEST("1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST("1","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String(2). String convertible to number. 2 arguments used.');
		// Case #4: Reference link(2). Reference links to single cells. 2 arguments used.
		oParser = new parserFormula('LOGEST(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(A100,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link(2). Reference links to single cells. 2 arguments used.');
		// Case #5: Area(2). Single-cell ranges. 2 arguments used.
		oParser = new parserFormula('LOGEST(A100:A100,B100:B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(A100:A100,B100:B100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area(2). Single-cell ranges. 2 arguments used.');
		// Case #6: Array(2). Arrays with multiple elements. 2 arguments used.
		oParser = new parserFormula('LOGEST({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Array(2). Arrays with multiple elements. 2 arguments used.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue().toFixed(3), "0.125", 'Test: Positive case: Array(2). Arrays with multiple elements. 2 arguments used.');
		// Case #7: Name(2). Named ranges. 2 arguments used.
		oParser = new parserFormula('LOGEST(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name(2). Named ranges. 2 arguments used.');
		// Case #8: Name3D(2). 3D named ranges. 2 arguments used.
		oParser = new parserFormula('LOGEST(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D(2). 3D named ranges. 2 arguments used.');
		// Case #9: Ref3D(2). 3D references. 2 arguments used.
		oParser = new parserFormula('LOGEST(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(2). 3D references. 2 arguments used.');
		// Case #10: Area3D(2). 3D single-cell ranges. 2 arguments used.
		oParser = new parserFormula('LOGEST(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(2). 3D single-cell ranges. 2 arguments used.');
		// Case #11: Table. Table structured references. 2 arguments used.
		oParser = new parserFormula('LOGEST(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Table. Table structured references. 2 arguments used.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 1, 'Test: Positive case: Table. Table structured references. 2 arguments used.');
		// Case #12: Date, Time. Date and time as arguments. 2 arguments used.
		oParser = new parserFormula('LOGEST(DATE(2025,1,1),TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(DATE(2025,1,1),TIME(0,0,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Date, Time. Date and time as arguments. 2 arguments used.');
		// Case #13: Formula. LOGEST inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(LOGEST(A100:A101,B100:B101),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(LOGEST(A100:A101,B100:B101),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 5.25, 'Test: Positive case: Formula. LOGEST inside SUM formula. 2 arguments used.');
		// Case #14: Array. Multi-element arrays with const. 3 arguments used.
		oParser = new parserFormula('LOGEST({1,2,3},{4,5,6},FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST({1,2,3},{4,5,6},FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(9), "1.139529787", 'Test: Positive case: Array. Multi-element arrays with const. 3 arguments used.');
		// Case #15: Number, Array, Boolean. Mixed number and array. 3 arguments used.
		oParser = new parserFormula('LOGEST(1,{2,3},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(1,{2,3},TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number, Array, Boolean. Mixed number and array. 3 arguments used.');
		// Case #16: Reference link, Area. Mixed reference and range. 2 arguments used.
		oParser = new parserFormula('LOGEST(A100,B100:B100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(A100,B100:B100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Reference link, Area. Mixed reference and range. 2 arguments used.');
		// Case #17: Name, Name3D. Mixed name types. 2 arguments used.
		oParser = new parserFormula('LOGEST(TestName,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(TestName,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Name, Name3D. Mixed name types. 2 arguments used.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), -0.5, 'Test: Positive case: Name, Name3D. Mixed name types. 2 arguments used.');
		// Case #18: Ref3D, Area3D. Mixed 3D types. 2 arguments used.
		oParser = new parserFormula('LOGEST(Sheet2!A1,Sheet2!B1:B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(Sheet2!A1,Sheet2!B1:B1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Ref3D, Area3D. Mixed 3D types. 2 arguments used.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), 0.5, 'Test: Positive case: Ref3D, Area3D. Mixed 3D types. 2 arguments used.');
		// Case #19: Table, Array. Mixed table and array. 2 arguments used.
		oParser = new parserFormula('LOGEST(Table1[Column1],{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(Table1[Column1],{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Table, Array. Mixed table and array. 2 arguments used.');
		// Case #20: Formula, String. Mixed formula and string. 2 arguments used.
		oParser = new parserFormula('LOGEST(SQRT(A100:A101),"1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(SQRT(A100:A101),"1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Positive case: Formula, String. Mixed formula and string. 2 arguments used.');

		// Negative cases:
		// Case #0: String(2). Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('LOGEST("text","text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST("text","text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #1: Boolean(2). Boolean values return #VALUE!. 2 arguments used.
		oParser = new parserFormula('LOGEST(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Boolean values return #VALUE!. 2 arguments used.');
		// Case #2: Empty(2). Empty arguments return #NUM!. 2 arguments used.
		oParser = new parserFormula('LOGEST(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty(2). Empty arguments return #NUM!. 2 arguments used.');
		// Case #3: Error. Error propagation. 2 arguments used.
		oParser = new parserFormula('LOGEST(NA(),NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(NA(),NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error propagation. 2 arguments used.');
		// Case #4: Number, Empty. One empty argument returns #NUM!. 2 arguments used.
		oParser = new parserFormula('LOGEST(1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(1,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Number, Empty. One empty argument returns #NUM!. 2 arguments used.');
		// Case #5: Area(2). Mismatched range sizes return #REF!. 2 arguments used.
		oParser = new parserFormula('LOGEST(A100:A102,B100:B101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(A100:A102,B100:B101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Area(2). Mismatched range sizes return #REF!. 2 arguments used.');
		// Case #6: Array(2). Mismatched array sizes. 2 arguments used.
		oParser = new parserFormula('LOGEST({1},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST({1},{2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Array(2). Mismatched array sizes return #REF!. 2 arguments used.');
		// Case #7: Number. Single argument. 1 argument used.
		oParser = new parserFormula('LOGEST(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Negative case: Number. Single argument returns #N/A. 1 argument used.');
		// Case #8: Time, Boolean. Invalid combination returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('LOGEST(TIME(1,0,0),FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(TIME(1,0,0),FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Time, Boolean. Invalid combination returns #VALUE!. 2 arguments used.');
		// Case #9: Date, String. Invalid combination returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('LOGEST(DATE(2025,1,1),"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(DATE(2025,1,1),"text") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Date, String. Invalid combination returns #VALUE!. 2 arguments used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LOGEST(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LOGEST(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 1 argument used.');
		// Case #12: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LOGEST(Table1[Text])', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: LINEST(Table1[Text]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #13: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('LOGEST({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST({TRUE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');
		// Case #14: Number(2). Zero values return 0. 2 arguments used.
		oParser = new parserFormula('LOGEST(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Zero values return err. 2 arguments used.');

		// Bounded cases:
		// Case #0: Number(2). Maximum valid numbers. 2 arguments used.
		oParser = new parserFormula('LOGEST(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Number(2). Maximum valid numbers. 2 arguments used.');
		// Case #1: Number(2). Minimum valid numbers. 2 arguments used.
		oParser = new parserFormula('LOGEST(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(1E-307,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Number(2). Minimum valid numbers. 2 arguments used.');
		// Case #2: Date, Number. Maximum valid date. 2 arguments used.
		oParser = new parserFormula('LOGEST(DATE(9999,12,31),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(DATE(9999,12,31),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Date, Number. Maximum valid date. 2 arguments used.');
		// Case #3: Time, Number. Maximum valid time. 2 arguments used.
		oParser = new parserFormula('LOGEST(TIME(23,59,59),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGEST(TIME(23,59,59),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Time, Number. Maximum valid time. 2 arguments used.');

		// Need to fix: error check, cellsRange check, Name check, DATE and TIME check, different error return, strings
		// Different result with MS

		ws.getRange2("A200").setValue("1");
		ws.getRange2("A201").setValue("2");
		ws.getRange2("A202").setValue("3");
		ws.getRange2("B200").setValue("1");
		ws.getRange2("B201").setValue("2");
		ws.getRange2("B202").setValue("3");
		ws.getRange2("C200").setValue("1");
		ws.getRange2("C201").setValue("2");
		ws.getRange2("C202").setValue("3");

		// different matrix length tests
		oParser = new parserFormula("LOGEST(A200:A201,A200:C200)", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST(A200:A201,A200:C200)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LOGEST(A200:A201,A200:C200)");

		oParser = new parserFormula("LOGEST(A200:A202,A200:C200)", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST(A200:A202,A200:C200)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LOGEST(A200:A202,A200:C200)");

		oParser = new parserFormula("LOGEST(A200:B201,A200:C201)", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST(A200:B201,A200:C201)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LOGEST(A200:B201,A200:C201)");

		oParser = new parserFormula("LOGEST({1,2,3},{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({1,2,3},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LOGEST({1,2,3},{1,2})");

		oParser = new parserFormula("LOGEST({1,2,3},{1,2,3,4})", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({1,2,3},{1,2,3,4})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LOGEST({1,2,3},{1,2,3,4})");

		oParser = new parserFormula("LOGEST({1,2;1,2},{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({1,2;1,2},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of LOGEST({1,2;1,2},{1,2})");

		oParser = new parserFormula("LOGEST(A200:B200,{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST(A200:B200,{1,2})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, "Result of LOGEST(A200:B200,{1,2})[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 1, "Result of LOGEST(A200:B200,{1,2})[0,1]");

		// identical X-trend tests
		oParser = new parserFormula("LOGEST({1,1},{0,0})", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({1,1},{0,0})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1, "Result of LOGEST({1,1},{0,0}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 1, "Result of LOGEST({1,1},{0,0}) [0,1]");

		oParser = new parserFormula("LOGEST({123,123},{123,123})", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({123,123},{123,123})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1, "Result of LOGEST({123,123},{123,123}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 123, "Result of LOGEST({123,123},{123,123}) [0,1]");

		oParser = new parserFormula("LOGEST({2,8},{1,1})", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({2,8},{1,1})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1, "Result of LOGEST({2,8},{1,1}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 4, "Result of LOGEST({2,8},{1,1}) [0,1]");

		oParser = new parserFormula("LOGEST({2,8},{1,1},FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({2,8},{1,1},FALSE)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 4, "Result of LOGEST({2,8},{1,1},FALSE) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 1, "Result of LOGEST({2,8},{1,1},FALSE) [0,1]");

		oParser = new parserFormula("LOGEST({2,8},{1,1},FALSE,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({2,8},{1,1},FALSE,TRUE)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 4, "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 1, "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(5)-0, 0.69315, "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [1,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue(), "#N/A", "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [1,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue().toFixed(5)-0, 0.8, "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [2,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 1).getValue().toFixed(5)-0, 0.98026, "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [2,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(3, 0).getValue().toFixed(5)-0, 4, "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [3,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(3, 1).getValue(), 1, "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [3,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(4, 0).getValue().toFixed(5)-0, 3.84362, "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [4,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(4, 1).getValue().toFixed(5)-0, 0.96091, "Result of LOGEST({2,8},{1,1},FALSE,TRUE) [4,1]");

		oParser = new parserFormula("LOGEST({2,8},{1,1},TRUE,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({2,8},{1,1},TRUE,TRUE)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 4, "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue(), 0, "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [1,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue(), 0, "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [1,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue(), 1, "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [2,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 1).getValue(), 0, "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [2,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(3, 0).getValue(), "#N/A", "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [3,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(3, 1).getValue(), 0, "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [3,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(4, 0).getValue(), 0, "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [4,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(4, 1).getValue(), 0, "Result of LOGEST({2,8},{1,1},TRUE,TRUE) [4,1]");

		oParser = new parserFormula("LOGEST({2,8;1,1},{1,1;1,1})", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({2,8;1,1},{1,1;1,1})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1, "Result of LOGEST({2,8;1,1},{1,1;1,1}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 2, "Result of LOGEST({2,8;1,1},{1,1;1,1}) [0,1]");

		oParser = new parserFormula("LOGEST({2,8;1,1},{1,1;1,1},FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({2,8;1,1},{1,1;1,1},FALSE)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 2, "Result of LOGEST({2,8;1,1},{1,1;1,1},FALSE) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 1, "Result of LOGEST({2,8;1,1},{1,1;1,1},FALSE) [0,1]");

		oParser = new parserFormula("LOGEST({2,8;2,2;10,10},{1,1;1,1;1,1})", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({2,8;2,2;10,10},{1,1;1,1;1,1})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1, "Result of LOGEST({2,8;2,2;10,10},{1,1;1,1;1,1}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(8) - 0, 4.30886938, "Result of LOGEST({2,8;2,2;10,10},{1,1;1,1;1,1}) [0,1]");

		oParser = new parserFormula("LOGEST({2,8;2,2;10,10},{1,1;1,1;1,1},FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "LOGEST({2,8;2,2;10,10},{1,1;1,1;1,1},FALSE)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 4.30886938, "Result of LOGEST({2,8;2,2;10,10},{1,1;1,1;1,1},FALSE) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(8) - 0, 1, "Result of LOGEST({2,8;2,2;10,10},{1,1;1,1;1,1},FALSE) [0,1]");


	});

	QUnit.test("Test: \"LOGINV\"", function (assert) {

		function loginv(x, mue, sigma) {
			if (sigma <= 0 || x <= 0 || x >= 1) {
				return "#NUM!";
			} else {
				return toFixed(Math.exp(mue + sigma * (AscCommonExcel.gaussinv(x))));
			}
		}

		oParser = new parserFormula("LOGINV(0.039084,3.5,1.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), loginv(0.039084, 3.5, 1.2));

		oParser = new parserFormula("LOGINV(0,3.5,1.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), loginv(0, 3.5, 1.2));

		oParser = new parserFormula("LOGINV(0,3.5,1.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), loginv(10, 3.5, 1.2));

		oParser = new parserFormula("LOGINV(0,3.5,1.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), loginv(-10, 3.5, 1.2));


		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number, Number, Number. Basic valid input: probability=0.5, mean=0, stdev=1. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Number, Number. Basic valid input: probability=0.5, mean=0, stdev=1. 3 of 3 arguments used.');
		// Case #2: Number, Number, Number. Float inputs. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.1, 2, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.1, 2, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "3.893171874", 'Test: Positive case: Number, Number, Number. Float inputs. 3 of 3 arguments used.');
		// Case #3: String, Number, Number. String convertible to number. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV("0.5", 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV("0.5", 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String, Number, Number. String convertible to number. 3 of 3 arguments used.');
		// Case #4: Formula, Number, Number. Nested formula. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(SQRT(0.25), 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(SQRT(0.25), 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula, Number, Number. Nested formula. 3 of 3 arguments used.');
		// Case #5: Reference link, Number, Number. Ref to cell with valid number. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(A100, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(A100, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link, Number, Number. Ref to cell with valid number. 3 of 3 arguments used.');
		// Case #6: Area, Number, Number. Single-cell range. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(A101:A101, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(A101:A101, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area, Number, Number. Single-cell range. 3 of 3 arguments used.');
		// Case #7: Array, Number, Number. Array with single element. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV({0.5}, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV({0.5}, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array, Number, Number. Array with single element. 3 of 3 arguments used.');
		// Case #8: Name, Number, Number. Named range. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(TestName, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(TestName, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Number, Number. Named range. 3 of 3 arguments used.');
		// Case #9: Name3D, Number, Number. 3D named range. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(TestName3D, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(TestName3D, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Number, Number. 3D named range. 3 of 3 arguments used.');
		// Case #10: Ref3D, Number, Number. 3D reference to cell. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(Sheet2!A1, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(Sheet2!A1, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D, Number, Number. 3D reference to cell. 3 of 3 arguments used.');
		// Case #11: Area3D, Number, Number. 3D single-cell range. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(Sheet2!A1:A1, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(Sheet2!A1:A1, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D, Number, Number. 3D single-cell range. 3 of 3 arguments used.');
		// Case #12: Table, Number, Number. Table structured reference. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(Table1[Column1], 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(Table1[Column1], 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table, Number, Number. Table structured reference. 3 of 3 arguments used.');
		// Case #13: Formula, Formula, Formula. All arguments as formulas. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(IF(TRUE,0.5,0), SQRT(4), 2/2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(IF(TRUE,0.5,0), SQRT(4), 2/2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "7.389056099", 'Test: Positive case: Formula, Formula, Formula. All arguments as formulas. 3 of 3 arguments used.');
		// Case #14: Number, Number, Formula. Stdev as formula. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 0, SQRT(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 0, SQRT(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Number, Formula. Stdev as formula. 3 of 3 arguments used.');
		// Case #15: String, String, String. All string args convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV("0.5","0","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV("0.5","0","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String, String, String. All string args convertible to numbers. 3 of 3 arguments used.');
		// Case #16: Date, Number, Number. Date math results in valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(DATE(2025,1,1)-DATE(2025,1,1)+0.5, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(DATE(2025,1,1)-DATE(2025,1,1)+0.5, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date, Number, Number. Date math results in valid probability. 3 of 3 arguments used.');
		// Case #17: Time, Number, Number. Time as probability (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(TIME(12,0,0), 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(TIME(12,0,0), 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time, Number, Number. Time as probability (0.5). 3 of 3 arguments used.');
		// Case #18: Array, Array, Array. Multi-element arrays. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV({0.5,0.6}, {0,1}, {1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV({0.5,0.6}, {0,1}, {1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array, Array, Array. Multi-element arrays. 3 of 3 arguments used.');
		// Case #19: Formula. LOGINV inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(LOGINV(0.5,0,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(LOGINV(0.5,0,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Formula. LOGINV inside SUM formula. 3 of 3 arguments used.');
		// Case #20: Number, Number, Number. Minimal probability without underflow. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(1E-307, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(1E-307, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.283633461195681e-17, 'Test: Positive case: Number, Number, Number. Minimal probability without underflow. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: String, Number, Number. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV("text", 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV("text", 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Number. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #2: Number, Number, Number. Probability <=0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number. Probability <=0 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number, Number, Number. Probability >=1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(1, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(1, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number. Probability >=1 returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number, Number, Number. Stdev <=0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number. Stdev <=0 returns #NUM!. 3 of 3 arguments used.');
		// Case #5: Error, Number, Number. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(NA(), 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(NA(), 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Number. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #6: Boolean, Number, Number. Boolean as probability returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(TRUE, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(TRUE, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number, Number. Boolean as probability returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Number, String, Number. Non-numeric mean returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, "text", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, "text", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number. Non-numeric mean returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Number, Number, String. Non-numeric stdev returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 0, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 0, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String. Non-numeric stdev returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Empty, Number, Number. Empty probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number, Number. Empty probability returns #NUM!. 3 of 3 arguments used.');
		// Case #10: Number, Empty, Number. Empty mean returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, , 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, , 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Empty, Number. Empty mean returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Number, Number, Empty. Empty stdev returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 0, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 0, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Empty. Empty stdev returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Array, Number, Number. Array with invalid probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV({0.5,1.5}, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV({0.5,1.5}, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array, Number, Number. Array with invalid probability. 3 of 3 arguments used.');
		// Case #13: Number, Array, Number. Array with invalid mean. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, {0,"text"}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, {0,"text"}, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Array, Number. Array with invalid mean. 3 of 3 arguments used.');
		// Case #14: Number, Number, Array. Array with invalid stdev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 0, {1,-1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 0, {1,-1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Number, Array. Array with invalid stdev. 3 of 3 arguments used.');
		// Case #15: Area, Number, Number. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(A102:A103, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(A102:A103, 0, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number, Number. Multi-cell range returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Ref3D, Number, Number. 3D ref to text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(Sheet2!A2, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(Sheet2!A2, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Number, Number. 3D ref to text returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Name, Number, Number. Named range with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(TestNameArea2, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(TestNameArea2, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "2.320125395", 'Test: Negative case: Name, Number, Number. Named range with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #18: Table, Number, Number. Table column with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(Table1[Column2], 0, 1)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: LOGINV(Table1[Column2], 0, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=LOGINV(Table1[Column2], 0, 1)', 'Test: Negative case: Table, Number, Number. Table column with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Formula, Number, Number. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(SQRT(-1), 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(SQRT(-1), 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number, Number. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #20: Number, Number, Number. Extremely large mean/stdev may cause errors. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 1E+307, 1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 1E+307, 1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number. Extremely large mean/stdev may cause errors. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number, Number, Number. Minimal valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(1E-307, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(1E-307, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.283633461195681e-17, 'Test: Bounded case: Number, Number, Number. Minimal valid probability. 3 of 3 arguments used.');
		// Case #2: Number, Number, Number. Probability just below 1. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(1-1E-15, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(1-1E-15, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), "2811.418635", 'Test: Bounded case: Number, Number, Number. Probability just below 1. 3 of 3 arguments used.');
		// Case #3: Number, Number, Number. Minimal mean. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, -1E+307, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, -1E+307, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number, Number. Minimal mean. 3 of 3 arguments used.');
		// Case #4: Number, Number, Number. Maximal mean. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 1E+307, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 1E+307, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number, Number. Maximal mean. 3 of 3 arguments used.');
		// Case #5: Number, Number, Number. Minimal stdev >0. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 0, 1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 0, 1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number, Number. Minimal stdev >0. 3 of 3 arguments used.');
		// Case #6: Number, Number, Number. Maximal stdev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGINV(0.5, 0, 1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGINV(0.5, 0, 1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number, Number. Maximal stdev. 3 of 3 arguments used.');

		// Need to fix:
		// Case #15: Area, Number, Number. Multi-cell range returns #VALUE!. 3 of 3 arguments used.

		testArrayFormula2(assert, "LOGINV", 3, 3);
	});

	QUnit.test("Test: \"LOGNORM.DIST\"", function (assert) {
		ws.getRange2("A2").setValue("4");
		ws.getRange2("A3").setValue("3.5");
		ws.getRange2("A4").setValue("1.2");

		oParser = new parserFormula("LOGNORM.DIST(A2,A3,A4,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "LOGNORM.DIST(A2,A3,A4,TRUE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0390836, "LOGNORM.DIST(A2,A3,A4,TRUE)");

		oParser = new parserFormula("LOGNORM.DIST(A2,A3,A4,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "LOGNORM.DIST(A2,A3,A4,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0176176, "LOGNORM.DIST(A2,A3,A4,FALSE)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number(4). Basic valid input: x=1, mean=0, stdev=1, cumulative=TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number(4). Basic valid input: x=1, mean=0, stdev=1, cumulative=TRUE. 4 of 4 arguments used.');
		// Case #1: Number(4). Float inputs, cumulative=FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(2.5,1,0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(2.5,1,0.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.31471224435057743, 'Test: Positive case: Number(4). Float inputs, cumulative=FALSE. 4 of 4 arguments used.');
		// Case #2: String(4). String inputs convertible to numbers. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST("1","0","1","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST("1","0","1","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String(4). String inputs convertible to numbers. 4 of 4 arguments used.');
		// Case #3: Formula(4). All arguments as formulas. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(SQRT(4),AVERAGE(0,0),STDEV.S(1,1),AND(TRUE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(SQRT(4),AVERAGE(0,0),STDEV.S(1,1),AND(TRUE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula(4). All arguments as formulas. 4 of 4 arguments used.');
		// Case #4: Reference link(4). All arguments as reference links. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.00010596165407813115, 'Test: Positive case: Reference link(4). All arguments as reference links. 4 of 4 arguments used.');
		// Case #5: Area(4). Single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(A104:A104,A105:A105,A106:A106,A107:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(A104:A104,A105:A105,A106:A106,A107:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area(4). Single-cell ranges. 4 of 4 arguments used.');
		// Case #6: Array(4). Single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST({1},{0},{1},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST({1},{0},{1},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array(4). Single-element arrays. 4 of 4 arguments used.');
		// Case #7: Name(4). Named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(TestName,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(TestName,TestName1,TestName2,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(4). Named ranges. 4 of 4 arguments used.');
		// Case #8: Name3D(4). 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(4). 3D named ranges. 4 of 4 arguments used.');
		// Case #9: Ref3D(4). 3D references. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(4). 3D references. 4 of 4 arguments used.');
		// Case #10: Area3D(4). Single-cell 3D ranges. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(4). Single-cell 3D ranges. 4 of 4 arguments used.');
		// Case #11: Table. Table structured references. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15865525393145696, 'Test: Positive case: Table. Table structured references. 4 of 4 arguments used.');
		// Case #12: Date,Time,Number,Boolean. Mixed date/time inputs. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(DATE(2025,1,1),TIME(12,0,0),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(DATE(2025,1,1),TIME(12,0,0),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date,Time,Number,Boolean. Mixed date/time inputs. 4 of 4 arguments used.');
		// Case #13: Number(3),Empty. Empty cumulative argument (defaults to FALSE). 3 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,0,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,0,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3989422804014327, 'Test: Positive case: Number(3),Empty. Empty cumulative argument (defaults to FALSE). 3 of 4 arguments used.');
		// Case #14: Number(3),Boolean. Boolean expression for cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1.5,0.5,0.25,1>0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1.5,0.5,0.25,1>0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.35266345803129756, 'Test: Positive case: Number(3),Boolean. Boolean expression for cumulative. 4 of 4 arguments used.');
		// Case #15: Number(3),String. String for logical argument. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(3,1,0.5,"TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(3,1,0.5,"TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.578174101, 'Test: Positive case: Number(3),String. String for logical argument. 4 of 4 arguments used.');
		// Case #16: Number(4). Large numbers. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1E+154,1E+154,1E+154,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1E+154,1E+154,1E+154,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15865525393145696, 'Test: Positive case: Number(4). Large numbers. 4 of 4 arguments used.');
		// Case #17: Number(4). Very small numbers above zero. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1.000000000000001,0.000000000000001,0.000000000000001,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1.000000000000001,0.000000000000001,0.000000000000001,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.158655254, 'Test: Positive case: Number(4). Very small numbers above zero. 4 of 4 arguments used.');
		// Case #18: Array(4). Multi-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST({1,2},{0,0},{1,1},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST({1,2},{0,0},{1,1},{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array(4). Multi-element arrays. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number(4). x ? 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(0,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(0,0,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). x ? 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number(4). standard_dev ? 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,0,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,0,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). standard_dev ? 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number(4). Negative x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(-1,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(-1,0,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Negative x returns #NUM!. 4 of 4 arguments used.');
		// Case #4: String(4). Non-numeric x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST("a",0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST("a",0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric x returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: String(4). Non-numeric mean returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,"b",1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,"b",1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric mean returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: String(4). Non-numeric stdev returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,0,"c",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,0,"c",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric stdev returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: String(4). Non-boolean cumulative returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,0,1,"d")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,0,1,"d") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-boolean cumulative returns #VALUE!. 4 of 4 arguments used.');
		// Case #8: Error(4). Propagates #N/A error. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(NA(),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(NA(),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(4). Propagates #N/A error. 4 of 4 arguments used.');
		// Case #9: Area(4). Multi-cell ranges return #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(A108:A109,A110:A111,A112:A113,A114:A115)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(A108:A109,A110:A111,A112:A113,A114:A115) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area(4). Multi-cell ranges return #NUM!. 4 of 4 arguments used.');
		// Case #10: Empty(4). All empty arguments return #NUM!. 0 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(,,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty(4). All empty arguments return #NUM!. 0 of 4 arguments used.');
		// Case #11: Boolean(4). Boolean inputs return #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(TRUE,FALSE,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(TRUE,FALSE,TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3989422804014327, 'Test: Negative case: Boolean(4). Boolean inputs return #VALUE!. 4 of 4 arguments used.');
		// Case #12: Ref3D(4). 3D refs to text return #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D(4). 3D refs to text return #VALUE!. 4 of 4 arguments used.');
		// Case #13: Name(4). Named ranges with text return #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(TestNameArea2,TestNameArea2,TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(TestNameArea2,TestNameArea2,TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10046095233795999, 'Test: Negative case: Name(4). Named ranges with text return #VALUE!. 4 of 4 arguments used.');
		// Case #14: Table. Table columns with text return #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table columns with text return #VALUE!. 4 of 4 arguments used.');
		// Case #15: Number(4). Negative stdev close to zero returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,0,-0.000000000000001,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,0,-0.000000000000001,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Negative stdev close to zero returns #NUM!. 4 of 4 arguments used.');
		// Case #16: Number(4). x slightly below 1 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1-1E-15,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1-1E-15,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Negative case: Number(4). x slightly below 1 returns #NUM!. 4 of 4 arguments used.');
		// Case #17: Number(4). Extremely large x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1E+307,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1E+307,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number(4). Extremely large x returns #NUM!. 4 of 4 arguments used.');
		// Case #18: Number(4). Extremely large mean returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,1E+307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,1E+307,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(4). Extremely large mean returns #NUM!. 4 of 4 arguments used.');
		// Case #19: Number(4). Extremely large stdev returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,0,1E+307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,0,1E+307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Number(4). Extremely large stdev returns #NUM!. 4 of 4 arguments used.');
		// Case #20: Area3D(4). Multi-cell 3D ranges return #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(Sheet2!A1:B1,Sheet2!A2:B2,Sheet2!A3:B3,Sheet2!A4:B4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(Sheet2!A1:B1,Sheet2!A2:B2,Sheet2!A3:B3,Sheet2!A4:B4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(4). Multi-cell 3D ranges return #NUM!. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number(4). Min valid standard_dev. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,0,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,0,1E-307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number(4). Min valid standard_dev. 4 of 4 arguments used.');
		// Case #2: Number(4). Min valid x. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1E-307,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1E-307,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(4). Min valid x. 4 of 4 arguments used.');
		// Case #3: Number(4). Max valid x. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(9.99999999999999E+307,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(9.99999999999999E+307,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(4). Max valid x. 4 of 4 arguments used.');
		// Case #4: Number(4). Max valid mean. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,9.99999999999999E+307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,9.99999999999999E+307,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(4). Max valid mean. 4 of 4 arguments used.');
		// Case #5: Number(4). Max valid standard_dev. 4 of 4 arguments used.
		oParser = new parserFormula('LOGNORM.DIST(1,0,9.99999999999999E+307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.DIST(1,0,9.99999999999999E+307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number(4). Max valid standard_dev. 4 of 4 arguments used.');

		// Need to fix: results diff from MS, diff error types
		// Case #2: String(4). String inputs convertible to numbers. 4 of 4 arguments used.
		// Case #7: Name(4). Named ranges. 4 of 4 arguments used.
		// Case #15: Number(3),String. String for logical argument. 4 of 4 arguments used.
		// Case #17: Number(4). Very small numbers above zero. 4 of 4 arguments used.
		// Case #1: Number(4). x ? 0 returns #NUM!. 4 of 4 arguments used.
		// Case #3: Number(4). Negative x returns #NUM!. 4 of 4 arguments used.
		// Case #9: Area(4). Multi-cell ranges return #NUM!. 4 of 4 arguments used.

		testArrayFormula2(assert, "LOGNORM.DIST", 4, 4);
	});

	QUnit.test("Test: \"LOGNORM.INV\"", function (assert) {
		ws.getRange2("A2").setValue("0.039084");
		ws.getRange2("A3").setValue("3.5");
		ws.getRange2("A4").setValue("1.2");

		oParser = new parserFormula("LOGNORM.INV(A2, A3, A4)", "A1", ws);
		assert.ok(oParser.parse(), "LOGNORM.INV(A2, A3, A4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 4.0000252, "LOGNORM.INV(A2, A3, A4)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("0.123"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: all arguments are numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Basic valid input: all arguments are numbers. 3 of 3 arguments used.');
		// Case #2: Number,String,Number. String convertible to number for mean. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.3, "0", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.3, "0", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5919101006095542, 'Test: Positive case: Number,String,Number. String convertible to number for mean. 3 of 3 arguments used.');
		// Case #3: Formula,Number,Number. Nested IF formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(IF(TRUE, 0.7, 0.2), 1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(IF(TRUE, 0.7, 0.2), 1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.758593171413644, 'Test: Positive case: Formula,Number,Number. Nested IF formula for probability. 3 of 3 arguments used.');
		// Case #4: Reference link,Number,Number. Reference link to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(A100, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(A100, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link,Number,Number. Reference link to valid probability. 3 of 3 arguments used.');
		// Case #5: Number,Reference link,Number. Reference link to valid mean. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, A101, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, A101, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.4816890703380645, 'Test: Positive case: Number,Reference link,Number. Reference link to valid mean. 3 of 3 arguments used.');
		// Case #6: Number,Number,Reference link. Reference link to valid standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number,Number,Reference link. Reference link to valid standard_dev. 3 of 3 arguments used.');
		// Case #7: Area,Number,Number. Single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(A100:A100, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(A100:A100, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area,Number,Number. Single-cell range for probability. 3 of 3 arguments used.');
		// Case #8: Number,Area,Number. Single-cell range for mean. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, A101:A101, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, A101:A101, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.4816890703380645, 'Test: Positive case: Number,Area,Number. Single-cell range for mean. 3 of 3 arguments used.');
		// Case #9: Number,Number,Area. Single-cell range for standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number,Number,Area. Single-cell range for standard_dev. 3 of 3 arguments used.');
		// Case #10: Array,Number,Number. Array with single valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV({0.5}, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV({0.5}, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array,Number,Number. Array with single valid probability. 3 of 3 arguments used.');
		// Case #11: Number,Array,Number. Array with single valid mean. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, {0}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, {0}, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number,Array,Number. Array with single valid mean. 3 of 3 arguments used.');
		// Case #12: Number,Number,Array. Array with single valid standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number,Number,Array. Array with single valid standard_dev. 3 of 3 arguments used.');
		// Case #13: Name,Number,Number. Named range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(TestName, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(TestName, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name,Number,Number. Named range for probability. 3 of 3 arguments used.');
		// Case #14: Number,Name,Number. Named range for mean. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, TestName1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, TestName1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6487212707001282, 'Test: Positive case: Number,Name,Number. Named range for mean. 3 of 3 arguments used.');
		// Case #15: Number,Number,Name. Named range for standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number,Number,Name. Named range for standard_dev. 3 of 3 arguments used.');
		// Case #16: Ref3D,Number,Number. 3D reference to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(Sheet2!A1, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(Sheet2!A1, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D,Number,Number. 3D reference to valid probability. 3 of 3 arguments used.');
		// Case #17: Number,Ref3D,Number. 3D reference to valid mean. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, Sheet2!A2, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, Sheet2!A2, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.38905609893065, 'Test: Positive case: Number,Ref3D,Number. 3D reference to valid mean. 3 of 3 arguments used.');
		// Case #18: Number,Number,Ref3D. 3D reference to valid standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number,Number,Ref3D. 3D reference to valid standard_dev. 3 of 3 arguments used.');
		// Case #19: Area3D,Number,Number. 3D single-cell range for probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(Sheet2!A1:A1, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(Sheet2!A1:A1, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D,Number,Number. 3D single-cell range for probability. 3 of 3 arguments used.');
		// Case #20: Table,Number,Number. Table structured reference for probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(Table1[Column1], 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(Table1[Column1], 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.31344860147217135, 'Test: Positive case: Table,Number,Number. Table structured reference for probability. 3 of 3 arguments used.');
		// Case #21: Formula,Number,Number. LOGNORM.INV inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(SUM(0.4, 0.1), 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(SUM(0.4, 0.1), 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula,Number,Number. LOGNORM.INV inside SUM formula. 3 of 3 arguments used.');
		// Case #22: Date,Number,Number. Date as serial number scaled to valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(DATE(2025,1,1)/100000, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(DATE(2025,1,1)/100000, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8966823798690586, 'Test: Positive case: Date,Number,Number. Date as serial number scaled to valid probability. 3 of 3 arguments used.');
		// Case #23: Time,Number,Number. Time as valid probability (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(TIME(12,0,0), 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(TIME(12,0,0), 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time,Number,Number. Time as valid probability (0.5). 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability > 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Probability > 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Negative probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(-0.5, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(-0.5, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number,Number,Number. Negative standard_dev returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Number,Number. Negative standard_dev returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number,Number,Number. Zero standard_dev returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Number,Number. Zero standard_dev returns #NUM!. 3 of 3 arguments used.');
		// Case #5: String,Number,Number. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV("abc", 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV("abc", 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Number,Number. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Empty,Number,Number. Empty reference link returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(A103, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(A103, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty,Number,Number. Empty reference link returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Number,Empty,Number. Empty reference link returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, A103, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, A103, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number,Empty,Number. Empty reference link returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Number,Number,Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Number,Empty. Empty reference link returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Error,Number,Number. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(NA(), 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(NA(), 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number,Number. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #10: Area,Number,Number. Multi-cell range returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(A100:A101, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(A100:A101, 0, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area,Number,Number. Multi-cell range returns #NUM!. 3 of 3 arguments used.');
		// Case #11: Number,Area,Number. Multi-cell range returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, A101:A102, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, A101:A102, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4.48168907, 'Test: Negative case: Number,Area,Number. Multi-cell range returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Number,Number,Area. Multi-cell range returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number,Number,Area. Multi-cell range returns #NUM!. 3 of 3 arguments used.');
		// Case #13: Name,Number,Number. Named range with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(TestNameArea2, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(TestNameArea2, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.320125394504318, 'Test: Negative case: Name,Number,Number. Named range with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Ref3D,Number,Number. 3D reference to text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(Sheet2!A4, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(Sheet2!A4, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D,Number,Number. 3D reference to text returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Formula,Number,Number. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(SQRT(-1), 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(SQRT(-1), 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Number,Number. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #16: Boolean,Number,Number. Boolean FALSE (0) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(FALSE, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(FALSE, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean,Number,Number. Boolean FALSE (0) returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Array,Number,Number. Array with boolean returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV({FALSE}, 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV({FALSE}, 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array,Number,Number. Array with boolean returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Number,Number,Name3D. Named 3D range with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, 0, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, 0, TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Number,Name3D. Named 3D range with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Table,Number,Number. Table column with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(Table1[Column2], 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(Table1[Column2], 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table,Number,Number. Table column with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Date,Number,Number. Date serial number (>1) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(DATE(2025,1,1), 0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(DATE(2025,1,1), 0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date,Number,Number. Date serial number (>1) returns #NUM!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability and standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(1E-307, 0, 1E-152)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(1E-307, 0, 1E-152) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid probability and standard_dev. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability, mean, and standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.999999999999999, 1E+307, 1E+152)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.999999999999999, 1E+307, 1E+152) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid probability, mean, and standard_dev. 3 of 3 arguments used.');
		// Case #3: Number. Minimum valid mean (large negative). 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORM.INV(0.5, -1E-307, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORM.INV(0.5, -1E-307, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid mean (large negative). 3 of 3 arguments used.');

		// Need to fix: ms results diff
		// Case #10: Area,Number,Number. Multi-cell range returns #NUM!. 3 of 3 arguments used.
		// Case #11: Number,Area,Number. Multi-cell range returns #NUM!. 3 of 3 arguments used.
		// Case #12: Number,Number,Area. Multi-cell range returns #NUM!. 3 of 3 arguments used.


		testArrayFormula2(assert, "LOGNORM.INV", 3, 3);
	});

	QUnit.test("Test: \"LOGNORMDIST\"", function (assert) {
		ws.getRange2("A2").setValue("4");
		ws.getRange2("A3").setValue("3.5");
		ws.getRange2("A4").setValue("1.2");

		oParser = new parserFormula("LOGNORMDIST(A2, A3, A4)", "A1", ws);
		assert.ok(oParser.parse(), "LOGNORMDIST(A2, A3, A4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0390836, "LOGNORMDIST(A2, A3, A4)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: positive numbers for x, any real number for mean, positive standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(2,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(2,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.755891404214631, 'Test: Positive case: Number. Basic valid input: positive numbers for x, any real number for mean, positive standard_dev. 3 of 3 arguments used.');
		// Case #2: Number. Float inputs. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(1.5,1,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(1.5,1,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.11720610376847473, 'Test: Positive case: Number. Float inputs. 3 of 3 arguments used.');
		// Case #3: String. Numeric strings converted to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST("2","0","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST("2","0","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.755891404214631, 'Test: Positive case: String. Numeric strings converted to numbers. 3 of 3 arguments used.');
		// Case #4: Formula. Nested formulas resolving to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(SQRT(4),ABS(-1),SQRT(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(SQRT(4),ABS(-1),SQRT(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3794777011200849, 'Test: Positive case: Formula. Nested formulas resolving to valid numbers. 3 of 3 arguments used.');
		// Case #5: Reference link. Reference to cells with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.000005764903251825881, 'Test: Positive case: Reference link. Reference to cells with valid numbers. 3 of 3 arguments used.');
		// Case #6: Area. Single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.000005764903251825881, 'Test: Positive case: Area. Single-cell ranges. 3 of 3 arguments used.');
		// Case #7: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST({2},{0},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST({2},{0},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.755891404214631, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');
		// Case #8: Name. Named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #10: Ref3D. 3D references to cells with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells with valid numbers. 3 of 3 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges. 3 of 3 arguments used.');
		// Case #12: Table. Table structured references with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15865525393145696, 'Test: Positive case: Table. Table structured references with valid numbers. 3 of 3 arguments used.');
		// Case #13: Date. Date as serial number (>0). 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(DATE(2025,1,1),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(DATE(2025,1,1),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number (>0). 3 of 3 arguments used.');
		// Case #14: Time. Time adjusted to valid number (>0). 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(TIME(12,0,0)+1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(TIME(12,0,0)+1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6574321694851541, 'Test: Positive case: Time. Time adjusted to valid number (>0). 3 of 3 arguments used.');
		// Case #15: Formula. LOGNORMDIST inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(LOGNORMDIST(2,0,1),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(LOGNORMDIST(2,0,1),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.855891404214631, 'Test: Positive case: Formula. LOGNORMDIST inside SUM formula. 3 of 3 arguments used.');
		// Case #16: Number. x slightly above 1. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(1.00000000000001,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(1.00000000000001,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Number. x slightly above 1. 3 of 3 arguments used.');
		// Case #17: String. Fractional string converted to number. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST("1.5/1.5","0","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST("1.5/1.5","0","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String. Fractional string converted to number. 3 of 3 arguments used.');
		// Case #18: Formula. Nested IF returning valid number. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(IF(TRUE,2,1),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(IF(TRUE,2,1),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.755891404214631, 'Test: Positive case: Formula. Nested IF returning valid number. 3 of 3 arguments used.');
		// Case #19: Array. Arrays with multiple valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST({2,3},{0,1},{1,0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST({2,3},{0,1},{1,0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.755891404214631, 'Test: Positive case: Array. Arrays with multiple valid elements. 3 of 3 arguments used.');
		// Case #20: Reference link. Reference to cells with different valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(A103,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. Reference to cells with different valid numbers. 3 of 3 arguments used.');
		// Case #21: Number. Negative mean with valid x and standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(10,-1,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(10,-1,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Negative mean with valid x and standard_dev. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. x = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(0,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(0,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. x = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Negative x returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(-1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(-1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative x returns #NUM!. 3 of 3 arguments used.');
		// Case #3: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST("abc",0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST("abc",0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: Empty. Empty cell reference returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(A106,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(A106,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty cell reference returns #VALUE!. 3 of 3 arguments used.');
		// Case #5: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(NA(),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(NA(),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #6: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(A100:A101,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(A100:A101,A101:A101,A102:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.0000057649, 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Number. standard_dev = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(2,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(2,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. standard_dev = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #8: Number. Negative standard_dev returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(2,0,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(2,0,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative standard_dev returns #NUM!. 3 of 3 arguments used.');
		// Case #9: String. String converting to 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST("0",0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST("0",0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String converting to 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #10: Boolean. Boolean FALSE (0) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(FALSE,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(FALSE,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference to text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(Sheet2!A4,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(Sheet2!A4,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Name. Named range with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(TestNameArea2,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(TestNameArea2,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.41171189185745494, 'Test: Negative case: Name. Named range with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Name3D. 3D named range with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(TestNameArea3D2,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(TestNameArea3D2,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.41171189185745494, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Table. Table column with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(Table1[Column2],0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(Table1[Column2],0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(SQRT(-1),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(SQRT(-1),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #16: Array. Array with invalid x (0) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST({0},0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST({0},0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with invalid x (0) returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Number. Extremely large negative mean may cause overflow, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(1,-1E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(1,-1E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Extremely large negative mean may cause overflow, returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(Sheet2!A1:A2,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(Sheet2!A1:A2,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Time. Time value (<1) returns valid result but may be unexpected. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(TIME(12,0,0),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(TIME(12,0,0),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24410859578536898, 'Test: Negative case: Time. Time value (<1) returns valid result but may be unexpected. 3 of 3 arguments used.');
		// Case #20: Formula. NA() in mean propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(2,NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(2,NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. NA() in mean propagates #N/A error. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid values for x and standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(1E-307,0,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(1E-307,0,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid values for x and standard_dev. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid values for x, mean, and standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('LOGNORMDIST(9.99999999999999E+307,1E+307,9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: LOGNORMDIST(9.99999999999999E+307,1E+307,9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46017216272297096, 'Test: Bounded case: Number. Maximum valid values for x, mean, and standard_dev. 3 of 3 arguments used.');

		// Need to fix: ms res diff
		// Case #6: Area. Multi-cell range returns #VALUE!. 3 of 3 arguments used.
		// Case #1: Number. Minimum valid values for x and standard_dev. 3 of 3 arguments used.


		testArrayFormula2(assert, "LOGNORMDIST", 3, 3);
	});

	QUnit.test("Test: \"MAX\"", function (assert) {

		oParser = new parserFormula("MAX(-1, TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);
	
		oParser = new parserFormula("MAX(0, FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(0, FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of MAX(0, FALSE)");
	
		oParser = new parserFormula("MAX(25, 25.1, 25.01, 25.02, 25.2, 25.222, 25.333, 25.3334)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(25, 25.1, 25.01, 25.02, 25.2, 25.222, 25.333, 25.3334)");
		assert.strictEqual(oParser.calculate().getValue(), 25.3334, "Result of MAX(25, 25.1, 25.01, 25.02, 25.2, 25.222, 25.333, 25.3334)");
	
		oParser = new parserFormula("MAX(TRUE, FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(TRUE, FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of MAX(TRUE, FALSE)");
	
		oParser = new parserFormula("MAX(FALSE, FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(FALSE, FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of MAX(FALSE, FALSE)");
	
		oParser = new parserFormula("MAX(str)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(str)");
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", "Result of MAX(str)");
	
		oParser = new parserFormula("MAX(49.08 - 432.81, 0)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(49.08 - 432.81, 0)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of MAX(49.08 - 432.81, 0)");

		oParser = new parserFormula("MAX(FALSE,-1-2,3-8,FALSE,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(FALSE,-1-2,3-8,FALSE,TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result of MAX(FALSE,-1-2,3-8,FALSE,TRUE)");
	
		oParser = new parserFormula("MAX(49.08 - 432.81, 9,99999999999999E+43)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(49.08 - 432.81, 9,99999999999999E+43)");
		assert.strictEqual(oParser.calculate().getValue(), 9.9999999999999e+56, "Result of MAX(49.08 - 432.81, 9,99999999999999E+43)");
	
		oParser = new parserFormula("MAX(49.08 - 432.81, {9,99999999999999E+43})", "A1", ws);
		assert.ok(oParser.parse(), "MAX(49.08 - 432.81, {9,99999999999999E+43})");
		assert.strictEqual(oParser.calculate().getValue(), 9.9999999999999e+56, "Result of MAX(49.08 - 432.81, {9,99999999999999E+43})");
	
		oParser = new parserFormula("MAX(49.08 - 432.81, {12,13;14,15})", "A1", ws);
		assert.ok(oParser.parse(), "MAX(49.08 - 432.81, {12,13;14,15})");
		assert.strictEqual(oParser.calculate().getValue(), 15, "Result of MAX(49.08 - 432.81, {12,13;14,15})");

		oParser = new parserFormula("MAX({1,1,TRUE,2})", "A1", ws);
		assert.ok(oParser.parse(), "MAX({1,1,TRUE,2})");
		assert.strictEqual(oParser.calculate().getValue(), 2, "Result of MAX({1,1,TRUE,2})");

		oParser = new parserFormula("MAX({1,1,TRUE,2},{1,2,3,4,5,6,7,8,9,11,1})", "A1", ws);
		assert.ok(oParser.parse(), "MAX({1,1,TRUE,2},{1,2,3,4,5,6,7,8,9,11,1})");
		assert.strictEqual(oParser.calculate().getValue(), 11, "Result of MAX({1,1,TRUE,2},{1,2,3,4,5,6,7,8,9,11,1})");

		oParser = new parserFormula("MAX({1,1,TRUE,2},{12;12;13;11},{1,2,3,4,5,6,7,8,9,11,1})", "A1", ws);
		assert.ok(oParser.parse(), "MAX({1,1,TRUE,2},{12;12;13;11},{1,2,3,4,5,6,7,8,9,11,1})");
		assert.strictEqual(oParser.calculate().getValue(), 13, "Result of MAX({1,1,TRUE,2},{12;12;13;11},{1,2,3,4,5,6,7,8,9,11,1})");

		ws.getRange2("S5").setValue("1");
		ws.getRange2("S6").setValue(numDivFact(-1, 2));
		ws.getRange2("S7").setValue(numDivFact(1, 4));
		ws.getRange2("S8").setValue(numDivFact(-1, 6));

		oParser = new parserFormula("MAX(S5:S8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		ws.getRange2("S5").setValue("#DIV/0!");
		ws.getRange2("S6").setValue("TRUE");
		ws.getRange2("S7").setValue("qwe");
		ws.getRange2("S8").setValue("");
		ws.getRange2("S9").setValue("-1");

		ws.getRange2("J10").setValue();
		ws.getRange2("J11").setValue("");
		ws.getRange2("J12").setValue("10");
		ws.getRange2("J13").setValue("7");
		ws.getRange2("J14").setValue("2");
		ws.getRange2("J15").setValue("27");
		ws.getRange2("J16").setValue("TRUE");
		ws.getRange2("J17").setValue("FALSE");
		ws.getRange2("J18").setValue("#N/A");
		ws.getRange2("J19").setValue("{2;3;4;5}");
		ws.getRange2("J20").setValue("{999;2;3;4;5}");
		ws.getRange2("J21").setValue("9.99999999999999E+43");
		ws.getRange2("J22").setValue("-9.99999999999999E+43");
		ws.getRange2("J23").setValue("0.000009");
		ws.getRange2("J24").setValue("-0.000009");
		ws.getRange2("J25").setValue("255");
		// string
		ws.getRange2("J25").setNumFormat("@");

		oParser = new parserFormula("MAX(J10)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(J10)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of MAX(J10)");

		oParser = new parserFormula("MAX(J11)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(J11)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of MAX(J11)");

		oParser = new parserFormula("MAX(J12)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(J12)");
		assert.strictEqual(oParser.calculate().getValue(), 10, "Result of MAX(J12)");

		oParser = new parserFormula("MAX(J10:J17,J19:J24)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(J10:J17,J19:J24)");
		assert.strictEqual(oParser.calculate().getValue(), 9.99999999999999E+43, "Result of MAX(J10:J17,J19:J24)");

		oParser = new parserFormula("MAX(J12:J19)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(J12:J19)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of MAX(J12:J19)");	

		oParser = new parserFormula("MAX(J10:J25)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(J10:J25)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of MAX(J10:J25)");
		
		oParser = new parserFormula("MAX(J25, J10:J17)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(J25, J10:J17)");
		assert.strictEqual(oParser.calculate().getValue(), 255, "Result of MAX(J25, J10:J17)");

		oParser = new parserFormula("MAX(J25, J10:J17, J18)", "A1", ws);
		assert.ok(oParser.parse(), "MAX(J25, J10:J17, J18)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of MAX(J25, J10:J17, J18)");	

		oParser = new parserFormula("MAX(S5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		oParser = new parserFormula("MAX(S6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("MAX(S7)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("MAX(S8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("MAX(S5:S9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		oParser = new parserFormula("MAX(S6:S9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1);

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");
		ws.getRange2("A112").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("321"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("#N/A");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number(2). Basic valid input: two numbers. 2 arguments used.
		oParser = new parserFormula('MAX(10, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(10, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(2). Basic valid input: two numbers. 2 arguments used.');
		// Case #1: Number, String. String convertible to number. 2 arguments used.
		oParser = new parserFormula('MAX(5, "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(5, "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, String. String convertible to number. 2 arguments used.');
		// Case #2: Formula(2). Nested formula. 2 arguments used.
		oParser = new parserFormula('MAX(SQRT(4), 1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(SQRT(4), 1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(2). Nested formula. 2 arguments used.');
		// Case #3: Reference link(2). Ref to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('MAX(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link(2). Ref to cells with valid numbers. 2 arguments used.');
		// Case #4: Area. Two-cell range. 1 argument used.
		oParser = new parserFormula('MAX(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Two-cell range. 1 argument used.');
		// Case #5: Array. Array with multiple elements. 1 argument used.
		oParser = new parserFormula('MAX({5, 3, 8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX({5, 3, 8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Array. Array with multiple elements. 1 argument used.');
		// Case #6: Name. Named ranges. 2 arguments used.
		oParser = new parserFormula('MAX(TestName1, TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(TestName1, TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.5, 'Test: Positive case: Name. Named ranges. 2 arguments used.');
		// Case #7: Ref3D. 3D references. 2 arguments used.
		oParser = new parserFormula('MAX(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D references. 2 arguments used.');
		// Case #8: Area3D. 3D range. 1 argument used.
		oParser = new parserFormula('MAX(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area3D. 3D range. 1 argument used.');
		// Case #9: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('MAX(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 321, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #10: Date, Time. Date and time as serial numbers. 2 arguments used.
		oParser = new parserFormula('MAX(DATE(2025,1,1), TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(DATE(2025,1,1), TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date, Time. Date and time as serial numbers. 2 arguments used.');
		// Case #11: Boolean. Booleans (TRUE=1, FALSE=0). 2 arguments used.
		oParser = new parserFormula('MAX(TRUE, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(TRUE, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean. Booleans (TRUE=1, FALSE=0). 2 arguments used.');
		// Case #12: Empty, Number. Empty cell ignored. 2 arguments used.
		oParser = new parserFormula('MAX(, 100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(, 100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Empty, Number. Empty cell ignored. 2 arguments used.');
		// Case #13: Formula. Nested IF. 2 arguments used.
		oParser = new parserFormula('MAX(IF(TRUE, 10, 5), 8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(IF(TRUE, 10, 5), 8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Nested IF. 2 arguments used.');
		// Case #14: String, Number. Date string vs number. 2 arguments used.
		oParser = new parserFormula('MAX("12/12/2025", 100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX("12/12/2025", 100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 46003, 'Test: Positive case: String, Number. Date string vs number. 2 arguments used.');
		// Case #15: Array. Mixed types in array. 1 argument used.
		oParser = new parserFormula('MAX({1, "2", TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX({1, "2", TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Mixed types in array. 1 argument used.');
		// Case #16: Name3D. 3D named ranges. 2 arguments used.
		oParser = new parserFormula('MAX(TestName3D, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(TestName3D, TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named ranges. 2 arguments used.');
		// Case #17: Reference link, Formula. Ref + nested formula. 2 arguments used.
		oParser = new parserFormula('MAX(A104, SQRT(16))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(A104, SQRT(16)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Reference link, Formula. Ref + nested formula. 2 arguments used.');
		// Case #18: Area, Empty. Range with empty cells. 1 argument used.
		oParser = new parserFormula('MAX(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, Empty. Range with empty cells. 1 argument used.');
		// Case #19: Array. Extreme numbers in array. 1 argument used.
		oParser = new parserFormula('MAX({-1E+307, 1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX({-1E+307, 1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Positive case: Array. Extreme numbers in array. 1 argument used.');
		// Case #20: Formula. MAX inside SUM. Parent formula not MAX, but included as per request.
		oParser = new parserFormula('SUM(MAX(1,2), MAX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MAX(1,2), MAX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. MAX inside SUM. Parent formula not MAX, but included as per request.');

		// Negative cases:
		// Case #1: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('MAX(NA(), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(NA(), 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #2: String. Non-numeric strings return 0. 2 arguments used.
		oParser = new parserFormula('MAX("abc", "def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX("abc", "def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return 0. 2 arguments used.');
		// Case #3: Error, Error. Multiple errors. 2 arguments used.
		oParser = new parserFormula('MAX(#VALUE!, #N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(#VALUE!, #N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Error. Multiple errors. 2 arguments used.');
		// Case #4: Empty. No arguments returns 0. 0 arguments used.
		oParser = new parserFormula('MAX(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. No arguments returns 0. 0 arguments used.');
		// Case #5: Area. Multi-cell range with text. 1 argument used.
		oParser = new parserFormula('MAX(A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range with text. 1 argument used.');
		// Case #6: Boolean, String. Boolean + non-numeric string. 2 arguments used.
		oParser = new parserFormula('MAX(FALSE, "xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(FALSE, "xyz") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, String. Boolean + non-numeric string. 2 arguments used.');
		// Case #7: Name. Named range with text. 1 argument used.
		oParser = new parserFormula('MAX(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Name. Named range with text. 1 argument used.');
		// Case #9: Ref3D. 3D ref to text. 1 argument used.
		oParser = new parserFormula('MAX(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(Sheet2!A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text. 1 argument used.');
		// Case #10: Area3D. 3D range with errors. 1 argument used.
		oParser = new parserFormula('MAX(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area3D. 3D range with errors. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Largest/smallest valid numbers. 2 arguments used.
		oParser = new parserFormula('MAX(1E+307, -1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(1E+307, -1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Number. Largest/smallest valid numbers. 2 arguments used.');
		// Case #2: Number. Smallest positive number. 2 arguments used.
		oParser = new parserFormula('MAX(1E-307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(1E-307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Smallest positive number. 2 arguments used.');
		// Case #3: Date. Max valid date. 2 arguments used.
		oParser = new parserFormula('MAX(DATE(9999,12,31), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(DATE(9999,12,31), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2958465, 'Test: Bounded case: Date. Max valid date. 2 arguments used.');
		// Case #4: Number. Max Excel number. 2 arguments used.
		oParser = new parserFormula('MAX(9.99999999999999E+307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(9.99999999999999E+307, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number. Max Excel number. 2 arguments used.');
		// Case #5: Time. Min time value. 2 arguments used.
		oParser = new parserFormula('MAX(TIME(0,0,0), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAX(TIME(0,0,0), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Time. Min time value. 2 arguments used.');


		// Need to fix: errors when only text in args
		// Case #2: String. Non-numeric strings return 0
		// Case #6: Boolean, String. Boolean + non-numeric string
		// Case #9: Ref3D. 3D ref to text.


		testArrayFormula2(assert, "MAX", 1, 8, null, true);
	});

	QUnit.test("Test: \"MAXA\"", function (assert) {

		ws.getRange2("S5").setValue("1");
		ws.getRange2("S6").setValue(numDivFact(-1, 2));
		ws.getRange2("S7").setValue(numDivFact(1, 4));
		ws.getRange2("S8").setValue(numDivFact(-1, 6));

		oParser = new parserFormula("MAXA(S5:S8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		ws.getRange2("S5").setValue("#DIV/0!");
		ws.getRange2("S6").setValue("TRUE");
		ws.getRange2("S7").setValue("qwe");
		ws.getRange2("S8").setValue("");
		ws.getRange2("S9").setValue("-1");
		oParser = new parserFormula("MAXA(S5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");
		oParser = new parserFormula("MAXA(S6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);
		oParser = new parserFormula("MAXA(S7)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);
		oParser = new parserFormula("MAXA(S8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);
		oParser = new parserFormula("MAXA(S5:S9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");
		oParser = new parserFormula("MAXA(S6:S9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);
		oParser = new parserFormula("MAXA(-1, TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");
		ws.getRange2("A112").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("321"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:F10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("#N/A");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number(2). Basic valid input: two numbers. 2 arguments used.
		oParser = new parserFormula('MAXA(10, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(10, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(2). Basic valid input: two numbers. 2 arguments used.');
		// Case #1: Number, String. String convertible to number. 2 arguments used.
		oParser = new parserFormula('MAXA(5, "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(5, "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, String. String convertible to number. 2 arguments used.');
		// Case #2: Formula(2). Nested formula. 2 arguments used.
		oParser = new parserFormula('MAXA(SQRT(4), 1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(SQRT(4), 1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(2). Nested formula. 2 arguments used.');
		// Case #3: Reference link(2). Ref to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('MAXA(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link(2). Ref to cells with valid numbers. 2 arguments used.');
		// Case #4: Area. Two-cell range. 1 argument used.
		oParser = new parserFormula('MAXA(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Two-cell range. 1 argument used.');
		// Case #5: Array. Array with multiple elements. 1 argument used.
		oParser = new parserFormula('MAXA({5, 3, 8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA({5, 3, 8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Array. Array with multiple elements. 1 argument used.');
		// Case #6: Name. Named ranges. 2 arguments used.
		oParser = new parserFormula('MAXA(TestName1, TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(TestName1, TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.5, 'Test: Positive case: Name. Named ranges. 2 arguments used.');
		// Case #7: Ref3D. 3D references. 2 arguments used.
		oParser = new parserFormula('MAXA(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D references. 2 arguments used.');
		// Case #8: Area3D. 3D range. 1 argument used.
		oParser = new parserFormula('MAXA(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area3D. 3D range. 1 argument used.');
		// Case #9: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('MAXA(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 321, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #10: Date, Time. Date and time as serial numbers. 2 arguments used.
		oParser = new parserFormula('MAXA(DATE(2025,1,1), TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(DATE(2025,1,1), TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date, Time. Date and time as serial numbers. 2 arguments used.');
		// Case #11: Boolean. Booleans (TRUE=1, FALSE=0). 2 arguments used.
		oParser = new parserFormula('MAXA(TRUE, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(TRUE, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean. Booleans (TRUE=1, FALSE=0). 2 arguments used.');
		// Case #12: Empty, Number. Empty cell ignored. 2 arguments used.
		oParser = new parserFormula('MAXA(, 100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(, 100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Empty, Number. Empty cell ignored. 2 arguments used.');
		// Case #13: Formula. Nested IF. 2 arguments used.
		oParser = new parserFormula('MAXA(IF(TRUE, 10, 5), 8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(IF(TRUE, 10, 5), 8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Nested IF. 2 arguments used.');
		// Case #14: String, Number. Date string vs number. 2 arguments used.
		oParser = new parserFormula('MAXA("12/12/2025", 100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA("12/12/2025", 100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 46003, 'Test: Positive case: String, Number. Date string vs number. 2 arguments used.');
		// Case #15: Array. Mixed types in array. 1 argument used.
		oParser = new parserFormula('MAXA({1, "2", TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA({1, "2", TRUE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Mixed types in array. 1 argument used.');
		// Case #16: Name3D. 3D named ranges. 2 arguments used.
		oParser = new parserFormula('MAXA(TestName3D, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(TestName3D, TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named ranges. 2 arguments used.');
		// Case #17: Reference link, Formula. Ref + nested formula. 2 arguments used.
		oParser = new parserFormula('MAXA(A104, SQRT(16))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(A104, SQRT(16)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Reference link, Formula. Ref + nested formula. 2 arguments used.');
		// Case #18: Area, Empty. Range with empty cells. 1 argument used.
		oParser = new parserFormula('MAXA(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, Empty. Range with empty cells. 1 argument used.');
		// Case #19: Array. Extreme numbers in array. 1 argument used.
		oParser = new parserFormula('MAXA({-1E+307, 1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA({-1E+307, 1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Positive case: Array. Extreme numbers in array. 1 argument used.');
		// Case #20: Formula. MAX inside SUM. Parent formula not MAXA, but included as per request.
		oParser = new parserFormula('SUM(MAXA(1,2), MAXA(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MAXA(1,2), MAXA(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. MAXA inside SUM. Parent formula not MAXA, but included as per request.');

		// Negative cases:
		// Case #1: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('MAXA(NA(), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(NA(), 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #2: String. Non-numeric strings return 0. 2 arguments used.
		oParser = new parserFormula('MAXA("abc", "def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA("abc", "def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return 0. 2 arguments used.');
		// Case #3: Error, Error. Multiple errors. 2 arguments used.
		oParser = new parserFormula('MAXA(#VALUE!, #N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(#VALUE!, #N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Error. Multiple errors. 2 arguments used.');
		// Case #4: Empty. No arguments returns 0. 0 arguments used.
		oParser = new parserFormula('MAXA(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. No arguments returns 0. 0 arguments used.');
		// Case #5: Area. Multi-cell range with text. 1 argument used.
		oParser = new parserFormula('MAXA(A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range with text. 1 argument used.');
		// Case #6: Boolean, String. Boolean + non-numeric string. 2 arguments used.
		oParser = new parserFormula('MAXA(FALSE, "xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(FALSE, "xyz") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, String. Boolean + non-numeric string. 2 arguments used.');
		// Case #7: Name. Named range with text. 1 argument used.
		oParser = new parserFormula('MAXA(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Name. Named range with text. 1 argument used.');
		// Case #9: Ref3D. 3D ref to text. 1 argument used.
		oParser = new parserFormula('MAXA(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(Sheet2!A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text. 1 argument used.');
		// Case #10: Area3D. 3D range with errors. 1 argument used.
		oParser = new parserFormula('MAXA(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area3D. 3D range with errors. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Largest/smallest valid numbers. 2 arguments used.
		oParser = new parserFormula('MAXA(1E+307, -1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(1E+307, -1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Number. Largest/smallest valid numbers. 2 arguments used.');
		// Case #2: Number. Smallest positive number. 2 arguments used.
		oParser = new parserFormula('MAXA(1E-307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(1E-307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Smallest positive number. 2 arguments used.');
		// Case #3: Date. Max valid date. 2 arguments used.
		oParser = new parserFormula('MAXA(DATE(9999,12,31), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(DATE(9999,12,31), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2958465, 'Test: Bounded case: Date. Max valid date. 2 arguments used.');
		// Case #4: Number. Max Excel number. 2 arguments used.
		oParser = new parserFormula('MAXA(9.99999999999999E+307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(9.99999999999999E+307, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number. Max Excel number. 2 arguments used.');
		// Case #5: Time. Min time value. 2 arguments used.
		oParser = new parserFormula('MAXA(TIME(0,0,0), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MAXA(TIME(0,0,0), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Time. Min time value. 2 arguments used.');


		// Need to fix: errors when only text in args. In arrays MS ignores text and logical values?
		// Case #2: String. Non-numeric strings return 0
		// Case #6: Boolean, String. Boolean + non-numeric string
		// Case #9: Ref3D. 3D ref to text.
		// Case #15: Array. Mixed types in array. - MS ignores text and logical values inside arrays

		testArrayFormula2(assert, "MAXA", 1, 8, null, true);
	});

	QUnit.test("Test: \"MAXIFS\"", function (assert) {

		ws.getRange2("AAA2").setValue("10");
		ws.getRange2("AAA3").setValue("1");
		ws.getRange2("AAA4").setValue("100");
		ws.getRange2("AAA5").setValue("1");
		ws.getRange2("AAA6").setValue("1");
		ws.getRange2("AAA7").setValue("50");

		ws.getRange2("BBB2").setValue("b");
		ws.getRange2("BBB3").setValue("a");
		ws.getRange2("BBB4").setValue("a");
		ws.getRange2("BBB5").setValue("b");
		ws.getRange2("BBB6").setValue("a");
		ws.getRange2("BBB7").setValue("b");

		ws.getRange2("DDD2").setValue("100");
		ws.getRange2("DDD3").setValue("100");
		ws.getRange2("DDD4").setValue("200");
		ws.getRange2("DDD5").setValue("300");
		ws.getRange2("DDD6").setValue("100");
		ws.getRange2("DDD7").setValue("400");

		oParser = new parserFormula('MAXIFS(AAA2:AAA7,BBB2:BBB7,"b",DDD2:DDD7,">100")', "A22", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 50);

		oParser = new parserFormula('MAXIFS(AAA2:AAA6,BBB2:BBB6,"a",DDD2:DDD6,">200")', "A22", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		testArrayFormulaEqualsValues(assert, "1,3.123,-4,#N/A;2,4,5,#N/A;#N/A,#N/A,#N/A,#N/A", "MAXIFS(A1:C2,A1:C2,A1:C2,A1:C2, A1:C2,A1:C2,A1:C2)");
		testArrayFormulaEqualsValues(assert, "1,0,0,#N/A;0,0,0,#N/A;#N/A,#N/A,#N/A,#N/A", "MAXIFS(A1:C2,A1:C2,A1:A1,A1:C2,A1:C2,A1:C2,A1:C2)");
		testArrayFormulaEqualsValues(assert, "1,0,0,#N/A;2,0,0,#N/A;#N/A,#N/A,#N/A,#N/A", "MAXIFS(A1:C2,A1:C2,A1:A2,A1:C2,A1:C2,A1:C2,A1:C2)");
	});

	QUnit.test("Test: \"MAXIFS with multiple criteria ranges\"", function (assert) {
		// Setup test data with 5 columns for testing
		ws.getRange2("E2").setValue("10");
		ws.getRange2("E3").setValue("20");
		ws.getRange2("E4").setValue("30");
		ws.getRange2("E5").setValue("40");
		ws.getRange2("E6").setValue("50");
		ws.getRange2("E7").setValue("60");

		ws.getRange2("F2").setValue("Red");
		ws.getRange2("F3").setValue("Blue");
		ws.getRange2("F4").setValue("Green");
		ws.getRange2("F5").setValue("Red");
		ws.getRange2("F6").setValue("Blue");
		ws.getRange2("F7").setValue("Green");

		ws.getRange2("G2").setValue("Small");
		ws.getRange2("G3").setValue("Medium");
		ws.getRange2("G4").setValue("Large");
		ws.getRange2("G5").setValue("Large");
		ws.getRange2("G6").setValue("Medium");
		ws.getRange2("G7").setValue("Small");

		ws.getRange2("H2").setValue("2023");
		ws.getRange2("H3").setValue("2023");
		ws.getRange2("H4").setValue("2024");
		ws.getRange2("H5").setValue("2024");
		ws.getRange2("H6").setValue("2025");
		ws.getRange2("H7").setValue("2025");

		ws.getRange2("I2").setValue("A");
		ws.getRange2("I3").setValue("B");
		ws.getRange2("I4").setValue("C");
		ws.getRange2("I5").setValue("A");
		ws.getRange2("I6").setValue("B");
		ws.getRange2("I7").setValue("C");

		// Test with 11 arguments (1 max_range + 5 criteria pairs)
		oParser = new parserFormula("MAXIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Large\", H2:H7, 2024, I2:I7, \"A\", I2:I7, \"*\")", "A1", ws);
		assert.ok(oParser.parse(), "MAXIFS with 5 criteria pairs");
		assert.strictEqual(oParser.calculate().getValue(), 40, "MAXIFS with 5 criteria pairs");

		// Test multiple conditions that match different values
		oParser = new parserFormula("MAXIFS(E2:E7, F2:F7, \"Blue\", G2:G7, \"Medium\")", "A1", ws);
		assert.ok(oParser.parse(), "MAXIFS with multiple matching values");
		assert.strictEqual(oParser.calculate().getValue(), 50, "MAXIFS with multiple matching values");

		// Test with cell references for criteria
		ws.getRange2("J2").setValue("Red");
		ws.getRange2("J3").setValue("Large");
		ws.getRange2("J4").setValue("2024");
		ws.getRange2("J5").setValue("A");
		oParser = new parserFormula("MAXIFS(E2:E7, F2:F7, J2, G2:G7, J3, H2:H7, J4, I2:I7, J5, I2:I7, \"*\")", "A1", ws);
		assert.ok(oParser.parse(), "MAXIFS with cell references for all criteria");
		assert.strictEqual(oParser.calculate().getValue(), 40, "MAXIFS with cell references for all criteria");

		// Test with complex criteria expressions
		oParser = new parserFormula("MAXIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"*\", H2:H7, \">\" & 2023, I2:I7, \"A\", I2:I7, \"<>Z\")", "A1", ws);
		assert.ok(oParser.parse(), "MAXIFS with complex criteria expressions");
		assert.strictEqual(oParser.calculate().getValue(), 40, "MAXIFS with complex criteria expressions");

		// Test with criteria that select a single row
		oParser = new parserFormula("MAXIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Large\", H2:H7, 2024, I2:I7, \"A\", E2:E7, 40)", "A1", ws);
		assert.ok(oParser.parse(), "MAXIFS with criteria selecting one row");
		assert.strictEqual(oParser.calculate().getValue(), 40, "MAXIFS with criteria selecting one row");

		// Test finding maximum value for a specific color
		oParser = new parserFormula("MAXIFS(E2:E7, F2:F7, \"Green\")", "A1", ws);
		assert.ok(oParser.parse(), "MAXIFS with single color criteria");
		assert.strictEqual(oParser.calculate().getValue(), 60, "MAXIFS with single color criteria");
	});

	QUnit.test("Test: \"MEDIAN\"", function (assert) {

		function median(x) {

			x.sort(fSortAscending);

			if (x.length % 2) {
				return x[(x.length - 1) / 2];
			} else {
				return (x[x.length / 2 - 1] + x[x.length / 2]) / 2;
			}
		}

		oParser = new parserFormula("MEDIAN(10.5,12.4,19.4,23.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), median([10.5, 12.4, 19.4, 23.2]));

		oParser = new parserFormula("MEDIAN(10.5,{12.4,19.4},23.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), median([10.5, 12.4, 19.4, 23.2]));

		oParser = new parserFormula("MEDIAN(-3.5,1.4,6.9,-4.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), median([-3.5, 1.4, 6.9, -4.5]));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A106").setValue("Text");
		ws.getRange2("A107").setValue("Text");
		ws.getRange2("A108").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");
		ws.getRange2("A112").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("321"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("#N/A");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number(3). Basic valid input: odd count of numbers. 3 arguments used.
		oParser = new parserFormula('MEDIAN(1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(3). Basic valid input: odd count of numbers. 3 arguments used.');
		// Case #1: Number(4). Even count of numbers (returns average of middle two). 4 arguments used.
		oParser = new parserFormula('MEDIAN(1,2,3,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(1,2,3,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Number(4). Even count of numbers (returns average of middle two). 4 arguments used.');
		// Case #2: Number(2). Float numbers with even count. 2 arguments used.
		oParser = new parserFormula('MEDIAN(1.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(1.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(2). Float numbers with even count. 2 arguments used.');
		// Case #3: String(3). String numbers converted to numeric. 3 arguments used.
		oParser = new parserFormula('MEDIAN("1","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN("1","2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String(3). String numbers converted to numeric. 3 arguments used.');
		// Case #4: Formula(3). Nested formulas. 3 arguments used.
		oParser = new parserFormula('MEDIAN(SQRT(1),SQRT(4),SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(SQRT(1),SQRT(4),SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(3). Nested formulas. 3 arguments used.');
		// Case #5: Reference link(3). Ref to cells with valid numbers. 3 arguments used.
		oParser = new parserFormula('MEDIAN(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link(3). Ref to cells with valid numbers. 3 arguments used.');
		// Case #6: Area. Three-cell range. 1 argument used.
		oParser = new parserFormula('MEDIAN(A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Area. Three-cell range. 1 argument used.');
		// Case #7: Array. Array with odd count. 1 argument used.
		oParser = new parserFormula('MEDIAN({1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN({1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array. Array with odd count. 1 argument used.');
		// Case #8: Name. Named range. 1 argument used.
		oParser = new parserFormula('MEDIAN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name. Named range. 1 argument used.');
		// Case #9: Name3D. 3D named range. 1 argument used.
		oParser = new parserFormula('MEDIAN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named range. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell. 1 argument used.
		oParser = new parserFormula('MEDIAN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Ref3D. 3D reference to cell. 1 argument used.');
		// Case #11: Area3D. 3D two-cell range. 1 argument used.
		oParser = new parserFormula('MEDIAN(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. 3D two-cell range. 1 argument used.');
		// Case #12: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('MEDIAN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 321, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #13: Date(3). Dates as serial numbers. 3 arguments used.
		oParser = new parserFormula('MEDIAN(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45659, 'Test: Positive case: Date(3). Dates as serial numbers. 3 arguments used.');
		// Case #15: Formula. MEDIAN inside SUM formula. 3 arguments used.
		oParser = new parserFormula('SUM(MEDIAN(1,2,3),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MEDIAN(1,2,3),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. MEDIAN inside SUM formula. 3 arguments used.');
		// Case #16: Array. Multi-element array with even count. 1 argument used.
		oParser = new parserFormula('MEDIAN({1,2,3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN({1,2,3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array. Multi-element array with even count. 1 argument used.');
		// Case #17: Formula. Nested IF returning values. 3 arguments used.
		oParser = new parserFormula('MEDIAN(IF(TRUE,1,0),IF(TRUE,2,0),IF(TRUE,3,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(IF(TRUE,1,0),IF(TRUE,2,0),IF(TRUE,3,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Nested IF returning values. 3 arguments used.');
		// Case #18: Empty,Number(2). One empty argument ignored. 3 arguments used.
		oParser = new parserFormula('MEDIAN(,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Empty,Number(2). One empty argument ignored. 3 arguments used.');
		// Case #19: Time(3). Time values. 3 arguments used.
		oParser = new parserFormula('MEDIAN(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08333333333333333, 'Test: Positive case: Time(3). Time values. 3 arguments used.');
		// Case #20: Array. Mixed types in array. 1 argument used.
		oParser = new parserFormula('MEDIAN({1,"2",TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN({1,"2",TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Mixed types in array. 1 argument used.');

		// Negative cases:
		// Case #1: String(3). Non-numeric strings return #VALUE!. 3 arguments used.
		oParser = new parserFormula('MEDIAN("a","b","c")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN("a","b","c") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). Non-numeric strings return #VALUE!. 3 arguments used.');
		// Case #2: Error. Propagates #N/A error. 3 arguments used.
		oParser = new parserFormula('MEDIAN(NA(),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(NA(),1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 arguments used.');
		// Case #3: Area. Multi-cell range with text returns #NUM!.
		oParser = new parserFormula('MEDIAN(A106:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(A106:A108) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range with text returns #VALUE!.');
		// Case #4: Empty. Reference to empty cell. 1 argument used.
		oParser = new parserFormula('MEDIAN(A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(A109) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Reference to empty cell. 1 argument used.');
		// Case #5: Boolean(3). All booleans return 0. 3 arguments used.
		oParser = new parserFormula('MEDIAN(FALSE,FALSE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(FALSE,FALSE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean(3). All booleans return 0. 3 arguments used.');
		// Case #6: Ref3D. 3D ref to text returns #VALUE!.
		oParser = new parserFormula('MEDIAN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('MEDIAN(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! error. 3 arguments used.
		oParser = new parserFormula('MEDIAN(SQRT(-1),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(SQRT(-1),1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 arguments used.');
		// Case #10: Array. Array with boolean and text returns #NUM!.
		oParser = new parserFormula('MEDIAN({FALSE,"a"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN({FALSE,"a"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean and text returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number(3). Max valid Excel number. 3 arguments used.
		oParser = new parserFormula('MEDIAN(1,1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(1,1E+307,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Number(3). Max valid Excel number. 3 arguments used.');
		// Case #2: Number(3). Min valid Excel number. 3 arguments used.
		oParser = new parserFormula('MEDIAN(1E-307,1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(1E-307,1E-307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number(3). Min valid Excel number. 3 arguments used.');
		// Case #3: Number(2). Min and max numbers. 2 arguments used.
		oParser = new parserFormula('MEDIAN(-1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(-1E+307,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Min and max numbers. 2 arguments used.');
		// Case #4: Date(2). Min and max valid dates. 2 arguments used.
		oParser = new parserFormula('MEDIAN(DATE(1900,1,1),DATE(9999,12,31))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(DATE(1900,1,1),DATE(9999,12,31)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1479233, 'Test: Bounded case: Date(2). Min and max valid dates. 2 arguments used.');
		// Case #5: Number(4). Even count with repeated values. 4 arguments used.
		oParser = new parserFormula('MEDIAN(1,1,2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MEDIAN(1,1,2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Bounded case: Number(4). Even count with repeated values. 4 arguments used.');

		// Need to fix: error handle and different, empty check, text convertation to numbers
		// Case #3: String(3). String numbers converted to numeric
		// Case #18: Empty,Number(2). One empty argument ignored.
		// Case #2: Error. Propagates #N/A error
		// Case #3: Area. Multi-cell range with text returns #NUM!.
		// Case #4: Empty. Reference to empty cell. 1 argument used.
		// Case #9: Formula. Formula resulting in #NUM! error
		// Case #10: Array. Array with boolean and text returns #NUM!.

		testArrayFormula2(assert, "MEDIAN", 1, 8, null, true);
	});

	QUnit.test("Test: \"MIN\"", function (assert) {

		ws.getRange2("S5").setValue("1");
		ws.getRange2("S6").setValue(numDivFact(-1, 2));
		ws.getRange2("S7").setValue(numDivFact(1, 4));
		ws.getRange2("S8").setValue(numDivFact(-1, 6));

		oParser = new parserFormula("MIN(S5:S8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1 / Math.fact(2));

		ws.getRange2("S5").setValue("#DIV/0!");
		ws.getRange2("S6").setValue("TRUE");
		ws.getRange2("S7").setValue("qwe");
		ws.getRange2("S8").setValue("");
		ws.getRange2("S9").setValue("2");
		oParser = new parserFormula("MIN(S5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");
		oParser = new parserFormula("MIN(S6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);
		oParser = new parserFormula("MIN(S7)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);
		oParser = new parserFormula("MIN(S8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);
		oParser = new parserFormula("MIN(S5:S9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");
		oParser = new parserFormula("MIN(S6:S9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 2);
		oParser = new parserFormula("MIN(2, TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);


		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");
		ws.getRange2("A112").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("321"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:F10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("#N/A");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number(2). Basic valid input: two numbers. 2 arguments used.
		oParser = new parserFormula('MIN(10, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(10, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number(2). Basic valid input: two numbers. 2 arguments used.');
		// Case #1: Number, String. String convertible to number. 2 arguments used.
		oParser = new parserFormula('MIN(5, "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(5, "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number, String. String convertible to number. 2 arguments used.');
		// Case #2: Formula(2). Nested formula. 2 arguments used.
		oParser = new parserFormula('MIN(SQRT(4), 1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(SQRT(4), 1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Formula(2). Nested formula. 2 arguments used.');
		// Case #3: Reference link(2). Ref to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('MIN(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link(2). Ref to cells with valid numbers. 2 arguments used.');
		// Case #4: Area. Two-cell range. 1 argument used.
		oParser = new parserFormula('MIN(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Two-cell range. 1 argument used.');
		// Case #5: Array. Array with multiple elements. 1 argument used.
		oParser = new parserFormula('MIN({5, 3, 8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN({5, 3, 8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array. Array with multiple elements. 1 argument used.');
		// Case #6: Name. Named ranges. 2 arguments used.
		oParser = new parserFormula('MIN(TestName1, TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(TestName1, TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Named ranges. 2 arguments used.');
		// Case #7: Ref3D. 3D references. 2 arguments used.
		oParser = new parserFormula('MIN(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D references. 2 arguments used.');
		// Case #8: Area3D. 3D range. 1 argument used.
		oParser = new parserFormula('MIN(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area3D. 3D range. 1 argument used.');
		// Case #9: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('MIN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 321, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #10: Date, Time. Date and time as serial numbers. 2 arguments used.
		oParser = new parserFormula('MIN(DATE(2025,1,1), TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(DATE(2025,1,1), TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Date, Time. Date and time as serial numbers. 2 arguments used.');
		// Case #11: Boolean. Booleans (TRUE=1, FALSE=0). 2 arguments used.
		oParser = new parserFormula('MIN(TRUE, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(TRUE, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean. Booleans (TRUE=1, FALSE=0). 2 arguments used.');
		// Case #12: Empty, Number. Empty cell ignored. 2 arguments used.
		oParser = new parserFormula('MIN(, 100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(, 100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number. Empty cell ignored. 2 arguments used.');
		// Case #13: Formula. Nested IF. 2 arguments used.
		oParser = new parserFormula('MIN(IF(TRUE, 10, 5), 8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(IF(TRUE, 10, 5), 8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Formula. Nested IF. 2 arguments used.');
		// Case #14: String, Number. Date string vs number. 2 arguments used.
		oParser = new parserFormula('MIN("12/12/2025", 100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN("12/12/2025", 100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: String, Number. Date string vs number. 2 arguments used.');
		// Case #15: Array. Mixed types in array. 1 argument used.
		oParser = new parserFormula('MIN({1, "2", TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN({1, "2", TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Mixed types in array. 1 argument used.');
		// Case #16: Name3D. 3D named ranges. 2 arguments used.
		oParser = new parserFormula('MIN(TestName3D, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(TestName3D, TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named ranges. 2 arguments used.');
		// Case #17: Reference link, Formula. Ref + nested formula. 2 arguments used.
		oParser = new parserFormula('MIN(A104, SQRT(16))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(A104, SQRT(16)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Reference link, Formula. Ref + nested formula. 2 arguments used.');
		// Case #18: Area, Empty. Range with empty cells. 1 argument used.
		oParser = new parserFormula('MIN(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, Empty. Range with empty cells. 1 argument used.');
		// Case #19: Array. Extreme numbers in array. 1 argument used.
		oParser = new parserFormula('MIN({-1E+307, 1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN({-1E+307, 1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+307, 'Test: Positive case: Array. Extreme numbers in array. 1 argument used.');
		// Case #20: Formula. MAX inside SUM. Parent formula not MAX, but included as per request.
		oParser = new parserFormula('SUM(MIN(1,2), MIN(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MIN(1,2), MIN(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. MAX inside SUM. Parent formula not MAX, but included as per request.');

		// Negative cases:
		// Case #1: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('MIN(NA(), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(NA(), 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #2: String. Non-numeric strings return 0. 2 arguments used.
		oParser = new parserFormula('MIN("abc", "def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN("abc", "def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return 0. 2 arguments used.');
		// Case #3: Error, Error. Multiple errors. 2 arguments used.
		oParser = new parserFormula('MIN(#VALUE!, #N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(#VALUE!, #N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Error. Multiple errors. 2 arguments used.');
		// Case #4: Empty. No arguments returns 0. 0 arguments used.
		oParser = new parserFormula('MIN(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. No arguments returns 0. 0 arguments used.');
		// Case #5: Area. Multi-cell range with text. 1 argument used.
		oParser = new parserFormula('MIN(A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range with text. 1 argument used.');
		// Case #6: Boolean, String. Boolean + non-numeric string. 2 arguments used.
		oParser = new parserFormula('MIN(FALSE, "xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(FALSE, "xyz") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, String. Boolean + non-numeric string. 2 arguments used.');
		// Case #7: Name. Named range with text. 1 argument used.
		oParser = new parserFormula('MIN(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with text. 1 argument used.');
		// Case #9: Ref3D. 3D ref to text. 1 argument used.
		oParser = new parserFormula('MIN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(Sheet2!A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text. 1 argument used.');
		// Case #10: Area3D. 3D range with errors. 1 argument used.
		oParser = new parserFormula('MIN(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area3D. 3D range with errors. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Largest/smallest valid numbers. 2 arguments used.
		oParser = new parserFormula('MIN(1E+307, -1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(1E+307, -1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+307, 'Test: Bounded case: Number. Largest/smallest valid numbers. 2 arguments used.');
		// Case #2: Number. Smallest positive number. 2 arguments used.
		oParser = new parserFormula('MIN(1E-307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(1E-307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive number. 2 arguments used.');
		// Case #3: Date. Max valid date. 2 arguments used.
		oParser = new parserFormula('MIN(DATE(9999,12,31), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(DATE(9999,12,31), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Date. Max valid date. 2 arguments used.');
		// Case #4: Number. Max Excel number. 2 arguments used.
		oParser = new parserFormula('MIN(9.99999999999999E+307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(9.99999999999999E+307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Max Excel number. 2 arguments used.');
		// Case #5: Time. Min time value. 2 arguments used.
		oParser = new parserFormula('MIN(TIME(0,0,0), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIN(TIME(0,0,0), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Time. Min time value. 2 arguments used.');

		// Need to fix: errors when only text in args
		// Case #2: String. Non-numeric strings return 0
		// Case #6: Boolean, String. Boolean + non-numeric string
		// Case #9: Ref3D. 3D ref to text.


		testArrayFormula2(assert, "min", 1, 8, null, true);
	});

	QUnit.test("Test: \"MINA\"", function (assert) {

		ws.getRange2("S5").setValue("1");
		ws.getRange2("S6").setValue(numDivFact(-1, 2));
		ws.getRange2("S7").setValue(numDivFact(1, 4));
		ws.getRange2("S8").setValue(numDivFact(-1, 6));

		oParser = new parserFormula("MINA(S5:S8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -1 / Math.fact(2));

		ws.getRange2("S5").setValue("#DIV/0!");
		ws.getRange2("S6").setValue("TRUE");
		ws.getRange2("S7").setValue("qwe");
		ws.getRange2("S8").setValue("");
		ws.getRange2("S9").setValue("2");
		oParser = new parserFormula("MINA(S5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");
		oParser = new parserFormula("MINA(S6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);
		oParser = new parserFormula("MINA(S7)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);
		oParser = new parserFormula("MINA(S8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);
		oParser = new parserFormula("MINA(S5:S9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");
		oParser = new parserFormula("MINA(S6:S9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);
		oParser = new parserFormula("MINA(2, TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");
		ws.getRange2("A112").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("321"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("#N/A");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number(2). Basic valid input: two numbers. 2 arguments used.
		oParser = new parserFormula('MINA(10, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(10, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number(2). Basic valid input: two numbers. 2 arguments used.');
		// Case #1: Number, String. String convertible to number. 2 arguments used.
		oParser = new parserFormula('MINA(5, "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(5, "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number, String. String convertible to number. 2 arguments used.');
		// Case #2: Formula(2). Nested formula. 2 arguments used.
		oParser = new parserFormula('MINA(SQRT(4), 1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(SQRT(4), 1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Formula(2). Nested formula. 2 arguments used.');
		// Case #3: Reference link(2). Ref to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('MINA(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link(2). Ref to cells with valid numbers. 2 arguments used.');
		// Case #4: Area. Two-cell range. 1 argument used.
		oParser = new parserFormula('MINA(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Two-cell range. 1 argument used.');
		// Case #5: Array. Array with multiple elements. 1 argument used.
		oParser = new parserFormula('MINA({5, 3, 8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA({5, 3, 8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array. Array with multiple elements. 1 argument used.');
		// Case #6: Name. Named ranges. 2 arguments used.
		oParser = new parserFormula('MINA(TestName1, TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(TestName1, TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Named ranges. 2 arguments used.');
		// Case #7: Ref3D. 3D references. 2 arguments used.
		oParser = new parserFormula('MINA(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D references. 2 arguments used.');
		// Case #8: Area3D. 3D range. 1 argument used.
		oParser = new parserFormula('MINA(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area3D. 3D range. 1 argument used.');
		// Case #9: Table. Table structured reference. 1 argument used.
		oParser = new parserFormula('MINA(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 321, 'Test: Positive case: Table. Table structured reference. 1 argument used.');
		// Case #10: Date, Time. Date and time as serial numbers. 2 arguments used.
		oParser = new parserFormula('MINA(DATE(2025,1,1), TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(DATE(2025,1,1), TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Date, Time. Date and time as serial numbers. 2 arguments used.');
		// Case #11: Boolean. Booleans (TRUE=1, FALSE=0). 2 arguments used.
		oParser = new parserFormula('MINA(TRUE, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(TRUE, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean. Booleans (TRUE=1, FALSE=0). 2 arguments used.');
		// Case #12: Empty, Number. Empty cell ignored. 2 arguments used.
		oParser = new parserFormula('MINA(, 100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(, 100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number. Empty cell ignored. 2 arguments used.');
		// Case #13: Formula. Nested IF. 2 arguments used.
		oParser = new parserFormula('MINA(IF(TRUE, 10, 5), 8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(IF(TRUE, 10, 5), 8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Formula. Nested IF. 2 arguments used.');
		// Case #14: String, Number. Date string vs number. 2 arguments used.
		oParser = new parserFormula('MINA("12/12/2025", 100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA("12/12/2025", 100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: String, Number. Date string vs number. 2 arguments used.');
		// Case #15: Array. Mixed types in array. 1 argument used.
		oParser = new parserFormula('MINA({1, "2", TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA({1, "2", TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Mixed types in array. 1 argument used.');
		// Case #16: Name3D. 3D named ranges. 2 arguments used.
		oParser = new parserFormula('MINA(TestName3D, TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(TestName3D, TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named ranges. 2 arguments used.');
		// Case #17: Reference link, Formula. Ref + nested formula. 2 arguments used.
		oParser = new parserFormula('MINA(A104, SQRT(16))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(A104, SQRT(16)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Reference link, Formula. Ref + nested formula. 2 arguments used.');
		// Case #18: Area, Empty. Range with empty cells. 1 argument used.
		oParser = new parserFormula('MINA(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, Empty. Range with empty cells. 1 argument used.');
		// Case #19: Array. Extreme numbers in array. 1 argument used.
		oParser = new parserFormula('MINA({-1E+307, 1E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA({-1E+307, 1E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+307, 'Test: Positive case: Array. Extreme numbers in array. 1 argument used.');
		// Case #20: Formula. MAX inside SUM. Parent formula not MAX, but included as per request.
		oParser = new parserFormula('SUM(MINA(1,2), MINA(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MINA(1,2), MINA(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. MAX inside SUM. Parent formula not MAX, but included as per request.');

		// Negative cases:
		// Case #1: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('MINA(NA(), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(NA(), 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #2: String. Non-numeric strings return 0. 2 arguments used.
		oParser = new parserFormula('MINA("abc", "def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA("abc", "def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return 0. 2 arguments used.');
		// Case #3: Error, Error. Multiple errors. 2 arguments used.
		oParser = new parserFormula('MINA(#VALUE!, #N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(#VALUE!, #N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Error. Multiple errors. 2 arguments used.');
		// Case #4: Empty. No arguments returns 0. 0 arguments used.
		oParser = new parserFormula('MINA(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. No arguments returns 0. 0 arguments used.');
		// Case #5: Area. Multi-cell range with text. 1 argument used.
		oParser = new parserFormula('MINA(A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range with text. 1 argument used.');
		// Case #6: Boolean, String. Boolean + non-numeric string. 2 arguments used.
		oParser = new parserFormula('MINA(FALSE, "xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(FALSE, "xyz") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, String. Boolean + non-numeric string. 2 arguments used.');
		// Case #7: Name. Named range with text. 1 argument used.
		oParser = new parserFormula('MINA(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with text. 1 argument used.');
		// Case #9: Ref3D. 3D ref to text. 1 argument used.
		oParser = new parserFormula('MINA(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(Sheet2!A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text. 1 argument used.');
		// Case #10: Area3D. 3D range with errors. 1 argument used.
		oParser = new parserFormula('MINA(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area3D. 3D range with errors. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Largest/smallest valid numbers. 2 arguments used.
		oParser = new parserFormula('MINA(1E+307, -1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(1E+307, -1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+307, 'Test: Bounded case: Number. Largest/smallest valid numbers. 2 arguments used.');
		// Case #2: Number. Smallest positive number. 2 arguments used.
		oParser = new parserFormula('MINA(1E-307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(1E-307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive number. 2 arguments used.');
		// Case #3: Date. Max valid date. 2 arguments used.
		oParser = new parserFormula('MINA(DATE(9999,12,31), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(DATE(9999,12,31), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Date. Max valid date. 2 arguments used.');
		// Case #4: Number. Max Excel number. 2 arguments used.
		oParser = new parserFormula('MINA(9.99999999999999E+307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(9.99999999999999E+307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Max Excel number. 2 arguments used.');
		// Case #5: Time. Min time value. 2 arguments used.
		oParser = new parserFormula('MINA(TIME(0,0,0), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MINA(TIME(0,0,0), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Time. Min time value. 2 arguments used.');

		// Need to fix: errors when only text in args
		// Case #2: String. Non-numeric strings return 0
		// Case #6: Boolean, String. Boolean + non-numeric string
		// Case #9: Ref3D. 3D ref to text.

		testArrayFormula2(assert, "mina", 1, 8, null, true);
	});

	QUnit.test("Test: \"MINIFS\"", function (assert) {

		ws.getRange2("AAA2").setValue("10");
		ws.getRange2("AAA3").setValue("1");
		ws.getRange2("AAA4").setValue("100");
		ws.getRange2("AAA5").setValue("1");
		ws.getRange2("AAA6").setValue("1");
		ws.getRange2("AAA7").setValue("50");

		ws.getRange2("BBB2").setValue("b");
		ws.getRange2("BBB3").setValue("a");
		ws.getRange2("BBB4").setValue("a");
		ws.getRange2("BBB5").setValue("b");
		ws.getRange2("BBB6").setValue("a");
		ws.getRange2("BBB7").setValue("b");

		ws.getRange2("DDD2").setValue("100");
		ws.getRange2("DDD3").setValue("100");
		ws.getRange2("DDD4").setValue("200");
		ws.getRange2("DDD5").setValue("300");
		ws.getRange2("DDD6").setValue("100");
		ws.getRange2("DDD7").setValue("400");

		oParser = new parserFormula('MINIFS(AAA2:AAA7,BBB2:BBB7,"b",DDD2:DDD7,">100")', "A22", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula('MINIFS(AAA2:AAA6,BBB2:BBB6,"a",DDD2:DDD6,">200")', "A22", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		testArrayFormulaEqualsValues(assert, "1,3.123,-4,#N/A;2,4,5,#N/A;#N/A,#N/A,#N/A,#N/A", "MINIFS(A1:C2,A1:C2,A1:C2,A1:C2, A1:C2,A1:C2,A1:C2)");
		testArrayFormulaEqualsValues(assert, "1,0,0,#N/A;0,0,0,#N/A;#N/A,#N/A,#N/A,#N/A", "MINIFS(A1:C2,A1:C2,A1:A1,A1:C2,A1:C2,A1:C2,A1:C2)");
		testArrayFormulaEqualsValues(assert, "1,0,0,#N/A;2,0,0,#N/A;#N/A,#N/A,#N/A,#N/A", "MINIFS(A1:C2,A1:C2,A1:A2,A1:C2,A1:C2,A1:C2,A1:C2)");
	});

	QUnit.test("Test: \"MINIFS with multiple criteria ranges\"", function (assert) {
		// Setup test data with 5 columns for testing
		ws.getRange2("E2").setValue("10");
		ws.getRange2("E3").setValue("20");
		ws.getRange2("E4").setValue("30");
		ws.getRange2("E5").setValue("40");
		ws.getRange2("E6").setValue("50");
		ws.getRange2("E7").setValue("60");

		ws.getRange2("F2").setValue("Red");
		ws.getRange2("F3").setValue("Blue");
		ws.getRange2("F4").setValue("Green");
		ws.getRange2("F5").setValue("Red");
		ws.getRange2("F6").setValue("Blue");
		ws.getRange2("F7").setValue("Green");

		ws.getRange2("G2").setValue("Small");
		ws.getRange2("G3").setValue("Medium");
		ws.getRange2("G4").setValue("Large");
		ws.getRange2("G5").setValue("Large");
		ws.getRange2("G6").setValue("Medium");
		ws.getRange2("G7").setValue("Small");

		ws.getRange2("H2").setValue("2023");
		ws.getRange2("H3").setValue("2023");
		ws.getRange2("H4").setValue("2024");
		ws.getRange2("H5").setValue("2024");
		ws.getRange2("H6").setValue("2025");
		ws.getRange2("H7").setValue("2025");

		ws.getRange2("I2").setValue("A");
		ws.getRange2("I3").setValue("B");
		ws.getRange2("I4").setValue("C");
		ws.getRange2("I5").setValue("A");
		ws.getRange2("I6").setValue("B");
		ws.getRange2("I7").setValue("C");

		// Test with 11 arguments (1 min_range + 5 criteria pairs)
		oParser = new parserFormula("MINIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Large\", H2:H7, 2024, I2:I7, \"A\", I2:I7, \"*\")", "A1", ws);
		assert.ok(oParser.parse(), "MINIFS with 5 criteria pairs");
		assert.strictEqual(oParser.calculate().getValue(), 40, "MINIFS with 5 criteria pairs");

		// Test multiple conditions that match different values
		oParser = new parserFormula("MINIFS(E2:E7, F2:F7, \"Blue\", G2:G7, \"Medium\")", "A1", ws);
		assert.ok(oParser.parse(), "MINIFS with multiple matching values");
		assert.strictEqual(oParser.calculate().getValue(), 20, "MINIFS with multiple matching values");

		// Test with cell references for criteria
		ws.getRange2("J2").setValue("Red");
		ws.getRange2("J3").setValue("Large");
		ws.getRange2("J4").setValue("2024");
		ws.getRange2("J5").setValue("A");
		oParser = new parserFormula("MINIFS(E2:E7, F2:F7, J2, G2:G7, J3, H2:H7, J4, I2:I7, J5, I2:I7, \"*\")", "A1", ws);
		assert.ok(oParser.parse(), "MINIFS with cell references for all criteria");
		assert.strictEqual(oParser.calculate().getValue(), 40, "MINIFS with cell references for all criteria");

		// Test with complex criteria expressions
		oParser = new parserFormula("MINIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"*\", H2:H7, \">\" & 2023, I2:I7, \"A\", I2:I7, \"<>Z\")", "A1", ws);
		assert.ok(oParser.parse(), "MINIFS with complex criteria expressions");
		assert.strictEqual(oParser.calculate().getValue(), 40, "MINIFS with complex criteria expressions");

		// Test with criteria that select a single row
		oParser = new parserFormula("MINIFS(E2:E7, F2:F7, \"Red\", G2:G7, \"Large\", H2:H7, 2024, I2:I7, \"A\", E2:E7, 40)", "A1", ws);
		assert.ok(oParser.parse(), "MINIFS with criteria selecting one row");
		assert.strictEqual(oParser.calculate().getValue(), 40, "MINIFS with criteria selecting one row");
	});

	QUnit.test("Test: \"MODE\"", function (assert) {

		function mode(x) {

			x.sort(AscCommon.fSortAscending);

			if (x.length < 1) {
				return "#VALUE!";
			} else {
				var nMaxIndex = 0, nMax = 1, nCount = 1, nOldVal = x[0], i;

				for (i = 1; i < x.length; i++) {
					if (x[i] == nOldVal) {
						nCount++;
					} else {
						nOldVal = x[i];
						if (nCount > nMax) {
							nMax = nCount;
							nMaxIndex = i - 1;
						}
						nCount = 1;
					}
				}
				if (nCount > nMax) {
					nMax = nCount;
					nMaxIndex = i - 1;
				}
				if (nMax == 1 && nCount == 1) {
					return "#VALUE!";
				} else if (nMax == 1) {
					return nOldVal;
				} else {
					return x[nMaxIndex];
				}
			}
		}

		oParser = new parserFormula("MODE(9,1,5,1,9,5,6,6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), mode([9, 1, 5, 1, 9, 5, 6, 6]));

		oParser = new parserFormula("MODE(1,9,5,1,9,5,6,6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), mode([1, 9, 5, 1, 9, 5, 6, 6]));

		oParser = new parserFormula("MODE(1,9,5,5,9,5,6,6)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), mode([1, 9, 5, 5, 9, 5, 6, 6]));

		ws.getRange2("G2").setValue("1");
		ws.getRange2("G3").setValue("1");
		ws.getRange2("G4").setValue("2");
		ws.getRange2("G5").setValue("2");
		ws.getRange2("G6").setValue("3");

		ws.getRange2("G7").setValue("test2");
		ws.getRange2("G8").setValue("#N/A");
		ws.getRange2("G9").setValue("TRUE");
		ws.getRange2("G10").setValue("{1;1;2;2;3}");

		oParser = new parserFormula("MODE(G2:G6)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(G2:G6)");
		array = oParser.calculate();
		assert.strictEqual(array.getValue(), 1);

		// number
		oParser = new parserFormula("MODE(12)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(12)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE(12)");

		oParser = new parserFormula("MODE(-12)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(-12)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.MULT(-12)");

		oParser = new parserFormula("MODE(0.0000000000002)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(0.0000000000002)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE(0.0000000000002)");

		oParser = new parserFormula("MODE(0.0000000000002, 0.0000000000002, 0.0000000000003)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(0.0000000000002, 0.0000000000002, 0.0000000000003)");
		assert.strictEqual(oParser.calculate().getValue(), 0.0000000000002, "Result MODE(0.0000000000002, 0.0000000000002, 0.0000000000003)");

		oParser = new parserFormula("MODE(-0.0000000000002)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(-0.0000000000002)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE(-0.0000000000002)");

		oParser = new parserFormula("MODE(-0.0000000000002, -0.0000000000002, -0.0000000000003)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(-0.0000000000002, -0.0000000000002, -0.0000000000003)");
		assert.strictEqual(oParser.calculate().getValue(), -0.0000000000002, "Result MODE(-0.0000000000002, -0.0000000000002, -0.0000000000003)");

		oParser = new parserFormula("MODE(999999999999999999999999999999)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(999999999999999999999999999999)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE(999999999999999999999999999999)");

		oParser = new parserFormula("MODE(-999999999999999999999999999999)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(-999999999999999999999999999999)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE(-999999999999999999999999999999)");

		oParser = new parserFormula("MODE(G6)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(3)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE(3)");

		// string
		oParser = new parserFormula("MODE(hello)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(hello)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE('hello')");

		oParser = new parserFormula("MODE(G7)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(test2)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE(test2)");

		// bool
		oParser = new parserFormula("MODE(TRUE)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE(TRUE)");

		oParser = new parserFormula("MODE(FALSE)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE(FALSE)");

		oParser = new parserFormula("MODE(G9)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE(TRUE)");

		// date
		oParser = new parserFormula("MODE(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))", "H1", ws);
		assert.ok(oParser.parse(), "MODE(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))");
		assert.strictEqual(oParser.calculate().getValue(), 36892, "Result MODE(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))");

		// array
		oParser = new parserFormula("MODE({2;2;3})", "H1", ws);
		assert.ok(oParser.parse(), "MODE({2;2;3})");
		assert.strictEqual(oParser.calculate().getValue(), 2, "Result in MODE({2;2;3})");

		oParser = new parserFormula("MODE({1;1;2;2;3})", "H1", ws);
		assert.ok(oParser.parse(), "MODE({1;1;2;2;3})");
		array = oParser.calculate();
		assert.strictEqual(array.getValue(), 1, "Result in MODE({1;1;2;2;3})");

		oParser = new parserFormula("MODE(G10)", "H1", ws);
		assert.ok(oParser.parse(), "MODE({1;1;2;2;3})");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result in MODE({1;1;2;2;3})");

		oParser = new parserFormula("MODE({TRUE;2;3})", "H1", ws);
		assert.ok(oParser.parse(), "MODE({TRUE;2;3})");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result in MODE({TRUE;2;3})");

		// multiple args
		oParser = new parserFormula("MODE(12,12,13,13)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(12,12,13,13)");
		array = oParser.calculate();
		assert.strictEqual(array.getValue(), 12, "Result in MODE(12,12,13,13)");

		oParser = new parserFormula("MODE(1,2,3,4,5,6,7,8,9,10)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(1,2,3,4,5,6,7,8,9,10)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE(1,2,3,4,5,6,7,8,9,10)");

		oParser = new parserFormula("MODE(G6,G6,G5)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(3,3,2)");
		assert.strictEqual(oParser.calculate().getValue(), 3, "Result in [0,0] MODE(3,3,2)");

		oParser = new parserFormula("MODE({1,2,3,4,5,6,7,8,9,10},10,10,11,11,11)", "H1", ws);
		assert.ok(oParser.parse(), "MODE(1,2,3,4,5,6,7,8,9,10)");
		assert.strictEqual(oParser.calculate().getValue(), 10, "Result MODE({1,2,3,4,5,6,7,8,9,10},10,10,11,11,11)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("B101").setValue("4");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("2");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE(2,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(2,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Basic valid input: numbers with a mode. 3 arguments used.');
		// Case #1: Number. Multiple numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE(1,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(1,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Multiple numbers with a mode. 3 arguments used.');
		// Case #3: String. Numeric strings converted to numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE("2","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE("2","2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Numeric strings converted to numbers with a mode. 3 arguments used.');
		// Case #4: Formula. Nested formula returning numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE(SQRT(4),SQRT(4),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(SQRT(4),SQRT(4),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Nested formula returning numbers with a mode. 3 arguments used.');
		// Case #5: Reference link. References to cells with numbers having a mode. 3 arguments used.
		oParser = new parserFormula('MODE(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(A100,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. References to cells with numbers having a mode. 3 arguments used.');
		// Case #6: Area. Single range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(A100:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area. Single range with numbers having a mode. 1 argument used.');
		// Case #7: Array. Array with single mode. 1 argument used.
		oParser = new parserFormula('MODE({2,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE({2,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array. Array with single mode. 1 argument used.');
		// Case #8: Name. Named range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name. Named range with numbers having a mode. 1 argument used.');
		// Case #9: Name3D. 3D named range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name3D. 3D named range with numbers having a mode. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with a number. 1 argument used.
		oParser = new parserFormula('MODE(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(Sheet2!A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D reference to cell with a number. 1 argument used.');
		// Case #11: Area3D. 3D range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D range with numbers having a mode. 1 argument used.');
		// Case #12: Table. Table column with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Table. Table column with numbers having a mode. 1 argument used.');
		// Case #13: Date. Dates as serial numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE(DATE(2025,1,1),DATE(2025,1,1),DATE(2025,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(DATE(2025,1,1),DATE(2025,1,1),DATE(2025,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date. Dates as serial numbers with a mode. 3 arguments used.');
		// Case #14: Time. Time values as fractions with a mode. 3 arguments used.
		oParser = new parserFormula('MODE(TIME(1,0,0),TIME(1,0,0),TIME(2,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(TIME(1,0,0),TIME(1,0,0),TIME(2,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), "0.0417", 'Test: Positive case: Time. Time values as fractions with a mode. 3 arguments used.');
		// Case #15: Formula. MODE inside SUM formula. 3 arguments used.
		oParser = new parserFormula('SUM(MODE(2,2,3),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MODE(2,2,3),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. MODE inside SUM formula. 3 arguments used.');
		// Case #16: Formula. Nested IF returning numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE(IF(TRUE,2,1),IF(TRUE,2,1),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(IF(TRUE,2,1),IF(TRUE,2,1),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Nested IF returning numbers with a mode. 3 arguments used.');
		// Case #17: String. Numeric strings with decimal points converted to numbers. 3 arguments used.
		oParser = new parserFormula('MODE("1.5","1.5","2.7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE("1.5","1.5","2.7") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Numeric strings with decimal points converted to numbers. 3 arguments used.');
		// Case #18: Array. Array with multiple elements and a mode. 1 argument used.
		oParser = new parserFormula('MODE({1,1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE({1,1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Array with multiple elements and a mode. 1 argument used.');
		// Case #19: Reference link. References to cells with identical values (mode exists). 2 arguments used.
		oParser = new parserFormula('MODE(A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. References to cells with identical values (mode exists). 2 arguments used.');
		// Case #20: Area. Single-cell range with identical values (mode exists). 1 argument used.
		oParser = new parserFormula('MODE(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area. Single-cell range with identical values (mode exists). 1 argument used.');

		// Negative cases:
		// Case #1: Number. No mode exists (all unique values), returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE(1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. No mode exists (all unique values), returns #NUM!. 3 arguments used.');
		// Case #2: String. Non-numeric strings, returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('MODE("abc","abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE("abc","abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Non-numeric strings, returns #VALUE!. 3 arguments used.');
		// Case #3: Error. Propagates #N/A error. 3 arguments used.
		oParser = new parserFormula('MODE(NA(),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(NA(),1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 arguments used.');
		// Case #4: Area. Multi-cell range with no mode, returns #NUM!. 1 argument used.
		oParser = new parserFormula('MODE(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(A105:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area. Multi-cell range with no mode, returns #NUM!. 1 argument used.');
		// Case #5: Empty. Reference to empty cell, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference to empty cell, returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean inputs, returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('MODE(TRUE,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(TRUE,TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean. Boolean inputs, returns #VALUE!. 3 arguments used.');
		// Case #7: Ref3D. 3D reference to text cell, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(Sheet2!A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text cell, returns #VALUE!. 1 argument used.');
		// Case #8: Name. Named range with text, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with text, returns #VALUE!. 1 argument used.');
		// Case #10: Formula. Formula resulting in #NUM! error, propagates error. 3 arguments used.
		oParser = new parserFormula('MODE(SQRT(-1),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(SQRT(-1),1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error, propagates error. 3 arguments used.');
		// Case #11: Array. Array with booleans, returns #N/A'. 1 argument used.
		oParser = new parserFormula('MODE({FALSE,TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE({FALSE,TRUE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Array with booleans, returns #VALUE!. 1 argument used.');
		// Case #12: Number. Number exceeds Excel’s limit, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE(1E+308,1E+308,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(1E+308,1E+308,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.00E+307, 'Test: Negative case: Number. Number exceeds Excel’s limit, returns #NUM!. 3 arguments used.');
		// Case #13: String. Empty string, returns #N/A'!. 3 arguments used.
		oParser = new parserFormula('MODE("","1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE("","1","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Empty string, returns #VALUE!. 3 arguments used.');
		// Case #14: Area3D. 3D range with text, returns #N/A'. 1 argument used.
		oParser = new parserFormula('MODE(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area3D. 3D range with text, returns #VALUE!. 1 argument used.');
		// Case #15: Name3D. 3D named range with text, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE(TestName3DArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(TestName3DArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with text, returns #VALUE!. 1 argument used.');
		// Case #16: Reference link. References to cells with no mode, returns #NUM!. 2 arguments used.
		oParser = new parserFormula('MODE(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. References to cells with no mode, returns #NUM!. 2 arguments used.');
		// Case #17: Array. Array with no mode, returns #NUM!. 1 argument used.
		oParser = new parserFormula('MODE({1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE({1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Array with no mode, returns #NUM!. 1 argument used.');
		// Case #18: Formula. Nested IF producing unique values, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE(IF(FALSE,1,2),IF(FALSE,1,3),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(IF(FALSE,1,2),IF(FALSE,1,3),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Nested IF producing unique values, returns #NUM!. 3 arguments used.');
		// Case #19: Date. Unique date serial numbers, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Date. Unique date serial numbers, returns #NUM!. 3 arguments used.');
		// Case #20: Time. Unique time fractions, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Time. Unique time fractions, returns #NUM!. 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimal positive number with a mode. 3 arguments used.
		oParser = new parserFormula('MODE(1E-307,1E-307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(1E-307,1E-307,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimal positive number with a mode. 3 arguments used.');
		// Case #2: Number. Maximal valid Excel number with a mode. 3 arguments used.
		oParser = new parserFormula('MODE(9.99999999999999E+307,9.99999999999999E+307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE(9.99999999999999E+307,9.99999999999999E+307,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number. Maximal valid Excel number with a mode. 3 arguments used.');
		// Case #3: Array. Array with equal frequency modes (Excel returns first mode). 1 argument used.
		oParser = new parserFormula('MODE({1,1,2,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE({1,1,2,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array. Array with equal frequency modes (Excel returns first mode). 1 argument used.');

		// Need to fix: error handle, error different types return
		// Case #3: String. Numeric strings converted to numbers with a mode. 3 arguments used.
		// Case #5: Reference link. References to cells with numbers having a mode. 3 arguments used.
		// Case #6: Area. Single range with numbers having a mode. 1 argument used.
		// Case #17: String. Numeric strings with decimal points converted to numbers. 3 arguments used.
		// Case #2: String. Non-numeric strings, returns #VALUE!. 3 arguments used.
		// Case #3: Error. Propagates #N/A error. 3 arguments used.
		// Case #4: Area. Multi-cell range with no mode, returns #NUM!. 1 argument used.
		// Case #6: Boolean. Boolean inputs, returns #VALUE!. 3 arguments used.
		// Case #7: Ref3D. 3D reference to text cell, returns #VALUE!. 1 argument used.
		// Case #8: Name. Named range with text, returns #VALUE!. 1 argument used.
		// Case #10: Formula. Formula resulting in #NUM! error, propagates error. 3 arguments used.
		// Case #11: Array. Array with booleans, returns #VALUE!. 1 argument used.
		// Case #12: Number. Number exceeds Excel’s limit, returns #NUM!. 3 arguments used.
		// Case #2: Number. Maximal valid Excel number with a mode. 3 arguments used.

		testArrayFormula2(assert, "mode", 1, 8, null, true);
	});

	QUnit.test("Test: \"MODE.MULT \"", function (assert) {

		ws.getRange2("F202").setValue("1");
		ws.getRange2("F203").setValue("2");
		ws.getRange2("F204").setValue("3");
		ws.getRange2("F205").setValue("4");
		ws.getRange2("F206").setValue("3");
		ws.getRange2("F207").setValue("2");
		ws.getRange2("F208").setValue("1");
		ws.getRange2("F209").setValue("2");
		ws.getRange2("F210").setValue("3");
		ws.getRange2("F211").setValue("5");
		ws.getRange2("F212").setValue("6");
		ws.getRange2("F213").setValue("1");

		ws.getRange2("G2").setValue("1");
		ws.getRange2("G3").setValue("1");
		ws.getRange2("G4").setValue("2");
		ws.getRange2("G5").setValue("2");
		ws.getRange2("G6").setValue("3");

		ws.getRange2("G7").setValue("test2");
		ws.getRange2("G8").setValue("#N/A");
		ws.getRange2("G9").setValue("TRUE");
		ws.getRange2("G10").setValue("{1;1;2;2;3}");

		// base case
		oParser = new parserFormula("MODE.MULT(F202:F213)", "F1", ws);
		assert.ok(oParser.parse());
		let array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue(), 1);
		assert.strictEqual(array.getElementRowCol(1,0).getValue(), 2);
		assert.strictEqual(array.getElementRowCol(2,0).getValue(), 3);

		// bug case
		oParser = new parserFormula("MODE.MULT(G2:G6)", "H1:H5", ws);
		assert.ok(oParser.parse(), "MODE.MULT(G2:G6)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue(), 1);
		assert.strictEqual(array.getElementRowCol(1,0).getValue(), 2);
		assert.strictEqual(array.getElementRowCol(2,0).getValue(), "");

		// number
		oParser = new parserFormula("MODE.MULT(12)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(12)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.MULT(12)");

		oParser = new parserFormula("MODE.MULT(-12)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(-12)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.MULT(-12)");

		oParser = new parserFormula("MODE.MULT(0.0000000000002)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(0.0000000000002)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.MULT(0.0000000000002)");

		oParser = new parserFormula("MODE.MULT(0.0000000000002, 0.0000000000002, 0.0000000000003)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(0.0000000000002, 0.0000000000002, 0.0000000000003)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.0000000000002, "Result MODE.MULT(0.0000000000002, 0.0000000000002, 0.0000000000003)");

		oParser = new parserFormula("MODE.MULT(-0.0000000000002)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(-0.0000000000002)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.MULT(-0.0000000000002)");

		oParser = new parserFormula("MODE.MULT(-0.0000000000002, -0.0000000000002, -0.0000000000003)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(-0.0000000000002, -0.0000000000002, -0.0000000000003)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -0.0000000000002, "Result MODE.MULT(-0.0000000000002, -0.0000000000002, -0.0000000000003)");

		oParser = new parserFormula("MODE.MULT(999999999999999999999999999999)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(999999999999999999999999999999)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.MULT(999999999999999999999999999999)");

		oParser = new parserFormula("MODE.MULT(-999999999999999999999999999999)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(-999999999999999999999999999999)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.MULT(-999999999999999999999999999999)");

		oParser = new parserFormula("MODE.MULT(G6)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(3)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.MULT(3)");

		// string
		oParser = new parserFormula("MODE.MULT(hello)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(hello)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE.MULT('hello')");

		oParser = new parserFormula("MODE.MULT(G7)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(test2)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE.MULT(test2)");

		// bool
		oParser = new parserFormula("MODE.MULT(TRUE)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE.MULT(TRUE)");

		oParser = new parserFormula("MODE.MULT(FALSE)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE.MULT(FALSE)");

		oParser = new parserFormula("MODE.MULT(G9)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE.MULT(TRUE)");

		// array
		oParser = new parserFormula("MODE.MULT({2;2;3})", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT({2;2;3})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, "Result in [0,0] MODE.MULT({2;2;3})");
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), "", "Result in [1,0] MODE.MULT({2;2;3})");

		oParser = new parserFormula("MODE.MULT({1;1;2;2;3})", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT({1;1;2;2;3})");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue(), 1, "Result in [0,0] MODE.MULT({1;1;2;2;3})");
		assert.strictEqual(array.getElementRowCol(1,0).getValue(), 2, "Result in [1,0] MODE.MULT({1;1;2;2;3})");
		assert.strictEqual(array.getElementRowCol(2,0).getValue(), "", "Result in [2,0] MODE.MULT({1;1;2;2;3})");
		assert.strictEqual(array.getElementRowCol(0,1).getValue(), "", "Result in [0,1] MODE.MULT({1;1;2;2;3})");
		assert.strictEqual(array.getElementRowCol(1,1).getValue(), "", "Result in [1,1] MODE.MULT({1;1;2;2;3})");
		assert.strictEqual(array.getElementRowCol(3,3).getValue(), "#N/A", "Result in [3,3] MODE.MULT({1;1;2;2;3})");

		oParser = new parserFormula("MODE.MULT(G10)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT({1;1;2;2;3})");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result in MODE.MULT({1;1;2;2;3})");

		oParser = new parserFormula("MODE.MULT({TRUE;2;3})", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT({TRUE;2;3})");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result in [0,0] MODE.MULT({TRUE;2;3})");

		// date
		oParser = new parserFormula("MODE.MULT(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue(), 36892, "Result in [0,0] MODE.MULT(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))");
		assert.strictEqual(array.getElementRowCol(1,0).getValue(), 37622, "Result in [1,0] MODE.MULT(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))");
		assert.strictEqual(array.getElementRowCol(0,1).getValue(), "", "Result in [0,1] MODE.MULT(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))");
		assert.strictEqual(array.getElementRowCol(1,1).getValue(), "", "Result in [1,1] MODE.MULT(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))");
		assert.strictEqual(array.getElementRowCol(2,2).getValue(), "#N/A", "Result in [2,2] MODE.MULT(DATE(2001,1,1),DATE(2003,1,1), DATE(2001,1,1),DATE(2003,1,1))");

		// multiple args
		oParser = new parserFormula("MODE.MULT(12,12,13,13)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(12,12,13,13)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0,0).getValue(), 12, "Result in [0,0] MODE.MULT(12,12,13,13)");
		assert.strictEqual(array.getElementRowCol(1,0).getValue(), 13, "Result in [1,0] MODE.MULT(12,12,13,13)");
		assert.strictEqual(array.getElementRowCol(0,1).getValue(), "", "Result in [0,1] MODE.MULT(12,12,13,13)");
		assert.strictEqual(array.getElementRowCol(1,1).getValue(), "", "Result in [1,1] MODE.MULT(12,12,13,13)");
		assert.strictEqual(array.getElementRowCol(2,2).getValue(), "#N/A", "Result in [2,2] MODE.MULT(12,12,13,13)");

		oParser = new parserFormula("MODE.MULT(1,2,3,4,5,6,7,8,9,10)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(1,2,3,4,5,6,7,8,9,10)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.MULT(1,2,3,4,5,6,7,8,9,10)");

		oParser = new parserFormula("MODE.MULT(G6,G6,G5)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(3,3,2)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, "Result in [0,0] MODE.MULT(3,3,2)");
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), "", "Result in [1,0] MODE.MULT(3,3,2)");

		oParser = new parserFormula("MODE.MULT({1,2,3,4,5,6,7,8,9,10},10,10,11,11,11)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(1,2,3,4,5,6,7,8,9,10)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 10, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},10,10,11,11,11)");
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 11, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},10,10,11,11,11)");

		oParser = new parserFormula("MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10})", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), 2, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(2,0).getValue(), 3, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(3,0).getValue(), 4, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(4,0).getValue(), 5, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(5,0).getValue(), 6, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(6,0).getValue(), 7, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(7,0).getValue(), 8, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(8,0).getValue(), 9, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(9,0).getValue(), 10, "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(10,0).getValue(), "", "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), "", "Result MODE.MULT({1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10},{1,2,3,4,5,6,7,8,9,10}");

		oParser = new parserFormula("MODE.MULT(G2:G4,G5:G6,G2:G6,G3:G5)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, "Result MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0,1).getValue(), "", "Result MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");
		assert.strictEqual(oParser.calculate().getElementRowCol(1,0).getValue(), "", "Result MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");

		// ctrl shift enter cases
		oParser = new parserFormula("MODE.MULT(G2:G4,G5:G6,G2:G6,G3:G5)", "H1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("G2:G6").bbox);
		assert.ok(oParser.parse(), "MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 2, "Result in [0,0] MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "", "Result in [1,0] MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");	// 2
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result in [0,1] MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");	// 2
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result in [1,1] MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");	// 2
		assert.strictEqual(array.getElementRowCol(2, 2).getValue(), "#N/A", "Result in [2,2] MODE.MULT(1,1,2,2,3,1,1,2,2,3,1,2,2)");

		oParser = new parserFormula("MODE.MULT({10;11;10;11})", "H1:K8", ws);
		oParser.setArrayFormulaRef(ws.getRange2("H1:K8").bbox);
		assert.ok(oParser.parse(), "MODE.MULT({10;11;10;11})");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 10, "Result in [0,0] MODE.MULT({10;11;10;11})");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 11, "Result in [1,0] MODE.MULT({10;11;10;11})");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), "", "Result in [0,1] MODE.MULT({10;11;10;11})");	// 10
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), "", "Result in [1,1] MODE.MULT({10;11;10;11})");	// 11
		assert.strictEqual(array.getElementRowCol(2, 2).getValue(), "#N/A", "Result in [2,2] MODE.MULT({10;11;10;11})");

		// TODO sort test
		oParser = new parserFormula("MODE.MULT({1,2,5,5,5,4,4,4,7,7,7,2,2,1,1})", "H1", ws);
		assert.ok(oParser.parse(), "MODE.MULT({1,2,5,5,5,4,4,4,7,7,7,2,2,1,1}");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 1, "Result in [0,0] MODE.MULT({1,2,5,5,5,4,4,4,7,7,7,2,2,1,1}");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 2, "Result in [1,0] MODE.MULT({1,2,5,5,5,4,4,4,7,7,7,2,2,1,1}");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 5, "Result in [2,0] MODE.MULT({1,2,5,5,5,4,4,4,7,7,7,2,2,1,1}");
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), 4, "Result in [3,0] MODE.MULT({1,2,5,5,5,4,4,4,7,7,7,2,2,1,1}");
		assert.strictEqual(array.getElementRowCol(4, 0).getValue(), 7, "Result in [4,0] MODE.MULT({1,2,5,5,5,4,4,4,7,7,7,2,2,1,1}");
		assert.strictEqual(array.getElementRowCol(5, 0).getValue(), "", "Result in [5,0] MODE.MULT({1,2,5,5,5,4,4,4,7,7,7,2,2,1,1}");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("B101").setValue("4");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("2");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(2,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(2,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Number. Basic valid input: numbers with a mode. 3 arguments used.');
		// Case #1: Number. Multiple numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(1,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(1,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number. Multiple numbers with a mode. 3 arguments used.');
		// Case #2: Number. Multiple numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(1.5,1.5,2.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(1.5,1.5,2.7) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1.5, 'Test: Positive case: Number. Multiple numbers with a mode. 3 arguments used.');
		// Case #3: String. Numeric strings converted to numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT("2","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT("2","2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Numeric strings converted to numbers with a mode. 3 arguments used.');
		// Case #4: Formula. Nested formula returning numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(SQRT(4),SQRT(4),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(SQRT(4),SQRT(4),3) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Formula. Nested formula returning numbers with a mode. 3 arguments used.');
		// Case #5: Reference link. References to cells with numbers having a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(A100,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. References to cells with numbers having a mode. 3 arguments used.');
		// Case #6: Area. Single range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.MULT(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(A100:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area. Single range with numbers having a mode. 1 argument used.');
		// Case #7: Array. Array with single mode. 1 argument used.
		oParser = new parserFormula('MODE.MULT({2,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT({2,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Array. Array with single mode. 1 argument used.');
		// Case #8: Name. Named range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.MULT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name. Named range with numbers having a mode. 1 argument used.');
		// Case #9: Name3D. 3D named range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.MULT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name3D. 3D named range with numbers having a mode. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with a number. 1 argument used.
		oParser = new parserFormula('MODE.MULT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(Sheet2!A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D reference to cell with a number. 1 argument used.');
		// Case #11: Area3D. 3D range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.MULT(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Area3D. 3D range with numbers having a mode. 1 argument used.');
		// Case #12: Table. Table column with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.MULT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Table. Table column with numbers having a mode. 1 argument used.');
		// Case #13: Date. Dates as serial numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(DATE(2025,1,1),DATE(2025,1,1),DATE(2025,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(DATE(2025,1,1),DATE(2025,1,1),DATE(2025,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 45658, 'Test: Positive case: Date. Dates as serial numbers with a mode. 3 arguments used.');
		// Case #14: Time. Time values as fractions with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(TIME(1,0,0),TIME(1,0,0),TIME(2,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(TIME(1,0,0),TIME(1,0,0),TIME(2,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(4), "0.0417", 'Test: Positive case: Time. Time values as fractions with a mode. 3 arguments used.');
		// Case #15: Formula. MODE inside SUM formula. 3 arguments used.
		oParser = new parserFormula('SUM(MODE.MULT(2,2,3),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MODE.MULT(2,2,3),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. MODE inside SUM formula. 3 arguments used.');
		// Case #16: Formula. Nested IF returning numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(IF(TRUE,2,1),IF(TRUE,2,1),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(IF(TRUE,2,1),IF(TRUE,2,1),3) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 2, 'Test: Positive case: Formula. Nested IF returning numbers with a mode. 3 arguments used.');
		// Case #17: String. Numeric strings with decimal points converted to numbers. 3 arguments used.
		oParser = new parserFormula('MODE.MULT("1.5","1.5","2.7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT("1.5","1.5","2.7") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Numeric strings with decimal points converted to numbers. 3 arguments used.');
		// Case #18: Array. Array with multiple elements and a mode. 1 argument used.
		oParser = new parserFormula('MODE.MULT({1,1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT({1,1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Array. Array with multiple elements and a mode. 1 argument used.');
		// Case #19: Reference link. References to cells with identical values (mode exists). 2 arguments used.
		oParser = new parserFormula('MODE.MULT(A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. References to cells with identical values (mode exists). 2 arguments used.');
		// Case #20: Area. Single-cell range with identical values (mode exists). 1 argument used.
		oParser = new parserFormula('MODE.MULT(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area. Single-cell range with identical values (mode exists). 1 argument used.');

		// Negative cases:
		// Case #1: Number. No mode exists (all unique values), returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. No mode exists (all unique values), returns #NUM!. 3 arguments used.');
		// Case #2: String. Non-numeric strings, returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('MODE.MULT("abc","abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT("abc","abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Non-numeric strings, returns #VALUE!. 3 arguments used.');
		// Case #3: Error. Propagates #N/A error. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(NA(),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(NA(),1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 arguments used.');
		// Case #4: Area. Multi-cell range with no mode, returns #NUM!. 1 argument used.
		oParser = new parserFormula('MODE.MULT(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(A105:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area. Multi-cell range with no mode, returns #NUM!. 1 argument used.');
		// Case #5: Empty. Reference to empty cell, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE.MULT(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference to empty cell, returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean inputs, returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(TRUE,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(TRUE,TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean. Boolean inputs, returns #VALUE!. 3 arguments used.');
		// Case #7: Ref3D. 3D reference to text cell, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE.MULT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(Sheet2!A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text cell, returns #VALUE!. 1 argument used.');
		// Case #8: Name. Named range with text, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE.MULT(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with text, returns #VALUE!. 1 argument used.');
		// Case #10: Formula. Formula resulting in #NUM! error, propagates error. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(SQRT(-1),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(SQRT(-1),1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error, propagates error. 3 arguments used.');
		// Case #11: Array. Array with booleans, returns #N/A'. 1 argument used.
		oParser = new parserFormula('MODE.MULT({FALSE,TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT({FALSE,TRUE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Array with booleans, returns #VALUE!. 1 argument used.');
		// Case #12: Number. Number exceeds Excel’s limit, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(1E+308,1E+308,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(1E+308,1E+308,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.00E+307, 'Test: Negative case: Number. Number exceeds Excel’s limit, returns #NUM!. 3 arguments used.');
		// Case #13: String. Empty string, returns #N/A'!. 3 arguments used.
		oParser = new parserFormula('MODE.MULT("","1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT("","1","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Empty string, returns #VALUE!. 3 arguments used.');
		// Case #14: Area3D. 3D range with text, returns #N/A'. 1 argument used.
		oParser = new parserFormula('MODE.MULT(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area3D. 3D range with text, returns #VALUE!. 1 argument used.');
		// Case #15: Name3D. 3D named range with text, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE.MULT(TestName3DArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(TestName3DArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with text, returns #VALUE!. 1 argument used.');
		// Case #16: Reference link. References to cells with no mode, returns #NUM!. 2 arguments used.
		oParser = new parserFormula('MODE.MULT(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. References to cells with no mode, returns #NUM!. 2 arguments used.');
		// Case #17: Array. Array with no mode, returns #NUM!. 1 argument used.
		oParser = new parserFormula('MODE.MULT({1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT({1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Array with no mode, returns #NUM!. 1 argument used.');
		// Case #18: Formula. Nested IF producing unique values, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(IF(FALSE,1,2),IF(FALSE,1,3),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(IF(FALSE,1,2),IF(FALSE,1,3),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Nested IF producing unique values, returns #NUM!. 3 arguments used.');
		// Case #19: Date. Unique date serial numbers, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Date. Unique date serial numbers, returns #NUM!. 3 arguments used.');
		// Case #20: Time. Unique time fractions, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Time. Unique time fractions, returns #NUM!. 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimal positive number with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(1E-307,1E-307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(1E-307,1E-307,2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1e-307, 'Test: Bounded case: Number. Minimal positive number with a mode. 3 arguments used.');
		// Case #2: Number. Maximal valid Excel number with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.MULT(9.99999999999999E+307,9.99999999999999E+307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT(9.99999999999999E+307,9.99999999999999E+307,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1e+308, 'Test: Bounded case: Number. Maximal valid Excel number with a mode. 3 arguments used.');
		// Case #3: Array. Array with equal frequency modes (Excel returns first mode). 1 argument used.
		oParser = new parserFormula('MODE.MULT({1,1,2,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.MULT({1,1,2,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Bounded case: Array. Array with equal frequency modes (Excel returns first mode). 1 argument used.');

		// TODO должна ли функция всегда возвращать массив, даже при единичных значениях?
		// Need to fix: error handle, error different types return
		// Case #3: String. Numeric strings converted to numbers with a mode. 3 arguments used.
		// Case #5: Reference link. References to cells with numbers having a mode. 3 arguments used.
		// Case #6: Area. Single range with numbers having a mode. 1 argument used.
		// Case #17: String. Numeric strings with decimal points converted to numbers. 3 arguments used.
		// Case #2: String. Non-numeric strings, returns #VALUE!. 3 arguments used.
		// Case #3: Error. Propagates #N/A error. 3 arguments used.
		// Case #4: Area. Multi-cell range with no mode, returns #NUM!. 1 argument used.
		// Case #6: Boolean. Boolean inputs, returns #VALUE!. 3 arguments used.
		// Case #7: Ref3D. 3D reference to text cell, returns #VALUE!. 1 argument used.
		// Case #8: Name. Named range with text, returns #VALUE!. 1 argument used.
		// Case #10: Formula. Formula resulting in #NUM! error, propagates error. 3 arguments used.
		// Case #11: Array. Array with booleans, returns #VALUE!. 1 argument used.
		// Case #12: Number. Number exceeds Excel’s limit, returns #NUM!. 3 arguments used.
		// Case #2: Number. Maximal valid Excel number with a mode. 3 arguments used.

	});

	QUnit.test("Test: \"MODE.SNGL \"", function (assert) {
		// func working the same as old MODE

		ws.getRange2("F202").setValue("5.6");
		ws.getRange2("F203").setValue("4");
		ws.getRange2("F204").setValue("4");
		ws.getRange2("F205").setValue("3");
		ws.getRange2("F206").setValue("2");
		ws.getRange2("F207").setValue("4");

		oParser = new parserFormula("MODE.SNGL(F202:F207)", "F1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 4);

		ws.getRange2("G2").setValue("1");
		ws.getRange2("G3").setValue("1");
		ws.getRange2("G4").setValue("2");
		ws.getRange2("G5").setValue("2");
		ws.getRange2("G6").setValue("3");

		oParser = new parserFormula("MODE.SNGL(G2:G6)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.SNGL(G2:G6)");
		array = oParser.calculate();
		assert.strictEqual(array.getValue(), 1);

		// number
		oParser = new parserFormula("MODE.SNGL(12)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.SNGL(12)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result MODE.SNGL(12)");

		// string
		oParser = new parserFormula("MODE.SNGL(hello)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.SNGL(hello)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE.SNGL('hello')");

		// bool
		oParser = new parserFormula("MODE.SNGL(TRUE)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.SNGL(TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result MODE.SNGL(TRUE)");

		// array
		oParser = new parserFormula("MODE.SNGL({1;1;2;2;3})", "H1", ws);
		assert.ok(oParser.parse(), "MODE.SNGL({1;1;2;2;3})");
		assert.strictEqual(oParser.calculate().getValue(), 1, "Result in MODE.SNGL({1;1;2;2;3})");

		// multiple args
		oParser = new parserFormula("MODE.SNGL({1,2,3,4,5,6,7,8,9,10},10,10,11,11,11)", "H1", ws);
		assert.ok(oParser.parse(), "MODE.SNGL(1,2,3,4,5,6,7,8,9,10)");
		assert.strictEqual(oParser.calculate().getValue(), 10, "Result MODE.SNGL({1,2,3,4,5,6,7,8,9,10},10,10,11,11,11)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("B101").setValue("4");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("2");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(2,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(2,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Basic valid input: numbers with a mode. 3 arguments used.');
		// Case #1: Number. Multiple numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(1,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(1,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Multiple numbers with a mode. 3 arguments used.');
		// Case #2: Number. Multiple numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(1.5,1.5,2.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(1.5,1.5,2.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Number. Multiple numbers with a mode. 3 arguments used.');
		// Case #3: String. Numeric strings converted to numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL("2","2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL("2","2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Numeric strings converted to numbers with a mode. 3 arguments used.');
		// Case #4: Formula. Nested formula returning numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(SQRT(4),SQRT(4),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(SQRT(4),SQRT(4),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Nested formula returning numbers with a mode. 3 arguments used.');
		// Case #5: Reference link. References to cells with numbers having a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(A100,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. References to cells with numbers having a mode. 3 arguments used.');
		// Case #6: Area. Single range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(A100:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area. Single range with numbers having a mode. 1 argument used.');
		// Case #7: Array. Array with single mode. 1 argument used.
		oParser = new parserFormula('MODE.SNGL({2,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL({2,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array. Array with single mode. 1 argument used.');
		// Case #8: Name. Named range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name. Named range with numbers having a mode. 1 argument used.');
		// Case #9: Name3D. 3D named range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name3D. 3D named range with numbers having a mode. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cell with a number. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(Sheet2!A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D reference to cell with a number. 1 argument used.');
		// Case #11: Area3D. 3D range with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D range with numbers having a mode. 1 argument used.');
		// Case #12: Table. Table column with numbers having a mode. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Table. Table column with numbers having a mode. 1 argument used.');
		// Case #13: Date. Dates as serial numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(DATE(2025,1,1),DATE(2025,1,1),DATE(2025,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(DATE(2025,1,1),DATE(2025,1,1),DATE(2025,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date. Dates as serial numbers with a mode. 3 arguments used.');
		// Case #14: Time. Time values as fractions with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(TIME(1,0,0),TIME(1,0,0),TIME(2,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(TIME(1,0,0),TIME(1,0,0),TIME(2,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), "0.0417", 'Test: Positive case: Time. Time values as fractions with a mode. 3 arguments used.');
		// Case #15: Formula. MODE inside SUM formula. 3 arguments used.
		oParser = new parserFormula('SUM(MODE.SNGL(2,2,3),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MODE.SNGL(2,2,3),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. MODE inside SUM formula. 3 arguments used.');
		// Case #16: Formula. Nested IF returning numbers with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(IF(TRUE,2,1),IF(TRUE,2,1),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(IF(TRUE,2,1),IF(TRUE,2,1),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. Nested IF returning numbers with a mode. 3 arguments used.');
		// Case #17: String. Numeric strings with decimal points converted to numbers. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL("1.5","1.5","2.7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL("1.5","1.5","2.7") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Numeric strings with decimal points converted to numbers. 3 arguments used.');
		// Case #18: Array. Array with multiple elements and a mode. 1 argument used.
		oParser = new parserFormula('MODE.SNGL({1,1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL({1,1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Array with multiple elements and a mode. 1 argument used.');
		// Case #19: Reference link. References to cells with identical values (mode exists). 2 arguments used.
		oParser = new parserFormula('MODE.SNGL(A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link. References to cells with identical values (mode exists). 2 arguments used.');
		// Case #20: Area. Single-cell range with identical values (mode exists). 1 argument used.
		oParser = new parserFormula('MODE.SNGL(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area. Single-cell range with identical values (mode exists). 1 argument used.');

		// Negative cases:
		// Case #1: Number. No mode exists (all unique values), returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. No mode exists (all unique values), returns #NUM!. 3 arguments used.');
		// Case #2: String. Non-numeric strings, returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL("abc","abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL("abc","abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Non-numeric strings, returns #VALUE!. 3 arguments used.');
		// Case #3: Error. Propagates #N/A error. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(NA(),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(NA(),1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 arguments used.');
		// Case #4: Area. Multi-cell range with no mode, returns #NUM!. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(A105:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area. Multi-cell range with no mode, returns #NUM!. 1 argument used.');
		// Case #5: Empty. Reference to empty cell, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Reference to empty cell, returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean inputs, returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(TRUE,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(TRUE,TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean. Boolean inputs, returns #VALUE!. 3 arguments used.');
		// Case #7: Ref3D. 3D reference to text cell, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(Sheet2!A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text cell, returns #VALUE!. 1 argument used.');
		// Case #8: Name. Named range with text, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with text, returns #VALUE!. 1 argument used.');
		// Case #10: Formula. Formula resulting in #NUM! error, propagates error. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(SQRT(-1),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(SQRT(-1),1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error, propagates error. 3 arguments used.');
		// Case #11: Array. Array with booleans, returns #N/A'. 1 argument used.
		oParser = new parserFormula('MODE.SNGL({FALSE,TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL({FALSE,TRUE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Array with booleans, returns #VALUE!. 1 argument used.');
		// Case #12: Number. Number exceeds Excel’s limit, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(1E+308,1E+308,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(1E+308,1E+308,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.00E+307, 'Test: Negative case: Number. Number exceeds Excel’s limit, returns #NUM!. 3 arguments used.');
		// Case #13: String. Empty string, returns #N/A'!. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL("","1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL("","1","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Empty string, returns #VALUE!. 3 arguments used.');
		// Case #14: Area3D. 3D range with text, returns #N/A'. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area3D. 3D range with text, returns #VALUE!. 1 argument used.');
		// Case #15: Name3D. 3D named range with text, returns #VALUE!. 1 argument used.
		oParser = new parserFormula('MODE.SNGL(TestName3DArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(TestName3DArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with text, returns #VALUE!. 1 argument used.');
		// Case #16: Reference link. References to cells with no mode, returns #NUM!. 2 arguments used.
		oParser = new parserFormula('MODE.SNGL(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. References to cells with no mode, returns #NUM!. 2 arguments used.');
		// Case #17: Array. Array with no mode, returns #NUM!. 1 argument used.
		oParser = new parserFormula('MODE.SNGL({1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL({1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Array with no mode, returns #NUM!. 1 argument used.');
		// Case #18: Formula. Nested IF producing unique values, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(IF(FALSE,1,2),IF(FALSE,1,3),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(IF(FALSE,1,2),IF(FALSE,1,3),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Nested IF producing unique values, returns #NUM!. 3 arguments used.');
		// Case #19: Date. Unique date serial numbers, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Date. Unique date serial numbers, returns #NUM!. 3 arguments used.');
		// Case #20: Time. Unique time fractions, returns #NUM!. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(TIME(1,0,0),TIME(2,0,0),TIME(3,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Time. Unique time fractions, returns #NUM!. 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimal positive number with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(1E-307,1E-307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(1E-307,1E-307,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimal positive number with a mode. 3 arguments used.');
		// Case #2: Number. Maximal valid Excel number with a mode. 3 arguments used.
		oParser = new parserFormula('MODE.SNGL(9.99999999999999E+307,9.99999999999999E+307,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL(9.99999999999999E+307,9.99999999999999E+307,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1e+308, 'Test: Bounded case: Number. Maximal valid Excel number with a mode. 3 arguments used.');
		// Case #3: Array. Array with equal frequency modes (Excel returns first mode). 1 argument used.
		oParser = new parserFormula('MODE.SNGL({1,1,2,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MODE.SNGL({1,1,2,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array. Array with equal frequency modes (Excel returns first mode). 1 argument used.');

		// Need to fix: error handle, error different types return
		// Case #3: String. Numeric strings converted to numbers with a mode. 3 arguments used.
		// Case #5: Reference link. References to cells with numbers having a mode. 3 arguments used.
		// Case #6: Area. Single range with numbers having a mode. 1 argument used.
		// Case #17: String. Numeric strings with decimal points converted to numbers. 3 arguments used.
		// Case #2: String. Non-numeric strings, returns #VALUE!. 3 arguments used.
		// Case #3: Error. Propagates #N/A error. 3 arguments used.
		// Case #4: Area. Multi-cell range with no mode, returns #NUM!. 1 argument used.
		// Case #6: Boolean. Boolean inputs, returns #VALUE!. 3 arguments used.
		// Case #7: Ref3D. 3D reference to text cell, returns #VALUE!. 1 argument used.
		// Case #8: Name. Named range with text, returns #VALUE!. 1 argument used.
		// Case #10: Formula. Formula resulting in #NUM! error, propagates error. 3 arguments used.
		// Case #11: Array. Array with booleans, returns #VALUE!. 1 argument used.
		// Case #12: Number. Number exceeds Excel’s limit, returns #NUM!. 3 arguments used.
		// Case #2: Number. Maximal valid Excel number with a mode. 3 arguments used.

	});

	QUnit.test("Test: \"NEGBINOMDIST\"", function (assert) {

		function negbinomdist(x, r, p) {
			x = parseInt(x);
			r = parseInt(r);
			if (x < 0 || r < 1 || p < 0 || p > 1) {
				return "#NUM!";
			} else {
				return toFixed(Math.binomCoeff(x + r - 1, r - 1) * Math.pow(p, r) * Math.pow(1 - p, x));
			}
		}

		ws.getRange2("F202").setValue("10");
		ws.getRange2("F203").setValue("5");
		ws.getRange2("F204").setValue("0.25");

		oParser = new parserFormula("NEGBINOMDIST(F202,F203,F204)", "F1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.05504866);

		oParser = new parserFormula("NEGBINOMDIST(6,10,0.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), negbinomdist(6, 10, 0.5));

		oParser = new parserFormula("NEGBINOMDIST(6,10,1.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), negbinomdist(6, 10, 1.5));

		oParser = new parserFormula("NEGBINOMDIST(20,10,0.63)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), negbinomdist(20, 10, 0.63));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integers and probability. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(5,5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(5,5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.123046875, 'Test: Positive case: Number. Basic valid input: integers and probability. 3 of 3 arguments used.');
		// Case #1: Number. Valid input: integers and probability. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(10,3,0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(10,3,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10), '0.0000265539', 'Test: Positive case: Number. Valid input: integers and probability. 3 of 3 arguments used.');
		// Case #2: Number. Floats truncated to integers. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(2.5,3.7,0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(2.5,3.7,0.25) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(10), 0.052734375, 'Test: Positive case: Number. Floats truncated to integers. 3 of 3 arguments used.');
		// Case #3: String. Strings convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST("5","5","0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST("5","5","0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.123046875, 'Test: Positive case: String. Strings convertible to numbers. 3 of 3 arguments used.');
		// Case #4: Formula. Nested formulas resolving to valid inputs. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(SQRT(25),ROUND(5.7,0),ABS(-0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(SQRT(25),ROUND(5.7,0),ABS(-0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.123046875, 'Test: Positive case: Formula. Nested formulas resolving to valid inputs. 3 of 3 arguments used.');
		// Case #5: Reference link. Reference links to valid cells. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(A100,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. Reference links to valid cells. 3 of 3 arguments used.');
		// Case #6: Area. Single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(A100:A100,A101:A101,A102:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Single-cell ranges. 3 of 3 arguments used.');
		// Case #7: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST({5},{5},{0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST({5},{5},{0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.123046875, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');
		// Case #8: Name. Named ranges with valid values. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid values. 3 of 3 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid values. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid values. 3 of 3 arguments used.');
		// Case #10: Ref3D. 3D references to valid cells. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to valid cells. 3 of 3 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges. 3 of 3 arguments used.');
		// Case #12: Table. Table structured references with valid values. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured references with valid values. 3 of 3 arguments used.');
		// Case #13: Formula. Probability_s as nested formula. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(5,5,SQRT(0.25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(5,5,SQRT(0.25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.123046875, 'Test: Positive case: Formula. Probability_s as nested formula. 3 of 3 arguments used.');
		// Case #14: Number,String. Mixed number and string inputs. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(5,5,"0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(5,5,"0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.123046875, 'Test: Positive case: Number,String. Mixed number and string inputs. 3 of 3 arguments used.');
		// Case #15: Number. Zero Number_f, valid case. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(0,5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(0,5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03125, 'Test: Positive case: Number. Zero Number_f, valid case. 3 of 3 arguments used.');
		// Case #16: Reference link. Reusing reference links with valid values. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(A103,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(A103,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. Reusing reference links with valid values. 3 of 3 arguments used.');
		// Case #17: Formula. Formulas resolving to valid inputs. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(ABS(-5),ROUND(5.2,0),SQRT(0.25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(ABS(-5),ROUND(5.2,0),SQRT(0.25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.123046875, 'Test: Positive case: Formula. Formulas resolving to valid inputs. 3 of 3 arguments used.');
		// Case #18: String. All string inputs convertible to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST("10","3","0.75")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST("10","3","0.75") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10), '0.0000265539', 'Test: Positive case: String. All string inputs convertible to valid values. 3 of 3 arguments used.');
		// Case #19: Array. Arrays with multiple valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST({10,5},{3,5},{0.75,0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST({10,5},{3,5},{0.75,0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10), '0.0000265539', 'Test: Positive case: Array. Arrays with multiple valid elements. 3 of 3 arguments used.');
		// Case #20: Formula,Number. Probability_s via formula, other args numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(5,5,ABS(-0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(5,5,ABS(-0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.123046875, 'Test: Positive case: Formula,Number. Probability_s via formula, other args numbers. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative Number_f returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(-1,5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(-1,5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative Number_f returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Negative Number_s returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(5,-1,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(5,-1,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative Number_s returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Negative Probability_s returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(5,5,-0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(5,5,-0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative Probability_s returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. Probability_s > 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(5,5,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(5,5,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability_s > 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #5: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST("abc",5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST("abc",5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(NA(),5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(NA(),5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #7: Area. Multi-cell range returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(A100:A101,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(A100:A101,A101:A101,A102:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range returns #NUM!. 3 of 3 arguments used.');
		// Case #8: Empty. Empty reference link returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(A104,5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(A104,5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty reference link returns #NUM!. 3 of 3 arguments used.');
		// Case #9: String. Empty string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST("",5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST("",5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Boolean. Boolean FALSE (0) is valid, but testing for clarity. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(FALSE,5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(FALSE,5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03125, 'Test: Negative case: Boolean. Boolean FALSE (0) is valid, but testing for clarity. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(Sheet2!A5,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(Sheet2!A5,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(TestNameArea2,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(TestNameArea,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(SQRT(-1),5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(SQRT(-1),5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #15: Number. Probability_s = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(5,5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(5,5,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability_s = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Number. Probability_s = 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(5,5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(5,5,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability_s = 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Array. Array with boolean returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST({FALSE},{5},{0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST({FALSE},{5},{0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03125, 'Test: Negative case: Array. Array with boolean returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Area3D. 3D multi-cell range returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Time. Time value (0.5) truncated to 0, valid case. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(TIME(12,0,0),5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(TIME(12,0,0),5,0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.03125, 'Test: Negative case: Time. Time value (0.5) truncated to 0, valid case. 3 of 3 arguments used.');
		// Case #20: Date. Date as large number, valid but impractical. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(DATE(2025,1,1),5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(DATE(2025,1,1),5,0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Date. Date as large number, valid but impractical. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid values for Number_f, Number_s, and Probability_s. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(0,0,0.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(0,0,0.000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid values for Number_f, Number_s, and Probability_s. 3 of 3 arguments used.');
		// Case #2: Number. Large valid integers and max Probability_s. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(1000000,1000000,0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(1000000,1000000,0.999999999999999) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Large valid integers and max Probability_s. 3 of 3 arguments used.');
		// Case #3: Number. Minimum Probability_s with zero Number_f. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(0,5,0.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(0,5,0.000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0000000000000004e-75, 'Test: Bounded case: Number. Minimum Probability_s with zero Number_f. 3 of 3 arguments used.');
		// Case #4: Number. Large Number_f, max Probability_s. 3 of 3 arguments used.
		oParser = new parserFormula('NEGBINOMDIST(1000000,5,0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOMDIST(1000000,5,0.999999999999999) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Large Number_f, max Probability_s. 3 of 3 arguments used.');


		// TODO need to fix different results
		// Need to fix: errors types, ms diff results, area/array handle
		// Case #2: Number. Floats truncated to integers. 3 of 3 arguments used.
		// Case #5: Reference link. Reference links to valid cells. 3 of 3 arguments used.
		// Case #6: Area. Single-cell ranges. 3 of 3 arguments used.
		// Case #12: Table. Table structured references with valid values. 3 of 3 arguments used.
		// Case #16: Reference link. Reusing reference links with valid values. 3 of 3 arguments used.
		// Case #7: Area. Multi-cell range returns #NUM!. 3 of 3 arguments used.
		// Case #15: Number. Probability_s = 0 returns #NUM!. 3 of 3 arguments used.
		// Case #16: Number. Probability_s = 1 returns #NUM!. 3 of 3 arguments used.
		// Case #19: Time. Time value (0.5) truncated to 0, valid case. 3 of 3 arguments used.
		// Case #20: Date. Date as large number, valid but impractical. 3 of 3 arguments used.
		// Case #2: Number. Large valid integers and max Probability_s. 3 of 3 arguments used.
		// Case #4: Number. Large Number_f, max Probability_s. 3 of 3 arguments used.

		testArrayFormula2(assert, "NEGBINOMDIST", 3, 3);
	});

	QUnit.test("Test: \"NEGBINOM.DIST \"", function (assert) {

		ws.getRange2("F202").setValue("10");
		ws.getRange2("F203").setValue("5");
		ws.getRange2("F204").setValue("0.25");

		oParser = new parserFormula("NEGBINOM.DIST(F202,F203,F204,TRUE)", "F1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.3135141);

		oParser = new parserFormula("NEGBINOM.DIST(F202,F203,F204,FALSE)", "F1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0550487);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integers and probability. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(5,5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(5,5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.623046875, 'Test: Positive case: Number. Basic valid input: integers and probability. 4 of 4 arguments used.');
		// Case #1: Number. Valid input: integers, probability, non-cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(10,3,0.75,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(10,3,0.75,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10), '0.0000265539', 'Test: Positive case: Number. Valid input: integers, probability, non-cumulative. 4 of 4 arguments used.');
		// Case #2: Number. Floats truncated to integers. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(2.5,3.7,0.25,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(2.5,3.7,0.25,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.103515625, 'Test: Positive case: Number. Floats truncated to integers. 4 of 4 arguments used.');
		// Case #3: String. Strings convertible to numbers and boolean. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST("5","5","0.5","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST("5","5","0.5","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.623046875, 'Test: Positive case: String. Strings convertible to numbers and boolean. 4 of 4 arguments used.');
		// Case #4: Formula. Nested formulas resolving to valid inputs. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(SQRT(25),ROUND(5.7,0),ABS(-0.5),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(SQRT(25),ROUND(5.7,0),ABS(-0.5),IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Formula. Nested formulas resolving to valid inputs. 4 of 4 arguments used.');
		// Case #5: Reference link. Reference links to valid cells. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. Reference links to valid cells. 4 of 4 arguments used.');
		// Case #6: Area. Single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Single-cell ranges. 4 of 4 arguments used.');
		// Case #7: Array. Arrays with single valid elements. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST({5},{5},{0.5},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST({5},{5},{0.5},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.623046875, 'Test: Positive case: Array. Arrays with single valid elements. 4 of 4 arguments used.');
		// Case #8: Name. Named ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(TestName,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(TestName,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid values. 4 of 4 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid values. 4 of 4 arguments used.');
		// Case #10: Ref3D. 3D references to valid cells. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to valid cells. 4 of 4 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges. 4 of 4 arguments used.');
		// Case #12: Table. Table structured references with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured references with valid values. 4 of 4 arguments used.');
		// Case #13: Formula. Cumulative as nested IF formula. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(5,5,0.5,IF(1>0,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(5,5,0.5,IF(1>0,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.623046875, 'Test: Positive case: Formula. Cumulative as nested IF formula. 4 of 4 arguments used.');
		// Case #14: Number,String. Mixed number and string inputs. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(5,5,"0.5",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(5,5,"0.5",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.623046875, 'Test: Positive case: Number,String. Mixed number and string inputs. 4 of 4 arguments used.');
		// Case #15: Number. Zero Number_f, valid case. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(0,5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(0,5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03125, 'Test: Positive case: Number. Zero Number_f, valid case. 4 of 4 arguments used.');
		// Case #16: Reference link. Reusing reference links with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(A104,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(A104,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. Reusing reference links with valid values. 4 of 4 arguments used.');
		// Case #17: Formula. Formulas resolving to valid inputs. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(ABS(-5),ROUND(5.2,0),SQRT(0.25),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(ABS(-5),ROUND(5.2,0),SQRT(0.25),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.623046875, 'Test: Positive case: Formula. Formulas resolving to valid inputs. 4 of 4 arguments used.');
		// Case #18: String. All string inputs convertible to valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST("10","3","0.75","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST("10","3","0.75","FALSE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.65539E-05, 'Test: Positive case: String. All string inputs convertible to valid values. 4 of 4 arguments used.');
		// Case #19: Array. Arrays with multiple valid elements. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST({10,5},{3,5},{0.75,0.5},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST({10,5},{3,5},{0.75,0.5},{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.999988943', 'Test: Positive case: Array. Arrays with multiple valid elements. 4 of 4 arguments used.');
		// Case #20: Formula,Number. Probability_s via formula, other args numbers. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(5,5,ABS(-0.5),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(5,5,ABS(-0.5),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.623046875, 'Test: Positive case: Formula,Number. Probability_s via formula, other args numbers. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative Number_f returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(-1,5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(-1,5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative Number_f returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number. Negative Number_s returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(5,-1,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(5,-1,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative Number_s returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number. Negative Probability_s returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(5,5,-0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(5,5,-0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative Probability_s returns #NUM!. 4 of 4 arguments used.');
		// Case #4: Number. Probability_s > 1 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(5,5,1.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(5,5,1.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability_s > 1 returns #NUM!. 4 of 4 arguments used.');
		// Case #5: String. Non-numeric string returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST("abc",5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST("abc",5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: Error. Propagates #N/A error. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(NA(),5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(NA(),5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 4 of 4 arguments used.');
		// Case #7: Area. Multi-cell range returns arr. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(A100:A101,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(A100:A101,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Area. Multi-cell range returnsarr. 4 of 4 arguments used.');
		// Case #8: Empty. Empty reference link returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(A105,5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(A105,5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.109375, 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: String. Empty string returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST("",5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST("",5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 4 of 4 arguments used.');
		// Case #10: Boolean. Boolean FALSE (0) is valid, but testing for clarity. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(FALSE,5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(FALSE,5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03125, 'Test: Negative case: Boolean. Boolean FALSE (0) is valid, but testing for clarity. 4 of 4 arguments used.');
		// Case #11: Ref3D. 3D ref to non-numeric value returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 4 of 4 arguments used.');
		// Case #12: Name. Named range with non-numeric value returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(TestNameArea2,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(TestNameArea2,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 4 of 4 arguments used.');
		// Case #14: Formula. Formula resulting in #NUM! error. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(SQRT(-1),5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(SQRT(-1),5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 4 of 4 arguments used.');
		// Case #15: Number. Probability_s = 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(5,5,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(5,5,0,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability_s = 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #16: Number. Probability_s = 1 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(5,5,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(5,5,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability_s = 1 returns #NUM!. 4 of 4 arguments used.');
		// Case #17: Array. Array with boolean returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST({FALSE},{5},{0.5},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST({FALSE},{5},{0.5},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03125, 'Test: Negative case: Array. Array with boolean returns #NUM!. 4 of 4 arguments used.');
		// Case #18: Area3D. 3D multi-cell range returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 4 of 4 arguments used.');
		// Case #19: Time. Time value (0.5) truncated to 0, valid case. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(TIME(12,0,0),5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(TIME(12,0,0),5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03125, 'Test: Negative case: Time. Time value (0.5) truncated to 0, valid case. 4 of 4 arguments used.');
		// Case #20: Date. Date as large number, valid but impractical. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(DATE(2025,1,1),5,0.5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(DATE(2025,1,1),5,0.5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Date. Date as large number, valid but impractical. 4 of 4 arguments used.');

		// Bounded cases:

		// Case #1: Number. Minimum valid values for Number_f, Number_s, and Probability_s. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(0,0,0.000000000000001,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(0,0,0.000000000000001,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid values for Number_f, Number_s, and Probability_s. 4 of 4 arguments used.');
		// Case #2: Number. Large valid integers and max Probability_s. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(1000000,1000000,0.999999999999999,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(1000000,1000000,0.999999999999999,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Large valid integers and max Probability_s. 4 of 4 arguments used.');
		// Case #3: Number. Minimum Probability_s, non-cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(0,5,0.000000000000001,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(0,5,0.000000000000001,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0000000000000004e-75, 'Test: Bounded case: Number. Minimum Probability_s, non-cumulative. 4 of 4 arguments used.');
		// Case #4: Number. Large Number_f, max Probability_s, non-cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('NEGBINOM.DIST(1000000,5,0.999999999999999,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NEGBINOM.DIST(1000000,5,0.999999999999999,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Large Number_f, max Probability_s, non-cumulative. 4 of 4 arguments used.');

		// Need to fix: area/array handle, error types diff, MS result difference
		// Case #3: String. Strings convertible to numbers and boolean. 4 of 4 arguments used.
		// Case #12: Table. Table structured references with valid values. 4 of 4 arguments used.
		// Case #18: String. All string inputs convertible to valid values. 4 of 4 arguments used.
		// Case #7: Area. Multi-cell range returns arr. 4 of 4 arguments used.
		// Case #15: Number. Probability_s = 0 returns #NUM!. 4 of 4 arguments used.
		// Case #16: Number. Probability_s = 1 returns #NUM!. 4 of 4 arguments used.
		// Case #4: Number. Large Number_f, max Probability_s, non-cumulative. 4 of 4 arguments used.

		testArrayFormula2(assert, "NEGBINOM.DIST", 4, 4);
	});

	QUnit.test("Test: \"NORMDIST\"", function (assert) {

		function normdist(x, mue, sigma, kum) {
			if (sigma <= 0) {
				return "#NUM!";
			} else if (kum == false) {
				return toFixed(AscCommonExcel.phi((x - mue) / sigma) / sigma);
			} else {
				return toFixed(0.5 + AscCommonExcel.gauss((x - mue) / sigma));
			}

		}

		oParser = new parserFormula("NORMDIST(42,40,1.5,TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normdist(42, 40, 1.5, true));

		oParser = new parserFormula("NORMDIST(42,40,1.5,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normdist(42, 40, 1.5, false));

		oParser = new parserFormula("NORMDIST(42,40,-1.5,TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normdist(42, 40, -1.5, true));

		oParser = new parserFormula("NORMDIST(1,40,-1.5,TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normdist(1, 40, -1.5, true));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: all numbers, cumulative TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.841344746", 'Test: Positive case: Number. Basic valid input: all numbers, cumulative TRUE. 4 of 4 arguments used.');
		// Case #2: Number. Basic valid input: all numbers, cumulative FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,0,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,0,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.241970725", 'Test: Positive case: Number. Basic valid input: all numbers, cumulative FALSE. 4 of 4 arguments used.');
		// Case #3: String. String convertible to numbers and TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST("1","0","1","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST("1","0","1","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.841344746", 'Test: Positive case: String. String convertible to numbers and TRUE. 4 of 4 arguments used.');
		// Case #4: Formula. Nested formulas returning valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(SQRT(1),ABS(0),SQRT(1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(SQRT(1),ABS(0),SQRT(1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.841344746", 'Test: Positive case: Formula. Nested formulas returning valid numbers. 4 of 4 arguments used.');
		// Case #5: Reference link. Reference to cells with valid numbers and TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(A100,A101,A102,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.125794409, 'Test: Positive case: Reference link. Reference to cells with valid numbers and TRUE. 4 of 4 arguments used.');
		// Case #6: Area. Single-cell ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.125794409, 'Test: Positive case: Area. Single-cell ranges with valid values. 4 of 4 arguments used.');
		// Case #7: Array. Array with single valid elements. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST({1},{0},{1},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST({1},{0},{1},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.841344746", 'Test: Positive case: Array. Array with single valid elements. 4 of 4 arguments used.');
		// Case #8: Name. Named ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(TestName,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(TestName,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.462062856', 'Test: Positive case: Name. Named ranges with valid values. 4 of 4 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid values. 4 of 4 arguments used.');
		// Case #10: Ref3D. 3D references to cells with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells with valid values. 4 of 4 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid values. 4 of 4 arguments used.');
		// Case #12: Table. Table structured references with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Table. Table structured references with valid values. 4 of 4 arguments used.');
		// Case #13: Date. Date as serial number for x. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(DATE(2025,1,1),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(DATE(2025,1,1),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number for x. 4 of 4 arguments used.');
		// Case #14: Time. Time as fractional number for x. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(TIME(12,0,0),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(TIME(12,0,0),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.691462461', 'Test: Positive case: Time. Time as fractional number for x. 4 of 4 arguments used.');
		// Case #15: Formula. NORM.DIST inside SUM formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(NORMDIST(1,0,1,TRUE),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(NORMDIST(1,0,1,TRUE),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.341344746', 'Test: Positive case: Formula. NORM.DIST inside SUM formula. 4 of 4 arguments used.');
		// Case #16: Number. Very small standard_dev. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(0,0,0.0000000001,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(0,0,0.0000000001,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Very small standard_dev. 4 of 4 arguments used.');
		// Case #17: String. Strings convertible to numbers and FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST("1.5","0","1","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST("1.5","0","1","FALSE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.129517596', 'Test: Positive case: String. Strings convertible to numbers and FALSE. 4 of 4 arguments used.');
		// Case #18: Formula. Nested IF returning valid x value. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(IF(TRUE,1,0),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(IF(TRUE,1,0),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.841344746', 'Test: Positive case: Formula. Nested IF returning valid x value. 4 of 4 arguments used.');
		// Case #19: Number. Negative x value, valid input. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(-1,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(-1,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.158655254', 'Test: Positive case: Number. Negative x value, valid input. 4 of 4 arguments used.');
		// Case #20: Array. Array with single elements for probability density. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST({1},{0},{1},{FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST({1},{0},{1},{FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.241970725', 'Test: Positive case: Array. Array with single elements for probability density. 4 of 4 arguments used.');
		// Case #21: Number,Formula. Formula for mean. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,AVERAGE(0,0),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,AVERAGE(0,0),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.841344746', 'Test: Positive case: Number,Formula. Formula for mean. 4 of 4 arguments used.');
		// Case #22: String,Number. String convertible to TRUE for cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST("1",0,1,"1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST("1",0,1,"1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String,Number. String convertible to TRUE for cumulative. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative standard_dev returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,0,-1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,0,-1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative standard_dev returns #NUM!. 4 of 4 arguments used.');
		// Case #2: String. Non-numeric string for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST("abc",0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST("abc",0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #3: Error. Propagates #N/A error. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(NA(),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(NA(),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 4 of 4 arguments used.');
		// Case #4: Area. Multi-cell range returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(A100:A101,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(A100:A101,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: Empty. Empty cell reference for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(A104,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(A104,0,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Empty. Empty cell reference for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: String. Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,0,1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,0,1,"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: Number. Zero standard_dev returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,0,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,0,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero standard_dev returns #NUM!. 4 of 4 arguments used.');
		// Case #8: Ref3D. 3D reference to text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Name. Named range with text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(TestNameArea,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(TestNameArea,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Formula. Formula resulting in #NUM! error for x. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(SQRT(-1),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(SQRT(-1),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error for x. 4 of 4 arguments used.');
		// Case #12: Array. Multi-element array for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST({1,2},0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST({1,2},0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8413447460685429, 'Test: Negative case: Array. Multi-element array for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #13: String. String convertible to negative standard_dev returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST("0.5",0,"-1","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST("0.5",0,"-1","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to negative standard_dev returns #NUM!. 4 of 4 arguments used.');
		// Case #14: Boolean. Boolean FALSE (0) for x is valid but tests edge case. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(FALSE,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(FALSE,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Boolean. Boolean FALSE (0) for x is valid but tests edge case. 4 of 4 arguments used.');
		// Case #15: Number. Very small standard_dev may cause #NUM! due to precision limits. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,0,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,0,1E-307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Very small standard_dev due to precision limits. 4 of 4 arguments used.');
		// Case #16: Area3D. 3D multi-cell range returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 4 of 4 arguments used.');
		// Case #17: Name3D. 3D named range with text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(TestNameArea3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(TestNameArea3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 4 of 4 arguments used.');
		// Case #18: String. Empty string for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST("",0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST("",0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #19: Formula. NA() for mean propagates #N/A error. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,NA(),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,NA(),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. NA() for mean propagates #N/A error. 4 of 4 arguments used.');
		// Case #20: Array. Multi-element array for cumulative returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,0,1,{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,0,1,{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.841344746', 'Test: Negative case: Array. Multi-element array for cumulative returns #VALUE!. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number. Maximum valid x value. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1E+307,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1E+307,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid x value. 4 of 4 arguments used.');
		// Case #2: Number. Minimum valid x value. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(-1E+307,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(-1E+307,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid x value. 4 of 4 arguments used.');
		// Case #3: Number. Maximum valid mean value. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(0,1E+307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(0,1E+307,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid mean value. 4 of 4 arguments used.');
		// Case #4: Number. Minimum valid mean value. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(0,-1E+307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(0,-1E+307,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid mean value. 4 of 4 arguments used.');
		// Case #5: Number. Minimum valid standard_dev value. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(0,0,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(0,0,1E-307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Minimum valid standard_dev value. 4 of 4 arguments used.');
		// Case #6: String. String convertible to TRUE for cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,0,1,"1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,0,1,"1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: String. String convertible to TRUE for cumulative. 4 of 4 arguments used.');
		// Case #7: String. String convertible to FALSE for cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('NORMDIST(1,0,1,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDIST(1,0,1,"0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: String. String convertible to FALSE for cumulative. 4 of 4 arguments used.');

		// TODO need to fix critical error when trying to convert val to Bool
		// Case #5: Reference link. Reference to cells with valid numbers and TRUE. 4 of 4 arguments used.
		// Case #6: Area. Single-cell ranges with valid values. 4 of 4 arguments used.
		// Case #22: String,Number. String convertible to TRUE for cumulative. 4 of 4 arguments used. Critical
		// Case #5: Empty. Empty cell reference for x returns #VALUE!. 4 of 4 arguments used.
		// Case #6: String. Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.
		// Case #6: String. String convertible to TRUE for cumulative. 4 of 4 arguments used.


		testArrayFormula2(assert, "NORMDIST", 4, 4);
	});

	QUnit.test("Test: \"NORM.DIST \"", function (assert) {

		ws.getRange2("F202").setValue("42");
		ws.getRange2("F203").setValue("40");
		ws.getRange2("F204").setValue("1.5");

		oParser = new parserFormula("NORM.DIST(F202,F203,F204,TRUE)", "F1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.9087888);

		oParser = new parserFormula("NORM.DIST(F202,F203,F204,FALSE)", "F1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 0.10934);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: all numbers, cumulative TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.841344746", 'Test: Positive case: Number. Basic valid input: all numbers, cumulative TRUE. 4 of 4 arguments used.');
		// Case #2: Number. Basic valid input: all numbers, cumulative FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,0,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,0,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.241970725", 'Test: Positive case: Number. Basic valid input: all numbers, cumulative FALSE. 4 of 4 arguments used.');
		// Case #3: String. String convertible to numbers and TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST("1","0","1","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST("1","0","1","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.841344746", 'Test: Positive case: String. String convertible to numbers and TRUE. 4 of 4 arguments used.');
		// Case #4: Formula. Nested formulas returning valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(SQRT(1),ABS(0),SQRT(1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(SQRT(1),ABS(0),SQRT(1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.841344746", 'Test: Positive case: Formula. Nested formulas returning valid numbers. 4 of 4 arguments used.');
		// Case #5: Reference link. Reference to cells with valid numbers and TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(A100,A101,A102,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.125794409, 'Test: Positive case: Reference link. Reference to cells with valid numbers and TRUE. 4 of 4 arguments used.');
		// Case #6: Area. Single-cell ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.125794409, 'Test: Positive case: Area. Single-cell ranges with valid values. 4 of 4 arguments used.');
		// Case #7: Array. Array with single valid elements. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST({1},{0},{1},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST({1},{0},{1},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), "0.841344746", 'Test: Positive case: Array. Array with single valid elements. 4 of 4 arguments used.');
		// Case #8: Name. Named ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(TestName,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(TestName,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.462062856', 'Test: Positive case: Name. Named ranges with valid values. 4 of 4 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid values. 4 of 4 arguments used.');
		// Case #10: Ref3D. 3D references to cells with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells with valid values. 4 of 4 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid values. 4 of 4 arguments used.');
		// Case #12: Table. Table structured references with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Table. Table structured references with valid values. 4 of 4 arguments used.');
		// Case #13: Date. Date as serial number for x. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(DATE(2025,1,1),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(DATE(2025,1,1),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number for x. 4 of 4 arguments used.');
		// Case #14: Time. Time as fractional number for x. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(TIME(12,0,0),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(TIME(12,0,0),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.691462461', 'Test: Positive case: Time. Time as fractional number for x. 4 of 4 arguments used.');
		// Case #15: Formula. NORM.DIST inside SUM formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(NORM.DIST(1,0,1,TRUE),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(NORM.DIST(1,0,1,TRUE),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.341344746', 'Test: Positive case: Formula. NORM.DIST inside SUM formula. 4 of 4 arguments used.');
		// Case #16: Number. Very small standard_dev. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(0,0,0.0000000001,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(0,0,0.0000000001,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Very small standard_dev. 4 of 4 arguments used.');
		// Case #17: String. Strings convertible to numbers and FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST("1.5","0","1","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST("1.5","0","1","FALSE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.129517596', 'Test: Positive case: String. Strings convertible to numbers and FALSE. 4 of 4 arguments used.');
		// Case #18: Formula. Nested IF returning valid x value. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(IF(TRUE,1,0),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(IF(TRUE,1,0),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.841344746', 'Test: Positive case: Formula. Nested IF returning valid x value. 4 of 4 arguments used.');
		// Case #19: Number. Negative x value, valid input. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(-1,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(-1,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.158655254', 'Test: Positive case: Number. Negative x value, valid input. 4 of 4 arguments used.');
		// Case #20: Array. Array with single elements for probability density. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST({1},{0},{1},{FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMDINORM.DISTST({1},{0},{1},{FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.241970725', 'Test: Positive case: Array. Array with single elements for probability density. 4 of 4 arguments used.');
		// Case #21: Number,Formula. Formula for mean. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,AVERAGE(0,0),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,AVERAGE(0,0),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.841344746', 'Test: Positive case: Number,Formula. Formula for mean. 4 of 4 arguments used.');
		// Case #22: String,Number. String convertible to TRUE for cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST("1",0,1,"1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST("1",0,1,"1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String,Number. String convertible to TRUE for cumulative. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative standard_dev returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,0,-1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,0,-1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative standard_dev returns #NUM!. 4 of 4 arguments used.');
		// Case #2: String. Non-numeric string for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST("abc",0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST("abc",0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #3: Error. Propagates #N/A error. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(NA(),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(NA(),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 4 of 4 arguments used.');
		// Case #4: Area. Multi-cell range returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(A100:A101,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(A100:A101,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: Empty. Empty cell reference for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(A104,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(A104,0,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Empty. Empty cell reference for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: String. Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,0,1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,0,1,"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: Number. Zero standard_dev returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,0,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,0,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero standard_dev returns #NUM!. 4 of 4 arguments used.');
		// Case #8: Ref3D. 3D reference to text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Name. Named range with text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(TestNameArea,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(TestNameArea,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Formula. Formula resulting in #NUM! error for x. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(SQRT(-1),0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(SQRT(-1),0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error for x. 4 of 4 arguments used.');
		// Case #12: Array. Multi-element array for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST({1,2},0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST({1,2},0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8413447460685429, 'Test: Negative case: Array. Multi-element array for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #13: String. String convertible to negative standard_dev returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST("0.5",0,"-1","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST("0.5",0,"-1","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to negative standard_dev returns #NUM!. 4 of 4 arguments used.');
		// Case #14: Boolean. Boolean FALSE (0) for x is valid but tests edge case. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(FALSE,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(FALSE,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Boolean. Boolean FALSE (0) for x is valid but tests edge case. 4 of 4 arguments used.');
		// Case #15: Number. Very small standard_dev may cause #NUM! due to precision limits. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,0,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,0,1E-307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Very small standard_dev due to precision limits. 4 of 4 arguments used.');
		// Case #16: Area3D. 3D multi-cell range returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 4 of 4 arguments used.');
		// Case #17: Name3D. 3D named range with text returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(TestNameArea3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(TestNameArea3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 4 of 4 arguments used.');
		// Case #18: String. Empty string for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST("",0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST("",0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #19: Formula. NA() for mean propagates #N/A error. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,NA(),1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,NA(),1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. NA() for mean propagates #N/A error. 4 of 4 arguments used.');
		// Case #20: Array. Multi-element array for cumulative returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,0,1,{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,0,1,{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.841344746', 'Test: Negative case: Array. Multi-element array for cumulative returns #VALUE!. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number. Maximum valid x value. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1E+307,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1E+307,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid x value. 4 of 4 arguments used.');
		// Case #2: Number. Minimum valid x value. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(-1E+307,0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(-1E+307,0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid x value. 4 of 4 arguments used.');
		// Case #3: Number. Maximum valid mean value. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(0,1E+307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(0,1E+307,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid mean value. 4 of 4 arguments used.');
		// Case #4: Number. Minimum valid mean value. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(0,-1E+307,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(0,-1E+307,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid mean value. 4 of 4 arguments used.');
		// Case #5: Number. Minimum valid standard_dev value. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(0,0,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(0,0,1E-307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Minimum valid standard_dev value. 4 of 4 arguments used.');
		// Case #6: String. String convertible to TRUE for cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,0,1,"1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,0,1,"1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: String. String convertible to TRUE for cumulative. 4 of 4 arguments used.');
		// Case #7: String. String convertible to FALSE for cumulative. 4 of 4 arguments used.
		oParser = new parserFormula('NORM.DIST(1,0,1,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.DIST(1,0,1,"0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: String. String convertible to FALSE for cumulative. 4 of 4 arguments used.');

		// TODO need to fix critical error when trying to convert val to Bool
		// Case #5: Reference link. Reference to cells with valid numbers and TRUE. 4 of 4 arguments used.
		// Case #6: Area. Single-cell ranges with valid values. 4 of 4 arguments used.
		// Case #22: String,Number. String convertible to TRUE for cumulative. 4 of 4 arguments used. Critical
		// Case #5: Empty. Empty cell reference for x returns #VALUE!. 4 of 4 arguments used.
		// Case #6: String. Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.
		// Case #6: String. String convertible to TRUE for cumulative. 4 of 4 arguments used.

	});

	QUnit.test("Test: \"NORMSDIST\"", function (assert) {

		function normsdist(x) {
			return toFixed(0.5 + AscCommonExcel.gauss(x));
		}

		oParser = new parserFormula("NORMSDIST(1.333333)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normsdist(1.333333));

		oParser = new parserFormula("NORMSDIST(-1.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normsdist(-1.5));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integer. 1 argument used.
		oParser = new parserFormula('NORMSDIST(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Positive case: Number. Basic valid input: integer. 1 argument used.');
		// Case #1: Number. Negative integer input. 1 argument used.
		oParser = new parserFormula('NORMSDIST(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15865525393145696, 'Test: Positive case: Number. Negative integer input. 1 argument used.');
		// Case #2: Number. Float input. 1 argument used.
		oParser = new parserFormula('NORMSDIST(1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9331927987311419, 'Test: Positive case: Number. Float input. 1 argument used.');
		// Case #3: Number. Zero input. 1 argument used.
		oParser = new parserFormula('NORMSDIST(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Zero input. 1 argument used.');
		// Case #4: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('NORMSDIST("1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST("1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #5: String. Negative numeric string. 1 argument used.
		oParser = new parserFormula('NORMSDIST("-1.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST("-1.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06680720126885809, 'Test: Positive case: String. Negative numeric string. 1 argument used.');
		// Case #6: Formula. Nested formula evaluating to valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(SQRT(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(SQRT(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Positive case: Formula. Nested formula evaluating to valid number. 1 argument used.');
		// Case #7: Formula. Nested IF formula returning valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(IF(TRUE,1,-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(IF(TRUE,1,-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Positive case: Formula. Nested IF formula returning valid number. 1 argument used.');
		// Case #8: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6914624612740136, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #9: Area. Single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9331927987311419, 'Test: Positive case: Area. Single-cell range with valid number. 1 argument used.');
		// Case #10: Array. Array with single numeric element. 1 argument used.
		oParser = new parserFormula('NORMSDIST({1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST({1}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.841344746068543, 'Test: Positive case: Array. Array with single numeric element. 1 argument used.');
		// Case #11: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.30853753872598644, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #12: Name3D. 3D named range with valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.30853753872598644, 'Test: Positive case: Name3D. 3D named range with valid number. 1 argument used.');
		// Case #13: Ref3D. 3D reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6914624612740136, 'Test: Positive case: Ref3D. 3D reference to cell with valid number. 1 argument used.');
		// Case #14: Area3D. 3D single-cell range with valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9331927987311419, 'Test: Positive case: Area3D. 3D single-cell range with valid number. 1 argument used.');
		// Case #15: Table. Table structured reference with valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Positive case: Table. Table structured reference with valid number. 1 argument used.');
		// Case #16: Date. Date as serial number (large number). 1 argument used.
		oParser = new parserFormula('NORMSDIST(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number (large number). 1 argument used.');
		// Case #17: Time. Time adjusted to valid number (>=1). 1 argument used.
		oParser = new parserFormula('NORMSDIST(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9331927987311419, 'Test: Positive case: Time. Time adjusted to valid number (>=1). 1 argument used.');
		// Case #18: Array. Multi-element array, processes first valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST({1.5,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST({1.5,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.9331927987311419, 'Test: Positive case: Array. Multi-element array, processes first valid number. 1 argument used.');
		// Case #19: Formula. Nested formula returning positive number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(ABS(-1.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(ABS(-1.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9331927987311419, 'Test: Positive case: Formula. Nested formula returning positive number. 1 argument used.');
		// Case #20: String. String convertible to zero. 1 argument used.
		oParser = new parserFormula('NORMSDIST("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. String convertible to zero. 1 argument used.');
		// Case #21: Number. Positive integer input. 1 argument used.
		oParser = new parserFormula('NORMSDIST(2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9772498680518208, 'Test: Positive case: Number. Positive integer input. 1 argument used.');
		// Case #22: Formula. Nested formula rounding to valid number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(ROUND(1.555,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(ROUND(1.555,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.940620059405207, 'Test: Positive case: Formula. Nested formula rounding to valid number. 1 argument used.');

		// Negative cases:
		// Case #1: Number. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: Boolean. Boolean input returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Negative case: Boolean. Boolean input returns #VALUE!. 1 argument used.');
		// Case #3: Boolean. Boolean FALSE returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('NORMSDIST(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Area. Multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.691462461, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 1 argument used.');
		// Case #6: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15865525393145696, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #7: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #8: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST({TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST({TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.841344746068543, 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');
		// Case #9: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 1 argument used.');
		// Case #10: Ref3D. 3D reference to non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Ref3D. 3D reference to non-numeric value returns #VALUE!. 1 argument used.');
		// Case #11: Name. Named range with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7881446014198606, 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #12: Name3D. 3D named range with non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7881446014198606, 'Test: Negative case: Name3D. 3D named range with non-numeric value returns #VALUE!. 1 argument used.');
		// Case #14: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('NORMSDIST(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #15: String. Text string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST("Str")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST("Str") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Text string returns #VALUE!. 1 argument used.');
		// Case #16: Array. Array with non-numeric element returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST({1,"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST({1,"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.841344746068543, 'Test: Negative case: Array. Array with non-numeric element returns #VALUE!. 1 argument used.');
		// Case #17: Area. Multi-cell range with mixed data returns #NUM!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(A105:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.841344746, 'Test: Negative case: Area. Multi-cell range with mixed data returns #NUM!. 1 argument used.');
		// Case #18: Ref3D. 3D reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST(Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Ref3D. 3D reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('NORMSDIST(DIVIDE(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(DIVIDE(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #20: Array. Array with only booleans returns #VALUE!. 1 argument used.
		oParser = new parserFormula('NORMSDIST({FALSE,TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST({FALSE,TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.5, 'Test: Negative case: Array. Array with only booleans returns #VALUE!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Maximum valid Excel number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid Excel number. 1 argument used.');
		// Case #2: Number. Minimum valid Excel number. 1 argument used.
		oParser = new parserFormula('NORMSDIST(-9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(-9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid Excel number. 1 argument used.');
		// Case #3: Number. Statistical boundary (z=6, output near 1). 1 argument used.
		oParser = new parserFormula('NORMSDIST(6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.00', 'Test: Bounded case: Number. Statistical boundary (z=6, output near 1). 1 argument used.');
		// Case #4: Number. Statistical boundary (z=-6, output near 0). 1 argument used.
		oParser = new parserFormula('NORMSDIST(-6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSDIST(-6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.86599857366599e-10, 'Test: Bounded case: Number. Statistical boundary (z=-6, output near 0). 1 argument used.');

		// Need to fix: area handle
		// Case #5: Area. Multi-cell range returns #NUM!. 1 argument used.
		// Case #17: Area. Multi-cell range with mixed data returns #NUM!. 1 argument used.

		testArrayFormula(assert, "NORMSDIST");

	});

	QUnit.test("Test: \"NORMINV\"", function (assert) {

		function norminv(x, mue, sigma) {
			if (sigma <= 0.0 || x <= 0.0 || x >= 1.0) {
				return "#NUM!";
			} else {
				return toFixed(AscCommonExcel.gaussinv(x) * sigma + mue);
			}
		}

		oParser = new parserFormula("NORMINV(0.954,40,1.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), norminv(0.954, 40, 1.5));

		oParser = new parserFormula("NORMINV(0.13,100,0.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), norminv(0.13, 100, 0.5));

		oParser = new parserFormula("NORMINV(0.6782136,6,0.005)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), norminv(0.6782136, 6, 0.005));

		oParser = new parserFormula("NORMINV(-1.6782136,7,0)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), norminv(-1.6782136, 7, 0));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: probability=0.5, mean=0, standard_dev=1. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: probability=0.5, mean=0, standard_dev=1. 3 of 3 arguments used.');
		// Case #2: Number. Valid input with positive mean and standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.75,10,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.75,10,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '11.3489795', 'Test: Positive case: Number. Valid input with positive mean and standard_dev. 3 of 3 arguments used.');
		// Case #3: Number. Valid input with negative mean. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.25,-5,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.25,-5,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-7.023469251', 'Test: Positive case: Number. Valid input with negative mean. 3 of 3 arguments used.');
		// Case #4: String. String convertible to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("0.5","0","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("0.5","0","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String convertible to valid numbers. 3 of 3 arguments used.');
		// Case #5: Formula. Nested formulas returning valid values. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(SQRT(0.25),ABS(-10),SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(SQRT(0.25),ABS(-10),SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Nested formulas returning valid values. 3 of 3 arguments used.');
		// Case #6: Reference link. Reference links to cells with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Reference link. Reference links to cells with valid numbers. 3 of 3 arguments used.');
		// Case #7: Area. Single-cell ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell ranges with valid numbers. 3 of 3 arguments used.');
		// Case #8: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV({0.5},{0},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV({0.5},{0},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');
		// Case #9: Name. Named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D references to cells with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells with valid numbers. 3 of 3 arguments used.');
		// Case #12: Area3D. 3D single-cell ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers. 3 of 3 arguments used.');
		// Case #13: Table. Table structured references with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured references with valid numbers. 3 of 3 arguments used.');
		// Case #14: Formula. Nested IF formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(IF(TRUE,0.5,0.1),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(IF(TRUE,0.5,0.1),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula. Nested IF formula for probability. 3 of 3 arguments used.');
		// Case #15: Date. Date converted to valid probability (<1). 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(DATE(2025,1,1)/1000000,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(DATE(2025,1,1)/1000000,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.688496293', 'Test: Positive case: Date. Date converted to valid probability (<1). 3 of 3 arguments used.');
		// Case #16: Time. Time converted to valid probability (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TIME(12,0,0),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TIME(12,0,0),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time. Time converted to valid probability (0.5). 3 of 3 arguments used.');
		// Case #17: Number. High probability value. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.999,100,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.999,100,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '130.9023231', 'Test: Positive case: Number. High probability value. 3 of 3 arguments used.');
		// Case #18: String. String convertible to small probability and standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("0.0001","-100","0.1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("0.0001","-100","0.1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-100.3719016', 'Test: Positive case: String. String convertible to small probability and standard_dev. 3 of 3 arguments used.');
		// Case #19: Formula. NORMINV inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(NORMINV(0.5,0,1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(NORMINV(0.5,0,1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. NORMINV inside SUM formula. 3 of 3 arguments used.');
		// Case #20: Array. Arrays with multiple valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV({0.5,0.7},{0,0},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV({0.5,0.7},{0,0},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Arrays with multiple valid elements. 3 of 3 arguments used.');
		// Case #21: Formula. Multiple nested formulas for all arguments. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(ABS(-0.5),ROUND(10,0),SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(ABS(-0.5),ROUND(10,0),SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Multiple nested formulas for all arguments. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Standard_dev = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Standard_dev = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. Negative standard_dev returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,0,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,0,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative standard_dev returns #NUM!. 3 of 3 arguments used.');
		// Case #5: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("abc",0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("abc",0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(NA(),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(NA(),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #7: Empty. Empty cell reference returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(A106,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(A106,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty cell reference returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: String. Empty string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("",0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("",0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Boolean. Boolean TRUE (1) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TRUE,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TRUE,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean TRUE (1) returns #NUM!. 3 of 3 arguments used.');
		// Case #10: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(A107:A108,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(A107:A108,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference to text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Sheet2!A7,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Sheet2!A7,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Name. Named range with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TestNameArea,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TestNameArea,0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(SQRT(-1),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(SQRT(-1),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #15: Array. Array with boolean returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV({TRUE},0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV({TRUE},0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Number. Negative probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(-0.1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(-0.1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 3 of 3 arguments used.');
		// Case #17: String. String convertible to probability > 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("1.5",0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("1.5",0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to probability > 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Date. Date as large number (>1) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(DATE(2025,1,1),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(DATE(2025,1,1),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date as large number (>1) returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Time. Time = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TIME(0,0,0),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TIME(0,0,0),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #20: Area3D. 3D multi-cell range returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Sheet2!A8:A9,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Sheet2!A8:A9,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(1E-307,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(1E-307,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '-37.47933256', 'Test: Bounded case: Number. Minimum valid probability. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.999999999999999,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.999999999999999,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '7.941444487', 'Test: Bounded case: Number. Maximum valid probability. 3 of 3 arguments used.');
		// Case #3: Number. Minimum valid standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,0,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,0,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid standard_dev. 3 of 3 arguments used.');
		// Case #4: Number. Maximum valid mean. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,1.79769313486232E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,1.79769313486232E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.79769313486232e+307, 'Test: Bounded case: Number. Maximum valid mean. 3 of 3 arguments used.');
		// Case #5: Number. Minimum valid mean. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,-1.79769313486232E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,-1.79769313486232E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.79769313486232e+307, 'Test: Bounded case: Number. Minimum valid mean. 3 of 3 arguments used.');

		// Need to fix:
		// Case #10: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		// Case #12: Name. Named range with text returns #VALUE!. 3 of 3 arguments used.
		// Case #20: Area3D. 3D multi-cell range returns #NUM!. 3 of 3 arguments used.

		testArrayFormula2(assert, "NORMINV", 3, 3);
	});

	QUnit.test("Test: \"NORM.INV \"", function (assert) {

		ws.getRange2("F202").setValue("0.908789");
		ws.getRange2("F203").setValue("40");
		ws.getRange2("F204").setValue("1.5");

		oParser = new parserFormula("NORM.INV(F202,F203,F204)", "F1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 42.000002);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: probability=0.5, mean=0, standard_dev=1. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: probability=0.5, mean=0, standard_dev=1. 3 of 3 arguments used.');
		// Case #2: Number. Valid input with positive mean and standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.75,10,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.75,10,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '11.3489795', 'Test: Positive case: Number. Valid input with positive mean and standard_dev. 3 of 3 arguments used.');
		// Case #3: Number. Valid input with negative mean. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.25,-5,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.25,-5,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-7.023469251', 'Test: Positive case: Number. Valid input with negative mean. 3 of 3 arguments used.');
		// Case #4: String. String convertible to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("0.5","0","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("0.5","0","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String convertible to valid numbers. 3 of 3 arguments used.');
		// Case #5: Formula. Nested formulas returning valid values. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(SQRT(0.25),ABS(-10),SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(SQRT(0.25),ABS(-10),SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Nested formulas returning valid values. 3 of 3 arguments used.');
		// Case #6: Reference link. Reference links to cells with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Reference link. Reference links to cells with valid numbers. 3 of 3 arguments used.');
		// Case #7: Area. Single-cell ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell ranges with valid numbers. 3 of 3 arguments used.');
		// Case #8: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV({0.5},{0},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV({0.5},{0},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');
		// Case #9: Name. Named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #10: Name3D. 3D named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D references to cells with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells with valid numbers. 3 of 3 arguments used.');
		// Case #12: Area3D. 3D single-cell ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers. 3 of 3 arguments used.');
		// Case #13: Table. Table structured references with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured references with valid numbers. 3 of 3 arguments used.');
		// Case #14: Formula. Nested IF formula for probability. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(IF(TRUE,0.5,0.1),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(IF(TRUE,0.5,0.1),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula. Nested IF formula for probability. 3 of 3 arguments used.');
		// Case #15: Date. Date converted to valid probability (<1). 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(DATE(2025,1,1)/1000000,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(DATE(2025,1,1)/1000000,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-1.688496293', 'Test: Positive case: Date. Date converted to valid probability (<1). 3 of 3 arguments used.');
		// Case #16: Time. Time converted to valid probability (0.5). 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TIME(12,0,0),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TIME(12,0,0),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time. Time converted to valid probability (0.5). 3 of 3 arguments used.');
		// Case #17: Number. High probability value. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.999,100,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.999,100,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '130.9023231', 'Test: Positive case: Number. High probability value. 3 of 3 arguments used.');
		// Case #18: String. String convertible to small probability and standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("0.0001","-100","0.1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("0.0001","-100","0.1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-100.3719016', 'Test: Positive case: String. String convertible to small probability and standard_dev. 3 of 3 arguments used.');
		// Case #19: Formula. NORMINV inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(NORMINV(0.5,0,1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(NORMINV(0.5,0,1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. NORMINV inside SUM formula. 3 of 3 arguments used.');
		// Case #20: Array. Arrays with multiple valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV({0.5,0.7},{0,0},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV({0.5,0.7},{0,0},{1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Arrays with multiple valid elements. 3 of 3 arguments used.');
		// Case #21: Formula. Multiple nested formulas for all arguments. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(ABS(-0.5),ROUND(10,0),SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(ABS(-0.5),ROUND(10,0),SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Multiple nested formulas for all arguments. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. Standard_dev = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Standard_dev = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. Negative standard_dev returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,0,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,0,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative standard_dev returns #NUM!. 3 of 3 arguments used.');
		// Case #5: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("abc",0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("abc",0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(NA(),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(NA(),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #7: Empty. Empty cell reference returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(A106,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(A106,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty cell reference returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: String. Empty string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("",0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("",0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Boolean. Boolean TRUE (1) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TRUE,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TRUE,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean TRUE (1) returns #NUM!. 3 of 3 arguments used.');
		// Case #10: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(A107:A108,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(A107:A108,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.');
		// Case #11: Ref3D. 3D reference to text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Sheet2!A7,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Sheet2!A7,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Name. Named range with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TestNameArea,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TestNameArea,0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(SQRT(-1),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(SQRT(-1),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #15: Array. Array with boolean returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV({TRUE},0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV({TRUE},0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Number. Negative probability returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(-0.1,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(-0.1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 3 of 3 arguments used.');
		// Case #17: String. String convertible to probability > 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV("1.5",0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV("1.5",0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to probability > 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Date. Date as large number (>1) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(DATE(2025,1,1),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(DATE(2025,1,1),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date as large number (>1) returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Time. Time = 0 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(TIME(0,0,0),0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(TIME(0,0,0),0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time = 0 returns #NUM!. 3 of 3 arguments used.');
		// Case #20: Area3D. 3D multi-cell range returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(Sheet2!A8:A9,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(Sheet2!A8:A9,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(1E-307,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(1E-307,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '-37.47933256', 'Test: Bounded case: Number. Minimum valid probability. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid probability. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.999999999999999,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.999999999999999,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '7.941444487', 'Test: Bounded case: Number. Maximum valid probability. 3 of 3 arguments used.');
		// Case #3: Number. Minimum valid standard_dev. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,0,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,0,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid standard_dev. 3 of 3 arguments used.');
		// Case #4: Number. Maximum valid mean. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,1.79769313486232E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,1.79769313486232E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.79769313486232e+307, 'Test: Bounded case: Number. Maximum valid mean. 3 of 3 arguments used.');
		// Case #5: Number. Minimum valid mean. 3 of 3 arguments used.
		oParser = new parserFormula('NORMINV(0.5,-1.79769313486232E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMINV(0.5,-1.79769313486232E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.79769313486232e+307, 'Test: Bounded case: Number. Minimum valid mean. 3 of 3 arguments used.');

		// Need to fix: different error types
		// Case #13: Table. Table structured references with valid numbers. 3 of 3 arguments used.
		// Case #10: Area. Multi-cell range for probability returns #NUM!. 3 of 3 arguments used.
		// Case #12: Name. Named range with text returns #VALUE!. 3 of 3 arguments used.
		// Case #20: Area3D. 3D multi-cell range returns #NUM!. 3 of 3 arguments used.

	});

	QUnit.test("Test: \"NORM.S.DIST\"", function (assert) {

		oParser = new parserFormula("NORM.S.DIST(1.333333,TRUE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.908788726);

		oParser = new parserFormula("NORM.S.DIST(1.333333,FALSE)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.164010148);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number, Boolean. Basic valid input: z=0, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(0, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(0, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number, Boolean. Basic valid input: z=0, cumulative=TRUE. 2 arguments used.');
		// Case #1: Number, Boolean. Basic valid input: z=1, cumulative=FALSE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24197072451914337, 'Test: Positive case: Number, Boolean. Basic valid input: z=1, cumulative=FALSE. 2 arguments used.');
		// Case #2: Number, Boolean. Float input for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1.5, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1.5, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9331927987311419, 'Test: Positive case: Number, Boolean. Float input for z, cumulative=TRUE. 2 arguments used.');
		// Case #3: String, Boolean. String convertible to number for z, cumulative=FALSE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST("2", FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST("2", FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.05399096651318806, 'Test: Positive case: String, Boolean. String convertible to number for z, cumulative=FALSE. 2 arguments used.');
		// Case #4: Formula, Boolean. Nested formula for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(SQRT(4), TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(SQRT(4), TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9772498680518208, 'Test: Positive case: Formula, Boolean. Nested formula for z, cumulative=TRUE. 2 arguments used.');
		// Case #5: Reference link, Boolean. Reference to cell with valid number for z. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(A100, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(A100, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6914624612740136, 'Test: Positive case: Reference link, Boolean. Reference to cell with valid number for z. 2 arguments used.');
		// Case #6: Area, Boolean. Single-cell range for z, cumulative=FALSE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(A101:A101, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(A101:A101, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12951759566589174, 'Test: Positive case: Area, Boolean. Single-cell range for z, cumulative=FALSE. 2 arguments used.');
		// Case #7: Array, Boolean. Array with single element for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST({2}, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST({2}, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9772498680518208, 'Test: Positive case: Array, Boolean. Array with single element for z, cumulative=TRUE. 2 arguments used.');
		// Case #8: Name, Boolean. Named range for z, cumulative=FALSE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(TestName, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(TestName, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3520653267642995, 'Test: Positive case: Name, Boolean. Named range for z, cumulative=FALSE. 2 arguments used.');
		// Case #9: Name3D, Boolean. 3D named range for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(TestName3D, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(TestName3D, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.30853753872598644, 'Test: Positive case: Name3D, Boolean. 3D named range for z, cumulative=TRUE. 2 arguments used.');
		// Case #10: Ref3D, Boolean. 3D reference to cell for z, cumulative=FALSE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(Sheet2!A1, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(Sheet2!A1, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3520653267642995, 'Test: Positive case: Ref3D, Boolean. 3D reference to cell for z, cumulative=FALSE. 2 arguments used.');
		// Case #11: Area3D, Boolean. 3D single-cell range for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(Sheet2!A1:A1, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(Sheet2!A1:A1, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6914624612740136, 'Test: Positive case: Area3D, Boolean. 3D single-cell range for z, cumulative=TRUE. 2 arguments used.');
		// Case #12: Table, Boolean. Table structured reference for z, cumulative=FALSE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(Table1[Column1], FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(Table1[Column1], FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24197072451914337, 'Test: Positive case: Table, Boolean. Table structured reference for z, cumulative=FALSE. 2 arguments used.');
		// Case #13: Date, Boolean. Date as serial number for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(DATE(2025,1,1), TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(DATE(2025,1,1), TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date, Boolean. Date as serial number for z, cumulative=TRUE. 2 arguments used.');
		// Case #14: Time, Boolean. Time formula adjusted to valid number for z, cumulative=FALSE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(TIME(12,0,0)*1000, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(TIME(12,0,0)*1000, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time, Boolean. Time formula adjusted to valid number for z, cumulative=FALSE. 2 arguments used.');
		// Case #15: Formula, Boolean. NORM.S.DIST inside SUM formula, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('SUM(NORM.S.DIST(2, TRUE), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(NORM.S.DIST(2, TRUE), 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0772498680518208, 'Test: Positive case: Formula, Boolean. NORM.S.DIST inside SUM formula, cumulative=TRUE. 2 arguments used.');
		// Case #16: Number, Number. Numeric 1 for cumulative treated as TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Positive case: Number, Number. Numeric 1 for cumulative treated as TRUE. 2 arguments used.');
		// Case #17: String, Boolean. String of small positive number for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST("1.000000000000001", TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST("1.000000000000001", TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8413447460685434, 'Test: Positive case: String, Boolean. String of small positive number for z, cumulative=TRUE. 2 arguments used.');
		// Case #18: Array, Boolean. Multi-element array for z, cumulative=FALSE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST({1, 2}, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST({1, 2}, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24197072451914337, 'Test: Positive case: Array, Boolean. Multi-element array for z, cumulative=FALSE. 2 arguments used.');
		// Case #19: Formula, Boolean. Nested IF returning valid value for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(IF(TRUE, 2, 0.5), TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(IF(TRUE, 2, 0.5), TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9772498680518208, 'Test: Positive case: Formula, Boolean. Nested IF returning valid value for z, cumulative=TRUE. 2 arguments used.');
		// Case #20: Number, String. Negative number for z, string "TRUE" for cumulative. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(-1, "TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(-1, "TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.158655254, 'Test: Positive case: Number, String. Negative number for z, string "TRUE" for cumulative. 2 arguments used.');
		// Case #21: Area3D, Boolean. 3D multi-cell range for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(Sheet2!A1:B1, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(Sheet2!A1:B1, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6914624612740136, 'Test: Positive case: Area3D, Boolean. 3D multi-cell range for z, cumulative=TRUE. 2 arguments used.');
		// Case #22: Number, Formula. Formula returning logical value for cumulative. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1.5, IF(TRUE, TRUE, FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1.5, IF(TRUE, TRUE, FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9331927987311419, 'Test: Positive case: Number, Formula. Formula returning logical value for cumulative. 2 arguments used.');

		// Negative cases:
		// Case #1: String, Boolean. Non-numeric string for z returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST("abc", TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST("abc", TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Boolean. Non-numeric string for z returns #VALUE!. 2 arguments used.');
		// Case #2: Error, Boolean. Propagates #N/A error for z. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(NA(), FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(NA(), FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Boolean. Propagates #N/A error for z. 2 arguments used.');
		// Case #3: Area, Boolean. Multi-cell range for z returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(A102:A103, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(A102:A103, TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.691462461, 'Test: Negative case: Area, Boolean. Multi-cell range for z returns #VALUE!. 2 arguments used.');
		// Case #4: Empty, Boolean. Reference to empty cell for z returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(A103, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(A103, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3989422804014327, 'Test: Negative case: Empty, Boolean. Reference to empty cell for z returns #VALUE!. 2 arguments used.');
		// Case #5: String, Boolean. Empty string for z returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST("", TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST("", TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Boolean. Empty string for z returns #VALUE!. 2 arguments used.');
		// Case #6: Boolean, Boolean. Boolean FALSE (0) for z, valid cumulative. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(FALSE, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(FALSE, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3989422804014327, 'Test: Negative case: Boolean, Boolean. Boolean FALSE (0) for z, valid cumulative. 2 arguments used.');
		// Case #7: Ref3D, Boolean. 3D reference to text cell returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(Sheet2!A2, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(Sheet2!A2, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9331927987311419, 'Test: Negative case: Ref3D, Boolean. 3D reference to text cell returns #VALUE!. 2 arguments used.');
		// Case #8: Name, Boolean. Named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(TestNameArea, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(TestNameArea, FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.241970725, 'Test: Negative case: Name, Boolean. Named range with text returns #VALUE!. 2 arguments used.');
		// Case #10: Formula, Boolean. Formula resulting in #NUM! for z. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(SQRT(-1), FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(SQRT(-1), FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Boolean. Formula resulting in #NUM! for z. 2 arguments used.');
		// Case #11: Number, String. Non-logical string for cumulative returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-logical string for cumulative returns #VALUE!. 2 arguments used.');
		// Case #12: Number, Empty. Empty cell reference for cumulative returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1, A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1, A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Negative case: Number, Empty. Empty cell reference for cumulative returns #VALUE!. 2 arguments used.');
		// Case #13: Number, Array. Multi-element array for cumulative returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1, {TRUE, FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1, {TRUE, FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Negative case: Number, Array. Multi-element array for cumulative returns #VALUE!. 2 arguments used.');
		// Case #14: Array, Boolean. Array with boolean for z returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST({FALSE}, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST({FALSE}, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Array, Boolean. Array with boolean for z returns #VALUE!. 2 arguments used.');
		// Case #15: Number, Area. Multi-cell range for cumulative returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1, A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1, A105:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Negative case: Number, Area. Multi-cell range for cumulative returns #VALUE!. 2 arguments used.');
		// Case #16: Area3D, Boolean. 3D multi-cell range for z returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(Sheet2!A2:A3, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(Sheet2!A2:A3, FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.129517596, 'Test: Negative case: Area3D, Boolean. 3D multi-cell range for z returns #VALUE!. 2 arguments used.');
		// Case #17: Name3D, Boolean. 3D named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(TestNameArea3D2, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(TestNameArea3D2, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7881446014198606, 'Test: Negative case: Name3D, Boolean. 3D named range with text returns #VALUE!. 2 arguments used.');
		// Case #18: Number, Ref3D. 3D reference to text cell for cumulative returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1, Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1, Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Ref3D. 3D reference to text cell for cumulative returns #VALUE!. 2 arguments used.');
		// Case #19: Time, Boolean. Time value (0.5) for z, valid cumulative. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(TIME(12,0,0), TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(TIME(12,0,0), TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6914624612740136, 'Test: Negative case: Time, Boolean. Time value (0.5) for z, valid cumulative. 2 arguments used.');
		// Case #20: Number, Number. Non-boolean number for cumulative returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.841344746068543, 'Test: Negative case: Number, Number. Non-boolean number for cumulative returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number, Boolean. Minimum positive value for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1E-308, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1E-308, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number, Boolean. Minimum positive value for z, cumulative=TRUE. 2 arguments used.');
		// Case #2: Number, Boolean. Maximum negative value for z, cumulative=FALSE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(-1E+308, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(-1E+308, FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Boolean. Maximum negative value for z, cumulative=FALSE. 2 arguments used.');
		// Case #3: Number, Boolean. Maximum positive value for z, cumulative=TRUE. 2 arguments used.
		oParser = new parserFormula('NORM.S.DIST(1E+308, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.DIST(1E+308, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Boolean. Maximum positive value for z, cumulative=TRUE. 2 arguments used.');

		// Need to fix: area handle, #NUM! error instead zero val
		// Case #20: Number, String. Negative number for z, string "TRUE" for cumulative. 2 arguments used.
		// Case #3: Area, Boolean. Multi-cell range for z returns #VALUE!. 2 arguments used.
		// Case #8: Name, Boolean. Named range with text returns #VALUE!. 2 arguments used.
		// Case #15: Number, Area. Multi-cell range for cumulative returns #VALUE!. 2 arguments used.
		// Case #16: Area3D, Boolean. 3D multi-cell range for z returns #VALUE!. 2 arguments used.
		// Case #2: Number, Boolean. Maximum negative value for z, cumulative=FALSE. 2 arguments used.

		testArrayFormula2(assert, "NORM.S.DIST", 2, 2)
	});

	QUnit.test("Test: \"NORMSINV\"", function (assert) {

		function normsinv(x) {
			if (x <= 0.0 || x >= 1.0) {
				return "#N/A";
			} else {
				return toFixed(AscCommonExcel.gaussinv(x));
			}
		}

		oParser = new parserFormula("NORMSINV(0.954)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normsinv(0.954));

		oParser = new parserFormula("NORMSINV(0.13)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normsinv(0.13));

		oParser = new parserFormula("NORMSINV(0.6782136)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normsinv(0.6782136));

		oParser = new parserFormula("NORMSINV(1.6782136)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normsinv(1.6782136));

		oParser = new parserFormula("NORMSINV(-1.6782136)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), normsinv(-1.6782136));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: probability 0.5 returns z-score 0.
		oParser = new parserFormula('NORMSINV(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: probability 0.5 returns z-score 0.');
		// Case #2: Number. Valid probability near upper bound (0.975 returns ~1.96).
		oParser = new parserFormula('NORMSINV(0.975)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(0.975) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9599639845400536, 'Test: Positive case: Number. Valid probability near upper bound (0.975 returns ~1.96).');
		// Case #3: Number. Valid probability near lower bound (0.025 returns ~-1.96).
		oParser = new parserFormula('NORMSINV(0.025)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(0.025) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-1.9600', 'Test: Positive case: Number. Valid probability near lower bound (0.025 returns ~-1.96).');
		// Case #4: Number. Valid probability 0.3 returns ~-0.524.
		oParser = new parserFormula('NORMSINV(0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(0.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5244005127080407, 'Test: Positive case: Number. Valid probability 0.3 returns ~-0.524.');
		// Case #5: String. String convertible to valid probability 0.7.
		oParser = new parserFormula('NORMSINV("0.7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV("0.7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5244005127080407, 'Test: Positive case: String. String convertible to valid probability 0.7.');
		// Case #6: Formula. Simple formula evaluating to 0.25.
		oParser = new parserFormula('NORMSINV(1/4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(1/4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.6744897501960817, 'Test: Positive case: Formula. Simple formula evaluating to 0.25.');
		// Case #7: Formula. Nested SQRT formula evaluating to 0.7.
		oParser = new parserFormula('NORMSINV(SQRT(0.49))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(SQRT(0.49)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5244005127080407, 'Test: Positive case: Formula. Nested SQRT formula evaluating to 0.7.');
		// Case #8: Formula. Nested IF formula returning valid probability 0.99.
		oParser = new parserFormula('NORMSINV(IF(TRUE,0.99,0.1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(IF(TRUE,0.99,0.1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.32634787404084, 'Test: Positive case: Formula. Nested IF formula returning valid probability 0.99.');
		// Case #9: Reference link. Reference to cell with valid probability (0.5).
		oParser = new parserFormula('NORMSINV(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cell with valid probability (0.5).');
		// Case #10: Area. Single-cell range with valid probabilit.
		oParser = new parserFormula('NORMSINV(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(A101:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell range with valid probability.');
		// Case #11: Array. Array with single valid probability.
		oParser = new parserFormula('NORMSINV({0.3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV({0.3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(),-0.5244005127080407, 'Test: Positive case: Array. Array with single valid probability.');
		// Case #12: Name. Named range with valid probability (-0.5).
		oParser = new parserFormula('NORMSINV(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid probability (0.5).');
		// Case #13: Name3D. 3D named range with valid probability (-0.5).
		oParser = new parserFormula('NORMSINV(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid probability (0.5).');
		// Case #14: Ref3D. 3D reference to cell with valid probability (0.5).
		oParser = new parserFormula('NORMSINV(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to cell with valid probability (0.5).');
		// Case #15: Area3D. 3D single-cell range with valid probability.
		oParser = new parserFormula('NORMSINV(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with valid probability.');
		// Case #16: Table. Table structured reference with valid probability 1.
		oParser = new parserFormula('NORMSINV(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with valid probability 1.');
		// Case #17: Date. Date serial number adjusted to valid probability (~0.00046).
		oParser = new parserFormula('NORMSINV(DATE(2025,1,1)/1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(DATE(2025,1,1)/1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.6884962928295268, 'Test: Positive case: Date. Date serial number adjusted to valid probability (~0.00046).');
		// Case #18: Time. Time value (0.5) as valid probability.
		oParser = new parserFormula('NORMSINV(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time. Time value (0.5) as valid probability.');
		// Case #19: Formula. Nested ROUND formula evaluating to 0.67.
		oParser = new parserFormula('NORMSINV(ROUND(0.666,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(ROUND(0.666,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4399131656732339, 'Test: Positive case: Formula. Nested ROUND formula evaluating to 0.67.');
		// Case #20: Array. Multi-element array with valid probabilities.
		oParser = new parserFormula('NORMSINV({0.3,0.7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV({0.3,0.7}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -0.5244005127080407, 'Test: Positive case: Array. Multi-element array with valid probabilities.');
		// Case #21: Formula. NORMSINV inside SUM formula, valid probability 0.5.
		oParser = new parserFormula('SUM(NORMSINV(0.5),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(NORMSINV(0.5),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. NORMSINV inside SUM formula, valid probability 0.5.');
		// Case #22: Formula. Nested ABS formula evaluating to 0.8.
		oParser = new parserFormula('NORMSINV(ABS(-0.8))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(ABS(-0.8)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8416212335729144, 'Test: Positive case: Formula. Nested ABS formula evaluating to 0.8.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!.
		oParser = new parserFormula('NORMSINV(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 0 returns #NUM!.');
		// Case #2: Number. Probability = 1 returns #NUM!.
		oParser = new parserFormula('NORMSINV(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 1 returns #NUM!.');
		// Case #3: Number. Negative probability returns #NUM!.
		oParser = new parserFormula('NORMSINV(-0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(-0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!.');
		// Case #4: Number. Probability > 1 returns #NUM!.
		oParser = new parserFormula('NORMSINV(1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(1.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability > 1 returns #NUM!.');
		// Case #5: Number. Large negative probability returns #NUM!.
		oParser = new parserFormula('NORMSINV(-1E+100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(-1E+100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large negative probability returns #NUM!.');
		// Case #6: Number. Large probability > 1 returns #NUM!.
		oParser = new parserFormula('NORMSINV(1E+100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(1E+100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large probability > 1 returns #NUM!.');
		// Case #7: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('NORMSINV("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #8: String. String convertible to 0 returns #NUM!.
		oParser = new parserFormula('NORMSINV("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV("0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to 0 returns #NUM!.');
		// Case #9: Error. Propagates #N/A error.
		oParser = new parserFormula('NORMSINV(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #10: Empty. Reference to empty cell returns #VALUE!.
		oParser = new parserFormula('NORMSINV(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!.');
		// Case #11: Boolean. Boolean TRUE (1) returns #NUM!.
		oParser = new parserFormula('NORMSINV(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean TRUE (1) returns #NUM!.');
		// Case #12: Boolean. Boolean FALSE (0) returns #NUM!.
		oParser = new parserFormula('NORMSINV(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!.');
		// Case #13: Area. Multi-cell range returns #NUM!.
		oParser = new parserFormula('NORMSINV(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range returns #NUM!.');
		// Case #14: Ref3D. 3D reference to text returns #VALUE!.
		oParser = new parserFormula('NORMSINV(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!.');
		// Case #15: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('NORMSINV(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #16: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('NORMSINV(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8416212335729144, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #18: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('NORMSINV(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #19: String. Empty string returns #VALUE!.
		oParser = new parserFormula('NORMSINV("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #20: Area3D. 3D multi-cell range returns #NUM!.
		oParser = new parserFormula('NORMSINV(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!.');

		// Bounded cases:
		// Case #1: Number. Smallest valid probability above 0, returns large negative z-score.
		oParser = new parserFormula('NORMSINV(1E-100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(1E-100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -21.27345356096532, 'Test: Bounded case: Number. Smallest valid probability above 0, returns large negative z-score.');
		// Case #2: Number. Largest valid probability below 1, returns large positive z-score.
		oParser = new parserFormula('NORMSINV(1-1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORMSINV(1-1E-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.941444487415977, 'Test: Bounded case: Number. Largest valid probability below 1, returns large positive z-score.');


		// Need to fix: area handle, error types difference, empty cell/value handle
		// Case #10: Area. Single-cell range with valid probabilit.
		// Case #12: Name. Named range with valid probability (0.5).
		// Case #13: Name3D. 3D named range with valid probability (0.5).
		// Case #15: Area3D. 3D single-cell range with valid probability.
		// Case #16: Table. Table structured reference with valid probability 1.
		// Case #1: Number. Probability = 0 returns #NUM!.
		// Case #2: Number. Probability = 1 returns #NUM!.
		// Case #3: Number. Negative probability returns #NUM!.
		// Case #4: Number. Probability > 1 returns #NUM!.
		// Case #5: Number. Large negative probability returns #NUM!.
		// Case #6: Number. Large probability > 1 returns #NUM!.
		// Case #8: String. String convertible to 0 returns #NUM!.
		// Case #11: Boolean. Boolean TRUE (1) returns #NUM!.
		// Case #12: Boolean. Boolean FALSE (0) returns #NUM!.
		// Case #13: Area. Multi-cell range returns #NUM!.
		// Case #15: Name. Named range with text returns #VALUE!.


		testArrayFormula(assert, "NORMSINV");
	});

	QUnit.test("Test: \"NORM.S.INV \"", function (assert) {

		oParser = new parserFormula("NORM.S.INV(0.908789)", "F1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 1.3333347);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: probability 0.5 returns z-score 0.
		oParser = new parserFormula('NORM.S.INV(0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: probability 0.5 returns z-score 0.');
		// Case #2: Number. Valid probability near upper bound (0.975 returns ~1.96).
		oParser = new parserFormula('NORM.S.INV(0.975)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(0.975) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9599639845400536, 'Test: Positive case: Number. Valid probability near upper bound (0.975 returns ~1.96).');
		// Case #3: Number. Valid probability near lower bound (0.025 returns ~-1.96).
		oParser = new parserFormula('NORM.S.INV(0.025)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(0.025) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-1.9600', 'Test: Positive case: Number. Valid probability near lower bound (0.025 returns ~-1.96).');
		// Case #4: Number. Valid probability 0.3 returns ~-0.524.
		oParser = new parserFormula('NORM.S.INV(0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(0.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5244005127080407, 'Test: Positive case: Number. Valid probability 0.3 returns ~-0.524.');
		// Case #5: String. String convertible to valid probability 0.7.
		oParser = new parserFormula('NORM.S.INV("0.7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV("0.7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5244005127080407, 'Test: Positive case: String. String convertible to valid probability 0.7.');
		// Case #6: Formula. Simple formula evaluating to 0.25.
		oParser = new parserFormula('NORM.S.INV(1/4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(1/4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.6744897501960817, 'Test: Positive case: Formula. Simple formula evaluating to 0.25.');
		// Case #7: Formula. Nested SQRT formula evaluating to 0.7.
		oParser = new parserFormula('NORM.S.INV(SQRT(0.49))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(SQRT(0.49)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5244005127080407, 'Test: Positive case: Formula. Nested SQRT formula evaluating to 0.7.');
		// Case #8: Formula. Nested IF formula returning valid probability 0.99.
		oParser = new parserFormula('NORM.S.INV(IF(TRUE,0.99,0.1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(IF(TRUE,0.99,0.1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.32634787404084, 'Test: Positive case: Formula. Nested IF formula returning valid probability 0.99.');
		// Case #9: Reference link. Reference to cell with valid probability (0.5).
		oParser = new parserFormula('NORM.S.INV(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cell with valid probability (0.5).');
		// Case #10: Area. Single-cell range with valid probabilit.
		oParser = new parserFormula('NORM.S.INV(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(A101:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell range with valid probability.');
		// Case #11: Array. Array with single valid probability.
		oParser = new parserFormula('NORM.S.INV({0.3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV({0.3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(),-0.5244005127080407, 'Test: Positive case: Array. Array with single valid probability.');
		// Case #12: Name. Named range with valid probability (-0.5).
		oParser = new parserFormula('NORM.S.INV(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid probability (0.5).');
		// Case #13: Name3D. 3D named range with valid probability (-0.5).
		oParser = new parserFormula('NORM.S.INV(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid probability (0.5).');
		// Case #14: Ref3D. 3D reference to cell with valid probability (0.5).
		oParser = new parserFormula('NORM.S.INV(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to cell with valid probability (0.5).');
		// Case #15: Area3D. 3D single-cell range with valid probability.
		oParser = new parserFormula('NORM.S.INV(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with valid probability.');
		// Case #16: Table. Table structured reference with valid probability 1.
		oParser = new parserFormula('NORM.S.INV(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with valid probability 1.');
		// Case #17: Date. Date serial number adjusted to valid probability (~0.00046).
		oParser = new parserFormula('NORM.S.INV(DATE(2025,1,1)/1000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(DATE(2025,1,1)/1000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.6884962928295268, 'Test: Positive case: Date. Date serial number adjusted to valid probability (~0.00046).');
		// Case #18: Time. Time value (0.5) as valid probability.
		oParser = new parserFormula('NORM.S.INV(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time. Time value (0.5) as valid probability.');
		// Case #19: Formula. Nested ROUND formula evaluating to 0.67.
		oParser = new parserFormula('NORM.S.INV(ROUND(0.666,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(ROUND(0.666,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4399131656732339, 'Test: Positive case: Formula. Nested ROUND formula evaluating to 0.67.');
		// Case #20: Array. Multi-element array with valid probabilities.
		oParser = new parserFormula('NORM.S.INV({0.3,0.7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV({0.3,0.7}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -0.5244005127080407, 'Test: Positive case: Array. Multi-element array with valid probabilities.');
		// Case #21: Formula. NORMSINV inside SUM formula, valid probability 0.5.
		oParser = new parserFormula('SUM(NORM.S.INV(0.5),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(NORM.S.INV(0.5),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. NORM.S.INV inside SUM formula, valid probability 0.5.');
		// Case #22: Formula. Nested ABS formula evaluating to 0.8.
		oParser = new parserFormula('NORM.S.INV(ABS(-0.8))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(ABS(-0.8)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8416212335729144, 'Test: Positive case: Formula. Nested ABS formula evaluating to 0.8.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 0 returns #NUM!.');
		// Case #2: Number. Probability = 1 returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 1 returns #NUM!.');
		// Case #3: Number. Negative probability returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(-0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(-0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!.');
		// Case #4: Number. Probability > 1 returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(1.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability > 1 returns #NUM!.');
		// Case #5: Number. Large negative probability returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(-1E+100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(-1E+100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large negative probability returns #NUM!.');
		// Case #6: Number. Large probability > 1 returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(1E+100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(1E+100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Large probability > 1 returns #NUM!.');
		// Case #7: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('NORM.S.INV("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #8: String. String convertible to 0 returns #NUM!.
		oParser = new parserFormula('NORM.S.INV("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV("0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to 0 returns #NUM!.');
		// Case #9: Error. Propagates #N/A error.
		oParser = new parserFormula('NORM.S.INV(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #10: Empty. Reference to empty cell returns #VALUE!.
		oParser = new parserFormula('NORM.S.INV(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!.');
		// Case #11: Boolean. Boolean TRUE (1) returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean TRUE (1) returns #NUM!.');
		// Case #12: Boolean. Boolean FALSE (0) returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!.');
		// Case #13: Area. Multi-cell range returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range returns #NUM!.');
		// Case #14: Ref3D. 3D reference to text returns #VALUE!.
		oParser = new parserFormula('NORM.S.INV(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!.');
		// Case #15: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('NORM.S.INV(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #16: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('NORM.S.INV(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8416212335729144, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #18: Formula. Formula resulting in #NUM! error.
		oParser = new parserFormula('NORM.S.INV(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error.');
		// Case #19: String. Empty string returns #VALUE!.
		oParser = new parserFormula('NORM.S.INV("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #20: Area3D. 3D multi-cell range returns #NUM!.
		oParser = new parserFormula('NORM.S.INV(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #NUM!.');

		// Bounded cases:
		// Case #1: Number. Smallest valid probability above 0, returns large negative z-score.
		oParser = new parserFormula('NORM.S.INV(1E-100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(1E-100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -21.27345356096532, 'Test: Bounded case: Number. Smallest valid probability above 0, returns large negative z-score.');
		// Case #2: Number. Largest valid probability below 1, returns large positive z-score.
		oParser = new parserFormula('NORM.S.INV(1-1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NORM.S.INV(1-1E-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.941444487415977, 'Test: Bounded case: Number. Largest valid probability below 1, returns large positive z-score.');


		// Need to fix: area handle, error types difference, empty cell/value handle
		// Case #10: Area. Single-cell range with valid probabilit.
		// Case #12: Name. Named range with valid probability (0.5).
		// Case #13: Name3D. 3D named range with valid probability (0.5).
		// Case #15: Area3D. 3D single-cell range with valid probability.
		// Case #16: Table. Table structured reference with valid probability 1.
		// Case #1: Number. Probability = 0 returns #NUM!.
		// Case #2: Number. Probability = 1 returns #NUM!.
		// Case #3: Number. Negative probability returns #NUM!.
		// Case #4: Number. Probability > 1 returns #NUM!.
		// Case #5: Number. Large negative probability returns #NUM!.
		// Case #6: Number. Large probability > 1 returns #NUM!.
		// Case #8: String. String convertible to 0 returns #NUM!.
		// Case #11: Boolean. Boolean TRUE (1) returns #NUM!.
		// Case #12: Boolean. Boolean FALSE (0) returns #NUM!.
		// Case #13: Area. Multi-cell range returns #NUM!.
		// Case #15: Name. Named range with text returns #VALUE!.


	});

	QUnit.test("Test: \"PEARSON\"", function (assert) {

		function pearson(x, y) {

			var sumXDeltaYDelta = 0, sqrXDelta = 0, sqrYDelta = 0, _x = 0, _y = 0, xLength = 0;

			if (x.length != y.length) {
				return "#N/A"
			}
			for (var i = 0; i < x.length; i++) {

				_x += x[i]
				_y += y[i]
				xLength++;
			}

			_x /= xLength;
			_y /= xLength;

			for (var i = 0; i < x.length; i++) {

				sumXDeltaYDelta += (x[i] - _x) * (y[i] - _y);
				sqrXDelta += (x[i] - _x) * (x[i] - _x);
				sqrYDelta += (y[i] - _y) * (y[i] - _y);

			}

			if (sqrXDelta == 0 || sqrYDelta == 0) {
				return "#DIV/0!"
			} else {
				return toFixed(sumXDeltaYDelta / Math.sqrt(sqrXDelta * sqrYDelta));
			}
		}

		oParser = new parserFormula("PEARSON({9,7,5,3,1},{10,6,1,5,3})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), pearson([9, 7, 5, 3, 1], [10, 6, 1, 5, 3]));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Arrays with numeric values. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Arrays with numeric values. 2 of 2 arguments used.');
		// Case #2: Array. Arrays with multiple elements, negative correlation. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,2,3,4},{4,3,2,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,2,3,4},{4,3,2,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Array. Arrays with multiple elements, negative correlation. 2 of 2 arguments used.');
		// Case #3: Formula. Nested formula in arrays. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,2},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,2},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested formula in arrays. 2 of 2 arguments used.');
		// Case #4: String. String numbers converted to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({"1","2"},{"3","4"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({"1","2"},{"3","4"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String numbers converted to numbers. 2 of 2 arguments used.');
		// Case #5: Reference link. Reference to cells with numbers. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(A100,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference to cells with numbers. 2 of 2 arguments used.');
		// Case #6: Area. Two-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area. Two-cell ranges. 2 of 2 arguments used.');
		// Case #7: Name. Named ranges with single values. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Named ranges with single values. 2 of 2 arguments used.');
		// Case #8: Name3D. 3D named ranges. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named ranges. 2 of 2 arguments used.');
		// Case #9: Ref3D. 3D references to cells. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(Sheet2!A1,Sheet2!A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D. 3D references to cells. 2 of 2 arguments used.');
		// Case #10: Area3D. 3D two-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D two-cell ranges. 2 of 2 arguments used.');
		// Case #11: Table. Table structured references. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured references. 2 of 2 arguments used.');
		// Case #12: Date. Dates as serial numbers. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({45658,45659},{45660,45661})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({45658,45659},{45660,45661}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Dates as serial numbers. 2 of 2 arguments used.');
		// Case #13: Time. Time adjusted to numbers. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({0,0.1},{0.1,0.2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({0,0.1},{0.1,0.2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time. Time adjusted to numbers. 2 of 2 arguments used.');
		// Case #14: Formula. Nested IF returning array. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(IF(TRUE,{1,2},{2,3}),{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(IF(TRUE,{1,2},{2,3}),{3,4}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested IF returning array. 2 of 2 arguments used.');
		// Case #15: Number. Identical values, zero variance. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,1,1},{2,2,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,1,1},{2,2,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number. Identical values, zero variance. 2 of 2 arguments used.');
		// Case #16: Array. Arrays with booleans (converted to 1/0). 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,2,TRUE},{3,4,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,2,TRUE},{3,4,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Arrays with booleans (converted to 1/0). 2 of 2 arguments used.');
		// Case #17: Formula. Rounded numbers via formula. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({2,3},{4,50})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({2,3},{4,50}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Rounded numbers via formula. 2 of 2 arguments used.');
		// Case #18: Number. Very small numbers. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1E-307,2E-307},{3E-307,4E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1E-307,2E-307},{3E-307,4E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number. Very small numbers. 2 of 2 arguments used.');
		// Case #19: Array. Perfect negative correlation. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,2,3,4,5},{5,4,3,2,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,2,3,4,5},{5,4,3,2,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Array. Perfect negative correlation. 2 of 2 arguments used.');
		// Case #20: Formula. Absolute value formulas. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({-1,-2},{-3,-4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({-1,-2},{-3,-4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Absolute value formulas. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric strings return #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({"abc","def"},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({"abc","def"},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-numeric strings return #N/A. 2 of 2 arguments used.');
		// Case #2: Error. Error value propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(NA(),{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(NA(),{2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value propagates #N/A. 2 of 2 arguments used.');
		// Case #3: Empty. Empty cells return #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty cells return #N/A. 2 of 2 arguments used.');
		// Case #4: Boolean. Booleans alone return #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({TRUE,FALSE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({TRUE,FALSE},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Booleans alone return #N/A. 2 of 2 arguments used.');
		// Case #5: Formula. Formula error returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(#NUM!,{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(#NUM!,{2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula error returns #N/A. 2 of 2 arguments used.');
		// Case #6: Area. Multi-cell range with non-numeric data returns #N/A.
		oParser = new parserFormula('PEARSON(A108:A109,A110:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(A108:A109,A110:A111) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area. Multi-cell range with non-numeric data returns #N/A.');
		// Case #7: Ref3D. 3D ref to text returns #N/A.
		oParser = new parserFormula('PEARSON(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #N/A.');
		// Case #8: Name. Named range with text returns #N/A.
		oParser = new parserFormula('PEARSON(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(TestName1,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name. Named range with text returns #N/A.');
		// Case #10: Number. Single-element arrays return #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Single-element arrays return #DIV/0!. 2 of 2 arguments used.');
		// Case #11: Array. Mismatched array sizes return #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Mismatched array sizes return #N/A. 2 of 2 arguments used.');
		// Case #12: Area3D. Mismatched range sizes return #N/A.
		oParser = new parserFormula('PEARSON(Sheet2!A5:A6,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(Sheet2!A5:A6,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. Mismatched range sizes return #N/A.');
		// Case #13: String. Empty strings return #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({"",""},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({"",""},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Empty strings return #N/A. 2 of 2 arguments used.');
		// Case #14: Date. Single-element date arrays return #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({2000},{2001})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({2000},{2001}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Date. Single-element date arrays return #DIV/0!. 2 of 2 arguments used.');
		// Case #15: Time. Single-element time arrays return #DIV/0!. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({0.04167},{0.083})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({0.04167},{0.083}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time. Single-element time arrays return #DIV/0!. 2 of 2 arguments used.');
		// Case #16: Number. Overflow numbers return #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1E+307,1E+306},{3E+307,4E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1E+307,1E+306},{3E+307,4E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Overflow numbers return #NUM!. 2 of 2 arguments used.');
		// Case #17: Array. Mixed array with booleans returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,TRUE,FALSE},{2,3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,TRUE,FALSE},{2,3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Mixed array with booleans returns #N/A. 2 of 2 arguments used.');
		// Case #18: Formula. Formula returning non-numeric value returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Formula. Formula returning non-numeric value returns #N/A. 2 of 2 arguments used.');
		// Case #19: Name3D. 3D named range with non-numeric data returns #N/A.
		oParser = new parserFormula('PEARSON(TestName3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(TestName3D,TestNameArea3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D. 3D named range with non-numeric data returns #N/A.');
		// Case #20: Reference link. Ref to non-numeric cell returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON(A100,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON(A100,A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Ref to non-numeric cell returns #N/A. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Smallest valid difference above 1. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({1,1},{2,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({1,1},{2,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Smallest valid difference above 1. 2 of 2 arguments used.');
		// Case #2: Number. Max valid Excel numbers. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({9.99999999999999E+307,9.99999999999998E+307},{9.99999999999997E+307,9.99999999999996E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({9.99999999999999E+307,9.99999999999998E+307},{9.99999999999997E+307,9.99999999999996E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Max valid Excel numbers. 2 of 2 arguments used.');
		// Case #3: Number. Min valid Excel numbers. 2 of 2 arguments used.
		oParser = new parserFormula('PEARSON({-9.99999999999999E+307,-9.99999999999998E+307},{-9.99999999999997E+307,-9.99999999999996E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PEARSON({-9.99999999999999E+307,-9.99999999999998E+307},{-9.99999999999997E+307,-9.99999999999996E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Min valid Excel numbers. 2 of 2 arguments used.');

		// Need to fix: different error types
		// Case #5: Reference link. Reference to cells with numbers. 2 of 2 arguments used.
		// Case #7: Name. Named ranges with single values. 2 of 2 arguments used.
		// Case #8: Name3D. 3D named ranges. 2 of 2 arguments used.
		// Case #9: Ref3D. 3D references to cells. 2 of 2 arguments used.
		// Case #10: Area3D. 3D two-cell ranges. 2 of 2 arguments used.
		// Case #11: Table. Table structured references. 2 of 2 arguments used.
		// Case #14: Formula. Nested IF returning array. 2 of 2 arguments used.
		// Case #2: Error. Error value propagates #N/A. 2 of 2 arguments used
		// Case #5: Formula. Formula error returns #N/A. 2 of 2 arguments used.
		// Case #6: Area. Multi-cell range with non-numeric data returns #N/A.
		// Case #8: Name. Named range with text returns #N/A.
		// Case #19: Name3D. 3D named range with non-numeric data returns #N/A.

		testArrayFormula2(assert, "PEARSON", 2, 2, null, true)
	});

	QUnit.test("Test: \"PERCENTILE\"", function (assert) {

		function percentile(A, k) {

			A.sort(fSortAscending)

			var nSize = A.length;
			if (A.length < 1 || nSize == 0) {
				return new AscCommonExcel.cError(AscCommonExcel.cErrorType.not_available).toString();
			} else {
				if (nSize == 1) {
					return toFixed(A[0]);
				} else {
					var nIndex = Math.floor(k * (nSize - 1));
					var fDiff = k * (nSize - 1) - Math.floor(k * (nSize - 1));
					if (fDiff == 0.0) {
						return toFixed(A[nIndex]);
					} else {
						return toFixed(A[nIndex] + fDiff * (A[nIndex + 1] - A[nIndex]));
					}
				}
			}

		}

		oParser = new parserFormula("PERCENTILE({1,3,2,4},0.3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), percentile([1, 3, 2, 4], 0.3));

		oParser = new parserFormula("PERCENTILE({1,3,2,4},0.75)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), percentile([1, 3, 2, 4], 0.75));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number, Number. Array of integers, k as decimal. Returns median (2).
		oParser = new parserFormula('PERCENTILE({1,2,3}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, Number. Array of integers, k as decimal. Returns median (2).');
		// Case #2: Array, Number. Array with multiple elements, k as quartile. Returns 1.75.
		oParser = new parserFormula('PERCENTILE({1,2,3,4}, 0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3,4}, 0.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.75, 'Test: Positive case: Array, Number. Array with multiple elements, k as quartile. Returns 1.75.');
		// Case #3: String, Number. Numeric strings converted to numbers. Returns 2.
		oParser = new parserFormula('PERCENTILE({"1","2","3"}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({"1","2","3"}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String, Number. Numeric strings converted to numbers. Returns 2.');
		// Case #4: Reference link, Number. Reference to array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE(A100, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(A100, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number. Reference to array, k as number. Returns 2.');
		// Case #5: Area, Number. Single-cell range for array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE(A101:A102, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(A101:A102, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Number. Single-cell range for array, k as number. Returns 2.');
		// Case #6: Table, Number. Table structured reference, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE(Table1[Column1], 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(Table1[Column1], 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Number. Table structured reference, k as number. Returns 2.');
		// Case #7: Name, Number. Named range for array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE(TestName, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(TestName, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name, Number. Named range for array, k as number. Returns 2.');
		// Case #8: Name3D, Number. 3D named range, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE(TestName3D, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(TestName3D, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D, Number. 3D named range, k as number. Returns 2.');
		// Case #9: Ref3D, Number. 3D reference to array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE(Sheet2!A1, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(Sheet2!A1, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D, Number. 3D reference to array, k as number. Returns 2.');
		// Case #10: Area3D, Number. 3D single-cell range, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE(Sheet2!A1:A2, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(Sheet2!A1:A2, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area3D, Number. 3D single-cell range, k as number. Returns 2.');
		// Case #11: Number, String. k as numeric string converted to number. Returns 2.
		oParser = new parserFormula('PERCENTILE({1,2,3}, "0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, "0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, String. k as numeric string converted to number. Returns 2.');
		// Case #12: Reference link, Reference link. Both arguments as references. Returns 2.
		oParser = new parserFormula('PERCENTILE(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(A100, A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link, Reference link. Both arguments as references. Returns 2.');
		// Case #13: Area, Area. Both arguments as single-cell ranges. Returns 2.
		oParser = new parserFormula('PERCENTILE(A102:A103, A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(A102:A103, A104:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area, Area. Both arguments as single-cell ranges. Returns 2.');
		// Case #14: Array, Array. Both arguments as single-element arrays. Returns 2.
		oParser = new parserFormula('PERCENTILE({1,2,3}, {0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, {0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array, Array. Both arguments as single-element arrays. Returns 2.');
		// Case #15: Number, Number. Larger numbers, k as quartile. Returns 550.
		oParser = new parserFormula('PERCENTILE({10,100,1000}, 0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({10,100,1000}, 0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 550, 'Test: Positive case: Number, Number. Larger numbers, k as quartile. Returns 550.');
		// Case #16: Number, Number. Array of decimals, k as decimal. Returns 2.5.
		oParser = new parserFormula('PERCENTILE({1.5,2.5,3.5}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1.5,2.5,3.5}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Number, Number. Array of decimals, k as decimal. Returns 2.5.');
		// Case #17: Formula. PERCENTILE inside SUM formula. Returns 3.
		oParser = new parserFormula('SUM(PERCENTILE({1,2,3}, 0.5), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PERCENTILE({1,2,3}, 0.5), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. PERCENTILE inside SUM formula. Returns 3.');
		// Case #18: Number, Number. Small k value. Returns 1.2.
		oParser = new parserFormula('PERCENTILE({1,2,3}, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.2, 'Test: Positive case: Number, Number. Small k value. Returns 1.2.');
		// Case #19: Number, Number. Large k value. Returns 2.8.
		oParser = new parserFormula('PERCENTILE({1,2,3}, 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, 0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.8, 'Test: Positive case: Number, Number. Large k value. Returns 2.8.');
		// Case #20: Date, Number. Dates as serial numbers (e.g., 01/01/2016, 02/01/2016). Returns median.
		oParser = new parserFormula('PERCENTILE({42139,42170}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({42139,42170}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 42154.5, 'Test: Positive case: Date, Number. Dates as serial numbers (e.g., 01/01/2016, 02/01/2016). Returns median.');

		// Negative cases:
		// Case #1: Number, Number. k < 0 returns #NUM!.
		oParser = new parserFormula('PERCENTILE({1,2,3}, -0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, -0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. k < 0 returns #NUM!.');
		// Case #2: Number, Number. k > 1 returns #NUM!.
		oParser = new parserFormula('PERCENTILE({1,2,3}, 1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, 1.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. k > 1 returns #NUM!.');
		// Case #3: String, Number. Non-numeric string in array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE({"abc",2,3}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({"abc",2,3}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Negative case: String, Number. Non-numeric string in array returns #VALUE!.');
		// Case #4: Empty, Number. Empty array returns #NUM!.
		oParser = new parserFormula('PERCENTILE({""}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({""}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty array returns #NUM!.');
		// Case #5: Error, Number. Error in array propagates #N/A.
		oParser = new parserFormula('PERCENTILE(NA(), 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(NA(), 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error in array propagates #N/A.');
		// Case #6: Area, Number. Multi-cell range with invalid data returns #VALUE!.
		oParser = new parserFormula('PERCENTILE(A105:A106, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(A105:A106, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area, Number. Multi-cell range with invalid data returns #VALUE!.');
		// Case #7: Reference link, Number. Reference to empty cell returns #NUM!.
		oParser = new parserFormula('PERCENTILE(A107, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(A107, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Number. Reference to empty cell returns #NUM!.');
		// Case #8: Number, String. Non-numeric k returns #VALUE!.
		oParser = new parserFormula('PERCENTILE({1,2,3}, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric k returns #VALUE!.');
		// Case #9: Number, Boolean. Boolean k (1) is valid but tested for edge case. Returns 3.
		oParser = new parserFormula('PERCENTILE({1,2,3}, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Number, Boolean. Boolean k (1) is valid but tested for edge case. Returns 3.');
		// Case #10: Ref3D, Number. 3D reference to text returns #VALUE!.
		oParser = new parserFormula('PERCENTILE(Sheet2!A3, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(Sheet2!A3, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D, Number. 3D reference to text returns #VALUE!.');
		// Case #11: Name, Number. Named range with invalid data returns #VALUE!.
		oParser = new parserFormula('PERCENTILE(TestNameArea, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(TestNameArea, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Name, Number. Named range with invalid data returns #VALUE!.');
		// Case #13: Number, Number. Single-element array returns valid result but tested for edge case. Returns 1.
		oParser = new parserFormula('PERCENTILE({1}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Number. Single-element array returns valid result but tested for edge case. Returns 1.');
		// Case #14: Array, Number. Boolean array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE({FALSE}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({FALSE}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Boolean array returns #VALUE!.');
		// Case #15: Number, Number. k slightly above 1 returns #NUM!.
		oParser = new parserFormula('PERCENTILE({1,2,3}, 1+1e-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, 1+1e-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. k slightly above 1 returns #NUM!.');
		// Case #16: Number, Number. Extreme numbers return valid result but tested for edge case. Returns median.
		oParser = new parserFormula('PERCENTILE({-1E+307,1E+307}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({-1E+307,1E+307}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number, Number. Extreme numbers return valid result but tested for edge case. Returns median.');
		// Case #17: String, Number. Mixed date and text in array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE({"01/01/2025","abc"}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({"01/01/2025","abc"}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Mixed date and text in array returns #VALUE!.');
		// Case #18: Area3D, Number. 3D range with invalid data returns #VALUE!.
		oParser = new parserFormula('PERCENTILE(Sheet2!A3:A4, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE(Sheet2!A3:A4, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D range with invalid data returns #VALUE!.');
		// Case #19: Number, Empty. Empty k returns #VALUE!.
		oParser = new parserFormula('PERCENTILE({1,2,3}, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Empty. Empty k returns #VALUE!.');
		// Case #20: String, Number. Empty string in array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE({""}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({""}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Empty string in array returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number, Number. Minimum valid k (0). Returns 1.
		oParser = new parserFormula('PERCENTILE({1,2,3}, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Minimum valid k (0). Returns 1.');
		// Case #2: Number, Number. Maximum valid k (1). Returns 3.
		oParser = new parserFormula('PERCENTILE({1,2,3}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1,2,3}, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Bounded case: Number, Number. Maximum valid k (1). Returns 3.');
		// Case #3: Number, Number. Maximum valid number in array. Returns median.
		oParser = new parserFormula('PERCENTILE({9.99999999999999E+307,1}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({9.99999999999999E+307,1}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.999999999999995e+307, 'Test: Bounded case: Number, Number. Maximum valid number in array. Returns median.');
		// Case #4: Number, Number. Minimum valid number in array. Returns median.
		oParser = new parserFormula('PERCENTILE({1E-307,2}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE({1E-307,2}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Minimum valid number in array. Returns median.');

		// Need to fix: empty handle, error types difference, results different from MS
		// Case #3: String, Number. Numeric strings converted to numbers. Returns 2.
		// Case #4: Reference link, Number. Reference to array, k as number. Returns 2.
		// Case #6: Table, Number. Table structured reference, k as number. Returns 2.
		// Case #7: Name, Number. Named range for array, k as number. Returns 2.
		// Case #8: Name3D, Number. 3D named range, k as number. Returns 2.
		// Case #9: Ref3D, Number. 3D reference to array, k as number. Returns 2.
		// Case #10: Area3D, Number. 3D single-cell range, k as number. Returns 2.
		// Case #12: Reference link, Reference link. Both arguments as references. Returns 2.
		// Case #13: Area, Area. Both arguments as single-cell ranges. Returns 2.
		// Case #4: Empty, Number. Empty array returns #NUM!.
		// Case #7: Reference link, Number. Reference to empty cell returns #NUM!.
		// Case #10: Ref3D, Number. 3D reference to text returns #VALUE!.
		// Case #11: Name, Number. Named range with invalid data returns #VALUE!.
		// Case #14: Array, Number. Boolean array returns #VALUE!.
		// Case #17: String, Number. Mixed date and text in array returns #VALUE!.
		// Case #18: Area3D, Number. 3D range with invalid data returns #VALUE!.
		// Case #20: String, Number. Empty string in array returns #VALUE!.

		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "PERCENTILE", 2, 2, null, true);
	});

	QUnit.test("Test: \"PERCENTILE.INC\"", function (assert) {
		ws.getRange2("A2").setValue("1");
		ws.getRange2("A3").setValue("2");
		ws.getRange2("A4").setValue("3");
		ws.getRange2("A5").setValue("4");

		oParser = new parserFormula("PERCENTILE.INC(A2:A5,0.3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1.9);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number, Number. Array of integers, k as decimal. Returns median (2).
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, Number. Array of integers, k as decimal. Returns median (2).');
		// Case #2: Array, Number. Array with multiple elements, k as quartile. Returns 1.75.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3,4}, 0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3,4}, 0.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.75, 'Test: Positive case: Array, Number. Array with multiple elements, k as quartile. Returns 1.75.');
		// Case #3: String, Number. Numeric strings converted to numbers. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC({"1","2","3"}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({"1","2","3"}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String, Number. Numeric strings converted to numbers. Returns 2.');
		// Case #4: Reference link, Number. Reference to array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC(A100, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(A100, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number. Reference to array, k as number. Returns 2.');
		// Case #5: Area, Number. Single-cell range for array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC(A101:A102, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(A101:A102, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Number. Single-cell range for array, k as number. Returns 2.');
		// Case #6: Table, Number. Table structured reference, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC(Table1[Column1], 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(Table1[Column1], 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Number. Table structured reference, k as number. Returns 2.');
		// Case #7: Name, Number. Named range for array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC(TestName, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(TestName, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name, Number. Named range for array, k as number. Returns 2.');
		// Case #8: Name3D, Number. 3D named range, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC(TestName3D, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(TestName3D, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D, Number. 3D named range, k as number. Returns 2.');
		// Case #9: Ref3D, Number. 3D reference to array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC(Sheet2!A1, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(Sheet2!A1, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D, Number. 3D reference to array, k as number. Returns 2.');
		// Case #10: Area3D, Number. 3D single-cell range, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC(Sheet2!A1:A2, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(Sheet2!A1:A2, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area3D, Number. 3D single-cell range, k as number. Returns 2.');
		// Case #11: Number, String. k as numeric string converted to number. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, "0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, "0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, String. k as numeric string converted to number. Returns 2.');
		// Case #12: Reference link, Reference link. Both arguments as references. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(A100, A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link, Reference link. Both arguments as references. Returns 2.');
		// Case #13: Area, Area. Both arguments as single-cell ranges. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC(A102:A103, A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(A102:A103, A104:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area, Area. Both arguments as single-cell ranges. Returns 2.');
		// Case #14: Array, Array. Both arguments as single-element arrays. Returns 2.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, {0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, {0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array, Array. Both arguments as single-element arrays. Returns 2.');
		// Case #15: Number, Number. Larger numbers, k as quartile. Returns 550.
		oParser = new parserFormula('PERCENTILE.INC({10,100,1000}, 0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({10,100,1000}, 0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 550, 'Test: Positive case: Number, Number. Larger numbers, k as quartile. Returns 550.');
		// Case #16: Number, Number. Array of decimals, k as decimal. Returns 2.5.
		oParser = new parserFormula('PERCENTILE.INC({1.5,2.5,3.5}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1.5,2.5,3.5}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Number, Number. Array of decimals, k as decimal. Returns 2.5.');
		// Case #17: Formula. PERCENTILE.INC inside SUM formula. Returns 3.
		oParser = new parserFormula('SUM(PERCENTILE.INC({1,2,3}, 0.5), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PERCENTILE.INC({1,2,3}, 0.5), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. PERCENTILE.INC inside SUM formula. Returns 3.');
		// Case #18: Number, Number. Small k value. Returns 1.2.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.2, 'Test: Positive case: Number, Number. Small k value. Returns 1.2.');
		// Case #19: Number, Number. Large k value. Returns 2.8.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, 0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.8, 'Test: Positive case: Number, Number. Large k value. Returns 2.8.');
		// Case #20: Date, Number. Dates as serial numbers (e.g., 01/01/2016, 02/01/2016). Returns median.
		oParser = new parserFormula('PERCENTILE.INC({42139,42170}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({42139,42170}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 42154.5, 'Test: Positive case: Date, Number. Dates as serial numbers (e.g., 01/01/2016, 02/01/2016). Returns median.');

		// Negative cases:
		// Case #1: Number, Number. k < 0 returns #NUM!.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, -0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, -0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. k < 0 returns #NUM!.');
		// Case #2: Number, Number. k > 1 returns #NUM!.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, 1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, 1.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. k > 1 returns #NUM!.');
		// Case #3: String, Number. Non-numeric string in array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC({"abc",2,3}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({"abc",2,3}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Negative case: String, Number. Non-numeric string in array returns #VALUE!.');
		// Case #4: Empty, Number. Empty array returns #NUM!.
		oParser = new parserFormula('PERCENTILE.INC({""}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({""}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty array returns #NUM!.');
		// Case #5: Error, Number. Error in array propagates #N/A.
		oParser = new parserFormula('PERCENTILE.INC(NA(), 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(NA(), 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error in array propagates #N/A.');
		// Case #6: Area, Number. Multi-cell range with invalid data returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC(A105:A106, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(A105:A106, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area, Number. Multi-cell range with invalid data returns #VALUE!.');
		// Case #7: Reference link, Number. Reference to empty cell returns #NUM!.
		oParser = new parserFormula('PERCENTILE.INC(A107, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(A107, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Number. Reference to empty cell returns #NUM!.');
		// Case #8: Number, String. Non-numeric k returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric k returns #VALUE!.');
		// Case #9: Number, Boolean. Boolean k (1) is valid but tested for edge case. Returns 3.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Number, Boolean. Boolean k (1) is valid but tested for edge case. Returns 3.');
		// Case #10: Ref3D, Number. 3D reference to text returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC(Sheet2!A3, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(Sheet2!A3, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D, Number. 3D reference to text returns #VALUE!.');
		// Case #11: Name, Number. Named range with invalid data returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC(TestNameArea, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(TestNameArea, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Name, Number. Named range with invalid data returns #VALUE!.');
		// Case #13: Number, Number. Single-element array returns valid result but tested for edge case. Returns 1.
		oParser = new parserFormula('PERCENTILE.INC({1}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Number. Single-element array returns valid result but tested for edge case. Returns 1.');
		// Case #14: Array, Number. Boolean array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC({FALSE}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({FALSE}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Boolean array returns #VALUE!.');
		// Case #15: Number, Number. k slightly above 1 returns #NUM!.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, 1+1e-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, 1+1e-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. k slightly above 1 returns #NUM!.');
		// Case #16: Number, Number. Extreme numbers return valid result but tested for edge case. Returns median.
		oParser = new parserFormula('PERCENTILE.INC({-1E+307,1E+307}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({-1E+307,1E+307}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number, Number. Extreme numbers return valid result but tested for edge case. Returns median.');
		// Case #17: String, Number. Mixed date and text in array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC({"01/01/2025","abc"}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({"01/01/2025","abc"}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Mixed date and text in array returns #VALUE!.');
		// Case #18: Area3D, Number. 3D range with invalid data returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC(Sheet2!A3:A4, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC(Sheet2!A3:A4, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D range with invalid data returns #VALUE!.');
		// Case #19: Number, Empty. Empty k returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Empty. Empty k returns #VALUE!.');
		// Case #20: String, Number. Empty string in array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.INC({""}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({""}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Empty string in array returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number, Number. Minimum valid k (0). Returns 1.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Minimum valid k (0). Returns 1.');
		// Case #2: Number, Number. Maximum valid k (1). Returns 3.
		oParser = new parserFormula('PERCENTILE.INC({1,2,3}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1,2,3}, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Bounded case: Number, Number. Maximum valid k (1). Returns 3.');
		// Case #3: Number, Number. Maximum valid number in array. Returns median.
		oParser = new parserFormula('PERCENTILE.INC({9.99999999999999E+307,1}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({9.99999999999999E+307,1}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.999999999999995e+307, 'Test: Bounded case: Number, Number. Maximum valid number in array. Returns median.');
		// Case #4: Number, Number. Minimum valid number in array. Returns median.
		oParser = new parserFormula('PERCENTILE.INC({1E-307,2}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.INC({1E-307,2}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Minimum valid number in array. Returns median.');

		// Need to fix: empty handle, error types difference, results different from MS
		// Case #3: String, Number. Numeric strings converted to numbers. Returns 2.
		// Case #4: Reference link, Number. Reference to array, k as number. Returns 2.
		// Case #6: Table, Number. Table structured reference, k as number. Returns 2.
		// Case #7: Name, Number. Named range for array, k as number. Returns 2.
		// Case #8: Name3D, Number. 3D named range, k as number. Returns 2.
		// Case #9: Ref3D, Number. 3D reference to array, k as number. Returns 2.
		// Case #10: Area3D, Number. 3D single-cell range, k as number. Returns 2.
		// Case #12: Reference link, Reference link. Both arguments as references. Returns 2.
		// Case #13: Area, Area. Both arguments as single-cell ranges. Returns 2.
		// Case #4: Empty, Number. Empty array returns #NUM!.
		// Case #7: Reference link, Number. Reference to empty cell returns #NUM!.
		// Case #10: Ref3D, Number. 3D reference to text returns #VALUE!.
		// Case #11: Name, Number. Named range with invalid data returns #VALUE!.
		// Case #14: Array, Number. Boolean array returns #VALUE!.
		// Case #17: String, Number. Mixed date and text in array returns #VALUE!.
		// Case #18: Area3D, Number. 3D range with invalid data returns #VALUE!.
		// Case #20: String, Number. Empty string in array returns #VALUE!.

	});

	QUnit.test("Test: \"PERCENTILE.EXC\"", function (assert) {
		ws.getRange2("A202").setValue("1");
		ws.getRange2("A203").setValue("2");
		ws.getRange2("A204").setValue("3");
		ws.getRange2("A205").setValue("6");
		ws.getRange2("A206").setValue("6");
		ws.getRange2("A207").setValue("6");
		ws.getRange2("A208").setValue("7");
		ws.getRange2("A209").setValue("8");
		ws.getRange2("A210").setValue("9");

		oParser = new parserFormula("PERCENTILE.EXC(A202:A210, 0.25)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTILE.EXC(A202:A210, 0.25)");
		assert.strictEqual(oParser.calculate().getValue(), 2.5, "PERCENTILE.EXC(A202:A210, 0.25)");

		oParser = new parserFormula("PERCENTILE.EXC(A202:A210, 0)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTILE.EXC(A202:A210, 0)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "PERCENTILE.EXC(A202:A210, 0)");

		oParser = new parserFormula("PERCENTILE.EXC(A202:A210, 0.01)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTILE.EXC(A202:A210, 0.01)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "PERCENTILE.EXC(A202:A210, 0.01)");

		oParser = new parserFormula("PERCENTILE.EXC(A202:A210, 2)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTILE.EXC(A202:A210, 2)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "PERCENTILE.EXC(A202:A210, 2)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number, Number. Array of integers, k as decimal. Returns median (2).
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, Number. Array of integers, k as decimal. Returns median (2).');
		// Case #2: Array, Number. Array with multiple elements, k as quartile. Returns 1.75.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3,4}, 0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3,4}, 0.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Positive case: Array, Number. Array with multiple elements, k as quartile. Returns 1.75.');
		// Case #3: String, Number. Numeric strings converted to numbers. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC({"1","2","3"}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({"1","2","3"}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String, Number. Numeric strings converted to numbers. Returns 2.');
		// Case #4: Reference link, Number. Reference to array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC(A100, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(A100, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number. Reference to array, k as number. Returns 2.');
		// Case #5: Area, Number. Single-cell range for array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC(A101:A102, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(A101:A102, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Number. Single-cell range for array, k as number. Returns 2.');
		// Case #6: Table, Number. Table structured reference, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC(Table1[Column1], 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(Table1[Column1], 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Number. Table structured reference, k as number. Returns 2.');
		// Case #7: Name, Number. Named range for array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC(TestName, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(TestName, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name, Number. Named range for array, k as number. Returns 2.');
		// Case #8: Name3D, Number. 3D named range, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC(TestName3D, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(TestName3D, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D, Number. 3D named range, k as number. Returns 2.');
		// Case #9: Ref3D, Number. 3D reference to array, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC(Sheet2!A1, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(Sheet2!A1, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D, Number. 3D reference to array, k as number. Returns 2.');
		// Case #10: Area3D, Number. 3D single-cell range, k as number. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC(Sheet2!A1:A2, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(Sheet2!A1:A2, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area3D, Number. 3D single-cell range, k as number. Returns 2.');
		// Case #11: Number, String. k as numeric string converted to number. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, "0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, "0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number, String. k as numeric string converted to number. Returns 2.');
		// Case #12: Reference link, Reference link. Both arguments as references. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(A100, A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link, Reference link. Both arguments as references. Returns 2.');
		// Case #13: Area, Area. Both arguments as single-cell ranges. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC(A102:A103, A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(A102:A103, A104:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area, Area. Both arguments as single-cell ranges. Returns 2.');
		// Case #14: Array, Array. Both arguments as single-element arrays. Returns 2.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, {0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, {0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array, Array. Both arguments as single-element arrays. Returns 2.');
		// Case #15: Number, Number. Larger numbers, k as quartile. Returns 550.
		oParser = new parserFormula('PERCENTILE.EXC({10,100,1000}, 0.75)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({10,100,1000}, 0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Positive case: Number, Number. Larger numbers, k as quartile. Returns 550.');
		// Case #16: Number, Number. Array of decimals, k as decimal. Returns 2.5.
		oParser = new parserFormula('PERCENTILE.EXC({1.5,2.5,3.5}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1.5,2.5,3.5}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Number, Number. Array of decimals, k as decimal. Returns 2.5.');
		// Case #17: Formula. PERCENTILE.EXC inside SUM formula. Returns 3.
		oParser = new parserFormula('SUM(PERCENTILE.EXC({1,2,3}, 0.5), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PERCENTILE.EXC({1,2,3}, 0.5), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. PERCENTILE.EXC inside SUM formula. Returns 3.');
		// Case #18: Number, Number. Small k value. Returns 1.2.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, 0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.2, 'Test: Positive case: Number, Number. Small k value. Returns 1.2.');
		// Case #19: Number, Number. Large k value. Returns 2.8.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, 0.9) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.8, 'Test: Positive case: Number, Number. Large k value. Returns 2.8.');
		// Case #20: Date, Number. Dates as serial numbers (e.g., 01/01/2016, 02/01/2016). Returns median.
		oParser = new parserFormula('PERCENTILE.EXC({42139,42170}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({42139,42170}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 42154.5, 'Test: Positive case: Date, Number. Dates as serial numbers (e.g., 01/01/2016, 02/01/2016). Returns median.');

		// Negative cases:
		// Case #1: Number, Number. k < 0 returns #NUM!.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, -0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, -0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. k < 0 returns #NUM!.');
		// Case #2: Number, Number. k > 1 returns #NUM!.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, 1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, 1.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. k > 1 returns #NUM!.');
		// Case #3: String, Number. Non-numeric string in array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC({"abc",2,3}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({"abc",2,3}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Negative case: String, Number. Non-numeric string in array returns #VALUE!.');
		// Case #4: Empty, Number. Empty array returns #NUM!.
		oParser = new parserFormula('PERCENTILE.EXC({""}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({""}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty array returns #NUM!.');
		// Case #5: Error, Number. Error in array propagates #N/A.
		oParser = new parserFormula('PERCENTILE.EXC(NA(), 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(NA(), 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error in array propagates #N/A.');
		// Case #6: Area, Number. Multi-cell range with invalid data returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC(A105:A106, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(A105:A106, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area, Number. Multi-cell range with invalid data returns #VALUE!.');
		// Case #7: Reference link, Number. Reference to empty cell returns #NUM!.
		oParser = new parserFormula('PERCENTILE.EXC(A107, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(A107, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Number. Reference to empty cell returns #NUM!.');
		// Case #8: Number, String. Non-numeric k returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric k returns #VALUE!.');
		// Case #9: Number, Boolean. Boolean k (1) is valid but tested for edge case. Returns 3.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Number, Boolean. Boolean k (1) is valid but tested for edge case. Returns 3.');
		// Case #10: Ref3D, Number. 3D reference to text returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC(Sheet2!A3, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(Sheet2!A3, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D, Number. 3D reference to text returns #VALUE!.');
		// Case #11: Name, Number. Named range with invalid data returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC(TestNameArea, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(TestNameArea, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Name, Number. Named range with invalid data returns #VALUE!.');
		// Case #13: Number, Number. Single-element array returns valid result but tested for edge case. Returns 1.
		oParser = new parserFormula('PERCENTILE.EXC({1}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Number. Single-element array returns valid result but tested for edge case. Returns 1.');
		// Case #14: Array, Number. Boolean array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC({FALSE}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({FALSE}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Boolean array returns #VALUE!.');
		// Case #15: Number, Number. k slightly above 1 returns #NUM!.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, 1+1e-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, 1+1e-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. k slightly above 1 returns #NUM!.');
		// Case #16: Number, Number. Extreme numbers return valid result but tested for edge case. Returns median.
		oParser = new parserFormula('PERCENTILE.EXC({-1E+307,1E+307}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({-1E+307,1E+307}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number, Number. Extreme numbers return valid result but tested for edge case. Returns median.');
		// Case #17: String, Number. Mixed date and text in array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC({"01/01/2025","abc"}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({"01/01/2025","abc"}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Mixed date and text in array returns #VALUE!.');
		// Case #18: Area3D, Number. 3D range with invalid data returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC(Sheet2!A3:A4, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC(Sheet2!A3:A4, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D range with invalid data returns #VALUE!.');
		// Case #19: Number, Empty. Empty k returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, ) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Empty. Empty k returns #VALUE!.');
		// Case #20: String, Number. Empty string in array returns #VALUE!.
		oParser = new parserFormula('PERCENTILE.EXC({""}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({""}, 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Empty string in array returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number, Number. Minimum valid k (0). Returns 1.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Minimum valid k (0). Returns 1.');
		// Case #2: Number, Number. Maximum valid k (1). Returns 3.
		oParser = new parserFormula('PERCENTILE.EXC({1,2,3}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1,2,3}, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Bounded case: Number, Number. Maximum valid k (1). Returns 3.');
		// Case #3: Number, Number. Maximum valid number in array. Returns median.
		oParser = new parserFormula('PERCENTILE.EXC({9.99999999999999E+307,1}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({9.99999999999999E+307,1}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.999999999999995e+307, 'Test: Bounded case: Number, Number. Maximum valid number in array. Returns median.');
		// Case #4: Number, Number. Minimum valid number in array. Returns median.
		oParser = new parserFormula('PERCENTILE.EXC({1E-307,2}, 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTILE.EXC({1E-307,2}, 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Minimum valid number in array. Returns median.');

		// Need to fix: empty handle, error types difference, results different from MS, Many cases different with arrays
		// Case #3: String, Number. Numeric strings converted to numbers. Returns 2.
		// Case #4: Reference link, Number. Reference to array, k as number. Returns 2.
		// Case #6: Table, Number. Table structured reference, k as number. Returns 2.
		// Case #7: Name, Number. Named range for array, k as number. Returns 2.
		// Case #8: Name3D, Number. 3D named range, k as number. Returns 2.
		// Case #9: Ref3D, Number. 3D reference to array, k as number. Returns 2.
		// Case #10: Area3D, Number. 3D single-cell range, k as number. Returns 2.
		// Case #12: Reference link, Reference link. Both arguments as references. Returns 2.
		// Case #13: Area, Area. Both arguments as single-cell ranges. Returns 2.
		// Case #4: Empty, Number. Empty array returns #NUM!.
		// Case #7: Reference link, Number. Reference to empty cell returns #NUM!.
		// Case #10: Ref3D, Number. 3D reference to text returns #VALUE!.
		// Case #11: Name, Number. Named range with invalid data returns #VALUE!.
		// Case #14: Array, Number. Boolean array returns #VALUE!.
		// Case #17: String, Number. Mixed date and text in array returns #VALUE!.
		// Case #18: Area3D, Number. 3D range with invalid data returns #VALUE!.
		// Case #20: String, Number. Empty string in array returns #VALUE!.
		// Case #18: Number, Number. Small k value. Returns 1.2.

		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "PERCENTILE.EXC", 2, 2, null, true)
	});

	QUnit.test("Test: \"PERCENTRANK\"", function (assert) {

		function percentrank(A, x, k) {

			var tA = A, t, fNum = x;

			if (!k) {
				k = 3;
			}

			tA.sort(fSortAscending);

			var nSize = tA.length;
			if (tA.length < 1 || nSize == 0) {
				return "#N/A";
			} else {
				if (fNum < tA[0] || fNum > tA[nSize - 1]) {
					return "#N/A";
				} else if (nSize == 1) {
					return 1
				} else {
					var fRes, nOldCount = 0, fOldVal = tA[0], i;
					for (i = 1; i < nSize && tA[i] < fNum; i++) {
						if (tA[i] != fOldVal) {
							nOldCount = i;
							fOldVal = tA[i];
						}
					}
					if (tA[i] != fOldVal) {
						nOldCount = i;
					}
					if (fNum == tA[i]) {
						fRes = nOldCount / (nSize - 1);
					} else {
						if (nOldCount == 0) {
							fRes = 0.0;
						} else {
							var fFract = (fNum - tA[nOldCount - 1]) / (tA[nOldCount] - tA[nOldCount - 1]);
							fRes = (nOldCount - 1 + fFract) / (nSize - 1);
						}
					}
					return fRes.toString().substr(0, fRes.toString().indexOf(".") + 1 + k) - 0;
				}
			}
		}

		oParser = new parserFormula("PERCENTRANK({12,6,7,9,3,8},4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), percentrank([12, 6, 7, 9, 3, 8], 4));

		oParser = new parserFormula("PERCENTRANK({12,6,7,9,3,8},5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), percentrank([12, 6, 7, 9, 3, 8], 5));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: array of numbers, x in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.333, 'Test: Positive case: Number. Basic valid input: array of numbers, x in array. 2 of 3 arguments used.');
		// Case #1: Number. Valid input with significance specified. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3,4},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3,4},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.333, 'Test: Positive case: Number. Valid input with significance specified. 3 of 3 arguments used.');
		// Case #2: Array. Array input, x not in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({5,3,7,1},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({5,3,7,1},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Array input, x not in array. 2 of 3 arguments used.');
		// Case #3: String. String array convertible to numbers. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({"1","2","3"},"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({"1","2","3"},"2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. String array convertible to numbers. 2 of 3 arguments used.');
		// Case #4: Formula. Nested formula for x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3},AVERAGE(1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3},AVERAGE(1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested formula for x. 2 of 3 arguments used.');
		// Case #5: Reference link. Reference link to array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(A100:A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(A100:A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Reference link. Reference link to array and x. 2 of 3 arguments used.');
		// Case #6: Area. Single-cell range for array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(A100:A101,A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(A100:A101,A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell range for array. 2 of 3 arguments used.');
		// Case #7: Area. Multi-cell range for array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(A100:A102,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(A100:A102,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Multi-cell range for array. 2 of 3 arguments used.');
		// Case #8: Name. Named range for array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name. Named range for array and x. 2 of 3 arguments used.');
		// Case #9: Name3D. 3D named range for array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name3D. 3D named range for array and x. 2 of 3 arguments used.');
		// Case #10: Ref3D. 3D reference to array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(Sheet2!A1:A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(Sheet2!A1:A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D reference to array and x. 2 of 3 arguments used.');
		// Case #11: Area3D. 3D single-cell range for array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(Sheet2!A1:A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(Sheet2!A1:A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell range for array. 2 of 3 arguments used.');
		// Case #12: Table. Table structured reference. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference. 2 of 3 arguments used.');
		// Case #13: Date. Date as serial numbers. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({45688,45689},DATE(2025,1,15))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({45688,45689},DATE(2025,1,15)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Date. Date as serial numbers. 2 of 3 arguments used.');
		// Case #14: Time. Time as fractional numbers. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({0.04,0.083},TIME(1,30,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({0.04,0.083},TIME(1,30,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.523, 'Test: Positive case: Time. Time as fractional numbers. 2 of 3 arguments used.');
		// Case #15: Formula. PERCENTRANK inside SUM formula. 2 of 3 arguments used.
		oParser = new parserFormula('SUM(PERCENTRANK({1,2,3},2),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PERCENTRANK({1,2,3},2),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6, 'Test: Positive case: Formula. PERCENTRANK inside SUM formula. 2 of 3 arguments used.');
		// Case #16: Number. Very small number in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({0.000000000000001,1},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({0.000000000000001,1},0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.499, 'Test: Positive case: Number. Very small number in array. 2 of 3 arguments used.');
		// Case #17: String. Float strings in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({"1.5","2.5"},"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({"1.5","2.5"},"2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Float strings in array. 2 of 3 arguments used.');
		// Case #18: Array. Larger array with valid x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3,4,5},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3,4,5},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Larger array with valid x. 2 of 3 arguments used.');
		// Case #19: Formula. Nested IF for x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3},IF(TRUE,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3},IF(TRUE,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested IF for x. 2 of 3 arguments used.');
		// Case #20: Number. Negative and zero values in array. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({-100,0,100},0,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({-100,0,100},0,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Negative and zero values in array. 3 of 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Single-element array returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Single-element array returns #N/A. 2 of 3 arguments used.');
		// Case #1: Empty. Empty array reference returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(A105:A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(A105:A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Empty array reference returns #N/A. 2 of 3 arguments used.');
		// Case #2: String. Non-numeric strings in array return #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({"abc","def"},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({"abc","def"},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Non-numeric strings in array return #VALUE!. 2 of 3 arguments used.');
		// Case #3: Error. Error in array propagates #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(1/0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(1/0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Error in array propagates #N/A. 2 of 3 arguments used.');
		// Case #4: Number. Error in x propagates #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Error in x propagates #N/A. 2 of 3 arguments used.');
		// Case #5: Number. Negative significance returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3},1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3},1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative significance returns #NUM!. 3 of 3 arguments used.');
		// Case #6: Area. Multi-cell range for x returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(A100:A102,A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 2 of 3 arguments used.');
		// Case #7: Boolean. Boolean array returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({TRUE,FALSE},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({TRUE,FALSE},TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean. Boolean array returns #N/A. 2 of 3 arguments used.');
		// Case #8: Ref3D. 3D ref to non-numeric data returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(Sheet2!A6:A9,Sheet2!A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(Sheet2!A6:A9,Sheet2!A10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D. 3D ref to non-numeric data returns #VALUE!. 2 of 3 arguments used.');
		// Case #9: Name. Named range with non-numeric data returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(TestNameArea,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(TestNameArea,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with non-numeric data returns #VALUE!. 2 of 3 arguments used.');
		// Case #11: Formula. Formula resulting in #NUM! propagates error. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3},SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3},SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 of 3 arguments used.');
		// Case #12: Number. Empty array literal returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({""},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({""},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Empty array literal returns #N/A. 2 of 3 arguments used.');
		// Case #13: String. Empty string in array returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({"1",""},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({"1",""},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Empty string in array returns #VALUE!. 2 of 3 arguments used.');
		// Case #14: Array. Mixed array with non-numeric element returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,"abc"},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,"abc"},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Mixed array with non-numeric element returns #VALUE!. 2 of 3 arguments used.');
		// Case #15: Number. Zero significance returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero significance returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Area3D. Multi-cell 3D range for array returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK(Sheet2!A1:B2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK(Sheet2!A1:B2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. Multi-cell 3D range for array returns #VALUE!. 2 of 3 arguments used.');
		// Case #17: Time. Time values (0 to 1) valid but edge case. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({0,0.04167},TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({0,0.04167},TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Time. Time values (0 to 1) valid but edge case. 2 of 3 arguments used.');
		// Case #18: String. Non-numeric x string returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({"-1","0"},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({"-1","0"},"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric x string returns #VALUE!. 2 of 3 arguments used.');
		// Case #19: Formula. Division by zero in x returns #DIV/0!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3},1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3},1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero in x returns #DIV/0!. 2 of 3 arguments used.');

		// Bounded cases:
		// Case #0: Number. Max/min Excel numbers in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({-1.79769313486232E+307,1.79769313486232E+307},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({-1.79769313486232E+307,1.79769313486232E+307},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Max/min Excel numbers in array. 2 of 3 arguments used.');
		// Case #1: Number. Smallest positive number in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({2.2250738585072E-308,1},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({2.2250738585072E-308,1},0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Smallest positive number in array. 2 of 3 arguments used.');
		// Case #2: Number. Max significance (15 digits). 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK({1,2,3},1,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK({1,2,3},1,15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Max significance (15 digits). 3 of 3 arguments used.');

		// Need to fix: error types difference, Boolean handle
		// Case #8: Name. Named range for array and x. 2 of 3 arguments used.
		// Case #9: Name3D. 3D named range for array and x. 2 of 3 arguments used.
		// Case #12: Table. Table structured reference. 2 of 3 arguments used.
		// Case #6: Area. Multi-cell range for x returns #VALUE!. 2 of 3 arguments used.
		// Case #7: Boolean. Boolean array returns #N/A. 2 of 3 arguments used.

		//TODO нужен другой тест
		//testArrayFormula2(assert, "PERCENTRANK", 2, 3, null, true);
	});

	QUnit.test("Test: \"PERCENTRANK.EXC\"", function (assert) {
		ws.getRange2("A202").setValue("1");
		ws.getRange2("A203").setValue("2");
		ws.getRange2("A204").setValue("3");
		ws.getRange2("A205").setValue("6");
		ws.getRange2("A206").setValue("6");
		ws.getRange2("A207").setValue("6");
		ws.getRange2("A208").setValue("7");
		ws.getRange2("A209").setValue("8");
		ws.getRange2("A210").setValue("9");

		oParser = new parserFormula("PERCENTRANK.EXC(A202:A210, 7)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTRANK.EXC(A202:A210, 7)");
		assert.strictEqual(oParser.calculate().getValue(), 0.7, "PERCENTRANK.EXC(A202:A210, 7)");

		oParser = new parserFormula("PERCENTRANK.EXC(A202:A210, 5.43)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTRANK.EXC(A202:A210, 5.43)");
		assert.strictEqual(oParser.calculate().getValue(), 0.381, "PERCENTRANK.EXC(A202:A210, 5.43)");

		oParser = new parserFormula("PERCENTRANK.EXC(A202:A210, 5.43, 1)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTRANK.EXC(A202:A210, 5.43, 1)");
		assert.strictEqual(oParser.calculate().getValue(), 0.3, "PERCENTRANK.EXC(A202:A210, 5.43, 1)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: array of numbers, x in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4, 'Test: Positive case: Number. Basic valid input: array of numbers, x in array. 2 of 3 arguments used.');
		// Case #1: Number. Valid input with significance specified. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3,4},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3,4},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4, 'Test: Positive case: Number. Valid input with significance specified. 3 of 3 arguments used.');
		// Case #2: Array. Array input, x not in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({5,3,7,1},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({5,3,7,1},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Array input, x not in array. 2 of 3 arguments used.');
		// Case #3: String. String array convertible to numbers. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({"1","2","3"},"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({"1","2","3"},"2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. String array convertible to numbers. 2 of 3 arguments used.');
		// Case #4: Formula. Nested formula for x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3},AVERAGE(1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3},AVERAGE(1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested formula for x. 2 of 3 arguments used.');
		// Case #5: Reference link. Reference link to array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(A100:A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(A100:A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Reference link. Reference link to array and x. 2 of 3 arguments used.');
		// Case #6: Area. Single-cell range for array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(A100:A101,A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(A100:A101,A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.333, 'Test: Positive case: Area. Single-cell range for array. 2 of 3 arguments used.');
		// Case #7: Area. Multi-cell range for array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(A100:A102,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(A100:A102,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Area. Multi-cell range for array. 2 of 3 arguments used.');
		// Case #8: Name. Named range for array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name. Named range for array and x. 2 of 3 arguments used.');
		// Case #9: Name3D. 3D named range for array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name3D. 3D named range for array and x. 2 of 3 arguments used.');
		// Case #10: Ref3D. 3D reference to array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(Sheet2!A1:A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(Sheet2!A1:A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D reference to array and x. 2 of 3 arguments used.');
		// Case #11: Area3D. 3D single-cell range for array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(Sheet2!A1:A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(Sheet2!A1:A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell range for array. 2 of 3 arguments used.');
		// Case #12: Table. Table structured reference. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference. 2 of 3 arguments used.');
		// Case #13: Date. Date as serial numbers. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({45688,45689},DATE(2025,1,15))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({45688,45689},DATE(2025,1,15)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Date. Date as serial numbers. 2 of 3 arguments used.');
		// Case #14: Time. Time as fractional numbers. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({0.04,0.083},TIME(1,30,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({0.04,0.083},TIME(1,30,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.507, 'Test: Positive case: Time. Time as fractional numbers. 2 of 3 arguments used.');
		// Case #15: Formula. PERCENTRANK.EXC inside SUM formula. 2 of 3 arguments used.
		oParser = new parserFormula('SUM(PERCENTRANK.EXC({1,2,3},2),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PERCENTRANK.EXC({1,2,3},2),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6, 'Test: Positive case: Formula. PERCENTRANK.EXC inside SUM formula. 2 of 3 arguments used.');
		// Case #16: Number. Very small number in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({0.000000000000001,1},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({0.000000000000001,1},0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Very small number in array. 2 of 3 arguments used.');
		// Case #17: String. Float strings in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({"1.5","2.5"},"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({"1.5","2.5"},"2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Float strings in array. 2 of 3 arguments used.');
		// Case #18: Array. Larger array with valid x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3,4,5},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3,4,5},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Larger array with valid x. 2 of 3 arguments used.');
		// Case #19: Formula. Nested IF for x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3},IF(TRUE,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3},IF(TRUE,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested IF for x. 2 of 3 arguments used.');
		// Case #20: Number. Negative and zero values in array. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({-100,0,100},0,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({-100,0,100},0,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Negative and zero values in array. 3 of 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Single-element array returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Single-element array returns #N/A. 2 of 3 arguments used.');
		// Case #1: Empty. Empty array reference returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(A105:A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(A105:A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Empty array reference returns #N/A. 2 of 3 arguments used.');
		// Case #2: String. Non-numeric strings in array return #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({"abc","def"},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({"abc","def"},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Non-numeric strings in array return #VALUE!. 2 of 3 arguments used.');
		// Case #3: Error. Error in array propagates #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(1/0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(1/0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Error in array propagates #N/A. 2 of 3 arguments used.');
		// Case #4: Number. Error in x propagates #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Error in x propagates #N/A. 2 of 3 arguments used.');
		// Case #5: Number. Negative significance returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3},1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3},1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative significance returns #NUM!. 3 of 3 arguments used.');
		// Case #6: Area. Multi-cell range for x returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(A100:A102,A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 2 of 3 arguments used.');
		// Case #7: Boolean. Boolean array returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({TRUE,FALSE},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({TRUE,FALSE},TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean. Boolean array returns #N/A. 2 of 3 arguments used.');
		// Case #8: Ref3D. 3D ref to non-numeric data returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(Sheet2!A6:A9,Sheet2!A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(Sheet2!A6:A9,Sheet2!A10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D. 3D ref to non-numeric data returns #VALUE!. 2 of 3 arguments used.');
		// Case #9: Name. Named range with non-numeric data returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(TestNameArea,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(TestNameArea,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with non-numeric data returns #VALUE!. 2 of 3 arguments used.');
		// Case #11: Formula. Formula resulting in #NUM! propagates error. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3},SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3},SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 of 3 arguments used.');
		// Case #12: Number. Empty array literal returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({""},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({""},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Empty array literal returns #N/A. 2 of 3 arguments used.');
		// Case #13: String. Empty string in array returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({"1",""},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({"1",""},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Empty string in array returns #VALUE!. 2 of 3 arguments used.');
		// Case #14: Array. Mixed array with non-numeric element returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,"abc"},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,"abc"},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.666, 'Test: Negative case: Array. Mixed array with non-numeric element returns #VALUE!. 2 of 3 arguments used.');
		// Case #15: Number. Zero significance returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero significance returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Area3D. Multi-cell 3D range for array returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC(Sheet2!A1:B2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC(Sheet2!A1:B2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. Multi-cell 3D range for array returns #VALUE!. 2 of 3 arguments used.');
		// Case #17: Time. Time values (0 to 1) valid but edge case. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({0,0.04167},TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({0,0.04167},TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.333, 'Test: Negative case: Time. Time values (0 to 1) valid but edge case. 2 of 3 arguments used.');
		// Case #18: String. Non-numeric x string returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({"-1","0"},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({"-1","0"},"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric x string returns #VALUE!. 2 of 3 arguments used.');
		// Case #19: Formula. Division by zero in x returns #DIV/0!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3},1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3},1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero in x returns #DIV/0!. 2 of 3 arguments used.');

		// Bounded cases:
		// Case #0: Number. Max/min Excel numbers in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({-1.79769313486232E+307,1.79769313486232E+307},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({-1.79769313486232E+307,1.79769313486232E+307},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Max/min Excel numbers in array. 2 of 3 arguments used.');
		// Case #1: Number. Smallest positive number in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({2.2250738585072E-308,1},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({2.2250738585072E-308,1},0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Smallest positive number in array. 2 of 3 arguments used.');
		// Case #2: Number. Max significance (15 digits). 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.EXC({1,2,3},1,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.EXC({1,2,3},1,15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Bounded case: Number. Max significance (15 digits). 3 of 3 arguments used.');

		// Need to fix: error types difference, Boolean handle
		// Case #8: Name. Named range for array and x. 2 of 3 arguments used.
		// Case #9: Name3D. 3D named range for array and x. 2 of 3 arguments used.
		// Case #12: Table. Table structured reference. 2 of 3 arguments used.
		// Case #6: Area. Multi-cell range for x returns #VALUE!. 2 of 3 arguments used.
		// Case #7: Boolean. Boolean array returns #N/A. 2 of 3 arguments used.


		//TODO нужен другой тест
		//testArrayFormula2(assert, "PERCENTRANK.EXC", 2, 3, null, true);
	});

	QUnit.test("Test: \"PERCENTRANK.INC\"", function (assert) {
		ws.getRange2("A202").setValue("13");
		ws.getRange2("A203").setValue("12");
		ws.getRange2("A204").setValue("11");
		ws.getRange2("A205").setValue("8");
		ws.getRange2("A206").setValue("4");
		ws.getRange2("A207").setValue("3");
		ws.getRange2("A208").setValue("2");
		ws.getRange2("A209").setValue("1");
		ws.getRange2("A210").setValue("1");
		ws.getRange2("A211").setValue("1");

		oParser = new parserFormula("PERCENTRANK.INC(A202:A211, 2)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTRANK.INC(A202:A211, 2)");
		assert.strictEqual(oParser.calculate().getValue(), 0.333, "PERCENTRANK.INC(A202:A211, 2)");

		oParser = new parserFormula("PERCENTRANK.INC(A202:A211, 4)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTRANK.INC(A202:A211, 4)");
		assert.strictEqual(oParser.calculate().getValue(), 0.555, "PERCENTRANK.INC(A202:A211, 4)");

		oParser = new parserFormula("PERCENTRANK.INC(A202:A211, 8)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTRANK.INC(A202:A211, 8)");
		assert.strictEqual(oParser.calculate().getValue(), 0.666, "PERCENTRANK.INC(A202:A211, 8)");

		oParser = new parserFormula("PERCENTRANK.INC(A202:A211, 5)", "A1", ws);
		assert.ok(oParser.parse(), "PERCENTRANK.INC(A202:A211, 5)");
		assert.strictEqual(oParser.calculate().getValue(), 0.583, "PERCENTRANK.INC(A202:A211, 5)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: array of numbers, x in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.333, 'Test: Positive case: Number. Basic valid input: array of numbers, x in array. 2 of 3 arguments used.');
		// Case #1: Number. Valid input with significance specified. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3,4},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3,4},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.333, 'Test: Positive case: Number. Valid input with significance specified. 3 of 3 arguments used.');
		// Case #2: Array. Array input, x not in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({5,3,7,1},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({5,3,7,1},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Array input, x not in array. 2 of 3 arguments used.');
		// Case #3: String. String array convertible to numbers. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({"1","2","3"},"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({"1","2","3"},"2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. String array convertible to numbers. 2 of 3 arguments used.');
		// Case #4: Formula. Nested formula for x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3},AVERAGE(1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3},AVERAGE(1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested formula for x. 2 of 3 arguments used.');
		// Case #5: Reference link. Reference link to array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(A100:A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(A100:A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Reference link. Reference link to array and x. 2 of 3 arguments used.');
		// Case #6: Area. Single-cell range for array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(A100:A101,A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(A100:A101,A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell range for array. 2 of 3 arguments used.');
		// Case #7: Area. Multi-cell range for array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(A100:A102,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(A100:A102,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Multi-cell range for array. 2 of 3 arguments used.');
		// Case #8: Name. Named range for array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name. Named range for array and x. 2 of 3 arguments used.');
		// Case #9: Name3D. 3D named range for array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name3D. 3D named range for array and x. 2 of 3 arguments used.');
		// Case #10: Ref3D. 3D reference to array and x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(Sheet2!A1:A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(Sheet2!A1:A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D. 3D reference to array and x. 2 of 3 arguments used.');
		// Case #11: Area3D. 3D single-cell range for array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(Sheet2!A1:A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(Sheet2!A1:A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell range for array. 2 of 3 arguments used.');
		// Case #12: Table. Table structured reference. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference. 2 of 3 arguments used.');
		// Case #13: Date. Date as serial numbers. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({45688,45689},DATE(2025,1,15))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({45688,45689},DATE(2025,1,15)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Date. Date as serial numbers. 2 of 3 arguments used.');
		// Case #14: Time. Time as fractional numbers. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({0.04,0.083},TIME(1,30,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({0.04,0.083},TIME(1,30,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.523, 'Test: Positive case: Time. Time as fractional numbers. 2 of 3 arguments used.');
		// Case #15: Formula. PERCENTRANK.INC inside SUM formula. 2 of 3 arguments used.
		oParser = new parserFormula('SUM(PERCENTRANK.INC({1,2,3},2),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PERCENTRANK.INC({1,2,3},2),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6, 'Test: Positive case: Formula. PERCENTRANK.INC inside SUM formula. 2 of 3 arguments used.');
		// Case #16: Number. Very small number in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({0.000000000000001,1},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({0.000000000000001,1},0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.499, 'Test: Positive case: Number. Very small number in array. 2 of 3 arguments used.');
		// Case #17: String. Float strings in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({"1.5","2.5"},"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({"1.5","2.5"},"2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Float strings in array. 2 of 3 arguments used.');
		// Case #18: Array. Larger array with valid x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3,4,5},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3,4,5},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Larger array with valid x. 2 of 3 arguments used.');
		// Case #19: Formula. Nested IF for x. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3},IF(TRUE,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3},IF(TRUE,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested IF for x. 2 of 3 arguments used.');
		// Case #20: Number. Negative and zero values in array. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({-100,0,100},0,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({-100,0,100},0,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Negative and zero values in array. 3 of 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Single-element array returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Single-element array returns #N/A. 2 of 3 arguments used.');
		// Case #1: Empty. Empty array reference returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(A105:A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(A105:A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Empty array reference returns #N/A. 2 of 3 arguments used.');
		// Case #2: String. Non-numeric strings in array return #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({"abc","def"},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({"abc","def"},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Non-numeric strings in array return #VALUE!. 2 of 3 arguments used.');
		// Case #3: Error. Error in array propagates #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(1/0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(1/0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Error in array propagates #N/A. 2 of 3 arguments used.');
		// Case #4: Number. Error in x propagates #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Error in x propagates #N/A. 2 of 3 arguments used.');
		// Case #5: Number. Negative significance returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3},1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3},1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative significance returns #NUM!. 3 of 3 arguments used.');
		// Case #6: Area. Multi-cell range for x returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(A100:A102,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(A100:A102,A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 2 of 3 arguments used.');
		// Case #7: Boolean. Boolean array returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({TRUE,FALSE},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({TRUE,FALSE},TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean. Boolean array returns #N/A. 2 of 3 arguments used.');
		// Case #8: Ref3D. 3D ref to non-numeric data returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(Sheet2!A6:A9,Sheet2!A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(Sheet2!A6:A9,Sheet2!A10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D. 3D ref to non-numeric data returns #VALUE!. 2 of 3 arguments used.');
		// Case #9: Name. Named range with non-numeric data returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(TestNameArea,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(TestNameArea,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with non-numeric data returns #VALUE!. 2 of 3 arguments used.');
		// Case #11: Formula. Formula resulting in #NUM! propagates error. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3},SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3},SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 of 3 arguments used.');
		// Case #12: Number. Empty array literal returns #N/A. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({""},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({""},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Empty array literal returns #N/A. 2 of 3 arguments used.');
		// Case #13: String. Empty string in array returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({"1",""},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({"1",""},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Empty string in array returns #VALUE!. 2 of 3 arguments used.');
		// Case #14: Array. Mixed array with non-numeric element returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,"abc"},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,"abc"},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Mixed array with non-numeric element returns #VALUE!. 2 of 3 arguments used.');
		// Case #15: Number. Zero significance returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero significance returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Area3D. Multi-cell 3D range for array returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC(Sheet2!A1:B2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC(Sheet2!A1:B2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. Multi-cell 3D range for array returns #VALUE!. 2 of 3 arguments used.');
		// Case #17: Time. Time values (0 to 1) valid but edge case. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({0,0.04167},TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({0,0.04167},TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Time. Time values (0 to 1) valid but edge case. 2 of 3 arguments used.');
		// Case #18: String. Non-numeric x string returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({"-1","0"},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({"-1","0"},"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric x string returns #VALUE!. 2 of 3 arguments used.');
		// Case #19: Formula. Division by zero in x returns #DIV/0!. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3},1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3},1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Division by zero in x returns #DIV/0!. 2 of 3 arguments used.');

		// Bounded cases:
		// Case #0: Number. Max/min Excel numbers in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({-1.79769313486232E+307,1.79769313486232E+307},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({-1.79769313486232E+307,1.79769313486232E+307},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Max/min Excel numbers in array. 2 of 3 arguments used.');
		// Case #1: Number. Smallest positive number in array. 2 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({2.2250738585072E-308,1},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({2.2250738585072E-308,1},0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Smallest positive number in array. 2 of 3 arguments used.');
		// Case #2: Number. Max significance (15 digits). 3 of 3 arguments used.
		oParser = new parserFormula('PERCENTRANK.INC({1,2,3},1,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERCENTRANK.INC({1,2,3},1,15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Max significance (15 digits). 3 of 3 arguments used.');

		// Need to fix: error types difference, Boolean handle
		// Case #8: Name. Named range for array and x. 2 of 3 arguments used.
		// Case #9: Name3D. 3D named range for array and x. 2 of 3 arguments used.
		// Case #12: Table. Table structured reference. 2 of 3 arguments used.
		// Case #6: Area. Multi-cell range for x returns #VALUE!. 2 of 3 arguments used.
		// Case #7: Boolean. Boolean array returns #N/A. 2 of 3 arguments used.

	});

	QUnit.test("Test: \"PERMUT\"", function (assert) {
		ws.getRange2("A2").setValue("100");
		ws.getRange2("A3").setValue("3");

		oParser = new parserFormula("PERMUT(A2,A3)", "A1", ws);
		assert.ok(oParser.parse(), "PERMUT(A2,A3)");
		assert.strictEqual(oParser.calculate().getValue(), 970200, "PERMUT(A2,A3)");

		oParser = new parserFormula("PERMUT(3,2)", "A1", ws);
		assert.ok(oParser.parse(), "PERMUT(3,2)");
		assert.strictEqual(oParser.calculate().getValue(), 6, "PERMUT(3,2)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number, Number. Both arguments are integers. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Number, Number. Both arguments are integers. 2 of 2 arguments used.');
		// Case #1: Number, Number. Both arguments are integers. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(10,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(10,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 720, 'Test: Positive case: Number, Number. Both arguments are integers. 2 of 2 arguments used.');
		// Case #2: String, Number. String convertible to number for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT("5",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT("5",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: String, Number. String convertible to number for number. 2 of 2 arguments used.');
		// Case #3: Number, String. String convertible to number for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,"2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Number, String. String convertible to number for number_chosen. 2 of 2 arguments used.');
		// Case #4: Formula, Number. Nested formula for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(ABS(5),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(ABS(5),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Formula, Number. Nested formula for number. 2 of 2 arguments used.');
		// Case #5: Number, Formula. Nested formula for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Number, Formula. Nested formula for number_chosen. 2 of 2 arguments used.');
		// Case #6: Reference link, Number. Ref to cell with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(A100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(A100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link, Number. Ref to cell with valid number. 2 of 2 arguments used.');
		// Case #7: Number, Reference link. Ref to cell with valid number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Reference link. Ref to cell with valid number_chosen. 2 of 2 arguments used.');
		// Case #8: Area, Number. Single-cell range for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(A100:A100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(A100:A100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area, Number. Single-cell range for number. 2 of 2 arguments used.');
		// Case #9: Number, Area. Single-cell range for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Area. Single-cell range for number_chosen. 2 of 2 arguments used.');
		// Case #10: Array, Number. Array with single element for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT({5},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT({5},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Array, Number. Array with single element for number. 2 of 2 arguments used.');
		// Case #11: Number, Array. Array with single element for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Number, Array. Array with single element for number_chosen. 2 of 2 arguments used.');
		// Case #12: Name, Number. Named range for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(TestName,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(TestName,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Number. Named range for number. 2 of 2 arguments used.');
		// Case #13: Number, Name. Named range for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Name. Named range for number_chosen. 2 of 2 arguments used.');
		// Case #14: Name3D, Number. 3D named range for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(TestName3D,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(TestName3D,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Number. 3D named range for number. 2 of 2 arguments used.');
		// Case #15: Number, Name3D. 3D named range for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Name3D. 3D named range for number_chosen. 2 of 2 arguments used.');
		// Case #16: Ref3D, Number. 3D reference to cell for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(Sheet2!A1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(Sheet2!A1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D, Number. 3D reference to cell for number. 2 of 2 arguments used.');
		// Case #17: Number, Ref3D. 3D reference to cell for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,Sheet2!A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Number, Ref3D. 3D reference to cell for number_chosen. 2 of 2 arguments used.');
		// Case #18: Area3D, Number. 3D single-cell range for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(Sheet2!A1:A1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(Sheet2!A1:A1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D, Number. 3D single-cell range for number. 2 of 2 arguments used.');
		// Case #19: Number, Area3D. 3D single-cell range for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Number, Area3D. 3D single-cell range for number_chosen. 2 of 2 arguments used.');
		// Case #20: Table, Number. Table structured reference for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(Table1[Column1],2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(Table1[Column1],2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table, Number. Table structured reference for number. 2 of 2 arguments used.');
		// Case #22: Date, Number. Date as serial number for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(DATE(2025,1,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(DATE(2025,1,1),2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2084607306, 'Test: Positive case: Date, Number. Date as serial number for number. 2 of 2 arguments used.');
		// Case #23: Time, Number. Time adjusted to valid number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(TIME(0,0,0)+5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(TIME(0,0,0)+5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Time, Number. Time adjusted to valid number. 2 of 2 arguments used.');
		// Case #24: Formula, Formula. Both arguments are formulas. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(ROUND(5.6,0),FLOOR(2.7,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(ROUND(5.6,0),FLOOR(2.7,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Formula, Formula. Both arguments are formulas. 2 of 2 arguments used.');

		// Negative cases:
		// Case #0: Number, Number. number < number_chosen returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. number < number_chosen returns #NUM!. 2 of 2 arguments used.');
		// Case #1: Number, Number. Negative number returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(-1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(-1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative number returns #NUM!. 2 of 2 arguments used.');
		// Case #2: Number, Number. Negative number_chosen returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative number_chosen returns #NUM!. 2 of 2 arguments used.');
		// Case #3: Number, Number. Non-integer number returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(1.5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(1.5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Number. Non-integer number returns #NUM!. 2 of 2 arguments used.');
		// Case #4: Number, Number. Non-integer number_chosen returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Number, Number. Non-integer number_chosen returns #NUM!. 2 of 2 arguments used.');
		// Case #5: String, Number. Non-numeric string returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT("abc",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT("abc",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string returns #VALUE!. 2 of 2 arguments used.');
		// Case #6: Number, String. Non-numeric string for number_chosen returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for number_chosen returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Error, Number. Propagates #N/A error. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Propagates #N/A error. 2 of 2 arguments used.');
		// Case #8: Number, Error. Propagates #N/A error for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Propagates #N/A error for number_chosen. 2 of 2 arguments used.');
		// Case #9: Empty, Number. Reference to empty cell returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(A102,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(A102,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Reference to empty cell returns #VALUE!. 2 of 2 arguments used.');
		// Case #10: Number, Empty. Reference to empty cell for number_chosen returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Empty. Reference to empty cell for number_chosen returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Area, Number. Multi-cell range returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(A100:A101,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number. Multi-cell range returns #VALUE!. 2 of 2 arguments used.');
		// Case #12: Number, Area. Multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,A101:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Number, Area. Multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.');
		// Case #13: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(TestName2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(TestName2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 90, 'Test: Negative case: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #14: Number, Name. Named range with #N/A returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Negative case: Number, Name. Named range with #N/A returns #N/A. 2 of 2 arguments used.');
		// Case #15: Ref3D, Number. 3D ref to text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(Sheet2!A3,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(Sheet2!A3,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Number. 3D ref to text returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Number, Ref3D. 3D ref to #N/A returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,Sheet2!A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Ref3D. 3D ref to #N/A returns #N/A. 2 of 2 arguments used.');
		// Case #17: Area3D, Number. 3D multi-cell range returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(Sheet2!A1:A2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(Sheet2!A1:A2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D multi-cell range returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Number, Area3D. 3D multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(5,Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(5,Sheet2!A2:A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Negative case: Number, Area3D. 3D multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.');
		// Case #20: Formula, Number. Formula resulting in #NUM! returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in #NUM! returns #NUM!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #0: Number, Number. Minimum valid value (0,0) returns 1. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Minimum valid value (0,0) returns 1. 2 of 2 arguments used.');
		// Case #1: Number, Number. Large valid number within Excelâ??s numerical limit. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(170,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(170,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 170, 'Test: Bounded case: Number, Number. Large valid number within Excelâ??s numerical limit. 2 of 2 arguments used.');
		// Case #2: Number, Number. Maximum valid permutation within Excelâ??s numerical limit. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUT(170,170)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUT(170,170) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.257415615308004e+306, 'Test: Bounded case: Number, Number. Maximum valid permutation within Excelâ??s numerical limit. 2 of 2 arguments used.');

		// Need to fix: Different results from MS
		// Case #13: Number, Name. Named range for number_chosen. 2 of 2 arguments used.
		// Case #17: Number, Ref3D. 3D reference to cell for number_chosen. 2 of 2 arguments used.
		// Case #19: Number, Area3D. 3D single-cell range for number_chosen. 2 of 2 arguments used.
		// Case #10: Number, Empty. Reference to empty cell for number_chosen returns #VALUE!. 2 of 2 arguments used.
		// Case #11: Area, Number. Multi-cell range returns #VALUE!. 2 of 2 arguments used.
		// Case #12: Number, Area. Multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.
		// Case #22: Date, Number. Date as serial number for number. 2 of 2 arguments used.
		// Case #16: Number, Ref3D. 3D ref to #N/A returns #N/A. 2 of 2 arguments used.
		// Case #18: Number, Area3D. 3D multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.
		// Case #0: Number, Number. Minimum valid value (0,0) returns 1. 2 of 2 arguments used.


		testArrayFormula2(assert, "PERMUT", 2, 2);
	});

	QUnit.test("Test: \"PERMUTATIONA\"", function (assert) {
		oParser = new parserFormula("PERMUTATIONA(3,2)", "A1", ws);
		assert.ok(oParser.parse(), "PERMUTATIONA(3,2)");
		assert.strictEqual(oParser.calculate().getValue(), 9, "PERMUTATIONA(3,2)");

		oParser = new parserFormula("PERMUTATIONA(2,2)", "A1", ws);
		assert.ok(oParser.parse(), "PERMUTATIONA(2,2)");
		assert.strictEqual(oParser.calculate().getValue(), 4, "PERMUTATIONA(2,2)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number, Number. Both arguments are integers. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, Number. Both arguments are integers. 2 of 2 arguments used.');
		// Case #1: Number, Number. Both arguments are integers. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(10,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(10,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Positive case: Number, Number. Both arguments are integers. 2 of 2 arguments used.');
		// Case #2: String, Number. String convertible to number for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA("5",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA("5",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: String, Number. String convertible to number for number. 2 of 2 arguments used.');
		// Case #3: Number, String. String convertible to number for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,"2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, String. String convertible to number for number_chosen. 2 of 2 arguments used.');
		// Case #4: Formula, Number. Nested formula for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(ABS(5),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(ABS(5),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Formula, Number. Nested formula for number. 2 of 2 arguments used.');
		// Case #5: Number, Formula. Nested formula for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, Formula. Nested formula for number_chosen. 2 of 2 arguments used.');
		// Case #6: Reference link, Number. Ref to cell with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(A100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(A100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link, Number. Ref to cell with valid number. 2 of 2 arguments used.');
		// Case #7: Number, Reference link. Ref to cell with valid number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Reference link. Ref to cell with valid number_chosen. 2 of 2 arguments used.');
		// Case #8: Area, Number. Single-cell range for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(A100:A100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(A100:A100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, Number. Single-cell range for number. 2 of 2 arguments used.');
		// Case #9: Number, Area. Single-cell range for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Area. Single-cell range for number_chosen. 2 of 2 arguments used.');
		// Case #10: Array, Number. Array with single element for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA({5},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA({5},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Array, Number. Array with single element for number. 2 of 2 arguments used.');
		// Case #11: Number, Array. Array with single element for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, Array. Array with single element for number_chosen. 2 of 2 arguments used.');
		// Case #12: Name, Number. Named range for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(TestName,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(TestName,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Number. Named range for number. 2 of 2 arguments used.');
		// Case #13: Number, Name. Named range for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Name. Named range for number_chosen. 2 of 2 arguments used.');
		// Case #14: Name3D, Number. 3D named range for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(TestName3D,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(TestName3D,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Number. 3D named range for number. 2 of 2 arguments used.');
		// Case #15: Number, Name3D. 3D named range for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Positive case: Number, Name3D. 3D named range for number_chosen. 2 of 2 arguments used.');
		// Case #16: Ref3D, Number. 3D reference to cell for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(Sheet2!A1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(Sheet2!A1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D, Number. 3D reference to cell for number. 2 of 2 arguments used.');
		// Case #17: Number, Ref3D. 3D reference to cell for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,Sheet2!A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, Ref3D. 3D reference to cell for number_chosen. 2 of 2 arguments used.');
		// Case #18: Area3D, Number. 3D single-cell range for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(Sheet2!A1:A1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(Sheet2!A1:A1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D, Number. 3D single-cell range for number. 2 of 2 arguments used.');
		// Case #19: Number, Area3D. 3D single-cell range for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, Area3D. 3D single-cell range for number_chosen. 2 of 2 arguments used.');
		// Case #20: Table, Number. Table structured reference for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(Table1[Column1],2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(Table1[Column1],2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Number. Table structured reference for number. 2 of 2 arguments used.');
		// Case #22: Date, Number. Date as serial number for number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(DATE(2025,1,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(DATE(2025,1,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2084652964, 'Test: Positive case: Date, Number. Date as serial number for number. 2 of 2 arguments used.');
		// Case #23: Time, Number. Time adjusted to valid number. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(TIME(0,0,0)+5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(TIME(0,0,0)+5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Time, Number. Time adjusted to valid number. 2 of 2 arguments used.');
		// Case #24: Formula, Formula. Both arguments are formulas. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(ROUND(5.6,0),FLOOR(2.7,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(ROUND(5.6,0),FLOOR(2.7,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 36, 'Test: Positive case: Formula, Formula. Both arguments are formulas. 2 of 2 arguments used.');

		// Negative cases:
		// Case #0: Number, Number. number < number_chosen returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 32, 'Test: Negative case: Number, Number. number < number_chosen returns #NUM!. 2 of 2 arguments used.');
		// Case #1: Number, Number. Negative number returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(-1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(-1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative number returns #NUM!. 2 of 2 arguments used.');
		// Case #2: Number, Number. Negative number_chosen returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative number_chosen returns #NUM!. 2 of 2 arguments used.');
		// Case #3: Number, Number. Non-integer number returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(1.5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(1.5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Number. Non-integer number returns #NUM!. 2 of 2 arguments used.');
		// Case #4: Number, Number. Non-integer number_chosen returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Number, Number. Non-integer number_chosen returns #NUM!. 2 of 2 arguments used.');
		// Case #5: String, Number. Non-numeric string returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA("abc",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA("abc",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string returns #VALUE!. 2 of 2 arguments used.');
		// Case #6: Number, String. Non-numeric string for number_chosen returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for number_chosen returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Error, Number. Propagates #N/A error. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Propagates #N/A error. 2 of 2 arguments used.');
		// Case #8: Number, Error. Propagates #N/A error for number_chosen. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Propagates #N/A error for number_chosen. 2 of 2 arguments used.');
		// Case #9: Empty, Number. Reference to empty cell returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(A102,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(A102,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty, Number. Reference to empty cell returns #VALUE!. 2 of 2 arguments used.');
		// Case #10: Number, Empty. Reference to empty cell for number_chosen returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Empty. Reference to empty cell for number_chosen returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Area, Number. Multi-cell range returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(A100:A101,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area, Number. Multi-cell range returns #VALUE!. 2 of 2 arguments used.');
		// Case #12: Number, Area. Multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,A101:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Number, Area. Multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.');
		// Case #13: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(TestName2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(TestName2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Negative case: Name, Number. Named range with text returns #VALUE!. 2 of 2 arguments used.');
		// Case #14: Number, Name. Named range with #N/A returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Name. Named range with #N/A returns #N/A. 2 of 2 arguments used.');
		// Case #15: Ref3D, Number. 3D ref to text returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(Sheet2!A3,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(Sheet2!A3,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Number. 3D ref to text returns #VALUE!. 2 of 2 arguments used.');
		// Case #16: Number, Ref3D. 3D ref to #N/A returns #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Ref3D. 3D ref to #N/A returns #N/A. 2 of 2 arguments used.');
		// Case #17: Area3D, Number. 3D multi-cell range returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(Sheet2!A1:A2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(Sheet2!A1:A2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area3D, Number. 3D multi-cell range returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Number, Area3D. 3D multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(5,Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(5,Sheet2!A2:A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Negative case: Number, Area3D. 3D multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.');
		// Case #20: Formula, Number. Formula resulting in #NUM! returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in #NUM! returns #NUM!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #0: Number, Number. Minimum valid value (0,0) returns 1. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Minimum valid value (0,0) returns 1. 2 of 2 arguments used.');
		// Case #1: Number, Number. Large valid number within Excelâ??s numerical limit. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(170,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(170,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 170, 'Test: Bounded case: Number, Number. Large valid number within Excelâ??s numerical limit. 2 of 2 arguments used.');
		// Case #2: Number, Number. Maximum valid permutation within Excelâ??s numerical limit. 2 of 2 arguments used.
		oParser = new parserFormula('PERMUTATIONA(170,170)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PERMUTATIONA(170,170) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number. Maximum valid permutation within Excelâ??s numerical limit. 2 of 2 arguments used.');

		// Need to fix: Different results from MS
		// Case #16: Ref3D, Number. 3D reference to cell for number. 2 of 2 arguments used.
		// Case #17: Number, Ref3D. 3D reference to cell for number_chosen. 2 of 2 arguments used.
		// Case #18: Area3D, Number. 3D single-cell range for number. 2 of 2 arguments used.
		// Case #19: Number, Area3D. 3D single-cell range for number_chosen. 2 of 2 arguments used.
		// Case #11: Area, Number. Multi-cell range returns #VALUE!. 2 of 2 arguments used.
		// Case #12: Number, Area. Multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.
		// Case #17: Area3D, Number. 3D multi-cell range returns #VALUE!. 2 of 2 arguments used.
		// Case #18: Number, Area3D. 3D multi-cell range for number_chosen returns #VALUE!. 2 of 2 arguments used.


		testArrayFormula2(assert, "PERMUTATIONA", 2, 2);
	});

	QUnit.test("Test: \"PHI\"", function (assert) {
		oParser = new parserFormula("PHI(0.75)", "A1", ws);
		assert.ok(oParser.parse(), "PHI(0.75)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.301137432, "PHI(0.75)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integer. 1 argument used.
		oParser = new parserFormula('PHI(15.0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(15.0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.530709549844416e-50, 'Test: Positive case: Number. Basic valid input: integer. 1 argument used.');
		// Case #1: Number. Basic valid input: float number. 1 argument used.
		oParser = new parserFormula('PHI(3.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(3.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.00042478027055075143, 'Test: Positive case: Number. Basic valid input: float number. 1 argument used.');
		// Case #2: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('PHI("25")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI("25") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.653929736419393e-137, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #3: Formula. Nested formula returning number (3). 1 argument used.
		oParser = new parserFormula('PHI(SQRT(9.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(SQRT(9.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0044318484119380075, 'Test: Positive case: Formula. Nested formula returning number (3). 1 argument used.');
		// Case #4: Reference link. Reference to cell with valid number (3). 1 argument used.
		oParser = new parserFormula('PHI(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3520653267642995, 'Test: Positive case: Reference link. Reference to cell with valid number (3). 1 argument used.');
		// Case #5: Area. Single-cell range with valid number (1.1). 1 argument used.
		oParser = new parserFormula('PHI(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12951759566589174, 'Test: Positive case: Area. Single-cell range with valid number (1.1). 1 argument used.');
		// Case #6: Array. Array with single numeric element. 1 argument used.
		oParser = new parserFormula('PHI({5.0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI({5.0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0000014867195147342977, 'Test: Positive case: Array. Array with single numeric element. 1 argument used.');
		// Case #7: Name. Named range with valid number (3). 1 argument used.
		oParser = new parserFormula('PHI(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3520653267642995, 'Test: Positive case: Name. Named range with valid number (3). 1 argument used.');
		// Case #8: Name3D. 3D named range with valid number (2). 1 argument used.
		oParser = new parserFormula('PHI(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3520653267642995, 'Test: Positive case: Name3D. 3D named range with valid number (2). 1 argument used.');
		// Case #9: Ref3D. 3D reference to cell with valid number (2). 1 argument used.
		oParser = new parserFormula('PHI(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(Sheet2!A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.241970725, 'Test: Positive case: Ref3D. 3D reference to cell with valid number (2). 1 argument used.');
		// Case #10: Area3D. 3D single-cell range with valid number (2). 1 argument used.
		oParser = new parserFormula('PHI(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(Sheet2!A1:A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.241970725, 'Test: Positive case: Area3D. 3D single-cell range with valid number (2). 1 argument used.');
		// Case #11: Table. Table structured reference with valid number (3). 1 argument used.
		oParser = new parserFormula('PHI(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24197072451914337, 'Test: Positive case: Table. Table structured reference with valid number (3). 1 argument used.');
		// Case #12: Date. Date as serial number (45808). 1 argument used.
		oParser = new parserFormula('PHI(DATE(2025.0,6.0,30.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(DATE(2025.0,6.0,30.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date. Date as serial number (45808). 1 argument used.');
		// Case #13: Time. Time as fraction of day (0.60416667). 1 argument used.
		oParser = new parserFormula('PHI(TIME(14.0,30.0,0.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(TIME(14.0,30.0,0.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.33238969650447414, 'Test: Positive case: Time. Time as fraction of day (0.60416667). 1 argument used.');
		// Case #14: Formula. Nested ABS formula returning number (8). 1 argument used.
		oParser = new parserFormula('PHI(ABS(-8.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(ABS(-8.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.052271083536893e-15, 'Test: Positive case: Formula. Nested ABS formula returning number (8). 1 argument used.');
		// Case #15: Boolean. Boolean TRUE converts to 1. 1 argument used.
		oParser = new parserFormula('PHI(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24197072451914337, 'Test: Positive case: Boolean. Boolean TRUE converts to 1. 1 argument used.');
		// Case #16: Boolean. Boolean FALSE converts to 0. 1 argument used.
		oParser = new parserFormula('PHI(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3989422804014327, 'Test: Positive case: Boolean. Boolean FALSE converts to 0. 1 argument used.');
		// Case #17: String. Short date string convertible to number (6). 1 argument used.
		oParser = new parserFormula('PHI("6/6")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI("6/6") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Short date string convertible to number (6). 1 argument used.');
		// Case #18: Array. Multi-element array, returns first element (12). 1 argument used.
		oParser = new parserFormula('PHI({12.0,24.0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI({12.0,24.0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.1463837356630605e-32, 'Test: Positive case: Array. Multi-element array, returns first element (12). 1 argument used.');
		// Case #19: Formula. Nested IF returning valid number (10). 1 argument used.
		oParser = new parserFormula('PHI(IF(TRUE,10.0,4.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(IF(TRUE,10.0,4.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.69459862670642e-23, 'Test: Positive case: Formula. Nested IF returning valid number (10). 1 argument used.');
		// Case #20: Formula. Nested ROUND formula returning number (7.7). 1 argument used.
		oParser = new parserFormula('PHI(ROUND(7.666,1.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(ROUND(7.666,1.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.324148372252944e-14, 'Test: Positive case: Formula. Nested ROUND formula returning number (7.7). 1 argument used.');
		// Case #21: Formula. N with nested SUM formula returning number (7). 1 argument used.
		oParser = new parserFormula('PHI(SUM(5.0,2.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(SUM(5.0,2.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9.134720408364594e-12, 'Test: Positive case: Formula. N with nested SUM formula returning number (7). 1 argument used.');
		// Case #22: String. String in scientific notation convertible to number (1000000000000). 1 argument used.
		oParser = new parserFormula('PHI("1E+12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI("1E+12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. String in scientific notation convertible to number (1000000000000). 1 argument used.');

		// Negative cases:
		// Case #1: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('PHI(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #2: String. Non-numeric string returns 0. 1 argument used.
		oParser = new parserFormula('PHI("xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI("xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns 0. 1 argument used.');
		// Case #3: Empty. Reference to empty cell returns 0. 1 argument used.
		oParser = new parserFormula('PHI(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3520653267642995, 'Test: Negative case: Empty. Reference to empty cell returns 0. 1 argument used.');
		// Case #4: Area. Multi-cell range returns first cell’s value (1.1). 1 argument used.
		oParser = new parserFormula('PHI(A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(A101:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.129517596, 'Test: Negative case: Area. Multi-cell range returns first cell’s value (1.1). 1 argument used.');
		// Case #5: Ref3D. 3D reference to cell with text (abc) returns 0. 1 argument used.
		oParser = new parserFormula('PHI(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(Sheet2!A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.053990967, 'Test: Negative case: Ref3D. 3D reference to cell with text (abc) returns 0. 1 argument used.');
		// Case #6: Name. Named range with text (invalid) returns 0. 1 argument used.
		oParser = new parserFormula('PHI(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.241970725, 'Test: Negative case: Name. Named range with text (invalid) returns 0. 1 argument used.');
		// Case #7: Name3D. 3D named range with text (invalid) returns 0. 1 argument used.
		oParser = new parserFormula('PHI(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2896915527614828, 'Test: Negative case: Name3D. 3D named range with text (invalid) returns 0. 1 argument used.');
		// Case #9: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('PHI(DIVIDE(5.0,0.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(DIVIDE(5.0,0.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #10: String. Empty string returns 0. 1 argument used.
		oParser = new parserFormula('PHI("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns 0. 1 argument used.');
		// Case #11: Array. Array with booleans, returns first element (1). 1 argument used.
		oParser = new parserFormula('PHI({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI({TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24197072451914337, 'Test: Negative case: Array. Array with booleans, returns first element (1). 1 argument used.');
		// Case #12: Area3D. 3D multi-cell range, returns first cell’s value (2). 1 argument used.
		oParser = new parserFormula('PHI(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(Sheet2!A1:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.241970725, 'Test: Negative case: Area3D. 3D multi-cell range, returns first cell’s value (2). 1 argument used.');
		// Case #13: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('PHI(SQRT(-4.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(SQRT(-4.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #14: String. Text string returns 0. 1 argument used.
		oParser = new parserFormula('PHI("text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI("text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Text string returns 0. 1 argument used.');
		// Case #15: Array. Array with non-numeric string returns 0. 1 argument used.
		oParser = new parserFormula('PHI({"xyz"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI({"xyz"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with non-numeric string returns 0. 1 argument used.');
		// Case #16: Reference link. Reference to cell with non-numeric value (0.1) returns 0.1. 1 argument used.
		oParser = new parserFormula('PHI(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3989422804014327, 'Test: Negative case: Reference link. Reference to cell with non-numeric value (0.1) returns 0.1. 1 argument used.');
		// Case #17: Formula. Formula resulting in #N/A propagates error. 1 argument used.
		oParser = new parserFormula('PHI(VLOOKUP("z",A1:B1,2.0,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(VLOOKUP("z",A1:B1,2.0,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Formula resulting in #N/A propagates error. 1 argument used.');
		// Case #18: String. Non-numeric string with negative sign returns 0. 1 argument used.
		oParser = new parserFormula('PHI("-text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI("-text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string with negative sign returns 0. 1 argument used.');
		// Case #19: Time. Invalid time returns 0. 1 argument used.
		oParser = new parserFormula('PHI(TIME(26.0,0.0,0.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(TIME(26.0,0.0,0.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.39755946625834193, 'Test: Negative case: Time. Invalid time returns 0. 1 argument used.');
		// Case #20: Date. Date before valid range (0) returns 0. 1 argument used.
		oParser = new parserFormula('PHI(DATE(1899.0,12.0,31.0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(DATE(1899.0,12.0,31.0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Date. Date before valid range (0) returns 0. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Smallest valid positive number. 1 argument used.
		oParser = new parserFormula('PHI(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3989422804014327, 'Test: Bounded case: Number. Smallest valid positive number. 1 argument used.');
		// Case #2: Number. Largest valid Excel number. 1 argument used.
		oParser = new parserFormula('PHI(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(9.99999999999999E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Largest valid Excel number. 1 argument used.');
		// Case #3: Date. Smallest valid date serial number (1900-01-01). 1 argument used.
		oParser = new parserFormula('PHI(1.0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(1.0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24197072451914337, 'Test: Bounded case: Date. Smallest valid date serial number (1900-01-01). 1 argument used.');
		// Case #4: Date. Largest valid date serial number (9999-12-31). 1 argument used.
		oParser = new parserFormula('PHI(2958465.0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PHI(2958465.0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Date. Largest valid date serial number (9999-12-31). 1 argument used.');

		// Need to fix: areas handle, empty handle, boundary case, ms results diff
		// Case #9: Ref3D. 3D reference to cell with valid number (2). 1 argument used.
		// Case #10: Area3D. 3D single-cell range with valid number (2). 1 argument used.
		// Case #4: Area. Multi-cell range returns first cell’s value (1.1). 1 argument used.
		// Case #5: Ref3D. 3D reference to cell with text (abc) returns 0. 1 argument used.
		// Case #6: Name. Named range with text (invalid) returns 0. 1 argument used.
		// Case #12: Area3D. 3D multi-cell range, returns first cell’s value (2). 1 argument used.
		// Case #2: Number. Largest valid Excel number. 1 argument used.


		testArrayFormula2(assert, "PHI", 1, 1);
	});

	QUnit.test("Test: \"POISSON\"", function (assert) {

		function poisson(x, l, cumulativeFlag) {
			var _x = parseInt(x), _l = l, f = cumulativeFlag;

			if (f) {
				var sum = 0;
				for (var k = 0; k <= x; k++) {
					sum += Math.pow(_l, k) / Math.fact(k);
				}
				sum *= Math.exp(-_l);
				return toFixed(sum);
			} else {
				return toFixed(Math.exp(-_l) * Math.pow(_l, _x) / Math.fact(_x));
			}

		}

		oParser = new parserFormula("POISSON(8,2,false)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), poisson(8, 2, false));

		oParser = new parserFormula("POISSON(8,2,true)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), poisson(8, 2, true));

		oParser = new parserFormula("POISSON(2.6,5,false)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), poisson(2, 5, false));

		oParser = new parserFormula("POISSON(2,5.7,true)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), poisson(2, 5.7, true));

		oParser = new parserFormula("POISSON(-6,5,true)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("POISSON(6,-5,false)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Valid integer x, positive mean, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(5,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(5,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Number. Valid integer x, positive mean, cumulative TRUE. 3 of 3 arguments used.');
		// Case #1: Number. Zero x, positive float mean, cumulative FALSE. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(0,2.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(0,2.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0820849986238988, 'Test: Positive case: Number. Zero x, positive float mean, cumulative FALSE. 3 of 3 arguments used.');
		// Case #2: String. String arguments convertible to number and logical. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON("5","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON("5","10","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.067085963, 'Test: Positive case: String. String arguments convertible to number and logical. 3 of 3 arguments used.');
		// Case #3: Formula. Nested formulas for x and mean. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(ROUND(5.6,0),SQRT(25),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(ROUND(5.6,0),SQRT(25),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7621834629729387, 'Test: Positive case: Formula. Nested formulas for x and mean. 3 of 3 arguments used.');
		// Case #4: Reference link. Reference links to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22313016014842982, 'Test: Positive case: Reference link. Reference links to valid values. 3 of 3 arguments used.');
		// Case #5: Area. Single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(A103:A103,A104:A104,A105:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.718281828, 'Test: Positive case: Area. Single-cell ranges. 3 of 3 arguments used.');
		// Case #6: Array. Single-element arrays. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON({5},{10},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON({5},{10},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Array. Single-element arrays. 3 of 3 arguments used.');
		// Case #7: Name. Named ranges. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(TestName,TestName1,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges. 3 of 3 arguments used.');
		// Case #8: Name3D. 3D named ranges. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges. 3 of 3 arguments used.');
		// Case #9: Ref3D. 3D references to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to valid values. 3 of 3 arguments used.');
		// Case #10: Area3D. 3D single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell ranges. 3 of 3 arguments used.');
		// Case #11: Table. Table structured references. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.7357588823428847, 'Test: Positive case: Table. Table structured references. 3 of 3 arguments used.');
		// Case #12: Date. Date formula resolves to integer x. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(DATE(2025,1,1)-DATE(2024,1,1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(DATE(2025,1,1)-DATE(2024,1,1),10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date formula resolves to integer x. 3 of 3 arguments used.');
		// Case #13: Time. Time formula resolves to TRUE (1). 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(5,10,TIME(0,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(5,10,TIME(0,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Time. Time formula resolves to TRUE (1). 3 of 3 arguments used.');
		// Case #14: String. Short date string converts to number for x. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON("10/10","5","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON("10/10","5","FALSE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Short date string converts to number for x. 3 of 3 arguments used.');
		// Case #15: Formula. Nested IF for x. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(IF(TRUE,5,0),10,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(IF(TRUE,5,0),10,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0378332748020707, 'Test: Positive case: Formula. Nested IF for x. 3 of 3 arguments used.');
		// Case #16: Number. Large valid x and mean. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(100,100,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(100,100,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5265621985299985, 'Test: Positive case: Number. Large valid x and mean. 3 of 3 arguments used.');
		// Case #17: Array. Multi-element arrays, takes first valid value. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON({5,10},{10,20},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON({5,10},{10,20},{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Array. Multi-element arrays, takes first valid value. 3 of 3 arguments used.');
		// Case #18: String. String convertible to small numbers. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON("0.0","0.1","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON("0.0","0.1","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.904837418, 'Test: Positive case: String. String convertible to small numbers. 3 of 3 arguments used.');
		// Case #19: Formula. Formulas resolving to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(ABS(-5),SQRT(100),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(ABS(-5),SQRT(100),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Formula. Formulas resolving to valid values. 3 of 3 arguments used.');
		// Case #20: Number. Small positive mean. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(1,0.0001,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(1,0.0001,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '0.000100', 'Test: Positive case: Number. Small positive mean. 3 of 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Negative x returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(-1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(-1,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative x returns #NUM!. 3 of 3 arguments used.');
		// Case #1: Number. Negative mean returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(5,-1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(5,-1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative mean returns #NUM!. 3 of 3 arguments used.');
		// Case #2: String. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON("abc","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON("abc","10","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #3: String. Non-numeric string for mean returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON("5","abc","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON("5","abc","FALSE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for mean returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: Error. Error input for x propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(NA(),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(NA(),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error input for x propagates #N/A. 3 of 3 arguments used.');
		// Case #5: Empty. Empty reference links return #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(A106,A107,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(A106,A107,A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. Empty reference links return #VALUE!. 3 of 3 arguments used.');
		// Case #6: Boolean. Non-logical value for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(5,10,FALSE+TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(5,10,FALSE+TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Negative case: Boolean. Non-logical value for cumulative returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: String. Empty string for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON("","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON("","10","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Area. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(A109:A110,A111:A111,A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(A109:A110,A111:A111,A100:A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(Sheet2!A7,Sheet2!A8,Sheet2!A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(Sheet2!A7,Sheet2!A8,Sheet2!A9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(TestNameArea,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(TestNameArea,TestName1,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.90979599, 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Formula. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(SQRT(-1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(SQRT(-1),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.');
		// Case #13: Number. Zero mean returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(5,0,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(5,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Zero mean returns #NUM!. 3 of 3 arguments used.');
		// Case #14: Array. Array with non-numeric x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON({FALSE},{10},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON({FALSE},{10},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.00004539992976248485, 'Test: Negative case: Array. Array with non-numeric x returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: String. String convertible to negative x returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON("-5","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON("-5","10","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to negative x returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Time. Time value for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(5,10,TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(5,10,TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Negative case: Time. Time value for cumulative returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number. Excessively large x returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(1E+307,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(1E+307,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Excessively large x returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Date. Large date serial number for x returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(DATE(2025,1,1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(DATE(2025,1,1),10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Date. Large date serial number for x returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Area3D. Multi-cell 3D range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(Sheet2!A1:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(Sheet2!A1:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. Multi-cell 3D range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: String. Non-logical string for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON("5","10","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON("5","10","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-logical string for cumulative returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid x and mean. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(0,0.0000000001,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(0,0.0000000001,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Bounded case: Number. Minimum valid x and mean. 3 of 3 arguments used.');
		// Case #1: Number. Maximum valid x and mean without overflow. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON(1000,1000,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON(1000,1000,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.012614611, 'Test: Bounded case: Number. Maximum valid x and mean without overflow. 3 of 3 arguments used.');

		// Need to fix: string handle, error types diff, difference in results from MS
		// Case #2: String. String arguments convertible to number and logical. 3 of 3 arguments used.
		// Case #5: Area. Single-cell ranges. 3 of 3 arguments used.
		// Case #7: Name. Named ranges. 3 of 3 arguments used.
		// Case #12: Date. Date formula resolves to integer x. 3 of 3 arguments used.
		// Case #14: String. Short date string converts to number for x. 3 of 3 arguments used.
		// Case #18: String. String convertible to small numbers. 3 of 3 arguments used.
		// Case #8: Area. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		// Case #10: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		// Case #15: String. String convertible to negative x returns #NUM!. 3 of 3 arguments used.
		// Case #17: Number. Excessively large x returns #NUM!. 3 of 3 arguments used.
		// Case #18: Date. Large date serial number for x returns #NUM!. 3 of 3 arguments used.
		// Case #1: Number. Maximum valid x and mean without overflow. 3 of 3 arguments used.

		testArrayFormula2(assert, "POISSON", 3, 3);
	});

	QUnit.test("Test: \"POISSON.DIST\"", function (assert) {
		ws.getRange2("A202").setValue("2");
		ws.getRange2("A203").setValue("5");

		oParser = new parserFormula("POISSON.DIST(A202,A203,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "POISSON.DIST(A202,A203,TRUE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.124652, "POISSON.DIST(A202,A203,TRUE)");

		oParser = new parserFormula("POISSON.DIST(A202,A203,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "POISSON.DIST(A202,A203,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.084224, "POISSON.DIST(A202,A203,FALSE)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Valid integer x, positive mean, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(5,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(5,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Number. Valid integer x, positive mean, cumulative TRUE. 3 of 3 arguments used.');
		// Case #1: Number. Zero x, positive float mean, cumulative FALSE. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(0,2.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(0,2.5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0820849986238988, 'Test: Positive case: Number. Zero x, positive float mean, cumulative FALSE. 3 of 3 arguments used.');
		// Case #2: String. String arguments convertible to number and logical. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST("5","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST("5","10","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.067085963, 'Test: Positive case: String. String arguments convertible to number and logical. 3 of 3 arguments used.');
		// Case #3: Formula. Nested formulas for x and mean. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(ROUND(5.6,0),SQRT(25),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(ROUND(5.6,0),SQRT(25),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7621834629729387, 'Test: Positive case: Formula. Nested formulas for x and mean. 3 of 3 arguments used.');
		// Case #4: Reference link. Reference links to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22313016014842982, 'Test: Positive case: Reference link. Reference links to valid values. 3 of 3 arguments used.');
		// Case #5: Area. Single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(A103:A103,A104:A104,A105:A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.718281828, 'Test: Positive case: Area. Single-cell ranges. 3 of 3 arguments used.');
		// Case #6: Array. Single-element arrays. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST({5},{10},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST({5},{10},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Array. Single-element arrays. 3 of 3 arguments used.');
		// Case #7: Name. Named ranges. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(TestName,TestName1,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges. 3 of 3 arguments used.');
		// Case #8: Name3D. 3D named ranges. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges. 3 of 3 arguments used.');
		// Case #9: Ref3D. 3D references to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to valid values. 3 of 3 arguments used.');
		// Case #10: Area3D. 3D single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell ranges. 3 of 3 arguments used.');
		// Case #11: Table. Table structured references. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.7357588823428847, 'Test: Positive case: Table. Table structured references. 3 of 3 arguments used.');
		// Case #12: Date. Date formula resolves to integer x. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(DATE(2025,1,1)-DATE(2024,1,1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(DATE(2025,1,1)-DATE(2024,1,1),10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date formula resolves to integer x. 3 of 3 arguments used.');
		// Case #13: Time. Time formula resolves to TRUE (1). 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(5,10,TIME(0,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(5,10,TIME(0,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Time. Time formula resolves to TRUE (1). 3 of 3 arguments used.');
		// Case #14: String. Short date string converts to number for x. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST("10/10","5","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST("10/10","5","FALSE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Short date string converts to number for x. 3 of 3 arguments used.');
		// Case #15: Formula. Nested IF for x. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(IF(TRUE,5,0),10,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(IF(TRUE,5,0),10,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0378332748020707, 'Test: Positive case: Formula. Nested IF for x. 3 of 3 arguments used.');
		// Case #16: Number. Large valid x and mean. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(100,100,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(100,100,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5265621985299985, 'Test: Positive case: Number. Large valid x and mean. 3 of 3 arguments used.');
		// Case #17: Array. Multi-element arrays, takes first valid value. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST({5,10},{10,20},{TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST({5,10},{10,20},{TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Array. Multi-element arrays, takes first valid value. 3 of 3 arguments used.');
		// Case #18: String. String convertible to small numbers. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST("0.0","0.1","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST("0.0","0.1","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.904837418, 'Test: Positive case: String. String convertible to small numbers. 3 of 3 arguments used.');
		// Case #19: Formula. Formulas resolving to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(ABS(-5),SQRT(100),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(ABS(-5),SQRT(100),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Positive case: Formula. Formulas resolving to valid values. 3 of 3 arguments used.');
		// Case #20: Number. Small positive mean. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(1,0.0001,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(1,0.0001,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '0.000100', 'Test: Positive case: Number. Small positive mean. 3 of 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Negative x returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(-1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(-1,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative x returns #NUM!. 3 of 3 arguments used.');
		// Case #1: Number. Negative mean returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(5,-1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(5,-1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative mean returns #NUM!. 3 of 3 arguments used.');
		// Case #2: String. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST("abc","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST("abc","10","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #3: String. Non-numeric string for mean returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST("5","abc","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST("5","abc","FALSE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for mean returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: Error. Error input for x propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(NA(),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(NA(),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error input for x propagates #N/A. 3 of 3 arguments used.');
		// Case #5: Empty. Empty reference links return #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(A106,A107,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(A106,A107,A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. Empty reference links return #VALUE!. 3 of 3 arguments used.');
		// Case #6: Boolean. Non-logical value for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(5,10,FALSE+TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(5,10,FALSE+TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Negative case: Boolean. Non-logical value for cumulative returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: String. Empty string for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST("","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST("","10","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Area. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(A109:A110,A111:A111,A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(A109:A110,A111:A111,A100:A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(Sheet2!A7,Sheet2!A8,Sheet2!A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(Sheet2!A7,Sheet2!A8,Sheet2!A9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(TestNameArea,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(TestNameArea,TestName1,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.90979599, 'Test: Negative case: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Formula. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(SQRT(-1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(SQRT(-1),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.');
		// Case #13: Number. Zero mean returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(5,0,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(5,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Zero mean returns #NUM!. 3 of 3 arguments used.');
		// Case #14: Array. Array with non-numeric x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST({FALSE},{10},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST({FALSE},{10},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.00004539992976248485, 'Test: Negative case: Array. Array with non-numeric x returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: String. String convertible to negative x returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST("-5","10","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST("-5","10","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to negative x returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Time. Time value for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(5,10,TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(5,10,TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06708596287903178, 'Test: Negative case: Time. Time value for cumulative returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number. Excessively large x returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(1E+307,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(1E+307,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Excessively large x returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Date. Large date serial number for x returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(DATE(2025,1,1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(DATE(2025,1,1),10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Date. Large date serial number for x returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Area3D. Multi-cell 3D range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(Sheet2!A1:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(Sheet2!A1:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. Multi-cell 3D range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: String. Non-logical string for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST("5","10","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST("5","10","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-logical string for cumulative returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid x and mean. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(0,0.0000000001,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(0,0.0000000001,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Bounded case: Number. Minimum valid x and mean. 3 of 3 arguments used.');
		// Case #1: Number. Maximum valid x and mean without overflow. 3 of 3 arguments used.
		oParser = new parserFormula('POISSON.DIST(1000,1000,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: POISSON.DIST(1000,1000,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.012614611, 'Test: Bounded case: Number. Maximum valid x and mean without overflow. 3 of 3 arguments used.');

		// Need to fix: string handle, error types diff, difference in results from MS
		// Case #2: String. String arguments convertible to number and logical. 3 of 3 arguments used.
		// Case #5: Area. Single-cell ranges. 3 of 3 arguments used.
		// Case #7: Name. Named ranges. 3 of 3 arguments used.
		// Case #11: Table. Table structured references. 3 of 3 arguments used.
		// Case #12: Date. Date formula resolves to integer x. 3 of 3 arguments used.
		// Case #14: String. Short date string converts to number for x. 3 of 3 arguments used.
		// Case #18: String. String convertible to small numbers. 3 of 3 arguments used.
		// Case #8: Area. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		// Case #10: Name. Named range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		// Case #15: String. String convertible to negative x returns #NUM!. 3 of 3 arguments used.
		// Case #17: Number. Excessively large x returns #NUM!. 3 of 3 arguments used.
		// Case #18: Date. Large date serial number for x returns #NUM!. 3 of 3 arguments used.
		// Case #1: Number. Maximum valid x and mean without overflow. 3 of 3 arguments used.

		testArrayFormula2(assert, "POISSON.DIST", 3, 3);
	});

	QUnit.test("Test: \"PROB\"", function (assert) {

		oParser = new parserFormula("PROB({0,1,2,3},{0.2,0.3,0.1,0.4},2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.1);

		oParser = new parserFormula("PROB({0,1,2,3},{0.2,0.3,0.1,0.4},1,4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0.8);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A106").setValue("2");
		ws.getRange2("A107").setValue("3");
		ws.getRange2("A109").setValue("4");
		ws.getRange2("A109").setValue("5");
		ws.getRange2("A110").setValue("6");
		ws.getRange2("A111").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number,Array. 0.8
		oParser = new parserFormula('PROB({1,2,3},{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Positive case: Number,Array. 0.8');
		// Case #2: Number,Array. 0.3
		oParser = new parserFormula('PROB({1,2,3},{0.2,0.3,0.5},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,0.3,0.5},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3, 'Test: Positive case: Number,Array. 0.3');
		// Case #3: String,Array. 0
		oParser = new parserFormula('PROB({"1","2","3"},{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({"1","2","3"},{0.2,0.3,0.5},2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String,Array. 0');
		// Case #4: Formula,Array. 0
		oParser = new parserFormula('PROB({1,2,3},{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Positive case: Formula,Array. 0');
		// Case #5: Reference link,Array. 0
		oParser = new parserFormula('PROB(A100:A102,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(A100:A102,{0.2,0.3,0.5},2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link,Array. 0');
		// Case #6: Area,Array. 0
		oParser = new parserFormula('PROB(A100:A101,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(A100:A101,{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area,Array. 0');
		// Case #7: Array,Reference link. 0
		oParser = new parserFormula('PROB({1,2,3},A103:A105,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},A103:A105,2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Array,Reference link. 0');
		// Case #8: Array,Area. 0
		oParser = new parserFormula('PROB({1,2,3},A103:A104,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},A103:A104,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Array,Area. 0');
		// Case #9: Name,Array. 0
		oParser = new parserFormula('PROB(TestName,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(TestName,{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name,Array. 0');
		// Case #10: Name3D,Array. 0
		oParser = new parserFormula('PROB(TestName3D,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(TestName3D,{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name3D,Array. 0');
		// Case #11: Ref3D,Array. 0
		oParser = new parserFormula('PROB(Sheet2!A1:A3,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(Sheet2!A1:A3,{0.2,0.3,0.5},2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D,Array. 0');
		// Case #12: Area3D,Array. 0
		oParser = new parserFormula('PROB(Sheet2!A1:A2,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(Sheet2!A1:A2,{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area3D,Array. 0');
		// Case #13: Table,Array. 0
		oParser = new parserFormula('PROB(Table1[Column1],{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(Table1[Column1],{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Table,Array. 0');
		// Case #14: Array,Array,Formula. 0.8
		oParser = new parserFormula('PROB({1,2,3},{0.2,0.3,0.5},IF(TRUE,2,1),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,0.3,0.5},IF(TRUE,2,1),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Positive case: Array,Array,Formula. 0.8');
		// Case #15: Array,Array. 0.8
		oParser = new parserFormula('PROB({1,2,3},{0.2,0.3,0.5},2,IF(TRUE,3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,0.3,0.5},2,IF(TRUE,3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Positive case: Array,Array. 0.8');
		// Case #16: Date,Array. 0
		oParser = new parserFormula('PROB({45650,45660,45700},{0.2,0.3,0.5},DATE(2025,1,2),DATE(2025,1,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({45650,45660,45700},{0.2,0.3,0.5},DATE(2025,1,2),DATE(2025,1,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3, 'Test: Positive case: Date,Array. 0');
		// Case #17: Time,Array. 0
		oParser = new parserFormula('PROB({10.05,11.06,13.07},{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({10.05,11.06,13.07},{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time,Array. 0');
		// Case #18: Formula,Array. 1.8
		oParser = new parserFormula('SUM(PROB({1,2,3},{0.2,0.3,0.5},2,3),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PROB({1,2,3},{0.2,0.3,0.5},2,3),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8, 'Test: Positive case: Formula,Array. 1.8');
		// Case #19: String,Array. 0
		oParser = new parserFormula('PROB({"1.5","2.5","3.5"},{0.2,0.3,0.5},"2.5","3.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({"1.5","2.5","3.5"},{0.2,0.3,0.5},"2.5","3.5") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String,Array. 0');

		// Negative cases:
		// Case #1: Array,Array. 0
		oParser = new parserFormula('PROB({1,2},{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2},{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array,Array. 0');
		// Case #2: Array,Array. 0
		oParser = new parserFormula('PROB({1,2,3},{0.2,-0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,-0.3,0.5},2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array,Array. 0');
		// Case #3: String,Array. 0
		oParser = new parserFormula('PROB({"abc","2","3"},{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({"abc","2","3"},{0.2,0.3,0.5},2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String,Array. 0');
		// Case #4: Array,String. 0
		oParser = new parserFormula('PROB({1,2,3},{"0.2","abc","0.5"},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{"0.2","abc","0.5"},2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array,String. 0');
		// Case #5: Error,Array. 0
		oParser = new parserFormula('PROB(NA(),{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(NA(),{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Array. 0');
		// Case #6: Array,Error. 0
		oParser = new parserFormula('PROB(1/0,NA(),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(1/0,NA(),2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array,Error. 0');
		// Case #7: Area,Array. 0
		oParser = new parserFormula('PROB(A100:A103,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(A100:A103,{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area,Array. 0');
		// Case #8: Empty,Array. 0
		oParser = new parserFormula('PROB(A106,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(A106,{0.2,0.3,0.5},2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty,Array. 0');
		// Case #9: Array,Empty. 0
		oParser = new parserFormula('PROB({1,2,3},A106,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},A106,2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array,Empty. 0');
		// Case #10: Array,Array,Boolean. Boolean lower_limit, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('PROB({1,2,3},{1,2,3},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{1,2,3},TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array,Array,Boolean. Boolean lower_limit, returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Array,Array. 0.5
		oParser = new parserFormula('PROB({1,2,3},{0.2,0.3,0.5},2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,0.3,0.5},2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array,Array. 0.5');
		// Case #12: Ref3D,Array. 0
		oParser = new parserFormula('PROB(Sheet2!A4,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(Sheet2!A4,{0.2,0.3,0.5},2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D,Array. 0');
		// Case #13: Array,Ref3D. 0
		oParser = new parserFormula('PROB({1,2,3},Sheet2!A4,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},Sheet2!A4,2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array,Ref3D. 0');
		// Case #14: Name,Array. 0
		oParser = new parserFormula('PROB(TestNameArea,{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(TestNameArea,{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name,Array. 0');
		// Case #15: Array,Name. 0
		oParser = new parserFormula('PROB({1,2,3},TestNameArea,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},TestNameArea,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array,Name. 0');
		// Case #16: Array,Array,Formula. 0
		oParser = new parserFormula('PROB({1,2,3},{0.2,0.3,0.5},SQRT(-1),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,0.3,0.5},SQRT(-1),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array,Array,Formula. 0');
		// Case #17: Array,Array. 0
		oParser = new parserFormula('PROB({1,2,3},{0.2,0.3,0.5},2,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,0.3,0.5},2,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array,Array. 0');
		// Case #18: Array,Array,String. Non-numeric string for lower_limit, returns #VALUE!. 3 of 4 arguments used.
		oParser = new parserFormula('PROB({1,2,3},{1,2,3},"123")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{1,2,3},"123") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array,Array,String. Non-numeric string for lower_limit, returns #VALUE!. 3 of 4 arguments used.');
		// Case #19: Array,Array. 0
		oParser = new parserFormula('PROB({1,2,3},{0.2,0.3,0.5},2,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,3},{0.2,0.3,0.5},2,"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array,Array. 0');
		// Case #20: Table,Array. 0
		oParser = new parserFormula('PROB(Table1[Column2],{0.2,0.3,0.5},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB(Table1[Column2],{0.2,0.3,0.5},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Table,Array. 0');

		// Bounded cases:
		// Case #1: Number,Array. 1
		oParser = new parserFormula('PROB({1E-307,2,3},{0.2,0.3,0.5},1E-307,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1E-307,2,3},{0.2,0.3,0.5},1E-307,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number,Array. 1');
		// Case #2: Number,Array. 0.8
		oParser = new parserFormula('PROB({1,2,9.99999999999999E+307},{0.2,0.3,0.5},2,9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,9.99999999999999E+307},{0.2,0.3,0.5},2,9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Bounded case: Number,Array. 0.8');
		// Case #3: Array,Array. 0
		oParser = new parserFormula('PROB({1,2,30},{1E-307,1E-306,1E-305},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PROB({1,2,30},{1E-307,1E-306,1E-305},2,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array,Array. 0');

		// Need to fix: area handle, error types diff
		// Case #3: String,Array. 0
		// Case #5: Reference link,Array. 0
		// Case #7: Array,Reference link. 0
		// Case #11: Ref3D,Array. 0
		// Case #19: String,Array. 0
		// Case #2: Array,Array. 0
		// Case #3: String,Array. 0
		// Case #4: Array,String. 0
		// Case #6: Array,Error. 0
		// Case #12: Ref3D,Array. 0
		// Case #13: Array,Ref3D. 0
		// Case #18: Array,Array,String. Non-numeric string for lower_limit, returns #VALUE!. 3 of 4 arguments used.
		// Case #19: Array,Array. 0
		// Case #3: Array,Array. 0

	});

	QUnit.test("Test: \"QUARTILE1\"", function (assert) {

		function quartile(A, k) {

			var fFlag = k;

			A.sort(fSortAscending);

			var nSize = A.length;
			if (A.length < 1 || nSize == 0) {
				return "#N/A"
			} else {
				if (nSize == 1) {
					return toFixed(A[0]);
				} else {

					if (fFlag < 0.0 || fFlag > 4) {
						return "#NUM!";
					} else if (fFlag == 0.0) {
						return toFixed(A[0]);
					} else if (fFlag == 1.0) {
						var nIndex = Math.floor(0.25 * (nSize - 1)), fDiff = 0.25 * (nSize - 1) - Math.floor(0.25 * (nSize - 1));
						if (fDiff == 0.0) {
							return toFixed(A[nIndex]);
						} else {
							return toFixed(A[nIndex] + fDiff * (A[nIndex + 1] - A[nIndex]));
						}
					} else if (fFlag == 2.0) {
						if (nSize % 2 == 0) {
							return toFixed((A[nSize / 2 - 1] + A[nSize / 2]) / 2.0);
						} else {
							return toFixed(A[(nSize - 1) / 2]);
						}
					} else if (fFlag == 3.0) {
						var nIndex = Math.floor(0.75 * (nSize - 1)), fDiff = 0.75 * (nSize - 1) - Math.floor(0.75 * (nSize - 1));
						if (fDiff == 0.0) {
							return toFixed(A[nIndex]);
						} else {
							return toFixed(A[nIndex] + fDiff * (A[nIndex + 1] - A[nIndex]));
						}
					} else {
						return toFixed(A[nSize - 1]);
					}

				}
			}

		}

		oParser = new parserFormula("QUARTILE({1,2,4,7,8,9,10,12},-1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), quartile([1, 2, 4, 7, 8, 9, 10, 12], -1));

		oParser = new parserFormula("QUARTILE({1,2,4,7,8,9,10,12},0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), quartile([1, 2, 4, 7, 8, 9, 10, 12], 0));

		oParser = new parserFormula("QUARTILE({1,2,4,7,8,9,10,12},1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), quartile([1, 2, 4, 7, 8, 9, 10, 12], 1));

		oParser = new parserFormula("QUARTILE({1,2,4,7,8,9,10,12},2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), quartile([1, 2, 4, 7, 8, 9, 10, 12], 2));

		oParser = new parserFormula("QUARTILE({1,2,4,7,8,9,10,12},3)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), quartile([1, 2, 4, 7, 8, 9, 10, 12], 3));

		oParser = new parserFormula("QUARTILE({1,2,4,7,8,9,10,12},4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), quartile([1, 2, 4, 7, 8, 9, 10, 12], 4));

		oParser = new parserFormula("QUARTILE({1,2,4,7,8,9,10,12},5)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), quartile([1, 2, 4, 7, 8, 9, 10, 12], 5));

	});

	QUnit.test("Test: \"QUARTILE\"", function (assert) {
		ws.getRange2("A202").setValue("1");
		ws.getRange2("A203").setValue("2");
		ws.getRange2("A204").setValue("4");
		ws.getRange2("A205").setValue("7");
		ws.getRange2("A206").setValue("8");
		ws.getRange2("A207").setValue("9");
		ws.getRange2("A208").setValue("10");
		ws.getRange2("A209").setValue("12");

		oParser = new parserFormula("QUARTILE(A202:A209,1)", "A1", ws);
		assert.ok(oParser.parse(), "QUARTILE(A202:A209,1)");
		assert.strictEqual(oParser.calculate().getValue(), 3.5, "QUARTILE(A202:A209,1)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Array, Number. Array with valid numbers, quart = 2 (median). 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 2 (median). 2 arguments used.');
		// Case #1: Array, Number. Array with valid numbers, quart = 1 (first quartile). 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.75, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 1 (first quartile). 2 arguments used.');
		// Case #2: Array, Number. Array with valid numbers, quart = 3 (third quartile). 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.25, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 3 (third quartile). 2 arguments used.');
		// Case #3: Array, Number. Array with valid numbers, quart = 0 (minimum). 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 0 (minimum). 2 arguments used.');
		// Case #4: Array, Number. Array with valid numbers, quart = 4 (maximum). 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 4 (maximum). 2 arguments used.');
		// Case #5: Reference link, Number. Reference link to valid range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE(A100:A103,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(A100:A103,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number. Reference link to valid range, quart = 2. 2 arguments used.');
		// Case #6: Area, Number. Two-cell range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE(A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(A100:A101,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Number. Two-cell range, quart = 2. 2 arguments used.');
		// Case #7: Table, Number. Table structured reference with valid numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE(Table1[Column1],2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(Table1[Column1],2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Number. Table structured reference with valid numbers, quart = 2. 2 arguments used.');
		// Case #8: Name, Number. Named range with valid numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE(TestName,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(TestName,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name, Number. Named range with valid numbers, quart = 2. 2 arguments used.');
		// Case #9: Name3D, Number. 3D named range with valid numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE(TestName3D,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(TestName3D,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D, Number. 3D named range with valid numbers, quart = 2. 2 arguments used.');
		// Case #10: Ref3D, Number. 3D reference to valid range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE(Sheet2!A1:A4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(Sheet2!A1:A4,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Ref3D, Number. 3D reference to valid range, quart = 2. 2 arguments used.');
		// Case #11: Area3D, Number. 3D two-cell range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE(Sheet2!A1:A2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(Sheet2!A1:A2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area3D, Number. 3D two-cell range, quart = 2. 2 arguments used.');
		// Case #12: Formula, Number. Nested IF returning valid range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE(IF(TRUE,A100:A103,A101:A104),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(IF(TRUE,A100:A103,A101:A104),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula, Number. Nested IF returning valid range, quart = 2. 2 arguments used.');
		// Case #13: Array, Formula. Array with valid numbers, quart as formula. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},ROUND(2,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},ROUND(2,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array, Formula. Array with valid numbers, quart as formula. 2 arguments used.');
		// Case #14: Formula, Number. QUARTILE.INC inside SUM formula, quart = 2. 2 arguments used.
		oParser = new parserFormula('SUM(QUARTILE({1,2,3,4},2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(QUARTILE({1,2,3,4},2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Positive case: Formula, Number. QUARTILE.INC inside SUM formula, quart = 2. 2 arguments used.');
		// Case #15: String, Number. String array convertible to numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE({"1","2","3","4"},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({"1","2","3","4"},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String, Number. String array convertible to numbers, quart = 2. 2 arguments used.');
		// Case #16: Array, Number. Array with float numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,5,2,5,3,5,4,5},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,5,2,5,3,5,4,5},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.5, 'Test: Positive case: Array, Number. Array with float numbers, quart = 2. 2 arguments used.');
		// Case #17: Array, Number. Array with serial numbers (e.g., dates 01/01/2024, 02/01/2024, 03/01/2024), quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE({45292,45322,45352},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({45292,45322,45352},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45322, 'Test: Positive case: Array, Number. Array with serial numbers (e.g., dates 01/01/2024, 02/01/2024, 03/01/2024), quart = 2. 2 arguments used.');
		// Case #18: Array, Number. Array with fractions (e.g., time values 1:00, 2:00, 3:00), quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE({0,041666667,0,083333333,0,125},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({0,041666667,0,083333333,0,125},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 62.5, 'Test: Positive case: Array, Number. Array with fractions (e.g., time values 1:00, 2:00, 3:00), quart = 2. 2 arguments used.');
		// Case #19: Array, Number. Array with negative and zero values, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE({-1,0,1,2},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({-1,0,1,2},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array, Number. Array with negative and zero values, quart = 2. 2 arguments used.');
		// Case #20: Area, Number. Two-cell range, quart = 1. 2 arguments used.
		oParser = new parserFormula('QUARTILE(A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(A100:A101,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Area, Number. Two-cell range, quart = 1. 2 arguments used.');
		// Case #21: Formula, Formula. Formula for range and quart, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE(A100:A103,ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(A100:A103,ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula, Formula. Formula for range and quart, quart = 2. 2 arguments used.');
		// Case #22: Reference link, Number. Reference link to valid range, quart = 3. 2 arguments used.
		oParser = new parserFormula('QUARTILE(A105:A108,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(A105:A108,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link, Number. Reference link to valid range, quart = 3. 2 arguments used.');

		// Negative cases:
		// Case #1: Array, Number. Single-element array returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array, Number. Single-element array returns #NUM!. 2 arguments used.');
		// Case #2: Array, Number. Array with non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,"abc",3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,"abc",3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Array, Number. Array with non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #3: Error, Number. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('QUARTILE(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Propagates #N/A error. 2 arguments used.');
		// Case #4: Array, Number. Empty array returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({""},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({""},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Empty array returns #NUM!. 2 arguments used.');
		// Case #5: Empty, Number. Empty reference link returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE(A109,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(A109,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty reference link returns #NUM!. 2 arguments used.');
		// Case #6: Area, Number. Range with non-numeric values returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE(A109:A110,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(A109:A110,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number. Range with non-numeric values returns #VALUE!. 2 arguments used.');
		// Case #7: Array, Number. Array with booleans returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({FALSE,TRUE},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({FALSE,TRUE},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Array with booleans returns #VALUE!. 2 arguments used.');
		// Case #8: Array, Number. Quart > 4 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Quart > 4 returns #NUM!. 2 arguments used.');
		// Case #9: Array, Number. Negative quart returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Negative quart returns #NUM!. 2 arguments used.');
		// Case #10: Name, Number. Named range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE(TestNameArea2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(TestNameArea2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.8, 'Test: Negative case: Name, Number. Named range with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #11: Ref3D, Number. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE(Sheet2!A5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(Sheet2!A5,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D, Number. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.');
		// Case #12: Array, String. Non-numeric quart returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, String. Non-numeric quart returns #VALUE!. 2 arguments used.');
		// Case #13: Formula, Number. Formula resulting in #NUM! error. 2 arguments used.
		oParser = new parserFormula('QUARTILE(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in #NUM! error. 2 arguments used.');
		// Case #14: Array, Number. Array with value exceeding Excelâ??s limit returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1E+307,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1E+307,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Negative case: Array, Number. Array with value exceeding Excelâ??s limit returns #NUM!. 2 arguments used.');
		// Case #15: Array, Number. Non-integer quart returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.75, 'Test: Negative case: Array, Number. Non-integer quart returns #NUM!. 2 arguments used.');
		// Case #16: Area, Number. Multi-cell range with mixed data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE(A100:A102,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(A100:A102,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Area, Number. Multi-cell range with mixed data returns #VALUE!. 2 arguments used.');
		// Case #17: Array, Empty. Missing quart argument returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array, Empty. Missing quart argument returns #VALUE!. 2 arguments used.');
		// Case #19: Name3D, Number. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE(TestNameArea3D2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(TestNameArea3D2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.8, 'Test: Negative case: Name3D, Number. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #20: Array, Number. Two-element array returns #NUM! for quart 1 (insufficient data). 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Negative case: Array, Number. Two-element array returns #NUM! for quart 1 (insufficient data). 2 arguments used.');
		// Case #21: Array, Number. Array with empty string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,"",3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,"",3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Array, Number. Array with empty string returns #VALUE!. 2 arguments used.');
		// Case #22: Area3D, Number. 3D range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE(Sheet2!A3:A4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE(Sheet2!A3:A4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D range with non-numeric data returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Array, Number. Array with minimum positive number, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE({2,2.25073858507201E-293,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({2,2.25073858507201E-293,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Array, Number. Array with minimum positive number, quart = 2. 2 arguments used.');
		// Case #2: Array, Number. Array with maximum Excel number, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE({1.79769313486231E+307,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1.79769313486231E+307,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Bounded case: Array, Number. Array with maximum Excel number, quart = 2. 2 arguments used.');
		// Case #3: Array, Number. Minimum valid quart (0). 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array, Number. Minimum valid quart (0). 2 arguments used.');
		// Case #4: Array, Number. Maximum valid quart (4). 2 arguments used.
		oParser = new parserFormula('QUARTILE({1,2,3,4},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE({1,2,3,4},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Bounded case: Array, Number. Maximum valid quart (4). 2 arguments used.');

		// Need to fix: error types diff, area single column handle, different results from MS
		// Case #7: Table, Number. Table structured reference with valid numbers, quart = 2. 2 arguments used.
		// Case #8: Name, Number. Named range with valid numbers, quart = 2. 2 arguments used.
		// Case #9: Name3D, Number. 3D named range with valid numbers, quart = 2. 2 arguments used.
		// Case #10: Ref3D, Number. 3D reference to valid range, quart = 2. 2 arguments used.
		// Case #11: Area3D, Number. 3D two-cell range, quart = 2. 2 arguments used.
		// Case #15: String, Number. String array convertible to numbers, quart = 2. 2 arguments used.
		// Case #22: Reference link, Number. Reference link to valid range, quart = 3. 2 arguments used.
		// Case #4: Array, Number. Empty array returns #NUM!. 2 arguments used.
		// Case #5: Empty, Number. Empty reference link returns #NUM!. 2 arguments used.
		// Case #6: Area, Number. Range with non-numeric values returns #VALUE!. 2 arguments used.
		// Case #7: Array, Number. Array with booleans returns #VALUE!. 2 arguments used.
		// Case #10: Name, Number. Named range with non-numeric data returns #VALUE!. 2 arguments used.
		// Case #11: Ref3D, Number. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.
		// Case #19: Name3D, Number. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.

		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "QUARTILE", 2, 2)
	});

	QUnit.test("Test: \"QUARTILE.INC\"", function (assert) {
		ws.getRange2("A202").setValue("1");
		ws.getRange2("A203").setValue("2");
		ws.getRange2("A204").setValue("4");
		ws.getRange2("A205").setValue("7");
		ws.getRange2("A206").setValue("8");
		ws.getRange2("A207").setValue("9");
		ws.getRange2("A208").setValue("10");
		ws.getRange2("A209").setValue("12");

		oParser = new parserFormula("QUARTILE.INC(A202:A209,1)", "A1", ws);
		assert.ok(oParser.parse(), "QUARTILE.INC(A202:A209,1)");
		assert.strictEqual(oParser.calculate().getValue(), 3.5, "QUARTILE.INC(A202:A209,1)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Array, Number. Array with valid numbers, quart = 2 (median). 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 2 (median). 2 arguments used.');
		// Case #1: Array, Number. Array with valid numbers, quart = 1 (first quartile). 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.75, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 1 (first quartile). 2 arguments used.');
		// Case #2: Array, Number. Array with valid numbers, quart = 3 (third quartile). 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.25, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 3 (third quartile). 2 arguments used.');
		// Case #3: Array, Number. Array with valid numbers, quart = 0 (minimum). 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 0 (minimum). 2 arguments used.');
		// Case #4: Array, Number. Array with valid numbers, quart = 4 (maximum). 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 4 (maximum). 2 arguments used.');
		// Case #5: Reference link, Number. Reference link to valid range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(A100:A103,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(A100:A103,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number. Reference link to valid range, quart = 2. 2 arguments used.');
		// Case #6: Area, Number. Two-cell range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(A100:A101,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Number. Two-cell range, quart = 2. 2 arguments used.');
		// Case #7: Table, Number. Table structured reference with valid numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(Table1[Column1],2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(Table1[Column1],2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Number. Table structured reference with valid numbers, quart = 2. 2 arguments used.');
		// Case #8: Name, Number. Named range with valid numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(TestName,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(TestName,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name, Number. Named range with valid numbers, quart = 2. 2 arguments used.');
		// Case #9: Name3D, Number. 3D named range with valid numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(TestName3D,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(TestName3D,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D, Number. 3D named range with valid numbers, quart = 2. 2 arguments used.');
		// Case #10: Ref3D, Number. 3D reference to valid range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(Sheet2!A1:A4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(Sheet2!A1:A4,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Ref3D, Number. 3D reference to valid range, quart = 2. 2 arguments used.');
		// Case #11: Area3D, Number. 3D two-cell range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(Sheet2!A1:A2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(Sheet2!A1:A2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area3D, Number. 3D two-cell range, quart = 2. 2 arguments used.');
		// Case #12: Formula, Number. Nested IF returning valid range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(IF(TRUE,A100:A103,A101:A104),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(IF(TRUE,A100:A103,A101:A104),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula, Number. Nested IF returning valid range, quart = 2. 2 arguments used.');
		// Case #13: Array, Formula. Array with valid numbers, quart as formula. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},ROUND(2,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},ROUND(2,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array, Formula. Array with valid numbers, quart as formula. 2 arguments used.');
		// Case #14: Formula, Number. QUARTILE.INC.INC inside SUM formula, quart = 2. 2 arguments used.
		oParser = new parserFormula('SUM(QUARTILE.INC({1,2,3,4},2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(QUARTILE.INC({1,2,3,4},2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Positive case: Formula, Number. QUARTILE.INC.INC inside SUM formula, quart = 2. 2 arguments used.');
		// Case #15: String, Number. String array convertible to numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({"1","2","3","4"},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({"1","2","3","4"},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String, Number. String array convertible to numbers, quart = 2. 2 arguments used.');
		// Case #16: Array, Number. Array with float numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,5,2,5,3,5,4,5},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,5,2,5,3,5,4,5},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.5, 'Test: Positive case: Array, Number. Array with float numbers, quart = 2. 2 arguments used.');
		// Case #17: Array, Number. Array with serial numbers (e.g., dates 01/01/2024, 02/01/2024, 03/01/2024), quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({45292,45322,45352},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({45292,45322,45352},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45322, 'Test: Positive case: Array, Number. Array with serial numbers (e.g., dates 01/01/2024, 02/01/2024, 03/01/2024), quart = 2. 2 arguments used.');
		// Case #18: Array, Number. Array with fractions (e.g., time values 1:00, 2:00, 3:00), quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({0,041666667,0,083333333,0,125},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({0,041666667,0,083333333,0,125},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 62.5, 'Test: Positive case: Array, Number. Array with fractions (e.g., time values 1:00, 2:00, 3:00), quart = 2. 2 arguments used.');
		// Case #19: Array, Number. Array with negative and zero values, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({-1,0,1,2},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({-1,0,1,2},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array, Number. Array with negative and zero values, quart = 2. 2 arguments used.');
		// Case #20: Area, Number. Two-cell range, quart = 1. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(A100:A101,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Area, Number. Two-cell range, quart = 1. 2 arguments used.');
		// Case #21: Formula, Formula. Formula for range and quart, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(A100:A103,ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(A100:A103,ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula, Formula. Formula for range and quart, quart = 2. 2 arguments used.');
		// Case #22: Reference link, Number. Reference link to valid range, quart = 3. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(A105:A108,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(A105:A108,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link, Number. Reference link to valid range, quart = 3. 2 arguments used.');

		// Negative cases:
		// Case #1: Array, Number. Single-element array returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array, Number. Single-element array returns #NUM!. 2 arguments used.');
		// Case #2: Array, Number. Array with non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,"abc",3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,"abc",3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Array, Number. Array with non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #3: Error, Number. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Propagates #N/A error. 2 arguments used.');
		// Case #4: Array, Number. Empty array returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({""},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({""},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Empty array returns #NUM!. 2 arguments used.');
		// Case #5: Empty, Number. Empty reference link returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(A109,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(A109,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty reference link returns #NUM!. 2 arguments used.');
		// Case #6: Area, Number. Range with non-numeric values returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(A109:A110,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(A109:A110,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number. Range with non-numeric values returns #VALUE!. 2 arguments used.');
		// Case #7: Array, Number. Array with booleans returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({FALSE,TRUE},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({FALSE,TRUE},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Array with booleans returns #VALUE!. 2 arguments used.');
		// Case #8: Array, Number. Quart > 4 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Quart > 4 returns #NUM!. 2 arguments used.');
		// Case #9: Array, Number. Negative quart returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Negative quart returns #NUM!. 2 arguments used.');
		// Case #10: Name, Number. Named range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(TestNameArea2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(TestNameArea2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.8, 'Test: Negative case: Name, Number. Named range with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #11: Ref3D, Number. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(Sheet2!A5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(Sheet2!A5,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D, Number. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.');
		// Case #12: Array, String. Non-numeric quart returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, String. Non-numeric quart returns #VALUE!. 2 arguments used.');
		// Case #13: Formula, Number. Formula resulting in #NUM! error. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in #NUM! error. 2 arguments used.');
		// Case #14: Array, Number. Array with value exceeding Excelâ??s limit returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1E+307,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1E+307,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Negative case: Array, Number. Array with value exceeding Excelâ??s limit returns #NUM!. 2 arguments used.');
		// Case #15: Array, Number. Non-integer quart returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.75, 'Test: Negative case: Array, Number. Non-integer quart returns #NUM!. 2 arguments used.');
		// Case #16: Area, Number. Multi-cell range with mixed data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(A100:A102,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(A100:A102,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Area, Number. Multi-cell range with mixed data returns #VALUE!. 2 arguments used.');
		// Case #17: Array, Empty. Missing quart argument returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array, Empty. Missing quart argument returns #VALUE!. 2 arguments used.');
		// Case #19: Name3D, Number. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(TestNameArea3D2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(TestNameArea3D2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.8, 'Test: Negative case: Name3D, Number. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #20: Array, Number. Two-element array returns #NUM! for quart 1 (insufficient data). 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Negative case: Array, Number. Two-element array returns #NUM! for quart 1 (insufficient data). 2 arguments used.');
		// Case #21: Array, Number. Array with empty string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,"",3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,"",3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Array, Number. Array with empty string returns #VALUE!. 2 arguments used.');
		// Case #22: Area3D, Number. 3D range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC(Sheet2!A3:A4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC(Sheet2!A3:A4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D range with non-numeric data returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Array, Number. Array with minimum positive number, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({2,2.25073858507201E-293,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({2,2.25073858507201E-293,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Array, Number. Array with minimum positive number, quart = 2. 2 arguments used.');
		// Case #2: Array, Number. Array with maximum Excel number, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1.79769313486231E+307,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1.79769313486231E+307,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Bounded case: Array, Number. Array with maximum Excel number, quart = 2. 2 arguments used.');
		// Case #3: Array, Number. Minimum valid quart (0). 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Array, Number. Minimum valid quart (0). 2 arguments used.');
		// Case #4: Array, Number. Maximum valid quart (4). 2 arguments used.
		oParser = new parserFormula('QUARTILE.INC({1,2,3,4},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.INC({1,2,3,4},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Bounded case: Array, Number. Maximum valid quart (4). 2 arguments used.');

		// Need to fix: error types diff, area single column handle, different results from MS
		// Case #7: Table, Number. Table structured reference with valid numbers, quart = 2. 2 arguments used.
		// Case #8: Name, Number. Named range with valid numbers, quart = 2. 2 arguments used.
		// Case #9: Name3D, Number. 3D named range with valid numbers, quart = 2. 2 arguments used.
		// Case #10: Ref3D, Number. 3D reference to valid range, quart = 2. 2 arguments used.
		// Case #11: Area3D, Number. 3D two-cell range, quart = 2. 2 arguments used.
		// Case #15: String, Number. String array convertible to numbers, quart = 2. 2 arguments used.
		// Case #22: Reference link, Number. Reference link to valid range, quart = 3. 2 arguments used.
		// Case #4: Array, Number. Empty array returns #NUM!. 2 arguments used.
		// Case #5: Empty, Number. Empty reference link returns #NUM!. 2 arguments used.
		// Case #6: Area, Number. Range with non-numeric values returns #VALUE!. 2 arguments used.
		// Case #7: Array, Number. Array with booleans returns #VALUE!. 2 arguments used.
		// Case #10: Name, Number. Named range with non-numeric data returns #VALUE!. 2 arguments used.
		// Case #11: Ref3D, Number. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.
		// Case #19: Name3D, Number. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.
	});

	QUnit.test("Test: \"QUARTILE.EXC\"", function (assert) {
		ws.getRange2("A202").setValue("6");
		ws.getRange2("A203").setValue("7");
		ws.getRange2("A204").setValue("15");
		ws.getRange2("A205").setValue("36");
		ws.getRange2("A206").setValue("39");
		ws.getRange2("A207").setValue("40");
		ws.getRange2("A208").setValue("41");
		ws.getRange2("A209").setValue("42");
		ws.getRange2("A210").setValue("43");
		ws.getRange2("A211").setValue("47");
		ws.getRange2("A212").setValue("49");

		oParser = new parserFormula("QUARTILE.EXC(A202:A212,1)", "A1", ws);
		assert.ok(oParser.parse(), "QUARTILE.EXC(A202:A212,1)");
		assert.strictEqual(oParser.calculate().getValue(), 15, "QUARTILE.EXC(A202:A212,1)");

		oParser = new parserFormula("QUARTILE.EXC(A202:A212,3)", "A1", ws);
		assert.ok(oParser.parse(), "QUARTILE.EXC(A202:A212,3)");
		assert.strictEqual(oParser.calculate().getValue(), 43, "QUARTILE.EXC(A202:A212,3)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Array, Number. Array with valid numbers, quart = 2 (median). 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 2 (median). 2 arguments used.');
		// Case #1: Array, Number. Array with valid numbers, quart = 1 (first quartile). 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.75, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 1 (first quartile). 2 arguments used.');
		// Case #2: Array, Number. Array with valid numbers, quart = 3 (third quartile). 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.75, 'Test: Positive case: Array, Number. Array with valid numbers, quart = 3 (third quartile). 2 arguments used.');
		// Case #3: Array, Number. Array with valid numbers, quart = 0 (minimum). 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Array, Number. Array with valid numbers, quart = 0 (minimum). 2 arguments used.');
		// Case #4: Array, Number. Array with valid numbers, quart = 4 (maximum). 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Array, Number. Array with valid numbers, quart = 4 (maximum). 2 arguments used.');
		// Case #5: Reference link, Number. Reference link to valid range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(A100:A103,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(A100:A103,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number. Reference link to valid range, quart = 2. 2 arguments used.');
		// Case #6: Area, Number. Two-cell range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(A100:A101,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area, Number. Two-cell range, quart = 2. 2 arguments used.');
		// Case #7: Table, Number. Table structured reference with valid numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(Table1[Column1],2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(Table1[Column1],2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Number. Table structured reference with valid numbers, quart = 2. 2 arguments used.');
		// Case #8: Name, Number. Named range with valid numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(TestName,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(TestName,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name, Number. Named range with valid numbers, quart = 2. 2 arguments used.');
		// Case #9: Name3D, Number. 3D named range with valid numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(TestName3D,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(TestName3D,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D, Number. 3D named range with valid numbers, quart = 2. 2 arguments used.');
		// Case #10: Ref3D, Number. 3D reference to valid range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(Sheet2!A1:A4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(Sheet2!A1:A4,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Ref3D, Number. 3D reference to valid range, quart = 2. 2 arguments used.');
		// Case #11: Area3D, Number. 3D two-cell range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(Sheet2!A1:A2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(Sheet2!A1:A2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area3D, Number. 3D two-cell range, quart = 2. 2 arguments used.');
		// Case #12: Formula, Number. Nested IF returning valid range, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(IF(TRUE,A100:A103,A101:A104),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(IF(TRUE,A100:A103,A101:A104),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula, Number. Nested IF returning valid range, quart = 2. 2 arguments used.');
		// Case #13: Array, Formula. Array with valid numbers, quart as formula. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},ROUND(2,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},ROUND(2,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array, Formula. Array with valid numbers, quart as formula. 2 arguments used.');
		// Case #14: Formula, Number. QUARTILE.EXC.INC inside SUM formula, quart = 2. 2 arguments used.
		oParser = new parserFormula('SUM(QUARTILE.EXC({1,2,3,4},2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(QUARTILE.EXC({1,2,3,4},2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Positive case: Formula, Number. QUARTILE.EXC.INC inside SUM formula, quart = 2. 2 arguments used.');
		// Case #15: String, Number. String array convertible to numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({"1","2","3","4"},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({"1","2","3","4"},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String, Number. String array convertible to numbers, quart = 2. 2 arguments used.');
		// Case #16: Array, Number. Array with float numbers, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,5,2,5,3,5,4,5},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,5,2,5,3,5,4,5},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.5, 'Test: Positive case: Array, Number. Array with float numbers, quart = 2. 2 arguments used.');
		// Case #17: Array, Number. Array with serial numbers (e.g., dates 01/01/2024, 02/01/2024, 03/01/2024), quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({45292,45322,45352},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({45292,45322,45352},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45322, 'Test: Positive case: Array, Number. Array with serial numbers (e.g., dates 01/01/2024, 02/01/2024, 03/01/2024), quart = 2. 2 arguments used.');
		// Case #18: Array, Number. Array with fractions (e.g., time values 1:00, 2:00, 3:00), quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({0,041666667,0,083333333,0,125},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({0,041666667,0,083333333,0,125},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 62.5, 'Test: Positive case: Array, Number. Array with fractions (e.g., time values 1:00, 2:00, 3:00), quart = 2. 2 arguments used.');
		// Case #19: Array, Number. Array with negative and zero values, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({-1,0,1,2},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({-1,0,1,2},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array, Number. Array with negative and zero values, quart = 2. 2 arguments used.');
		// Case #20: Area, Number. Two-cell range, quart = 1. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(A100:A101,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area, Number. Two-cell range, quart = 1. 2 arguments used.');
		// Case #21: Formula, Formula. Formula for range and quart, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(A100:A103,ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(A100:A103,ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula, Formula. Formula for range and quart, quart = 2. 2 arguments used.');
		// Case #22: Reference link, Number. Reference link to valid range, quart = 3. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(A105:A108,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(A105:A108,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link, Number. Reference link to valid range, quart = 3. 2 arguments used.');

		// Negative cases:
		// Case #1: Array, Number. Single-element array returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array, Number. Single-element array returns #NUM!. 2 arguments used.');
		// Case #2: Array, Number. Array with non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,"abc",3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,"abc",3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Array, Number. Array with non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #3: Error, Number. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Propagates #N/A error. 2 arguments used.');
		// Case #4: Array, Number. Empty array returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({""},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({""},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Empty array returns #NUM!. 2 arguments used.');
		// Case #5: Empty, Number. Empty reference link returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(A109,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(A109,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty reference link returns #NUM!. 2 arguments used.');
		// Case #6: Area, Number. Range with non-numeric values returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(A109:A110,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(A109:A110,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number. Range with non-numeric values returns #VALUE!. 2 arguments used.');
		// Case #7: Array, Number. Array with booleans returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({FALSE,TRUE},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({FALSE,TRUE},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Array with booleans returns #VALUE!. 2 arguments used.');
		// Case #8: Array, Number. Quart > 4 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Quart > 4 returns #NUM!. 2 arguments used.');
		// Case #9: Array, Number. Negative quart returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Negative quart returns #NUM!. 2 arguments used.');
		// Case #10: Name, Number. Named range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(TestNameArea,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(TestNameArea,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Name, Number. Named range with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #11: Ref3D, Number. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(Sheet2!A5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(Sheet2!A5,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D, Number. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.');
		// Case #12: Array, String. Non-numeric quart returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, String. Non-numeric quart returns #VALUE!. 2 arguments used.');
		// Case #13: Formula, Number. Formula resulting in #NUM! error. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in #NUM! error. 2 arguments used.');
		// Case #14: Array, Number. Array with value exceeding Excelâ??s limit returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1E+307,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1E+307,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Negative case: Array, Number. Array with value exceeding Excelâ??s limit returns #NUM!. 2 arguments used.');
		// Case #15: Array, Number. Non-integer quart returns #NUM!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Negative case: Array, Number. Non-integer quart returns #NUM!. 2 arguments used.');
		// Case #16: Area, Number. Multi-cell range with mixed data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(A100:A102,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(A100:A102,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Area, Number. Multi-cell range with mixed data returns #VALUE!. 2 arguments used.');
		// Case #17: Array, Empty. Missing quart argument returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Empty. Missing quart argument returns #VALUE!. 2 arguments used.');
		// Case #19: Name3D, Number. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(TestNameArea3D,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(TestNameArea3D,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D, Number. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #20: Array, Number. Two-element array returns #NUM! for quart 1 (insufficient data). 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Two-element array returns #NUM! for quart 1 (insufficient data). 2 arguments used.');
		// Case #21: Array, Number. Array with empty string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,"",3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,"",3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Array, Number. Array with empty string returns #VALUE!. 2 arguments used.');
		// Case #22: Area3D, Number. 3D range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC(Sheet2!A3:A4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC(Sheet2!A3:A4,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D range with non-numeric data returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Array, Number. Array with minimum positive number, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({2,2.25073858507201E-293,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({2,2.25073858507201E-293,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Array, Number. Array with minimum positive number, quart = 2. 2 arguments used.');
		// Case #2: Array, Number. Array with maximum Excel number, quart = 2. 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1.79769313486231E+307,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1.79769313486231E+307,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Bounded case: Array, Number. Array with maximum Excel number, quart = 2. 2 arguments used.');
		// Case #3: Array, Number. Minimum valid quart (0). 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array, Number. Minimum valid quart (0). 2 arguments used.');
		// Case #4: Array, Number. Maximum valid quart (4). 2 arguments used.
		oParser = new parserFormula('QUARTILE.EXC({1,2,3,4},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: QUARTILE.EXC({1,2,3,4},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array, Number. Maximum valid quart (4). 2 arguments used.');

		// Need to fix: error types diff, area single column handle, different results from MS
		// Case #7: Table, Number. Table structured reference with valid numbers, quart = 2. 2 arguments used.
		// Case #8: Name, Number. Named range with valid numbers, quart = 2. 2 arguments used.
		// Case #9: Name3D, Number. 3D named range with valid numbers, quart = 2. 2 arguments used.
		// Case #10: Ref3D, Number. 3D reference to valid range, quart = 2. 2 arguments used.
		// Case #11: Area3D, Number. 3D two-cell range, quart = 2. 2 arguments used.
		// Case #15: String, Number. String array convertible to numbers, quart = 2. 2 arguments used.
		// Case #22: Reference link, Number. Reference link to valid range, quart = 3. 2 arguments used.
		// Case #4: Array, Number. Empty array returns #NUM!. 2 arguments used.
		// Case #5: Empty, Number. Empty reference link returns #NUM!. 2 arguments used.
		// Case #6: Area, Number. Range with non-numeric values returns #VALUE!. 2 arguments used.
		// Case #7: Array, Number. Array with booleans returns #VALUE!. 2 arguments used.
		// Case #10: Name, Number. Named range with non-numeric data returns #VALUE!. 2 arguments used.
		// Case #11: Ref3D, Number. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.
		// Case #1: Array, Number. Array with valid numbers, quart = 1 (first quartile). 2 arguments used.
		// Case #22: Area3D, Number. 3D range with non-numeric data returns #VALUE!. 2 arguments used.

		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "QUARTILE.EXC", 2, 2)
	});

	QUnit.test("Test: \"RANK\"", function (assert) {
		ws.getRange2("A2").setValue("7");
		ws.getRange2("A3").setValue("3.5");
		ws.getRange2("A4").setValue("3.5");
		ws.getRange2("A5").setValue("1");
		ws.getRange2("A6").setValue("2");

		oParser = new parserFormula("RANK(A3,A2:A6,1)", "A1", ws);
		assert.ok(oParser.parse(), "RANK(A3,A2:A6,1)");
		assert.strictEqual(oParser.calculate().getValue(), 3, "RANK(A3,A2:A6,1)");

		oParser = new parserFormula("RANK(A2,A2:A6,1)", "A1", ws);
		assert.ok(oParser.parse(), "RANK(A2,A2:A6,1)");
		assert.strictEqual(oParser.calculate().getValue(), 5, "RANK(A2,A2:A6,1)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number,Area,Number. Basic valid input: number in range, descending order. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area,Number. Basic valid input: number in range, descending order. 3 of 3 arguments used.');
		// Case #2: Number,Area,Number. Number in range, ascending order. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(2,A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(2,A100:A101,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area,Number. Number in range, ascending order. 3 of 3 arguments used.');
		// Case #3: Number,Area. Number in range, order omitted (defaults to descending). 2 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area. Number in range, order omitted (defaults to descending). 2 of 3 arguments used.');
		// Case #4: String,Area,Number. String convertible to number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK("0.5",A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK("0.5",A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String,Area,Number. String convertible to number in range. 3 of 3 arguments used.');
		// Case #5: Formula,Area,Number. Number from formula in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(SQRT(4),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(SQRT(4),A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Area,Number. Number from formula in range. 3 of 3 arguments used.');
		// Case #6: Reference link,Area,Number. Reference link to valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(A102,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(A102,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Reference link,Area,Number. Reference link to valid number in range. 3 of 3 arguments used.');
		// Case #7: Area,Area,Number. Single-cell range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(A102:A102,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(A102:A102,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area,Area,Number. Single-cell range as number in range. 3 of 3 arguments used.');
		// Case #8: Array,Area,Number. Single-element array as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK({1},A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK({1},A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Array,Area,Number. Single-element array as number in range. 3 of 3 arguments used.');
		// Case #9: Name,Area,Number. Named range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(TestName,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(TestName,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name,Area,Number. Named range as number in range. 3 of 3 arguments used.');
		// Case #10: Name3D,Area,Number. 3D named range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(TestName3D,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(TestName3D,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name3D,Area,Number. 3D named range as number in range. 3 of 3 arguments used.');
		// Case #11: Ref3D,Area,Number. 3D reference as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(Sheet2!A1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(Sheet2!A1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D,Area,Number. 3D reference as number in range. 3 of 3 arguments used.');
		// Case #12: Area3D,Area,Number. 3D single-cell range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(Sheet2!A1:A1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(Sheet2!A1:A1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area3D,Area,Number. 3D single-cell range as number in range. 3 of 3 arguments used.');
		// Case #13: Table,Area,Number. Table reference as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(Table1[Column1],A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(Table1[Column1],A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Table,Area,Number. Table reference as number in range. 3 of 3 arguments used.');
		// Case #14: Date,Area,Number. Date as serial number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(DATE(2025,1,1),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(DATE(2025,1,1),A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Date,Area,Number. Date as serial number in range. 3 of 3 arguments used.');
		// Case #15: Time,Area,Number. Time adjusted to valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(TIME(12,0,0)+1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(TIME(12,0,0)+1,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time,Area,Number. Time adjusted to valid number in range. 3 of 3 arguments used.');
		// Case #16: Formula,Area,Number. Nested IF returning valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(IF(TRUE,1,2),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(IF(TRUE,1,2),A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Area,Number. Nested IF returning valid number in range. 3 of 3 arguments used.');
		// Case #17: Number,Array,Number. Array as ref with number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,{1,2},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,{1,2},0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=RANK(1,{1,2},0)', 'Test: Positive case: Number,Array,Number. Array as ref with number in range. 3 of 3 arguments used.');
		// Case #18: Formula,Area,Formula. Order from formula evaluating to 1. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A100:A101,SUM(0,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A100:A101,SUM(0,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Area,Formula. Order from formula evaluating to 1. 3 of 3 arguments used.');
		// Case #19: Number,Area,Number. RANK inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(RANK(1,A100:A101,0),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(RANK(1,A100:A101,0),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area,Number. RANK inside SUM formula. 3 of 3 arguments used.');
		// Case #20: Number,Area3D,Number. 3D range as ref with number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,Sheet2!A1:A2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,Sheet2!A1:A2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number,Area3D,Number. 3D range as ref with number in range. 3 of 3 arguments used.');
		// Case #21: Number,Name,Number. Named range as ref with number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,TestName1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,TestName1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Name,Number. Named range as ref with number in range. 3 of 3 arguments used.');
		// Case #22: String,Area,String. String number and order convertible to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('RANK("1",A100:A101,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK("1",A100:A101,"0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String,Area,String. String number and order convertible to valid values. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(3,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(3,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.');
		// Case #2: Number,Empty,Number. Empty ref returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=RANK(1,,0)', 'Test: Negative case: Number,Empty,Number. Empty ref returns #N/A. 3 of 3 arguments used.');
		// Case #3: String,Area,Number. Non-numeric string number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK("abc",A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK("abc",A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Area,Number. Non-numeric string number returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: Error,Area,Number. Error number propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(NA(),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(NA(),A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Area,Number. Error number propagates #N/A. 3 of 3 arguments used.');
		// Case #5: Number,Area,Number. Invalid order (not 0 or 1) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A100:A101,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Invalid order (not 0 or 1) returns #NUM!. 3 of 3 arguments used.');
		// Case #6: Number,Area,Boolean. Boolean order returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A100:A101,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A100:A101,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Boolean. Boolean order returns #NUM!. 3 of 3 arguments used.');
		// Case #7: Number,Area,String. Non-numeric string order returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A100:A101,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A100:A101,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Area,String. Non-numeric string order returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Number,Area,Empty. Empty order treated as 0, but valid. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A100:A101,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A100:A101,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Empty. Empty order treated as 0, but valid. 3 of 3 arguments used.');
		// Case #9: Number,Area,Number. Ref with non-numeric values returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A102:A103,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A102:A103,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Ref with non-numeric values returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Number,Name,Number. Named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,TestNameArea,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,TestNameArea,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Number,Name,Number. Named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Number,Name3D,Number. 3D named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,TestNameArea3D,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,TestNameArea3D,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Number,Name3D,Number. 3D named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Number,Ref3D,Number. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,Sheet2!A3,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,Sheet2!A3,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Ref3D,Number. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Number,Area3D,Number. 3D range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,Sheet2!A3:A4,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,Sheet2!A3:A4,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area3D,Number. 3D range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(0,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(0,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.');
		// Case #16: Empty,Area,Number. Empty number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty,Area,Number. Empty number returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number,Area,Number. Single-cell ref returns #N/A (needs at least 2 values). 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A100:A100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A100:A100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Single-cell ref returns #N/A (needs at least 2 values). 3 of 3 arguments used.');
		// Case #18: Array,Area,Number. Array with boolean number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK({TRUE},A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK({TRUE},A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array,Area,Number. Array with boolean number returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Area,Area,Number. Multi-cell range as number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(A102:A103,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(A102:A103,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Area,Area,Number. Multi-cell range as number returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Formula,Area,Number. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(SQRT(-1),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(SQRT(-1),A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Area,Number. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number,Area,Number. Smallest positive number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1E-307,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1E-307,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Number,Area,Number. Smallest positive number in range. 3 of 3 arguments used.');
		// Case #2: Number,Area,Number. Largest valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK(9.99999999999999E+307,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(9.99999999999999E+307,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Number,Area,Number. Largest valid number in range. 3 of 3 arguments used.');
		// Case #3: Date,Area,Number. Minimum valid date serial (1/1/1900). 3 of 3 arguments used.
		oParser = new parserFormula('RANK(1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Date,Area,Number. Minimum valid date serial (1/1/1900). 3 of 3 arguments used.');
		// Case #4: Date,Area,Number. Maximum valid date serial (12/31/9999). 3 of 3 arguments used.
		oParser = new parserFormula('RANK(2958465.99999,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK(2958465.99999,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Date,Area,Number. Maximum valid date serial (12/31/9999). 3 of 3 arguments used.');

		// TODO warning window in ref argument and many different error types
		// Need to fix: diff error types, diff results from ms
		// Case #3: Number,Area. Number in range, order omitted (defaults to descending). 2 of 3 arguments used.
		// Case #8: Array,Area,Number. Single-element array as number in range. 3 of 3 arguments used.
		// Case #11: Ref3D,Area,Number. 3D reference as number in range. 3 of 3 arguments used.
		// Case #12: Area3D,Area,Number. 3D single-cell range as number in range. 3 of 3 arguments used.
		// Case #16: Formula,Area,Number. Nested IF returning valid number in range. 3 of 3 arguments used.
		// Case #17: Number,Array,Number. Array as ref with number in range. 3 of 3 arguments used. - should be Warning window
		// Case #18: Formula,Area,Formula. Order from formula evaluating to 1. 3 of 3 arguments used.
		// Case #19: Number,Area,Number. RANK inside SUM formula. 3 of 3 arguments used.
		// Case #22: String,Area,String. String number and order convertible to valid values. 3 of 3 arguments used.
		// Case #5: Number,Area,Number. Invalid order (not 0 or 1) returns #NUM!. 3 of 3 arguments used.
		// Case #6: Number,Area,Boolean. Boolean order returns #NUM!. 3 of 3 arguments used.
		// Case #10: Number,Name,Number. Named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.
		// Case #18: Array,Area,Number. Array with boolean number returns #VALUE!. 3 of 3 arguments used.
		// Case #19: Area,Area,Number. Multi-cell range as number returns #VALUE!. 3 of 3 arguments used.
		// Case #3: Date,Area,Number. Minimum valid date serial (1/1/1900). 3 of 3 arguments used.
		// Case #2: Number,Empty,Number. Empty ref returns #N/A. 3 of 3 arguments used. - should be Warning window


	});

	QUnit.test("Test: \"RANK.EQ\"", function (assert) {
		ws.getRange2("A2").setValue("7");
		ws.getRange2("A3").setValue("3.5");
		ws.getRange2("A4").setValue("3.5");
		ws.getRange2("A5").setValue("1");
		ws.getRange2("A6").setValue("2");

		oParser = new parserFormula("RANK.EQ(A2,A2:A6,1)", "A1", ws);
		assert.ok(oParser.parse(), "RANK.EQ(A2,A2:A6,1)");
		assert.strictEqual(oParser.calculate().getValue(), 5, "RANK.EQ(A2,A2:A6,1)");

		oParser = new parserFormula("RANK.EQ(A6,A2:A6)", "A1", ws);
		assert.ok(oParser.parse(), "RANK.EQ(A6,A2:A6)");
		assert.strictEqual(oParser.calculate().getValue(), 4, "RANK.EQ(A6,A2:A6)");

		oParser = new parserFormula("RANK.EQ(A3,A2:A6,1)", "A1", ws);
		assert.ok(oParser.parse(), "RANK.EQ(A3,A2:A6,1)");
		assert.strictEqual(oParser.calculate().getValue(), 3, "RANK.EQ(A3,A2:A6,1)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number,Area,Number. Basic valid input: number in range, descending order. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area,Number. Basic valid input: number in range, descending order. 3 of 3 arguments used.');
		// Case #2: Number,Area,Number. Number in range, ascending order. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(2,A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(2,A100:A101,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area,Number. Number in range, ascending order. 3 of 3 arguments used.');
		// Case #3: Number,Area. Number in range, order omitted (defaults to descending). 2 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area. Number in range, order omitted (defaults to descending). 2 of 3 arguments used.');
		// Case #4: String,Area,Number. String convertible to number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ("0.5",A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ("0.5",A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String,Area,Number. String convertible to number in range. 3 of 3 arguments used.');
		// Case #5: Formula,Area,Number. Number from formula in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(SQRT(4),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(SQRT(4),A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Area,Number. Number from formula in range. 3 of 3 arguments used.');
		// Case #6: Reference link,Area,Number. Reference link to valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(A102,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(A102,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Reference link,Area,Number. Reference link to valid number in range. 3 of 3 arguments used.');
		// Case #7: Area,Area,Number. Single-cell range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(A102:A102,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(A102:A102,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area,Area,Number. Single-cell range as number in range. 3 of 3 arguments used.');
		// Case #8: Array,Area,Number. Single-element array as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ({1},A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ({1},A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Array,Area,Number. Single-element array as number in range. 3 of 3 arguments used.');
		// Case #9: Name,Area,Number. Named range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(TestName,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(TestName,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name,Area,Number. Named range as number in range. 3 of 3 arguments used.');
		// Case #10: Name3D,Area,Number. 3D named range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(TestName3D,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(TestName3D,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name3D,Area,Number. 3D named range as number in range. 3 of 3 arguments used.');
		// Case #11: Ref3D,Area,Number. 3D reference as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(Sheet2!A1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(Sheet2!A1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D,Area,Number. 3D reference as number in range. 3 of 3 arguments used.');
		// Case #12: Area3D,Area,Number. 3D single-cell range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(Sheet2!A1:A1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(Sheet2!A1:A1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area3D,Area,Number. 3D single-cell range as number in range. 3 of 3 arguments used.');
		// Case #13: Table,Area,Number. Table reference as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(Table1[Column1],A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(Table1[Column1],A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Table,Area,Number. Table reference as number in range. 3 of 3 arguments used.');
		// Case #14: Date,Area,Number. Date as serial number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(DATE(2025,1,1),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(DATE(2025,1,1),A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Date,Area,Number. Date as serial number in range. 3 of 3 arguments used.');
		// Case #15: Time,Area,Number. Time adjusted to valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(TIME(12,0,0)+1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(TIME(12,0,0)+1,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time,Area,Number. Time adjusted to valid number in range. 3 of 3 arguments used.');
		// Case #16: Formula,Area,Number. Nested IF returning valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(IF(TRUE,1,2),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(IF(TRUE,1,2),A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Area,Number. Nested IF returning valid number in range. 3 of 3 arguments used.');
		// Case #17: Number,Array,Number. Array as ref with number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,{1,2},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,{1,2},0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=RANK.EQ(1,{1,2},0)', 'Test: Positive case: Number,Array,Number. Array as ref with number in range. 3 of 3 arguments used.');
		// Case #18: Formula,Area,Formula. Order from formula evaluating to 1. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A100:A101,SUM(0,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A100:A101,SUM(0,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Area,Formula. Order from formula evaluating to 1. 3 of 3 arguments used.');
		// Case #19: Number,Area,Number. RANK.EQ inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(RANK.EQ(1,A100:A101,0),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(RANK.EQ(1,A100:A101,0),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area,Number. RANK.EQ inside SUM formula. 3 of 3 arguments used.');
		// Case #20: Number,Area3D,Number. 3D range as ref with number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,Sheet2!A1:A2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,Sheet2!A1:A2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number,Area3D,Number. 3D range as ref with number in range. 3 of 3 arguments used.');
		// Case #21: Number,Name,Number. Named range as ref with number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,TestName1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,TestName1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Name,Number. Named range as ref with number in range. 3 of 3 arguments used.');
		// Case #22: String,Area,String. String number and order convertible to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ("1",A100:A101,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ("1",A100:A101,"0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String,Area,String. String number and order convertible to valid values. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(3,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(3,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.');
		// Case #2: Number,Empty,Number. Empty ref returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=RANK.EQ(1,,0)', 'Test: Negative case: Number,Empty,Number. Empty ref returns #N/A. 3 of 3 arguments used.');
		// Case #3: String,Area,Number. Non-numeric string number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ("abc",A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ("abc",A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Area,Number. Non-numeric string number returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: Error,Area,Number. Error number propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(NA(),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(NA(),A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Area,Number. Error number propagates #N/A. 3 of 3 arguments used.');
		// Case #5: Number,Area,Number. Invalid order (not 0 or 1) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A100:A101,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Invalid order (not 0 or 1) returns #NUM!. 3 of 3 arguments used.');
		// Case #6: Number,Area,Boolean. Boolean order returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A100:A101,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A100:A101,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Boolean. Boolean order returns #NUM!. 3 of 3 arguments used.');
		// Case #7: Number,Area,String. Non-numeric string order returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A100:A101,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A100:A101,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Area,String. Non-numeric string order returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Number,Area,Empty. Empty order treated as 0, but valid. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A100:A101,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A100:A101,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Empty. Empty order treated as 0, but valid. 3 of 3 arguments used.');
		// Case #9: Number,Area,Number. Ref with non-numeric values returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A102:A103,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A102:A103,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Ref with non-numeric values returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Number,Name,Number. Named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,TestNameArea,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,TestNameArea,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Number,Name,Number. Named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Number,Name3D,Number. 3D named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,TestNameArea3D,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,TestNameArea3D,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Number,Name3D,Number. 3D named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Number,Ref3D,Number. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,Sheet2!A3,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,Sheet2!A3,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Ref3D,Number. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Number,Area3D,Number. 3D range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,Sheet2!A3:A4,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,Sheet2!A3:A4,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area3D,Number. 3D range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(0,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(0,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.');
		// Case #16: Empty,Area,Number. Empty number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty,Area,Number. Empty number returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number,Area,Number. Single-cell ref returns #N/A (needs at least 2 values). 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A100:A100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A100:A100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Single-cell ref returns #N/A (needs at least 2 values). 3 of 3 arguments used.');
		// Case #18: Array,Area,Number. Array with boolean number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ({TRUE},A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ({TRUE},A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array,Area,Number. Array with boolean number returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Area,Area,Number. Multi-cell range as number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(A102:A103,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(A102:A103,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Area,Area,Number. Multi-cell range as number returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Formula,Area,Number. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(SQRT(-1),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(SQRT(-1),A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Area,Number. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number,Area,Number. Smallest positive number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1E-307,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1E-307,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Number,Area,Number. Smallest positive number in range. 3 of 3 arguments used.');
		// Case #2: Number,Area,Number. Largest valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(9.99999999999999E+307,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(9.99999999999999E+307,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Number,Area,Number. Largest valid number in range. 3 of 3 arguments used.');
		// Case #3: Date,Area,Number. Minimum valid date serial (1/1/1900). 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Date,Area,Number. Minimum valid date serial (1/1/1900). 3 of 3 arguments used.');
		// Case #4: Date,Area,Number. Maximum valid date serial (12/31/9999). 3 of 3 arguments used.
		oParser = new parserFormula('RANK.EQ(2958465.99999,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.EQ(2958465.99999,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Date,Area,Number. Maximum valid date serial (12/31/9999). 3 of 3 arguments used.');

		// TODO warning window in ref argument and many different error types
		// Need to fix: diff error types, diff results from ms
		// Case #3: Number,Area. Number in range, order omitted (defaults to descending). 2 of 3 arguments used.
		// Case #8: Array,Area,Number. Single-element array as number in range. 3 of 3 arguments used.
		// Case #11: Ref3D,Area,Number. 3D reference as number in range. 3 of 3 arguments used.
		// Case #12: Area3D,Area,Number. 3D single-cell range as number in range. 3 of 3 arguments used.
		// Case #16: Formula,Area,Number. Nested IF returning valid number in range. 3 of 3 arguments used.
		// Case #17: Number,Array,Number. Array as ref with number in range. 3 of 3 arguments used. - should be Warning window
		// Case #18: Formula,Area,Formula. Order from formula evaluating to 1. 3 of 3 arguments used.
		// Case #19: Number,Area,Number. RANK inside SUM formula. 3 of 3 arguments used.
		// Case #22: String,Area,String. String number and order convertible to valid values. 3 of 3 arguments used.
		// Case #5: Number,Area,Number. Invalid order (not 0 or 1) returns #NUM!. 3 of 3 arguments used.
		// Case #6: Number,Area,Boolean. Boolean order returns #NUM!. 3 of 3 arguments used.
		// Case #10: Number,Name,Number. Named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.
		// Case #18: Array,Area,Number. Array with boolean number returns #VALUE!. 3 of 3 arguments used.
		// Case #19: Area,Area,Number. Multi-cell range as number returns #VALUE!. 3 of 3 arguments used.
		// Case #3: Date,Area,Number. Minimum valid date serial (1/1/1900). 3 of 3 arguments used.
		// Case #2: Number,Empty,Number. Empty ref returns #N/A. 3 of 3 arguments used. - should be Warning window

	});

	QUnit.test("Test: \"RANK.AVG\"", function (assert) {
		ws.getRange2("A2").setValue("89");
		ws.getRange2("A3").setValue("88");
		ws.getRange2("A4").setValue("92");
		ws.getRange2("A5").setValue("101");
		ws.getRange2("A6").setValue("94");
		ws.getRange2("A7").setValue("97");
		ws.getRange2("A8").setValue("95");

		oParser = new parserFormula("RANK.AVG(94,A2:A8)", "A1", ws);
		assert.ok(oParser.parse(), "RANK.AVG(94,A2:A8)");
		assert.strictEqual(oParser.calculate().getValue(), 4, "RANK.AVG(94,A2:A8)");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number,Area,Number. Basic valid input: number in range, descending order. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area,Number. Basic valid input: number in range, descending order. 3 of 3 arguments used.');
		// Case #2: Number,Area,Number. Number in range, ascending order. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(2,A100:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(2,A100:A101,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area,Number. Number in range, ascending order. 3 of 3 arguments used.');
		// Case #3: Number,Area. Number in range, order omitted (defaults to descending). 2 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area. Number in range, order omitted (defaults to descending). 2 of 3 arguments used.');
		// Case #4: String,Area,Number. String convertible to number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG("0.5",A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG("0.5",A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String,Area,Number. String convertible to number in range. 3 of 3 arguments used.');
		// Case #5: Formula,Area,Number. Number from formula in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(SQRT(4),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(SQRT(4),A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Area,Number. Number from formula in range. 3 of 3 arguments used.');
		// Case #6: Reference link,Area,Number. Reference link to valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(A102,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(A102,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Reference link,Area,Number. Reference link to valid number in range. 3 of 3 arguments used.');
		// Case #7: Area,Area,Number. Single-cell range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(A102:A102,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(A102:A102,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area,Area,Number. Single-cell range as number in range. 3 of 3 arguments used.');
		// Case #8: Array,Area,Number. Single-element array as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG({1},A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG({1},A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Array,Area,Number. Single-element array as number in range. 3 of 3 arguments used.');
		// Case #9: Name,Area,Number. Named range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(TestName,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(TestName,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name,Area,Number. Named range as number in range. 3 of 3 arguments used.');
		// Case #10: Name3D,Area,Number. 3D named range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(TestName3D,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(TestName3D,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name3D,Area,Number. 3D named range as number in range. 3 of 3 arguments used.');
		// Case #11: Ref3D,Area,Number. 3D reference as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(Sheet2!A1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(Sheet2!A1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Ref3D,Area,Number. 3D reference as number in range. 3 of 3 arguments used.');
		// Case #12: Area3D,Area,Number. 3D single-cell range as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(Sheet2!A1:A1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(Sheet2!A1:A1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area3D,Area,Number. 3D single-cell range as number in range. 3 of 3 arguments used.');
		// Case #13: Table,Area,Number. Table reference as number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(Table1[Column1],A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(Table1[Column1],A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Table,Area,Number. Table reference as number in range. 3 of 3 arguments used.');
		// Case #14: Date,Area,Number. Date as serial number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(DATE(2025,1,1),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(DATE(2025,1,1),A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Date,Area,Number. Date as serial number in range. 3 of 3 arguments used.');
		// Case #15: Time,Area,Number. Time adjusted to valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(TIME(12,0,0)+1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(TIME(12,0,0)+1,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time,Area,Number. Time adjusted to valid number in range. 3 of 3 arguments used.');
		// Case #16: Formula,Area,Number. Nested IF returning valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(IF(TRUE,1,2),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(IF(TRUE,1,2),A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Area,Number. Nested IF returning valid number in range. 3 of 3 arguments used.');
		// Case #17: Number,Array,Number. Array as ref with number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,{1,2},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,{1,2},0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=RANK.AVG(1,{1,2},0)', 'Test: Positive case: Number,Array,Number. Array as ref with number in range. 3 of 3 arguments used.');
		// Case #18: Formula,Area,Formula. Order from formula evaluating to 1. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A100:A101,SUM(0,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A100:A101,SUM(0,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Area,Formula. Order from formula evaluating to 1. 3 of 3 arguments used.');
		// Case #19: Number,Area,Number. RANK.AVG inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(RANK.AVG(1,A100:A101,0),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(RANK.AVG(1,A100:A101,0),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Area,Number. RANK.AVG inside SUM formula. 3 of 3 arguments used.');
		// Case #20: Number,Area3D,Number. 3D range as ref with number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,Sheet2!A1:A2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,Sheet2!A1:A2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number,Area3D,Number. 3D range as ref with number in range. 3 of 3 arguments used.');
		// Case #21: Number,Name,Number. Named range as ref with number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,TestName1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,TestName1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Number,Name,Number. Named range as ref with number in range. 3 of 3 arguments used.');
		// Case #22: String,Area,String. String number and order convertible to valid values. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG("1",A100:A101,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG("1",A100:A101,"0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String,Area,String. String number and order convertible to valid values. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(3,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(3,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.');
		// Case #2: Number,Empty,Number. Empty ref returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=RANK.AVG(1,,0)', 'Test: Negative case: Number,Empty,Number. Empty ref returns #N/A. 3 of 3 arguments used.');
		// Case #3: String,Area,Number. Non-numeric string number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG("abc",A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG("abc",A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Area,Number. Non-numeric string number returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: Error,Area,Number. Error number propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(NA(),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(NA(),A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Area,Number. Error number propagates #N/A. 3 of 3 arguments used.');
		// Case #5: Number,Area,Number. Invalid order (not 0 or 1) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A100:A101,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Invalid order (not 0 or 1) returns #NUM!. 3 of 3 arguments used.');
		// Case #6: Number,Area,Boolean. Boolean order returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A100:A101,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A100:A101,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Boolean. Boolean order returns #NUM!. 3 of 3 arguments used.');
		// Case #7: Number,Area,String. Non-numeric string order returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A100:A101,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A100:A101,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Area,String. Non-numeric string order returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Number,Area,Empty. Empty order treated as 0, but valid. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A100:A101,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A100:A101,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Empty. Empty order treated as 0, but valid. 3 of 3 arguments used.');
		// Case #9: Number,Area,Number. Ref with non-numeric values returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A102:A103,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A102:A103,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Ref with non-numeric values returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Number,Name,Number. Named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,TestNameArea,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,TestNameArea,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Number,Name,Number. Named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Number,Name3D,Number. 3D named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,TestNameArea3D,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,TestNameArea3D,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Number,Name3D,Number. 3D named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Number,Ref3D,Number. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,Sheet2!A3,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,Sheet2!A3,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Ref3D,Number. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Number,Area3D,Number. 3D range with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,Sheet2!A3:A4,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,Sheet2!A3:A4,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area3D,Number. 3D range with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(0,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(0,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Number not in ref returns #N/A. 3 of 3 arguments used.');
		// Case #16: Empty,Area,Number. Empty number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty,Area,Number. Empty number returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number,Area,Number. Single-cell ref returns #N/A (needs at least 2 values). 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A100:A100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A100:A100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Area,Number. Single-cell ref returns #N/A (needs at least 2 values). 3 of 3 arguments used.');
		// Case #18: Array,Area,Number. Array with boolean number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG({TRUE},A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG({TRUE},A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array,Area,Number. Array with boolean number returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Area,Area,Number. Multi-cell range as number returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(A102:A103,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(A102:A103,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Area,Area,Number. Multi-cell range as number returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Formula,Area,Number. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(SQRT(-1),A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(SQRT(-1),A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Area,Number. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number,Area,Number. Smallest positive number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1E-307,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1E-307,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Number,Area,Number. Smallest positive number in range. 3 of 3 arguments used.');
		// Case #2: Number,Area,Number. Largest valid number in range. 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(9.99999999999999E+307,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(9.99999999999999E+307,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Number,Area,Number. Largest valid number in range. 3 of 3 arguments used.');
		// Case #3: Date,Area,Number. Minimum valid date serial (1/1/1900). 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(1,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(1,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Date,Area,Number. Minimum valid date serial (1/1/1900). 3 of 3 arguments used.');
		// Case #4: Date,Area,Number. Maximum valid date serial (12/31/9999). 3 of 3 arguments used.
		oParser = new parserFormula('RANK.AVG(2958465.99999,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RANK.AVG(2958465.99999,A100:A101,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Bounded case: Date,Area,Number. Maximum valid date serial (12/31/9999). 3 of 3 arguments used.');

		// TODO warning window in ref argument and many different error types
		// Need to fix: diff error types, diff results from ms
		// Case #3: Number,Area. Number in range, order omitted (defaults to descending). 2 of 3 arguments used.
		// Case #8: Array,Area,Number. Single-element array as number in range. 3 of 3 arguments used.
		// Case #11: Ref3D,Area,Number. 3D reference as number in range. 3 of 3 arguments used.
		// Case #12: Area3D,Area,Number. 3D single-cell range as number in range. 3 of 3 arguments used.
		// Case #16: Formula,Area,Number. Nested IF returning valid number in range. 3 of 3 arguments used.
		// Case #17: Number,Array,Number. Array as ref with number in range. 3 of 3 arguments used. - should be Warning window
		// Case #18: Formula,Area,Formula. Order from formula evaluating to 1. 3 of 3 arguments used.
		// Case #19: Number,Area,Number. RANK inside SUM formula. 3 of 3 arguments used.
		// Case #22: String,Area,String. String number and order convertible to valid values. 3 of 3 arguments used.
		// Case #5: Number,Area,Number. Invalid order (not 0 or 1) returns #NUM!. 3 of 3 arguments used.
		// Case #6: Number,Area,Boolean. Boolean order returns #NUM!. 3 of 3 arguments used.
		// Case #10: Number,Name,Number. Named range with area (non-numeric) returns #VALUE!. 3 of 3 arguments used.
		// Case #18: Array,Area,Number. Array with boolean number returns #VALUE!. 3 of 3 arguments used.
		// Case #19: Area,Area,Number. Multi-cell range as number returns #VALUE!. 3 of 3 arguments used.
		// Case #3: Date,Area,Number. Minimum valid date serial (1/1/1900). 3 of 3 arguments used.
		// Case #2: Number,Empty,Number. Empty ref returns #N/A. 3 of 3 arguments used. - should be Warning window

	});

	QUnit.test("Test: \"RSQ\"", function (assert) {

		function rsq(x, y) {

			var sumXDeltaYDelta = 0, sqrXDelta = 0, sqrYDelta = 0, _x = 0, _y = 0, xLength = 0;

			if (x.length != y.length) {
				return "#N/A"
			}
			for (var i = 0; i < x.length; i++) {

				_x += x[i]
				_y += y[i]
				xLength++;
			}

			_x /= xLength;
			_y /= xLength;

			for (var i = 0; i < x.length; i++) {

				sumXDeltaYDelta += (x[i] - _x) * (y[i] - _y);
				sqrXDelta += (x[i] - _x) * (x[i] - _x);
				sqrYDelta += (y[i] - _y) * (y[i] - _y);

			}

			if (sqrXDelta == 0 || sqrYDelta == 0) {
				return "#DIV/0!"
			} else {
				return toFixed(Math.pow(sumXDeltaYDelta / Math.sqrt(sqrXDelta * sqrYDelta), 2));
			}
		}

		oParser = new parserFormula("RSQ({9,7,5,3,1},{10,6,1,5,3})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), rsq([9, 7, 5, 3, 1], [10, 6, 1, 5, 3]));

		oParser = new parserFormula("RSQ({2,3,9,1,8,7,5},{6,5,11,7,5,4,4})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), rsq([2, 3, 9, 1, 8, 7, 5], [6, 5, 11, 7, 5, 4, 4]));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A104").setValue("5");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A105").setValue("6");
		ws.getRange2("A106").setValue("7");
		ws.getRange2("A107").setValue("8");
		ws.getRange2("A108").setValue("9");
		ws.getRange2("A109").setValue("10");
		ws.getRange2("A110").setValue("11");
		ws.getRange2("A111").setValue("11");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Array. Basic valid input: arrays with 3 numeric values. 2 arguments used.
		oParser = new parserFormula('RSQ({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Basic valid input: arrays with 3 numeric values. 2 arguments used.');
		// Case #1: Number. Float numbers in arrays. 2 arguments used.
		oParser = new parserFormula('RSQ({1.5,2.5,3.5},{4.5,5.5,6.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({1.5,2.5,3.5},{4.5,5.5,6.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Float numbers in arrays. 2 arguments used.');
		// Case #2: String. Numeric strings converted to numbers. 2 arguments used.
		oParser = new parserFormula('RSQ({"1","2","3"},{"4","5","6"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({"1","2","3"},{"4","5","6"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Numeric strings converted to numbers. 2 arguments used.');
		// Case #3: Formula. Nested formula producing valid array. 2 arguments used.
		oParser = new parserFormula('RSQ(SQRT({4,9,16}),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(SQRT({4,9,16}),{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested formula producing valid array. 2 arguments used.');
		// Case #4: Formula. RSQ inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(RSQ({1,2,3},{4,5,6}),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(RSQ({1,2,3},{4,5,6}),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. RSQ inside SUM formula. 2 arguments used.');
		// Case #5: Reference link. Reference to cells with valid arrays. 2 arguments used.
		oParser = new parserFormula('RSQ(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(A100,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference to cells with valid arrays. 2 arguments used.');
		// Case #6: Area. Single-cell ranges resolving to valid arrays. 2 arguments used.
		oParser = new parserFormula('RSQ(A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(A100:A102,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Single-cell ranges resolving to valid arrays. 2 arguments used.');
		// Case #7: Table. Table structured references with valid arrays. 2 arguments used.
		oParser = new parserFormula('RSQ(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(Table1[Column1],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured references with valid arrays. 2 arguments used.');
		// Case #8: Name. Named ranges with valid arrays. 2 arguments used.
		oParser = new parserFormula('RSQ(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Named ranges with valid arrays. 2 arguments used.');
		// Case #9: Name3D. 3D named ranges with valid arrays. 2 arguments used.
		oParser = new parserFormula('RSQ(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named ranges with valid arrays. 2 arguments used.');
		// Case #10: Ref3D. 3D references to cells with valid arrays. 2 arguments used.
		oParser = new parserFormula('RSQ(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(Sheet2!A1,Sheet2!A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D. 3D references to cells with valid arrays. 2 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges resolving to valid arrays. 2 arguments used.
		oParser = new parserFormula('RSQ(Sheet2!A1:A3,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(Sheet2!A1:A3,Sheet2!A4:A6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D single-cell ranges resolving to valid arrays. 2 arguments used.');
		// Case #12: Date. Date serial numbers as valid numbers. 2 arguments used.
		oParser = new parserFormula('RSQ({45658,45758,46858},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({45658,45758,46858},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.81203007518797, 'Test: Positive case: Date. Date serial numbers as valid numbers. 2 arguments used.');
		// Case #13: Time. Time adjusted to valid numbers. 2 arguments used.
		oParser = new parserFormula('RSQ({0.5,1.5,3.5},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({0.5,1.5,3.5},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9642857142857141, 'Test: Positive case: Time. Time adjusted to valid numbers. 2 arguments used.');
		// Case #14: Array,Number. Mixed types: array and number array. 2 arguments used.
		oParser = new parserFormula('RSQ({1,2,3},{4.5,5.5,6.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({1,2,3},{4.5,5.5,6.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array,Number. Mixed types: array and number array. 2 arguments used.');
		// Case #15: Formula,Reference link. Mixed types: formula and reference link. 2 arguments used.
		oParser = new parserFormula('RSQ(SQRT({4,9,16}),A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(SQRT({4,9,16}),A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula,Reference link. Mixed types: formula and reference link. 2 arguments used.');
		// Case #16: String,Array. Mixed types: string and array. 2 arguments used.
		oParser = new parserFormula('RSQ({"1","2","3"},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({"1","2","3"},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String,Array. Mixed types: string and array. 2 arguments used.');
		// Case #17: Formula. Nested IF returning valid array. 2 arguments used.
		oParser = new parserFormula('RSQ(IF(TRUE,{1,2,3},{4,5,6}),{7,8,9})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(IF(TRUE,{1,2,3},{4,5,6}),{7,8,9}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested IF returning valid array. 2 arguments used.');
		// Case #18: Array. Arrays with more than 3 values. 2 arguments used.
		oParser = new parserFormula('RSQ({1,2,3,4},{4,5,6,7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({1,2,3,4},{4,5,6,7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Arrays with more than 3 values. 2 arguments used.');
		// Case #19: Reference link. Reference links to different cells with valid arrays. 2 arguments used.
		oParser = new parserFormula('RSQ(A100,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(A100,A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference links to different cells with valid arrays. 2 arguments used.');
		// Case #20: Area,Table. Mixed types: area and table reference. 2 arguments used.
		oParser = new parserFormula('RSQ(A100:A102,Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(A100:A102,Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area,Table. Mixed types: area and table reference. 2 arguments used.');
		// Case #21: Name,Ref3D. Mixed types: name and 3D reference. 2 arguments used.
		oParser = new parserFormula('RSQ(TestName,Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(TestName,Sheet2!A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name,Ref3D. Mixed types: name and 3D reference. 2 arguments used.');

		// Negative cases:
		// Case #1: Array. Arrays with fewer than 3 values return #NUM!. 2 arguments used.
		oParser = new parserFormula('RSQ({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Arrays with fewer than 3 values return #NUM!. 2 arguments used.');
		// Case #2: Number. Valid arrays but may produce #NUM! if variance is zero. 2 arguments used.
		oParser = new parserFormula('RSQ({0.5,1,1.5},{2,3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({0.5,1,1.5},{2,3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Valid arrays but may produce #NUM! if variance is zero. 2 arguments used.');
		// Case #3: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('RSQ({"abc","def","ghi"},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({"abc","def","ghi"},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #4: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('RSQ(NA(),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(NA(),{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #5: Boolean. Boolean values return #VALUE!. 2 arguments used.
		oParser = new parserFormula('RSQ({TRUE,FALSE,TRUE},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({TRUE,FALSE,TRUE},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean values return #VALUE!. 2 arguments used.');
		// Case #6: Empty. Empty reference returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('RSQ(A103,{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(A103,{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Empty reference returns #VALUE!. 2 arguments used.');
		// Case #7: Area. Multi-cell ranges with fewer than 3 values return #NUM!. 2 arguments used.
		oParser = new parserFormula('RSQ(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area. Multi-cell ranges with fewer than 3 values return #NUM!. 2 arguments used.');
		// Case #8: String. Numeric strings but may produce #NUM! if variance is zero. 2 arguments used.
		oParser = new parserFormula('RSQ({"0.5","1","1.5"},{2,3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({"0.5","1","1.5"},{2,3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Numeric strings but may produce #NUM! if variance is zero. 2 arguments used.');
		// Case #9: Formula. Formula producing #NUM! error. 2 arguments used.
		oParser = new parserFormula('RSQ(SQRT({-1,4,9}),{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(SQRT({-1,4,9}),{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula producing #NUM! error. 2 arguments used.');
		// Case #10: Name. Named range with fewer than 3 values returns #NUM!. 2 arguments used.
		oParser = new parserFormula('RSQ(TestNameArea,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(TestNameArea,TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with fewer than 3 values returns #NUM!. 2 arguments used.');
		// Case #11: Name3D. 3D named range with fewer than 3 values returns #NUM!. 2 arguments used.
		oParser = new parserFormula('RSQ(TestNameArea3D2,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(TestNameArea3D2,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Name3D. 3D named range with fewer than 3 values returns #NUM!. 2 arguments used.');
		// Case #12: Ref3D. 3D references with fewer than 3 values return #NUM!. 2 arguments used.
		oParser = new parserFormula('RSQ(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D references with fewer than 3 values return #NUM!. 2 arguments used.');
		// Case #13: Area3D. 3D ranges with fewer than 3 values return #NUM!. 2 arguments used.
		oParser = new parserFormula('RSQ(Sheet2!A3:A4,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(Sheet2!A3:A4,Sheet2!A5:A6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D ranges with fewer than 3 values return #NUM!. 2 arguments used.');
		// Case #14: Table. Table with non-numeric values returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('RSQ(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table with non-numeric values returns #VALUE!. 2 arguments used.');
		// Case #15: Number. Negative numbers are valid but included for completeness. 2 arguments used.
		oParser = new parserFormula('RSQ({-1,-2,-3},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({-1,-2,-3},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Negative numbers are valid but included for completeness. 2 arguments used.');
		// Case #16: String. Empty string in array returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('RSQ({"","1","2"},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({"","1","2"},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Empty string in array returns #VALUE!. 2 arguments used.');
		// Case #17: Array. Constant array causes #NUM! due to zero variance. 2 arguments used.
		oParser = new parserFormula('RSQ({1,1,1},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({1,1,1},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Constant array causes #NUM! due to zero variance. 2 arguments used.');
		// Case #18: Time. Time values <1 may cause issues but included for testing. 2 arguments used.
		oParser = new parserFormula('RSQ({-0.5,-1.5,-3.5},{-1,-2,-3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({-0.5,-1.5,-3.5},{-1,-2,-3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9642857142857141, 'Test: Negative case: Time. Time values <1 may cause issues but included for testing. 2 arguments used.');
		// Case #19: Reference link. Reference to non-numeric values returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('RSQ(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(A104,A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to non-numeric values returns #VALUE!. 2 arguments used.');
		// Case #20: Area. Area with non-numeric values returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('RSQ(A104:A106,A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ(A104:A106,A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area. Area with non-numeric values returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Max Excel number in array, may cause #NUM! due to variance. 2 arguments used.
		oParser = new parserFormula('RSQ({1E+305,1E+306,2E+307},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({1E+305,1E+306,2E+307},{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Max Excel number in array, may cause #NUM! due to variance. 2 arguments used.');
		// Case #2: Number. Min positive Excel numbers in array. 2 arguments used.
		oParser = new parserFormula('RSQ({2.23E-308,3E-308,4E-308},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({2.23E-308,3E-308,4E-308},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Min positive Excel numbers in array. 2 arguments used.');
		// Case #3: Number. Max Excel numbers in both arrays, may cause #NUM!. 2 arguments used.
		oParser = new parserFormula('RSQ({1E+307,1E+307,1E+307},{2E+307,2E+307,2E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RSQ({1E+307,1E+307,1E+307},{2E+307,2E+307,2E+307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Max Excel numbers in both arrays, may cause #NUM!. 2 arguments used.');

		// Need to fix: error type diff, result diff, area handle
		// Case #5: Reference link. Reference to cells with valid arrays. 2 arguments used.
		// Case #7: Table. Table structured references with valid arrays. 2 arguments used.
		// Case #17: Formula. Nested IF returning valid array. 2 arguments used.
		// Case #20: Area,Table. Mixed types: area and table reference. 2 arguments used.


		testArrayFormula2(assert, "RSQ", 2, 2, null, true)
	});

	QUnit.test("Test: \"SKEW\"", function (assert) {

		function skew(x) {

			var sumSQRDeltaX = 0, _x = 0, xLength = 0, standDev = 0, sumSQRDeltaXDivstandDev = 0;
			for (var i = 0; i < x.length; i++) {

				_x += x[i];
				xLength++;

			}

			if (xLength <= 2) {
				return "#N/A"
			}

			_x /= xLength;

			for (var i = 0; i < x.length; i++) {

				sumSQRDeltaX += Math.pow(x[i] - _x, 2);

			}

			standDev = Math.sqrt(sumSQRDeltaX / (xLength - 1));

			for (var i = 0; i < x.length; i++) {

				sumSQRDeltaXDivstandDev += Math.pow((x[i] - _x) / standDev, 3);

			}

			return toFixed(xLength / (xLength - 1) / (xLength - 2) * sumSQRDeltaXDivstandDev)

		}

		oParser = new parserFormula("SKEW(3,4,5,2,3,4,5,6,4,7)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), skew([3, 4, 5, 2, 3, 4, 5, 6, 4, 7]));

		oParser = new parserFormula("SKEW({2,3,9,1,8,7,5},{6,5,11,7,5,4,4})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), skew([2, 3, 9, 1, 8, 7, 5, 6, 5, 11, 7, 5, 4, 4]));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A106").setValue("2");
		ws.getRange2("A107").setValue("3");
		ws.getRange2("A108").setValue("4");
		ws.getRange2("A109").setValue("5");
		ws.getRange2("A110").setValue("6");
		ws.getRange2("A111").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Array with valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW({1,2,3,4,50})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({1,2,3,4,50}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2206404584946933, 'Test: Positive case: Number. Array with valid numbers. Returns skewness.');
		// Case #2: Number. Array with larger numbers. Returns skewness.
		oParser = new parserFormula('SKEW({10,20,40})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({10,20,40}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9352195295828254, 'Test: Positive case: Number. Array with larger numbers. Returns skewness.');
		// Case #3: String. Numeric strings converted to numbers. Returns skewness.
		oParser = new parserFormula('SKEW({"1","2","3","5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({"1","2","3","5"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Numeric strings converted to numbers. Returns skewness.');
		// Case #4: Formula. Nested SQRT formulas producing valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW({1,2,3,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({1,2,3,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9796868910958225, 'Test: Positive case: Formula. Nested SQRT formulas producing valid numbers. Returns skewness.');
		// Case #5: Reference link. Reference to cell with valid array. Returns skewness.
		oParser = new parserFormula('SKEW(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference to cell with valid array. Returns skewness.');
		// Case #6: Area. Range of two cells. Returns skewness.
		oParser = new parserFormula('SKEW(A101:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(A101:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.1903401282789945, 'Test: Positive case: Area. Range of two cells. Returns skewness.');
		// Case #7: Array. Array with floating-point numbers. Returns skewness.
		oParser = new parserFormula('SKEW({1.5,2.5,3.5,4.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({1.5,2.5,3.5,4.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Array with floating-point numbers. Returns skewness.');
		// Case #8: Name. Named range with valid array. Returns skewness.
		oParser = new parserFormula('SKEW(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Named range with valid array. Returns skewness.');
		// Case #9: Name3D. 3D named range with valid array. Returns skewness.
		oParser = new parserFormula('SKEW(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(TestName3D2 is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named range with valid array. Returns skewness.');
		// Case #10: Ref3D. 3D reference to cell with valid array. Returns skewness.
		oParser = new parserFormula('SKEW(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D. 3D reference to cell with valid array. Returns skewness.');
		// Case #11: Area3D. 3D range of two cells. Returns skewness.
		oParser = new parserFormula('SKEW(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D range of two cells. Returns skewness.');
		// Case #12: Table. Table with valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table with valid numbers. Returns skewness.');
		// Case #13: Date. Dates as serial numbers. Returns skewness.
		oParser = new parserFormula('SKEW({1000,20000,30000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({1000,20000,30000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.8784306945218352, 'Test: Positive case: Date. Dates as serial numbers. Returns skewness.');
		// Case #14: Time. Time values as fractions. Returns skewness.
		oParser = new parserFormula('SKEW({0.04,0.4,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({0.04,0.4,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6795356000385135, 'Test: Positive case: Time. Time values as fractions. Returns skewness.');
		// Case #15: Formula. Nested IF returning valid array. Returns skewness.
		oParser = new parserFormula('SKEW(IF(TRUE,{1,2,3,4,50},{2,3,4,5,60}))', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A1:B2").bbox);
		assert.ok(oParser.parse(), 'Test: SKEW(IF(TRUE,{1,2,3,4,50},{2,3,4,5,60})) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2206404584946933, 'Test: Positive case: Formula. Nested IF returning valid array. Returns skewness.');
		// Case #16: Formula. Nested RAND generating valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW({0.5,0.6,0.7,0.1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({0.5,0.6,0.7,0.1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.4430588355316432, 'Test: Positive case: Formula. Nested RAND generating valid numbers. Returns skewness.');
		// Case #17: Number. Larger numbers in array. Returns skewness.
		oParser = new parserFormula('SKEW({100,200,300,400,500})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({100,200,300,400,500}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Larger numbers in array. Returns skewness.');
		// Case #18: String. Numeric strings with decimals. Returns skewness.
		oParser = new parserFormula('SKEW({"1.5","2.5","30.5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({"1.5","2.5","30.5"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Numeric strings with decimals. Returns skewness.');
		// Case #19: Reference link. Reference to cell with valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference to cell with valid numbers. Returns skewness.');
		// Case #20: Area. Two-cell range with valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW(A103:A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(A103:A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.36727693613628765, 'Test: Positive case: Area. Two-cell range with valid numbers. Returns skewness.');
		// Case #21: Formula. Nested SUM formulas. Returns skewness.
		oParser = new parserFormula('SKEW(SUM(1,1),SUM(2,2),SUM(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(SUM(1,1),SUM(2,2),SUM(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5855827262813893, 'Test: Positive case: Formula. Nested SUM formulas. Returns skewness.');

		// Negative cases:
		// Case #1: Number. Array with fewer than 3 values returns #DIV/0!.
		oParser = new parserFormula('SKEW({1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Array with fewer than 3 values returns #DIV/0!.');
		// Case #2: String. Non-numeric strings return #VALUE!.
		oParser = new parserFormula('SKEW({"abc","def","ghi"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({"abc","def","ghi"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-numeric strings return #VALUE!.');
		// Case #3: Error. Error value in array propagates #N/A.
		oParser = new parserFormula('SKEW(NA(),1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(NA(),1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value in array propagates #N/A.');
		// Case #4: Empty. Empty cell reference returns #DIV/0!.
		oParser = new parserFormula('SKEW(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(A105) is parsed.');
		 assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Empty cell reference returns #DIV/0!.');
		// Case #5: Boolean. Booleans in array return #VALUE!.
		oParser = new parserFormula('SKEW({TRUE,FALSE,TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({TRUE,FALSE,TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Booleans in array return #VALUE!.');
		// Case #6: Reference link. Reference to cell with text returns #VALUE!.
		oParser = new parserFormula('SKEW(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!.');
		// Case #7: Area. Range with non-numeric value returns #VALUE!.
		oParser = new parserFormula('SKEW(A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area. Range with non-numeric value returns #VALUE!.');
		// Case #8: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('SKEW(TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #9: Name3D. 3D named range with single value returns #DIV/0!.
		oParser = new parserFormula('SKEW(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D. 3D named range with single value returns #DIV/0!.');
		// Case #10: Ref3D. 3D reference to text returns #VALUE!.
		oParser = new parserFormula('SKEW(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!.');
		// Case #11: Area3D. 3D range with error value returns #N/A.
		oParser = new parserFormula('SKEW(Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with error value returns #N/A.');
		// Case #12: Table. Table with one value returns #DIV/0!.
		oParser = new parserFormula('SKEW(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Table. Table with one value returns #DIV/0!.');
		// Case #13: Formula. Nested formula with #NUM! error propagates error.
		oParser = new parserFormula('SKEW(SQRT(-1),1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(SQRT(-1),1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula with #NUM! error propagates error.');
		// Case #14: Number. All identical values return #DIV/0!.
		oParser = new parserFormula('SKEW({0,0,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({0,0,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. All identical values return #DIV/0!.');
		// Case #14.1: Number. All identical values return #DIV/0!.
		oParser = new parserFormula('SKEW({1,1,1,1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({1,1,1,1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. All identical values return #DIV/0!.');
		// Case #15: Array. Single-element array returns #DIV/0!.
		oParser = new parserFormula('SKEW({1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Single-element array returns #DIV/0!.');
		// Case #16: String. Empty string in array returns #VALUE!.
		oParser = new parserFormula('SKEW({""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({""}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Empty string in array returns #VALUE!.');
		// Case #17: Formula. Nested IF returning text causes #DIV/0 because text is skipped.
		oParser = new parserFormula('SKEW(IF(FALSE,1,"text"),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(IF(FALSE,1,"text"),2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Nested IF returning text causes #DIV/0 because text is skipped.');
		// Case #18: Reference link. Reference to error value returns #N/A.
		oParser = new parserFormula('SKEW(A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to error value returns #N/A.');
		// Case #19: Area. Range with one value returns #DIV/0!.
		oParser = new parserFormula('SKEW(A100:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(A100:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.40780672525755, 'Test: Negative case: Area. Range with one value returns #DIV/0!.');
		// Case #20: Name. Named range with two values returns #DIV/0!.
		oParser = new parserFormula('SKEW(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name. Named range with two values returns #DIV/0!.');
		// Case #21: Area3D. 3D range with two values returns #DIV/0!.
		oParser = new parserFormula('SKEW(Sheet2!A7:A8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW(Sheet2!A7:A8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with two values returns #DIV/0!.');

		// Bounded cases:
		// Case #1: Number. Max Excel number in dataset. Returns skewness.
		oParser = new parserFormula('SKEW({1.797E+307,1,2,3,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({1.797E+307,1,2,3,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Max Excel number in dataset. Returns skewness.');
		// Case #2: Number. Min positive Excel number in dataset. Returns skewness.
		oParser = new parserFormula('SKEW({2.23E-308,1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({2.23E-308,1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Min positive Excel number in dataset. Returns skewness.');
		// Case #3: Number. Highly skewed dataset with extreme values. Returns skewness.
		oParser = new parserFormula('SKEW({1E+100,1E+100,1E-100})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW({1E+100,1E+100,1E-100}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.7320508075688759, 'Test: Bounded case: Number. Highly skewed dataset with extreme values. Returns skewness.');

		testArrayFormula2(assert, "SKEW", 1, 8, null, true);
	});

	QUnit.test("Test: \"SKEW.P\"", function (assert) {
		ws.getRange2("A202").setValue("3");
		ws.getRange2("A203").setValue("4");
		ws.getRange2("A204").setValue("5");
		ws.getRange2("A205").setValue("2");
		ws.getRange2("A206").setValue("3");
		ws.getRange2("A207").setValue("4");
		ws.getRange2("A208").setValue("5");
		ws.getRange2("A209").setValue("6");
		ws.getRange2("A210").setValue("4");
		ws.getRange2("A211").setValue("7");

		oParser = new parserFormula("SKEW.P(A202:A211)", "A1", ws);
		assert.ok(oParser.parse(), "SKEW.P(A202:A211)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.303193, "SKEW.P(A202:A211)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("Text");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A106").setValue("2");
		ws.getRange2("A107").setValue("3");
		ws.getRange2("A108").setValue("4");
		ws.getRange2("A109").setValue("5");
		ws.getRange2("A110").setValue("6");
		ws.getRange2("A111").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Array with valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P({1,2,3,4,50})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({1,2,3,4,50}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.489650905634131, 'Test: Positive case: Number. Array with valid numbers. Returns skewness.');
		// Case #2: Number. Array with larger numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P({10,20,40})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({10,20,40}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3818017741606064, 'Test: Positive case: Number. Array with larger numbers. Returns skewness.');
		// Case #3: String. Numeric strings converted to numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P({"1","2","3","5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({"1","2","3","5"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Numeric strings converted to numbers. Returns skewness.');
		// Case #4: Formula. Nested SQRT formulas producing valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P({1,2,3,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({1,2,3,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1429727594853465, 'Test: Positive case: Formula. Nested SQRT formulas producing valid numbers. Returns skewness.');
		// Case #5: Reference link. Reference to cell with valid array. Returns skewness.
		oParser = new parserFormula('SKEW.P(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference to cell with valid array. Returns skewness.');
		// Case #6: Area. Range of two cells. Returns skewness.
		oParser = new parserFormula('SKEW.P(A101:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(A101:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.6872431934890912, 'Test: Positive case: Area. Range of two cells. Returns skewness.');
		// Case #7: Array. Array with floating-point numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P({1.5,2.5,3.5,4.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({1.5,2.5,3.5,4.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Array with floating-point numbers. Returns skewness.');
		// Case #8: Name. Named range with valid array. Returns skewness.
		oParser = new parserFormula('SKEW.P(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Named range with valid array. Returns skewness.');
		// Case #9: Name3D. 3D named range with valid array. Returns skewness.
		oParser = new parserFormula('SKEW.P(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named range with valid array. Returns skewness.');
		// Case #10: Ref3D. 3D reference to cell with valid array. Returns skewness.
		oParser = new parserFormula('SKEW.P(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D. 3D reference to cell with valid array. Returns skewness.');
		// Case #11: Area3D. 3D range of two cells. Returns skewness.
		oParser = new parserFormula('SKEW.P(Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D range of two cells. Returns skewness.');
		// Case #12: Table. Table with valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table with valid numbers. Returns skewness.');
		// Case #13: Date. Dates as serial numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P({1000,20000,30000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({1000,20000,30000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.358617829329523, 'Test: Positive case: Date. Dates as serial numbers. Returns skewness.');
		// Case #14: Time. Time values as fractions. Returns skewness.
		oParser = new parserFormula('SKEW.P({0.04,0.4,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({0.04,0.4,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6856675374889215, 'Test: Positive case: Time. Time values as fractions. Returns skewness.');
		// Case #15: Formula. Nested IF returning valid array. Returns skewness.
		oParser = new parserFormula('SKEW.P(IF(TRUE,{1,2,3,4,50},{2,3,4,5,60}))', 'A2', ws);
		oParser.setArrayFormulaRef(ws.getRange2("A1:B2").bbox);
		assert.ok(oParser.parse(), 'Test: SKEW.P(IF(TRUE,{1,2,3,4,50},{2,3,4,5,60})) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.489650905634131, 'Test: Positive case: Formula. Nested IF returning valid array. Returns skewness.');
		// Case #16: Formula. Nested RAND generating valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P({0.5,0.6,0.7,0.1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({0.5,0.6,0.7,0.1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.8331504071506622, 'Test: Positive case: Formula. Nested RAND generating valid numbers. Returns skewness.');
		// Case #17: Number. Larger numbers in array. Returns skewness.
		oParser = new parserFormula('SKEW.P({100,200,300,400,500})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({100,200,300,400,500}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Larger numbers in array. Returns skewness.');
		// Case #18: String. Numeric strings with decimals. Returns skewness.
		oParser = new parserFormula('SKEW.P({"1.5","2.5","30.5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({"1.5","2.5","30.5"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Numeric strings with decimals. Returns skewness.');
		// Case #19: Reference link. Reference to cell with valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link. Reference to cell with valid numbers. Returns skewness.');
		// Case #20: Area. Two-cell range with valid numbers. Returns skewness.
		oParser = new parserFormula('SKEW.P(A103:A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(A103:A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.2833603080482124, 'Test: Positive case: Area. Two-cell range with valid numbers. Returns skewness.');
		// Case #21: Formula. Nested SUM formulas. Returns skewness.
		oParser = new parserFormula('SKEW.P(SUM(1,1),SUM(2,2),SUM(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(SUM(1,1),SUM(2,2),SUM(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.23906314692954514, 'Test: Positive case: Formula. Nested SUM formulas. Returns skewness.');

		// Negative cases:
		// Case #1: Number. Array with fewer than 3 values returns #DIV/0!.
		oParser = new parserFormula('SKEW.P({1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Array with fewer than 3 values returns #DIV/0!.');
		// Case #2: String. Non-numeric strings return #VALUE!.
		oParser = new parserFormula('SKEW.P({"abc","def","ghi"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({"abc","def","ghi"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-numeric strings return #VALUE!.');
		// Case #3: Error. Error value in array propagates #N/A.
		oParser = new parserFormula('SKEW.P(NA(),1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(NA(),1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value in array propagates #N/A.');
		// Case #4: Empty. Empty cell reference returns #DIV/0!.
		oParser = new parserFormula('SKEW.P(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Empty cell reference returns #DIV/0!.');
		// Case #5: Boolean. Booleans in array return #VALUE!.
		oParser = new parserFormula('SKEW.P({TRUE,FALSE,TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({TRUE,FALSE,TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Booleans in array return #VALUE!.');
		// Case #6: Reference link. Reference to cell with text returns #VALUE!.
		oParser = new parserFormula('SKEW.P(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cell with text returns #VALUE!.');
		// Case #7: Area. Range with non-numeric value returns #VALUE!.
		oParser = new parserFormula('SKEW.P(A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area. Range with non-numeric value returns #VALUE!.');
		// Case #8: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('SKEW.P(TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #9: Name3D. 3D named range with single value returns #DIV/0!.
		oParser = new parserFormula('SKEW.P(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D. 3D named range with single value returns #DIV/0!.');
		// Case #10: Ref3D. 3D reference to text returns #VALUE!.
		oParser = new parserFormula('SKEW.P(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!.');
		// Case #11: Area3D. 3D range with error value returns #N/A.
		oParser = new parserFormula('SKEW.P(Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with error value returns #N/A.');
		// Case #12: Table. Table with single value returns #DIV/0!.
		oParser = new parserFormula('SKEW.P(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Table. Table with single value returns #DIV/0!.');
		// Case #13: Formula. Nested formula with #NUM! error propagates error.
		oParser = new parserFormula('SKEW.P(SQRT(-1),1,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(SQRT(-1),1,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested formula with #NUM! error propagates error.');
		// Case #14: Number. All identical values return #DIV/0!.
		oParser = new parserFormula('SKEW.P({0,0,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({0,0,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. All identical values return #DIV/0!.');
		// Case #14.1: Number. All identical values return #DIV/0!.
		oParser = new parserFormula('SKEW.P({1,1,1,1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({1,1,1,1,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. All identical values return #DIV/0!.');
		// Case #15: Array. Single-element array returns #DIV/0!.
		oParser = new parserFormula('SKEW.P({1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Single-element array returns #DIV/0!.');
		// Case #16: String. Empty string in array returns #VALUE!.
		oParser = new parserFormula('SKEW.P({""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({""}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Empty string in array returns #VALUE!.');
		// Case #17: Formula. Nested IF returning text causes #DIV/0!.
		oParser = new parserFormula('SKEW.P(IF(FALSE,1,"text"),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(IF(FALSE,1,"text"),2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Nested IF returning text causes #DIV/0!.');
		// Case #18: Reference link. Reference to error value returns #N/A.
		oParser = new parserFormula('SKEW.P(A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to error value returns #N/A.');
		// Case #19: Area. Range with one value returns #DIV/0!.
		oParser = new parserFormula('SKEW.P(A100:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(A100:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3438928258529, 'Test: Negative case: Area. Range with one value returns #DIV/0!.');
		// Case #20: Name. Named range with two values returns #DIV/0!.
		oParser = new parserFormula('SKEW.P(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name. Named range with two values returns #DIV/0!.');
		// Case #21: Area3D. 3D range with two values returns #DIV/0!.
		oParser = new parserFormula('SKEW.P(Sheet2!A7:A8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P(Sheet2!A7:A8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with two values returns #DIV/0!.');

		// Bounded cases:
		// Case #1: Number. Max Excel number in dataset. Returns skewness.
		oParser = new parserFormula('SKEW.P({1.797E+307,1,2,3,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({1.797E+307,1,2,3,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Max Excel number in dataset. Returns skewness.');
		// Case #2: Number. Min positive Excel number in dataset. Returns skewness.
		oParser = new parserFormula('SKEW.P({2.23E-308,1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({2.23E-308,1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Min positive Excel number in dataset. Returns skewness.');
		// Case #3: Number. Highly skewed dataset with extreme values. Returns skewness.
		oParser = new parserFormula('SKEW.P({1E+100,1E+100,1E-100})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SKEW.P({1E+100,1E+100,1E-100}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.7071067811865474, 'Test: Bounded case: Number. Highly skewed dataset with extreme values. Returns skewness.');


	});

	QUnit.test("Test: \"SLOPE\"", function (assert) {

		function slope(y, x) {

			var sumXDeltaYDelta = 0, sqrXDelta = 0, _x = 0, _y = 0, xLength = 0;

			if (x.length != y.length) {
				return "#N/A"
			}
			for (var i = 0; i < x.length; i++) {

				_x += x[i]
				_y += y[i]
				xLength++;
			}

			_x /= xLength;
			_y /= xLength;

			for (var i = 0; i < x.length; i++) {

				sumXDeltaYDelta += (x[i] - _x) * (y[i] - _y);
				sqrXDelta += (x[i] - _x) * (x[i] - _x);

			}

			if (sqrXDelta == 0) {
				return "#DIV/0!"
			} else {
				return toFixed(sumXDeltaYDelta / sqrXDelta);
			}
		}

		oParser = new parserFormula("SLOPE({9,7,5,3,1},{10,6,1,5,3})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), slope([9, 7, 5, 3, 1], [10, 6, 1, 5, 3]));

		oParser = new parserFormula("SLOPE({2,3,9,1,8,7,5},{6,5,11,7,5,4,4})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), slope([2, 3, 9, 1, 8, 7, 5], [6, 5, 11, 7, 5, 4, 4]));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A106").setValue("2");
		ws.getRange2("A107").setValue("3");
		ws.getRange2("A108").setValue("4");
		ws.getRange2("A109").setValue("5");
		ws.getRange2("A110").setValue("6");
		ws.getRange2("A111").setValue("7");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		ws.getRange2("C601").setValue("123rds"); // Text (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: arrays with three numbers, slope is 0.5.
		oParser = new parserFormula('SLOPE({1,2,3},{2,4,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1,2,3},{2,4,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Basic valid input: arrays with three numbers, slope is 0.5.');
		// Case #2: Number. Arrays with three numbers, slope is 0.2.
		oParser = new parserFormula('SLOPE({3,5,7},{10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({3,5,7},{10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2, 'Test: Positive case: Number. Arrays with three numbers, slope is 0.2.');
		// Case #3: Formula. SQRT formula applied to x-values, slope is 0.5.
		oParser = new parserFormula('SLOPE({1,2,3},SQRT({4,16,36}))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1,2,3},SQRT({4,16,36})) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. SQRT formula applied to x-values, slope is 0.5.');
		// Case #4: String. String numbers converted to numbers, slope is 0.5.
		oParser = new parserFormula('SLOPE({"1","2","3"},{"2","4","7"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({"1","2","3"},{"2","4","7"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String numbers converted to numbers, slope is 0.5.');
		// Case #5: Reference link. Reference to cells with three numbers, slope is 0.5.
		oParser = new parserFormula('SLOPE(A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(A100:A102,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Reference link. Reference to cells with three numbers, slope is 0.5.');
		// Case #6: Area. Three-cell ranges, slope is 0.5.
		oParser = new parserFormula('SLOPE(A106:A108,A109:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(A106:A108,A109:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Three-cell ranges, slope is 0.5.');
		// Case #7: Array. Four-element arrays, slope is 0.5.
		oParser = new parserFormula('SLOPE({1,3,5,7},{4,8,12,16})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1,3,5,7},{4,8,12,16}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Four-element arrays, slope is 0.5.');
		// Case #8: Name. Named ranges with three numbers, slope is 0.5.
		oParser = new parserFormula('SLOPE(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(TestName1,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Named ranges with three numbers, slope is 0.5.');
		// Case #9: Name3D. 3D named ranges with three numbers, slope is 0.5.
		oParser = new parserFormula('SLOPE(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named ranges with three numbers, slope is 0.5.');
		// Case #10: Ref3D. 3D references to three cells, slope is 0.5.
		oParser = new parserFormula('SLOPE(Sheet2!A1:A3,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(Sheet2!A1:A3,Sheet2!A4:A6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D. 3D references to three cells, slope is 0.5.');
		// Case #11: Area3D. 3D three-cell ranges, slope is 0.5.
		oParser = new parserFormula('SLOPE(Sheet2!A7:A9,Sheet2!A10:A12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(Sheet2!A7:A9,Sheet2!A10:A12) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D three-cell ranges, slope is 0.5.');
		// Case #12: Table. Table structured references with three numbers, slope is 0.5.
		oParser = new parserFormula('SLOPE(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(Table1[Column1],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured references with three numbers, slope is 0.5.');
		// Case #13: Date. Dates as serial numbers, slope is 0.5.
		oParser = new parserFormula('SLOPE({45658,45659,45660},{45670,45681,45692})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({45658,45659,45660},{45670,45681,45692}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09090909090909091, 'Test: Positive case: Date. Dates as serial numbers, slope is 0.5.');
		// Case #14: Time. Time values as fractions, slope is 0.5.
		oParser = new parserFormula('SLOPE({0.04,0.06,0.09},{0.08,0.1,0.2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({0.04,0.06,0.09},{0.08,0.1,0.2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.37903225806451607, 'Test: Positive case: Time. Time values as fractions, slope is 0.5.');
		// Case #15: Formula. SLOPE inside SUM formula, returns 1.
		oParser = new parserFormula('SUM(SLOPE({1,2,3},{2,4,6}),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SLOPE({1,2,3},{2,4,6}),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. SLOPE inside SUM formula, returns 1.');
		// Case #16: Number. Four-element arrays with larger numbers, slope is 0.5.
		oParser = new parserFormula('SLOPE({10,20,30,40},{20,40,60,80})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({10,20,30,40},{20,40,60,80}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Four-element arrays with larger numbers, slope is 0.5.');
		// Case #17: String. String numbers, three elements, slope is 0.5.
		oParser = new parserFormula('SLOPE({"10","20","30"},{"20","40","60"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({"10","20","30"},{"20","40","60"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String numbers, three elements, slope is 0.5.');
		// Case #18: Formula. Nested IF returning valid arrays, slope is 0.5.
		oParser = new parserFormula('SLOPE(IF(TRUE,{1,2,3},{0,0,0}),IF(TRUE,{2,4,6},{0,0,0}))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(IF(TRUE,{1,2,3},{0,0,0}),IF(TRUE,{2,4,6},{0,0,0})) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested IF returning valid arrays, slope is 0.5.');
		// Case #19: Number. Float numbers in arrays, slope is 0.3333.
		oParser = new parserFormula('SLOPE({1.5,2.5,3.5},{3,6,9})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1.5,2.5,3.5},{3,6,9}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3333333333333333, 'Test: Positive case: Number. Float numbers in arrays, slope is 0.3333.');
		// Case #20: Array. Five-element arrays, slope is 0.5.
		oParser = new parserFormula('SLOPE({100,200,300,400,500},{200,400,600,800,1000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({100,200,300,400,500},{200,400,600,800,1000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Five-element arrays, slope is 0.5.');

		// Negative cases:
		// Case #1: Number. Single-element arrays, returns #DIV/0! error.
		oParser = new parserFormula('SLOPE({1},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Single-element arrays, returns #DIV/0! error.');
		// Case #2: Number. Identical x-values, returns #DIV/0! error.
		oParser = new parserFormula('SLOPE({1,2,3},{2,2,22})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1,2,3},{2,2,22}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.075, 'Test: Negative case: Number. Identical x-values, returns #DIV/0! error.');
		// Case #3: String. Non-numeric strings, returns #VALUE! error.
		oParser = new parserFormula('SLOPE({"abc","def","ghi"},{2,4,7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({"abc","def","ghi"},{2,4,7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-numeric strings, returns #VALUE! error.');
		// Case #4: Error. NA() error propagates, returns #N/A.
		oParser = new parserFormula('SLOPE({"NA",1,2},{2,4,7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({"NA",1,2},{2,4,7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3333333333333333, 'Test: Negative case: Error. NA() error propagates, returns #N/A.');
		// Case #5: Empty. Empty cell references, returns #VALUE! error.
		oParser = new parserFormula('SLOPE(A100:A101,A104:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(A100:A101,A104:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Empty cell references, returns #VALUE! error.');
		// Case #6: Boolean. Boolean values, returns #VALUE! error.
		oParser = new parserFormula('SLOPE({TRUE,FALSE,TRUE},{2,4,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({TRUE,FALSE,TRUE},{2,4,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean values, returns #VALUE! error.');
		// Case #7: Area. Multi-cell range with text, returns #VALUE! error.
		oParser = new parserFormula('SLOPE(A104:A106,A107:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(A104:A106,A107:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Area. Multi-cell range with text, returns #VALUE! error.');
		// Case #8: Ref3D. 3D ref to text, returns #VALUE! error.
		oParser = new parserFormula('SLOPE(Sheet2!A7:A9,Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(Sheet2!A7:A9,Sheet2!A1:A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D ref to text, returns #VALUE! error.');
		// Case #9: Name. Named range with text, returns #VALUE! error.
		oParser = new parserFormula('SLOPE(TestNameArea2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(TestNameArea2,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with text, returns #VALUE! error.');
		// Case #10: Name3D. 3D named range with text, returns #VALUE! error.
		oParser = new parserFormula('SLOPE(TestNameArea3D2,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(TestNameArea3D2,TestName3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D. 3D named range with text, returns #VALUE! error.');
		// Case #11: Table. Table column with text, returns #VALUE! error.
		oParser = new parserFormula('SLOPE(Table1[Column3],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(Table1[Column3],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text, returns #VALUE! error.');
		// Case #12: Formula. Formula resulting in #NUM!, returns #NUM! error.
		oParser = new parserFormula('SLOPE(SQRT({-1,1,2}),{2,4,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(SQRT({-1,1,2}),{2,4,6}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM!, returns #NUM! error.');
		// Case #13: String. Boolean x-values as strings, returns #VALUE! error.
		oParser = new parserFormula('SLOPE({"1","2","3"},{"TRUE","FALSE","TRUE"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({"1","2","3"},{"TRUE","FALSE","TRUE"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Boolean x-values as strings, returns #VALUE! error.');
		// Case #14: Array. Array with booleans, returns #VALUE! error.
		oParser = new parserFormula('SLOPE({1,2,3},{FALSE,TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1,2,3},{FALSE,TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with booleans, returns #VALUE! error.');
		// Case #15: Area. Area with boolean values, returns #VALUE! error.
		oParser = new parserFormula('SLOPE(A110:A111,A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(A110:A111,A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Area. Area with boolean values, returns #VALUE! error.');
		// Case #16: Reference link. Single cell references, returns #DIV/0! error.
		oParser = new parserFormula('SLOPE(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(A100,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Single cell references, returns #DIV/0! error.');
		// Case #17: Date. Single date values, returns #DIV/0! error.
		oParser = new parserFormula('SLOPE({45650,45660},{45659,55659})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({45650,45660},{45659,55659}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.001, 'Test: Negative case: Date. Single date values, returns #DIV/0! error.');
		// Case #18: Time. Single time values, returns #DIV/0! error.
		oParser = new parserFormula('SLOPE({0.04},{0.08})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({0.04},{0.08}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time. Single time values, returns #DIV/0! error.');
		// Case #19: Formula. Single-element IF result, returns #DIV/0! error.
		oParser = new parserFormula('SLOPE(IF(TRUE,{1},{0}),IF(TRUE,{2},{0}))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE(IF(TRUE,{1},{0}),IF(TRUE,{2},{0})) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Single-element IF result, returns #DIV/0! error.');
		// Case #20: Number. Identical y-values with max number, returns #DIV/0! error.
		oParser = new parserFormula('SLOPE({1E+307,1E+307,1E+307},{2,4,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1E+307,1E+307,1E+307},{2,4,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Identical y-values with max number, returns #DIV/0! error.');

		// Bounded cases:
		// Case #1: Number. Maximum Excel number for y-values, slope is 0.5E308.
		oParser = new parserFormula('SLOPE({1E+307,2E+307,3E+307},{2,4,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1E+307,2E+307,3E+307},{2,4,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.999999999999999e+306, 'Test: Bounded case: Number. Maximum Excel number for y-values, slope is 0.5E308.');
		// Case #2: Number. Minimum Excel number for y-values, slope is -0.5E308.
		oParser = new parserFormula('SLOPE({-1E+307,-2E+307,-3E+307},{2,4,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({-1E+307,-2E+307,-3E+307},{2,4,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4.999999999999999e+306, 'Test: Bounded case: Number. Minimum Excel number for y-values, slope is -0.5E308.');
		// Case #3: Number. Smallest positive x-values, slope is 0.5.
		oParser = new parserFormula('SLOPE({1,2,3},{1E-307,2E-307,3E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1,2,3},{1E-307,2E-307,3E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Smallest positive x-values, slope is 0.5.');
		// Case #4: Number. Smallest positive y-values, slope is 0.5E-307.
		oParser = new parserFormula('SLOPE({1E-307,2E-307,3E-307},{2,4,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1E-307,2E-307,3E-307},{2,4,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.000000000000001e-308, 'Test: Bounded case: Number. Smallest positive y-values, slope is 0.5E-307.');
		// Case #5: Number. Beyond max Excel number for y-values, returns #NUM! error.
		oParser = new parserFormula('SLOPE({1E+306,2E+306,3E+306},{2,4,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1E+306,2E+306,3E+306},{2,4,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.000000000000001e+305, 'Test: Bounded case: Number. Beyond max Excel number for y-values, returns #NUM! error.');
		// Case #6: Number. Below smallest positive x-values, may return #NUM! or imprecise results.
		oParser = new parserFormula('SLOPE({1,2,3},{1E-308,2E-308,3E-308})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLOPE({1,2,3},{1E-308,2E-308,3E-308}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Below smallest positive x-values, may return #NUM! or imprecise results.');

		// Need to fix: error types diff, ms result diff
		// Case #18: Formula. Nested IF returning valid arrays, slope is 0.5.
		// Case #10: Name3D. 3D named range with text, returns #VALUE! error.
		// Case #12: Formula. Formula resulting in #NUM!, returns #NUM! error.
		// Case #16: Reference link. Single cell references, returns #DIV/0! error.
		// Case #19: Formula. Single-element IF result, returns #DIV/0! error.


		testArrayFormula2(assert, "SLOPE", 2, 2, null, true);
	});

	QUnit.test("Test: \"SMALL\"", function (assert) {

		oParser = new parserFormula("SMALL({3,5,3,5,4;4,2,4,6,7},3)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 3);

		oParser = new parserFormula("SMALL({3,5,3,5,4;4,2,4,6,7},7)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 5);

		oParser = new parserFormula("SMALL({1,TRUE,FALSE,3,4,5,32,5,4,3},9)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("SMALL({1,TRUE,FALSE,3,4,5,32,5,4,3},8)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 32);

		oParser = new parserFormula("SMALL({1,TRUE,10,3,4,5,32,5,4,3},10)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("SMALL({1,TRUE,10,3,4,5,32,5,4,3},1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("SMALL(3,1)", "A1", ws);
		assert.ok(oParser.parse(), 'SMALL(3,1)');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Result of SMALL(3,1)');

		oParser = new parserFormula("SMALL(1,1)", "A1", ws);
		assert.ok(oParser.parse(), 'SMALL(1,1)');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Result of SMALL(1,1)');

		oParser = new parserFormula("SMALL(1,2)", "A1", ws);
		assert.ok(oParser.parse(), 'SMALL(1,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Result of SMALL(1,2)');

		oParser = new parserFormula("SMALL(#N/A,1)", "A1", ws);
		assert.ok(oParser.parse(), 'SMALL(#N/A,1)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", 'Result of SMALL(#N/A,1)');

		oParser = new parserFormula('SMALL("1",1)', "A1", ws);
		assert.ok(oParser.parse(), 'SMALL("1",1)');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Result of SMALL("1",1)');

		oParser = new parserFormula('SMALL(-10,1)', "A1", ws);
		assert.ok(oParser.parse(), 'SMALL(-10,1)');
		assert.strictEqual(oParser.calculate().getValue(), -10, 'Result of SMALL(-10,1)');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: array of numbers, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3,4,5},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3,4,5},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number. Basic valid input: array of numbers, k as number. 2 arguments used.');
		// Case #1: String. String convertible to array of numbers, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL("1,2,3",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL("1,2,3",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String. String convertible to array of numbers, k as number. 2 arguments used.');
		// Case #2: Formula, Number. Formula resolving to array of numbers, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL(IF(TRUE,{1,2,3},{4,5,6}),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(IF(TRUE,{1,2,3},{4,5,6}),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula, Number. Formula resolving to array of numbers, k as number. 2 arguments used.');
		// Case #3: Reference link, Number. Reference to cell with number array, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL(A100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(A100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number. Reference to cell with number array, k as number. 2 arguments used.');
		// Case #4: Area, Number. Single-cell range for array, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL(A101:A102,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(A101:A102,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area, Number. Single-cell range for array, k as number. 2 arguments used.');
		// Case #5: Array, Number. Array with multiple numbers, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3,4},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3,4},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array, Number. Array with multiple numbers, k as number. 2 arguments used.');
		// Case #6: Name, Number. Named range with number array, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL(TestName,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(TestName,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name, Number. Named range with number array, k as number. 2 arguments used.');
		// Case #7: Name3D, Number. 3D named range with number array, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL(TestName3D,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(TestName3D,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D, Number. 3D named range with number array, k as number. 2 arguments used.');
		// Case #8: Ref3D, Number. 3D reference to cell with number array, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL(Sheet2!A1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(Sheet2!A1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D, Number. 3D reference to cell with number array, k as number. 2 arguments used.');
		// Case #9: Area3D, Number. 3D single-cell range for array, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL(Sheet2!A2:A3,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(Sheet2!A2:A3,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D, Number. 3D single-cell range for array, k as number. 2 arguments used.');
		// Case #10: Table, Number. Table structured reference with numbers, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL(Table1[Column1],1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(Table1[Column1],1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Number. Table structured reference with numbers, k as number. 2 arguments used.');
		// Case #11: Date, Number. Dates as serial numbers, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL({45666,45796},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({45666,45796},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45666, 'Test: Positive case: Date, Number. Dates as serial numbers, k as number. 2 arguments used.');
		// Case #12: Time, Number. Times as fractional numbers, k as number. 2 arguments used.
		oParser = new parserFormula('SMALL({0.04167,0.08333},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({0.04167,0.08333},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04167, 'Test: Positive case: Time, Number. Times as fractional numbers, k as number. 2 arguments used.');
		// Case #13: Array, String. Array of numbers, k as string convertible to number. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},"2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array, String. Array of numbers, k as string convertible to number. 2 arguments used.');
		// Case #14: Array, Formula. Array of numbers, k as formula resolving to number. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},ROUND(1.6,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},ROUND(1.6,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array, Formula. Array of numbers, k as formula resolving to number. 2 arguments used.');
		// Case #15: Reference link, Reference link. Both arguments as reference links to valid values. 2 arguments used.
		oParser = new parserFormula('SMALL(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link, Reference link. Both arguments as reference links to valid values. 2 arguments used.');
		// Case #16: Area, Area. Array as range, k as single-cell range. 2 arguments used.
		oParser = new parserFormula('SMALL(A102:A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(A102:A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area, Area. Array as range, k as single-cell range. 2 arguments used.');
		// Case #17: Array, Array. Array of numbers, k as single-element array. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},{2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array, Array. Array of numbers, k as single-element array. 2 arguments used.');
		// Case #18: Name, Name. Both arguments as named ranges with valid values. 2 arguments used.
		oParser = new parserFormula('SMALL(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Name. Both arguments as named ranges with valid values. 2 arguments used.');
		// Case #19: Table, Table. Both arguments as table references with valid values. 2 arguments used.
		oParser = new parserFormula('SMALL(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(Table1[Column1],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Table. Both arguments as table references with valid values. 2 arguments used.');
		// Case #20: Formula, Formula. Both arguments as formulas resolving to valid array and number. 2 arguments used.
		oParser = new parserFormula('SMALL(IF(TRUE,{1,2},{3,4}),IF(TRUE,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(IF(TRUE,{1,2},{3,4}),IF(TRUE,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula, Formula. Both arguments as formulas resolving to valid array and number. 2 arguments used.');
		// Case #21: Array, Number. Array with non-numeric value (ignored), k as number. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,"abc",4},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,"abc",4},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array, Number. Array with non-numeric value (ignored), k as number. 2 arguments used.');

		// Negative cases:
		// Case #1: Number. k < 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. k < 1 returns #NUM!. 2 arguments used.');
		// Case #2: Number. k > array length returns #NUM!. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. k > array length returns #NUM!. 2 arguments used.');
		// Case #3: String. Non-numeric string array returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL("abc",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL("abc",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string array returns #VALUE!. 2 arguments used.');
		// Case #4: Error. Error in array propagates #N/A. 2 arguments used.
		oParser = new parserFormula('SMALL(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in array propagates #N/A. 2 arguments used.');
		// Case #5: Empty. Empty cell reference for array returns #NUM!. 2 arguments used.
		oParser = new parserFormula('SMALL(A105,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(A105,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. Empty cell reference for array returns #NUM!. 2 arguments used.');
		// Case #6: Area. Multi-cell range for array with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL(A106:A107,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(A106:A107,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range for array with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #7: Number, Area. Multi-cell range for k returns #NUM!. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area. Multi-cell range for k returns #NUM!. 2 arguments used.');
		// Case #8: Boolean. Boolean array returns #NUM!. 2 arguments used.
		oParser = new parserFormula('SMALL({TRUE,FALSE},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({TRUE,FALSE},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean array returns #NUM!. 2 arguments used.');
		// Case #9: String. Array with non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL({"1","abc","3"},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({"1","abc","3"},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Array with non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #10: Ref3D. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL(Sheet2!A4,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(Sheet2!A4,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.');
		// Case #11: Name. Named range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL(TestNameArea2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(TestNameArea2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.8, 'Test: Negative case: Name. Named range with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #12: Table. Table column with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL(Table1[Column2],1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(Table1[Column2],1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Table. Table column with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #13: Formula. Formula resolving to non-numeric array returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL(IF(TRUE,"abc","def"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(IF(TRUE,"abc","def"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Formula resolving to non-numeric array returns #VALUE!. 2 arguments used.');
		// Case #14: Number. Empty array returns #NUM!. 2 arguments used.
		oParser = new parserFormula('SMALL({""},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({""},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Empty array returns #NUM!. 2 arguments used.');
		// Case #15: Number, Number. Negative k returns #NUM!. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative k returns #NUM!. 2 arguments used.');
		// Case #16: Number, Number. Non-integer k returns #NUM!. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},1.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Number. Non-integer k returns #NUM!. 2 arguments used.');
		// Case #17: Area3D. 3D multi-cell range for array with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL(Sheet2!A5:A6,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(Sheet2!A5:A6,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. 3D multi-cell range for array with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #18: Name3D. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL(TestNameArea3D2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL(TestNameArea3D2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.8, 'Test: Negative case: Name3D. 3D named range with non-numeric data returns #VALUE!. 2 arguments used.');
		// Case #19: Number, String. Non-numeric string for k returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for k returns #VALUE!. 2 arguments used.');
		// Case #20: Array, Array. Multi-element array for k returns #NUM!. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array, Array. Multi-element array for k returns #NUM!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid k (1). 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid k (1). 2 arguments used.');
		// Case #2: Number. k equals array length. 2 arguments used.
		oParser = new parserFormula('SMALL({1,2,3,4,5},5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1,2,3,4,5},5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Bounded case: Number. k equals array length. 2 arguments used.');
		// Case #3: Number. Smallest valid number in array. 2 arguments used.
		oParser = new parserFormula('SMALL({1E-307,2,3},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({1E-307,2,3},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Smallest valid number in array. 2 arguments used.');
		// Case #4: Number. Largest valid number in array. 2 arguments used.
		oParser = new parserFormula('SMALL({9.99999999999999E+307,1,2},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SMALL({9.99999999999999E+307,1,2},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Largest valid number in array. 2 arguments used.');

		// Need to fix: second argument many types handle, diff results from ms
		// Case #17: Array, Array. Array of numbers, k as single-element array. 2 arguments used.
		// Case #19: Table, Table. Both arguments as table references with valid values. 2 arguments used.
		// Case #10: Ref3D. 3D reference to non-numeric cell returns #VALUE!. 2 arguments used.
		// Case #16: Number, Number. Non-integer k returns #NUM!. 2 arguments used.
		// Case #19: Number, String. Non-numeric string for k returns #VALUE!. 2 arguments used.
		// Case #20: Array, Array. Multi-element array for k returns #NUM!. 2 arguments used.

		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "SMALL", 2, 2)
	});

	QUnit.test("Test: \"STANDARDIZE\"", function (assert) {

		function STANDARDIZE(x, mean, sigma) {

			if (sigma <= 0) {
				return "#NUM!"
			} else {
				return toFixed((x - mean) / sigma);
			}
		}

		oParser = new parserFormula("STANDARDIZE(42,40,1.5)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), STANDARDIZE(42, 40, 1.5));

		oParser = new parserFormula("STANDARDIZE(22,12,2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), STANDARDIZE(22, 12, 2));

		oParser = new parserFormula("STANDARDIZE(22,12,-2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), STANDARDIZE(22, 12, -2));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: all arguments are numbers, stdev > 0. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Number. Basic valid input: all arguments are numbers, stdev > 0. Returns 2.5. 3 of 3 arguments used.');
		// Case #2: Number. Valid input: numbers with positive stdev. Returns 1.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(8,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(8,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Number. Valid input: numbers with positive stdev. Returns 1.5. 3 of 3 arguments used.');
		// Case #3: Number. Valid input: x equals mean, returns 0. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(5,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(5,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Valid input: x equals mean, returns 0. 3 of 3 arguments used.');
		// Case #5: String. String inputs convertible to numbers. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE("10","5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE("10","5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: String. String inputs convertible to numbers. Returns 2.5. 3 of 3 arguments used.');
		// Case #6: Formula. All arguments filled with formulas. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(SQRT(100),SQRT(25),SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(SQRT(100),SQRT(25),SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Formula. All arguments filled with formulas. Returns 2.5. 3 of 3 arguments used.');
		// Case #7: Formula. Nested IF formula for x. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(IF(TRUE,10,5),5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(IF(TRUE,10,5),5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Formula. Nested IF formula for x. Returns 2.5. 3 of 3 arguments used.');
		// Case #8: Formula. Mean and stdev filled with statistical formulas. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,AVERAGE(4,6),STDEV(4,6))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,AVERAGE(4,6),STDEV(4,6)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5355339059327373, 'Test: Positive case: Formula. Mean and stdev filled with statistical formulas. Returns 2.5. 3 of 3 arguments used.');
		// Case #9: Reference link. All arguments as cell references. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Reference link. All arguments as cell references. Returns 2.5. 3 of 3 arguments used.');
		// Case #10: Area. All arguments as single-cell ranges. Returns 1.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. All arguments as single-cell ranges. Returns 1.5. 3 of 3 arguments used.');
		// Case #11: Array. All arguments as single-element arrays. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE({10},{5},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE({10},{5},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array. All arguments as single-element arrays. Returns 2.5. 3 of 3 arguments used.');
		// Case #12: Name. All arguments as named ranges. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.09523809523809523, 'Test: Positive case: Name. All arguments as named ranges. Returns 2.5. 3 of 3 arguments used.');
		// Case #13: Name3D. All arguments as 3D named ranges. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(TestName3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. All arguments as 3D named ranges. Returns 2.5. 3 of 3 arguments used.');
		// Case #14: Ref3D. All arguments as 3D cell references. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. All arguments as 3D cell references. Returns 2.5. 3 of 3 arguments used.');
		// Case #15: Area3D. All arguments as 3D single-cell ranges. Returns 1.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. All arguments as 3D single-cell ranges. Returns 1.5. 3 of 3 arguments used.');
		// Case #16: Table. All arguments as table structured references. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. All arguments as table structured references. Returns 2.5. 3 of 3 arguments used.');
		// Case #17: Date. Date as serial number for x and mean. Returns 2.5. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(DATE(2025,1,1),DATE(2025,1,1)-5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(DATE(2025,1,1),DATE(2025,1,1)-5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Date. Date as serial number for x and mean. Returns 2.5. 3 of 3 arguments used.');
		// Case #18: Time. Time adjusted to valid number for x and mean. Returns 2. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(TIME(12,0,0)+1,TIME(12,0,0),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(TIME(12,0,0)+1,TIME(12,0,0),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Time. Time adjusted to valid number for x and mean. Returns 2. 3 of 3 arguments used.');
		// Case #19: Formula. STANDARDIZE inside SUM formula. Returns 3.5. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(STANDARDIZE(10,5,2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(STANDARDIZE(10,5,2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.5, 'Test: Positive case: Formula. STANDARDIZE inside SUM formula. Returns 3.5. 3 of 3 arguments used.');
		// Case #20: String. Short date strings convertible to numbers. Returns 1. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE("12/12","10/10","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE("12/12","10/10","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31.5, 'Test: Positive case: String. Short date strings convertible to numbers. Returns 1. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Stdev is 0, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Stdev is 0, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #2: Number. Stdev is negative, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,5,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,5,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Stdev is negative, returns #NUM!. 3 of 3 arguments used.');
		// Case #3: String. Non-numeric x, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE("abc",5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE("abc",5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric x, returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: String. Non-numeric mean, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,"abc",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,"abc",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric mean, returns #VALUE!. 3 of 3 arguments used.');
		// Case #5: String. Non-numeric stdev, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,5,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,5,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric stdev, returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(NA(),5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(NA(),5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #7: Empty. x is empty cell, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(A106,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(A106,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.5, 'Test: Negative case: Empty. x is empty cell, returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Empty. Mean is empty cell, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,A107,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,A107,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Empty. Mean is empty cell, returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Empty. Stdev is empty cell, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,5,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,5,A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Stdev is empty cell, returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Boolean. Boolean x, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(TRUE,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(TRUE,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Negative case: Boolean. Boolean x, returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Boolean. Boolean mean, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,TRUE,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,TRUE,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.5, 'Test: Negative case: Boolean. Boolean mean, returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Boolean. Boolean stdev, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Boolean. Boolean stdev, returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Area. Multi-cell range for x, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(A109:A110,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(A109:A110,5,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2.5, 'Test: Negative case: Area. Multi-cell range for x, returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Area. Multi-cell range for mean, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,A109:A110,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,A109:A110,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Area. Multi-cell range for mean, returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Area. Multi-cell range for stdev, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(10,5,A109:A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(10,5,A109:A110) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range for stdev, returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Array. Multi-element array for x, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE({10,8},5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE({10,8},5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Negative case: Array. Multi-element array for x, returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Ref3D. 3D ref to text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(Sheet2!A7,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(Sheet2!A7,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.5, 'Test: Negative case: Ref3D. 3D ref to text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #18: Name. Named range with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(TestNameArea2,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(TestNameArea2,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.1, 'Test: Negative case: Name. Named range with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Name3D. 3D named range with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(TestNameArea3D2,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(TestNameArea3D2,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.1, 'Test: Negative case: Name3D. 3D named range with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Table. Table column with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(Table1[Column2],5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(Table1[Column2],5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text, returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid stdev and x, returns 1. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(1E-307,0,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(1E-307,0,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid stdev and x, returns 1. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid x with stdev=1, returns 1E+307. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(1E+307,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(1E+307,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Number. Maximum valid x with stdev=1, returns 1E+307. 3 of 3 arguments used.');
		// Case #3: Number. Maximum valid mean with stdev=1, returns -1E+307. 3 of 3 arguments used.
		oParser = new parserFormula('STANDARDIZE(0,1E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STANDARDIZE(0,1E+307,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+307, 'Test: Bounded case: Number. Maximum valid mean with stdev=1, returns -1E+307. 3 of 3 arguments used.');

		// Need to fix: area handle, error types diff
		// Case #13: Area. Multi-cell range for x, returns #VALUE!. 3 of 3 arguments used.
		// Case #14: Area. Multi-cell range for mean, returns #VALUE!. 3 of 3 arguments used.
		// Case #15: Area. Multi-cell range for stdev, returns #VALUE!. 3 of 3 arguments used.


		testArrayFormula2(assert, "STANDARDIZE", 3, 3);
	});

	QUnit.test("Test: \"STDEV\"", function (assert) {

		function stdev() {
			var average = 0, res = 0;
			for (var i = 0; i < arguments.length; i++) {
				average += arguments[i];
			}
			average /= arguments.length;
			for (var i = 0; i < arguments.length; i++) {
				res += (arguments[i] - average) * (arguments[i] - average);
			}
			return toFixed(Math.sqrt(res / (arguments.length - 1)));
		}

		oParser = new parserFormula("STDEV(123,134,143,173,112,109)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), stdev(123, 134, 143, 173, 112, 109));

		ws.getRange2("E400").setValue("\"123\"");
		ws.getRange2("E401").setValue("134");
		ws.getRange2("E402").setValue("143");
		ws.getRange2("E403").setValue("173");
		ws.getRange2("E404").setValue("112");
		ws.getRange2("E405").setValue("109");

		oParser = new parserFormula("STDEV(E400:E405)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), stdev(134, 143, 173, 112, 109));

	});

	QUnit.test("Test: \"STDEV.S\"", function (assert) {
		ws.getRange2("A202").setValue("1345");
		ws.getRange2("A203").setValue("1301");
		ws.getRange2("A204").setValue("1368");
		ws.getRange2("A205").setValue("1322");
		ws.getRange2("A206").setValue("1310");
		ws.getRange2("A207").setValue("1370");
		ws.getRange2("A208").setValue("1318");
		ws.getRange2("A209").setValue("1350");
		ws.getRange2("A210").setValue("1303");
		ws.getRange2("A211").setValue("1299");

		oParser = new parserFormula("STDEV.S(A202:A211)", "A1", ws);
		assert.ok(oParser.parse(), "STDEV.S(A202:A211)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 27.46391572, "STDEV.S(A202:A211)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integers. 3 arguments used.
		oParser = new parserFormula('STDEV.S(10,20,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(10,20,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number. Basic valid input: integers. 3 arguments used.');
		// Case #1: Number. Basic valid input: floats. 2 arguments used.
		oParser = new parserFormula('STDEV.S(1.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(1.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Number. Basic valid input: floats. 2 arguments used.');
		// Case #2: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.S("10","20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S("10","20") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #3: Formula. Nested formula returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.S(SQRT(16),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(SQRT(16),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Formula. Nested formula returning valid numbers. 2 arguments used.');
		// Case #4: Reference link. Reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.S(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Reference link. Reference to cells with valid numbers. 2 arguments used.');
		// Case #5: Area. Single-cell range expanded to two cells. 1 argument used.
		oParser = new parserFormula('STDEV.S(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Area. Single-cell range expanded to two cells. 1 argument used.');
		// Case #6: Array. Array with two valid elements. 1 argument used.
		oParser = new parserFormula('STDEV.S({10,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S({10,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Positive case: Array. Array with two valid elements. 1 argument used.');
		// Case #7: Name. Named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.S(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Name. Named range with valid numbers. 2 arguments used.');
		// Case #8: Name3D. 3D named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.S(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named range with valid numbers. 2 arguments used.');
		// Case #9: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.S(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.');
		// Case #10: Area3D. 3D range with two cells. 1 argument used.
		oParser = new parserFormula('STDEV.S(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Area3D. 3D range with two cells. 1 argument used.');
		// Case #11: Table. Table structured reference with valid numbers. 1 argument used.
		oParser = new parserFormula('STDEV.S(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured reference with valid numbers. 1 argument used.');
		// Case #12: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.S(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21.920310216782973, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #13: Time. Time values as fractions. 2 arguments used.
		oParser = new parserFormula('STDEV.S(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.029462782549439452, 'Test: Positive case: Time. Time values as fractions. 2 arguments used.');
		// Case #14: Formula. Multiple nested formulas. 2 arguments used.
		oParser = new parserFormula('STDEV.S(SUM(1,1),PRODUCT(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(SUM(1,1),PRODUCT(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4142135623730951, 'Test: Positive case: Formula. Multiple nested formulas. 2 arguments used.');
		// Case #15: Formula. STDEV inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(STDEV.S(10,20),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(STDEV.S(10,20),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.071067811865476, 'Test: Positive case: Formula. STDEV inside SUM formula. 2 arguments used.');
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		oParser = new parserFormula('STDEV.S(100,100.0000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(100,100.0000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Very close numbers for small standard deviation. 2 arguments used.');
		// Case #17: String. Numeric strings with decimal points. 2 arguments used.
		oParser = new parserFormula('STDEV.S("1.5","2.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S("1.5","2.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: String. Numeric strings with decimal points. 2 arguments used.');
		// Case #18: Array. Array with three valid elements. 1 argument used.
		oParser = new parserFormula('STDEV.S({10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S({10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Array. Array with three valid elements. 1 argument used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.S(IF(TRUE,10,5),IF(FALSE,5,20))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(IF(TRUE,10,5),IF(FALSE,5,20)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 2 arguments used.');
		// Case #20: Number. Small integers including zero. 3 arguments used.
		oParser = new parserFormula('STDEV.S(0,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(0,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Small integers including zero. 3 arguments used.');
		// Case #21: Area3D. 3D range with three cells. 1 argument used.
		oParser = new parserFormula('STDEV.S(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Area3D. 3D range with three cells. 1 argument used.');
		// Case #22: Reference link. Reference to three cells with valid numbers. 3 arguments used.
		oParser = new parserFormula('STDEV.S(A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0606601717798212, 'Test: Positive case: Reference link. Reference to three cells with valid numbers. 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Single number returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.S(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Single number returns #DIV/0!. 1 argument used.');
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV.S("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('STDEV.S(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(NA(),10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Single-cell range returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.S(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area. Single-cell range returns #DIV/0!. 1 argument used.');
		// Case #4: Empty. Empty cell reference returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.S(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Empty cell reference returns #DIV/0!. 1 argument used.');
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.S("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean values return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV.S(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Negative case: Boolean. Boolean values return #VALUE!. 2 arguments used.');
		// Case #7: Ref3D. 3D reference to text cells returns #VALUE!.
		oParser = new parserFormula('STDEV.S(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(Sheet2!A3,Sheet2!A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to text cells returns #VALUE!.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.S(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1313708498984762, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.S(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #10: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEV.S(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(SQRT(-1),10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.');
		// Case #11: Number. All identical numbers return 0, but valid. 3 arguments used.
		oParser = new parserFormula('STDEV.S(0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. All identical numbers return 0, but valid. 3 arguments used.');
		// Case #12: Array. Array with booleans returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.S({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S({TRUE,FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with booleans returns #VALUE!. 1 argument used.');
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		oParser = new parserFormula('STDEV.S(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.');
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV.S("1/1/2025","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S("1/1/2025","abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #15: Area3D. 3D range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.S(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(Sheet2!A3:A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with text returns #VALUE!. 1 argument used.');
		// Case #16: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEV.S(MMULT(1,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(MMULT(1,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.');
		// Case #17: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV.S(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(A106,A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.');
		// Case #18: Array. Single-element array returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.S({10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S({10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Single-element array returns #DIV/0!. 1 argument used.');
		// Case #19: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.S(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1313708498984762, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #20: Time. Single time value returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.S(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time. Single time value returns #DIV/0!. 1 argument used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.
		oParser = new parserFormula('STDEV.S(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.');
		// Case #1: Number. Smallest positive numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEV.S(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive numbers, returns 0. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEV.S(9.99999999999999E307,9.99999999999999E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(9.99999999999999E307,9.99999999999999E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.');
		// Case #3: Number. Smallest distinguishable difference near precision limit. 2 arguments used.
		oParser = new parserFormula('STDEV.S(1E-307,1.00000000000001E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.S(1E-307,1.00000000000001E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest distinguishable difference near precision limit. 2 arguments used.');

		// Need to fix: bool, string, array, error handle, errors type diff, diff results from ms
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		// Case #7: Ref3D. 3D reference to text cells returns #VALUE!.
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		// Case #10: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		// Case #12: Array. Array with booleans returns #VALUE!. 1 argument used.
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
		// Case #15: Area3D. 3D range with text returns #VALUE!. 1 argument used.
		// Case #17: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.


	});

	QUnit.test("Test: \"STDEV.P\"", function (assert) {
		ws.getRange2("A202").setValue("1345");
		ws.getRange2("A203").setValue("1301");
		ws.getRange2("A204").setValue("1368");
		ws.getRange2("A205").setValue("1322");
		ws.getRange2("A206").setValue("1310");
		ws.getRange2("A207").setValue("1370");
		ws.getRange2("A208").setValue("1318");
		ws.getRange2("A209").setValue("1350");
		ws.getRange2("A210").setValue("1303");
		ws.getRange2("A211").setValue("1299");

		oParser = new parserFormula("STDEV.P(A202:A211)", "A1", ws);
		assert.ok(oParser.parse(), "STDEV.P(A202:A211)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 26.05455814, "STDEV.P(A202:A211)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integers. 3 arguments used.
		oParser = new parserFormula('STDEV.P(10,20,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(10,20,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.16496580927726, 'Test: Positive case: Number. Basic valid input: integers. 3 arguments used.');
		// Case #1: Number. Basic valid input: floats. 2 arguments used.
		oParser = new parserFormula('STDEV.P(1.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(1.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Basic valid input: floats. 2 arguments used.');
		// Case #2: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.P("10","20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P("10","20") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #3: Formula. Nested formula returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.P(SQRT(16),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(SQRT(16),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested formula returning valid numbers. 2 arguments used.');
		// Case #4: Reference link. Reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.P(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. Reference to cells with valid numbers. 2 arguments used.');
		// Case #5: Area. Single-cell range expanded to two cells. 1 argument used.
		oParser = new parserFormula('STDEV.P(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Single-cell range expanded to two cells. 1 argument used.');
		// Case #6: Array. Array with two valid elements. 1 argument used.
		oParser = new parserFormula('STDEV.P({10,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P({10,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Array with two valid elements. 1 argument used.');
		// Case #7: Name. Named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.P(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Named range with valid numbers. 2 arguments used.');
		// Case #8: Name3D. 3D named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.P(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named range with valid numbers. 2 arguments used.');
		// Case #9: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.P(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.');
		// Case #10: Area3D. 3D range with two cells. 1 argument used.
		oParser = new parserFormula('STDEV.P(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. 3D range with two cells. 1 argument used.');
		// Case #11: Table. Table structured reference with valid numbers. 1 argument used.
		oParser = new parserFormula('STDEV.P(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference with valid numbers. 1 argument used.');
		// Case #12: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.P(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15.5, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #13: Time. Time values as fractions. 2 arguments used.
		oParser = new parserFormula('STDEV.P(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.020833333333333315, 'Test: Positive case: Time. Time values as fractions. 2 arguments used.');
		// Case #14: Formula. Multiple nested formulas. 2 arguments used.
		oParser = new parserFormula('STDEV.P(SUM(1,1),PRODUCT(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(SUM(1,1),PRODUCT(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Multiple nested formulas. 2 arguments used.');
		// Case #15: Formula. STDEV inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(STDEV.P(10,20),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(STDEV.P(10,20),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. STDEV inside SUM formula. 2 arguments used.');
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		oParser = new parserFormula('STDEV.P(100,100.0000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(100,100.0000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Very close numbers for small standard deviation. 2 arguments used.');
		// Case #17: String. Numeric strings with decimal points. 2 arguments used.
		oParser = new parserFormula('STDEV.P("1.5","2.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P("1.5","2.5") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Numeric strings with decimal points. 2 arguments used.');
		// Case #18: Array. Array with three valid elements. 1 argument used.
		oParser = new parserFormula('STDEV.P({10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P({10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.16496580927726, 'Test: Positive case: Array. Array with three valid elements. 1 argument used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV.P(IF(TRUE,10,5),IF(FALSE,5,20))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(IF(TRUE,10,5),IF(FALSE,5,20)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 2 arguments used.');
		// Case #20: Number. Small integers including zero. 3 arguments used.
		oParser = new parserFormula('STDEV.P(0,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(0,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.816496580927726, 'Test: Positive case: Number. Small integers including zero. 3 arguments used.');
		// Case #21: Area3D. 3D range with three cells. 1 argument used.
		oParser = new parserFormula('STDEV.P(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. 3D range with three cells. 1 argument used.');
		// Case #22: Reference link. Reference to three cells with valid numbers. 3 arguments used.
		oParser = new parserFormula('STDEV.P(A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Reference link. Reference to three cells with valid numbers. 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Single number returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.P(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Single number returns #DIV/0!. 1 argument used.');
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV.P("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('STDEV.P(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Single-cell range returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.P(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Single-cell range returns #DIV/0!. 1 argument used.');
		// Case #4: Empty. Empty cell reference returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.P(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty cell reference returns #DIV/0!. 1 argument used.');
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.P("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean values return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV.P(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Boolean. Boolean values return #VALUE!. 2 arguments used.');
		// Case #7: Ref3D. 3D reference to text cells returns #VALUE!.
		oParser = new parserFormula('STDEV.P(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to text cells returns #VALUE!.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.P(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.P(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #10: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEV.P(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.');
		// Case #11: Number. All identical numbers return 0, but valid. 3 arguments used.
		oParser = new parserFormula('STDEV.P(0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. All identical numbers return 0, but valid. 3 arguments used.');
		// Case #12: Array. Array with booleans returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.P({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P({TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with booleans returns #VALUE!. 1 argument used.');
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		oParser = new parserFormula('STDEV.P(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.');
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV.P("1/1/2025","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P("1/1/2025","abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #15: Area3D. 3D range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.P(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with text returns #VALUE!. 1 argument used.');
		// Case #16: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEV.P(MMULT(1,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(MMULT(1,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.');
		// Case #17: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV.P(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.');
		// Case #18: Array. Single-element array returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.P({10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P({10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Single-element array returns #DIV/0!. 1 argument used.');
		// Case #19: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV.P(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #20: Time. Single time value returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV.P(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Time. Single time value returns #DIV/0!. 1 argument used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.
		oParser = new parserFormula('STDEV.P(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.');
		// Case #1: Number. Smallest positive numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEV.P(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive numbers, returns 0. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEV.P(9.99999999999999E307,9.99999999999999E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(9.99999999999999E307,9.99999999999999E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.');
		// Case #3: Number. Smallest distinguishable difference near precision limit. 2 arguments used.
		oParser = new parserFormula('STDEV.P(1E-307,1.00000000000001E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV.P(1E-307,1.00000000000001E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest distinguishable difference near precision limit. 2 arguments used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.
		oParser = new parserFormula('STDEVP(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.');
		// Case #1: Number. Smallest positive numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEVP(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive numbers, returns 0. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEVP(9.99999999999999E307,9.99999999999999E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(9.99999999999999E307,9.99999999999999E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.');
		// Case #3: Number. Smallest distinguishable difference near precision limit. 2 arguments used.
		oParser = new parserFormula('STDEVP(1E-307,1.00000000000001E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(1E-307,1.00000000000001E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest distinguishable difference near precision limit. 2 arguments used.');

		// Need to fix: area handle, different results from MS, string handle, error types diff
		// Case #2: String. Strings convertible to numbers. 2 arguments used.
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		// Case #17: String. Numeric strings with decimal points. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
	});

	QUnit.test("Test: \"STDEVA\"", function (assert) {

		ws.getRange2("E400").setValue("\"123\"");
		ws.getRange2("E401").setValue("134");
		ws.getRange2("E402").setValue("143");
		ws.getRange2("E403").setValue("173");
		ws.getRange2("E404").setValue("112");
		ws.getRange2("E405").setValue("109");


		function stdeva() {
			var average = 0, res = 0;
			for (var i = 0; i < arguments.length; i++) {
				average += arguments[i];
			}
			average /= arguments.length;
			for (var i = 0; i < arguments.length; i++) {
				res += (arguments[i] - average) * (arguments[i] - average);
			}
			return toFixed(Math.sqrt(res / (arguments.length - 1)));
		}

		oParser = new parserFormula("STDEVA(123,134,143,173,112,109)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), stdeva(123, 134, 143, 173, 112, 109));

		oParser = new parserFormula("STDEVA(123,134,143,173,112,109)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), stdeva(123, 134, 143, 173, 112, 109));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integers. 3 arguments used.
		oParser = new parserFormula('STDEVA(10,20,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(10,20,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number. Basic valid input: integers. 3 arguments used.');
		// Case #1: Number. Basic valid input: floats. 2 arguments used.
		oParser = new parserFormula('STDEVA(1.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(1.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Number. Basic valid input: floats. 2 arguments used.');
		// Case #2: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('STDEVA("10","20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA("10","20") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #3: Formula. Nested formula returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVA(SQRT(16),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(SQRT(16),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Formula. Nested formula returning valid numbers. 2 arguments used.');
		// Case #4: Reference link. Reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVA(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Reference link. Reference to cells with valid numbers. 2 arguments used.');
		// Case #5: Area. Single-cell range expanded to two cells. 1 argument used.
		oParser = new parserFormula('STDEVA(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Area. Single-cell range expanded to two cells. 1 argument used.');
		// Case #6: Array. Array with two valid elements. 1 argument used.
		oParser = new parserFormula('STDEVA({10,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA({10,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Positive case: Array. Array with two valid elements. 1 argument used.');
		// Case #7: Name. Named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVA(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Name. Named range with valid numbers. 2 arguments used.');
		// Case #8: Name3D. 3D named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVA(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named range with valid numbers. 2 arguments used.');
		// Case #9: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVA(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.');
		// Case #10: Area3D. 3D range with two cells. 1 argument used.
		oParser = new parserFormula('STDEVA(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Area3D. 3D range with two cells. 1 argument used.');
		// Case #11: Table. Table structured reference with valid numbers. 1 argument used.
		oParser = new parserFormula('STDEVA(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured reference with valid numbers. 1 argument used.');
		// Case #12: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('STDEVA(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21.920310216782973, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #13: Time. Time values as fractions. 2 arguments used.
		oParser = new parserFormula('STDEVA(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.029462782549439452, 'Test: Positive case: Time. Time values as fractions. 2 arguments used.');
		// Case #14: Formula. Multiple nested formulas. 2 arguments used.
		oParser = new parserFormula('STDEVA(SUM(1,1),PRODUCT(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(SUM(1,1),PRODUCT(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4142135623730951, 'Test: Positive case: Formula. Multiple nested formulas. 2 arguments used.');
		// Case #15: Formula. STDEV inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(STDEVA(10,20),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(STDEVA(10,20),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.071067811865476, 'Test: Positive case: Formula. STDEV inside SUM formula. 2 arguments used.');
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		oParser = new parserFormula('STDEVA(100,100.0000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(100,100.0000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Very close numbers for small standard deviation. 2 arguments used.');
		// Case #17: String. Numeric strings with decimal points. 2 arguments used.
		oParser = new parserFormula('STDEVA("1.5","2.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA("1.5","2.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: String. Numeric strings with decimal points. 2 arguments used.');
		// Case #18: Array. Array with three valid elements. 1 argument used.
		oParser = new parserFormula('STDEVA({10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA({10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Array. Array with three valid elements. 1 argument used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVA(IF(TRUE,10,5),IF(FALSE,5,20))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(IF(TRUE,10,5),IF(FALSE,5,20)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 2 arguments used.');
		// Case #20: Number. Small integers including zero. 3 arguments used.
		oParser = new parserFormula('STDEVA(0,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(0,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Small integers including zero. 3 arguments used.');
		// Case #21: Area3D. 3D range with three cells. 1 argument used.
		oParser = new parserFormula('STDEVA(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(Sheet2!A1:A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D range with three cells. 1 argument used.');
		// Case #22: Reference link. Reference to three cells with valid numbers. 3 arguments used.
		oParser = new parserFormula('STDEVA(A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(A102,A103,A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.060660172, 'Test: Positive case: Reference link. Reference to three cells with valid numbers. 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Single number returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVA(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Single number returns #DIV/0!. 1 argument used.');
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVA("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('STDEVA(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(NA(),10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Single-cell range returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVA(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(A100:A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area. Single-cell range returns #DIV/0!. 1 argument used.');
		// Case #4: Empty. Empty cell reference returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVA(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Empty cell reference returns #DIV/0!. 1 argument used.');
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVA("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean values return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVA(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Negative case: Boolean. Boolean values return #VALUE!. 2 arguments used.');
		// Case #7: Ref3D. 3D reference to text cells returns #VALUE!.
		oParser = new parserFormula('STDEVA(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(Sheet2!A3,Sheet2!A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to text cells returns #VALUE!.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVA(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1313708498984762, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVA(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #10: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEVA(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.');
		// Case #11: Number. All identical numbers return 0, but valid. 3 arguments used.
		oParser = new parserFormula('STDEVA(0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. All identical numbers return 0, but valid. 3 arguments used.');
		// Case #12: Array. Array with booleans returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVA({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA({TRUE,FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with booleans returns #VALUE!. 1 argument used.');
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		oParser = new parserFormula('STDEVA(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.');
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVA("1/1/2025","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA("1/1/2025","abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #15: Area3D. 3D range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVA(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(Sheet2!A3:A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with text returns #VALUE!. 1 argument used.');
		// Case #16: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEVA(MMULT(1,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(MMULT(1,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.');
		// Case #17: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVA(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(A106,A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.');
		// Case #18: Array. Single-element array returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVA({10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA({10}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Single-element array returns #DIV/0!. 1 argument used.');
		// Case #19: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVA(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1313708498984762, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #20: Time. Single time value returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVA(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(TIME(0,0,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time. Single time value returns #DIV/0!. 1 argument used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.
		oParser = new parserFormula('STDEVA(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.');
		// Case #1: Number. Smallest positive numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEVA(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive numbers, returns 0. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEVA(9.99999999999999E307,9.99999999999999E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(9.99999999999999E307,9.99999999999999E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.');
		// Case #3: Number. Smallest distinguishable difference near precision limit. 2 arguments used.
		oParser = new parserFormula('STDEVA(1E-307,1.00000000000001E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVA(1E-307,1.00000000000001E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest distinguishable difference near precision limit. 2 arguments used.');

		// TODO many problems with argument types handle
		// Need to fix: many types handle(array, string, area), diff error types, diff results from ms

		testArrayFormula2(assert, "STDEVA", 1, 8, null, true);
	});

	QUnit.test("Test: \"STDEVPA\"", function (assert) {

		ws.getRange2("A103").setValue("1345");

		ws.getRange2("A104").setValue("1301");

		ws.getRange2("A105").setValue("1368");
		ws.getRange2("A106").setValue("1322");
		ws.getRange2("A107").setValue("1310");
		ws.getRange2("A108").setValue("1370");
		ws.getRange2("A109").setValue("1318");
		ws.getRange2("A110").setValue("1350");

		ws.getRange2("A111").setValue("1303");
		ws.getRange2("A112").setValue("1299");

		oParser = new parserFormula('STDEVPA(A103:A112)', "AA2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 26.05456);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:F10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integers. 3 arguments used.
		oParser = new parserFormula('STDEVPA(10,20,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(10,20,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.16496580927726, 'Test: Positive case: Number. Basic valid input: integers. 3 arguments used.');
		// Case #1: Number. Basic valid input: floats. 2 arguments used.
		oParser = new parserFormula('STDEVPA(1.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(1.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Basic valid input: floats. 2 arguments used.');
		// Case #2: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('STDEVPA("10","20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA("10","20") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #3: Formula. Nested formula returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVPA(SQRT(16),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(SQRT(16),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested formula returning valid numbers. 2 arguments used.');
		// Case #4: Reference link. Reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVPA(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. Reference to cells with valid numbers. 2 arguments used.');
		// Case #5: Area. Single-cell range expanded to two cells. 1 argument used.
		oParser = new parserFormula('STDEVPA(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Single-cell range expanded to two cells. 1 argument used.');
		// Case #6: Array. Array with two valid elements. 1 argument used.
		oParser = new parserFormula('STDEVPA({10,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA({10,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Array with two valid elements. 1 argument used.');
		// Case #7: Name. Named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVPA(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Named range with valid numbers. 2 arguments used.');
		// Case #8: Name3D. 3D named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVPA(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named range with valid numbers. 2 arguments used.');
		// Case #9: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVPA(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.');
		// Case #10: Area3D. 3D range with two cells. 1 argument used.
		oParser = new parserFormula('STDEVPA(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. 3D range with two cells. 1 argument used.');
		// Case #11: Table. Table structured reference with valid numbers. 1 argument used.
		oParser = new parserFormula('STDEVPA(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference with valid numbers. 1 argument used.');
		// Case #12: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('STDEVPA(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15.5, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #13: Time. Time values as fractions. 2 arguments used.
		oParser = new parserFormula('STDEVPA(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.020833333333333315, 'Test: Positive case: Time. Time values as fractions. 2 arguments used.');
		// Case #14: Formula. Multiple nested formulas. 2 arguments used.
		oParser = new parserFormula('STDEVPA(SUM(1,1),PRODUCT(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(SUM(1,1),PRODUCT(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Multiple nested formulas. 2 arguments used.');
		// Case #15: Formula. STDEV inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(STDEVPA(10,20),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(STDEVPA(10,20),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. STDEV inside SUM formula. 2 arguments used.');
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		oParser = new parserFormula('STDEVPA(100,100.0000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(100,100.0000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Very close numbers for small standard deviation. 2 arguments used.');
		// Case #17: String. Numeric strings with decimal points. 2 arguments used.
		oParser = new parserFormula('STDEVPA("1.5","2.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA("1.5","2.5") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Numeric strings with decimal points. 2 arguments used.');
		// Case #18: Array. Array with three valid elements. 1 argument used.
		oParser = new parserFormula('STDEVPA({10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA({10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.16496580927726, 'Test: Positive case: Array. Array with three valid elements. 1 argument used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVPA(IF(TRUE,10,5),IF(FALSE,5,20))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(IF(TRUE,10,5),IF(FALSE,5,20)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 2 arguments used.');
		// Case #20: Number. Small integers including zero. 3 arguments used.
		oParser = new parserFormula('STDEVPA(0,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(0,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.816496580927726, 'Test: Positive case: Number. Small integers including zero. 3 arguments used.');
		// Case #21: Area3D. 3D range with three cells. 1 argument used.
		oParser = new parserFormula('STDEVPA(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.816496580927726, 'Test: Positive case: Area3D. 3D range with three cells. 1 argument used.');
		// Case #22: Reference link. Reference to three cells with valid numbers. 3 arguments used.
		oParser = new parserFormula('STDEVPA(A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Reference link. Reference to three cells with valid numbers. 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Single number returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVPA(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Single number returns #DIV/0!. 1 argument used.');
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVPA("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('STDEVPA(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(NA(),10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Single-cell range returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVPA(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Single-cell range returns #DIV/0!. 1 argument used.');
		// Case #4: Empty. Empty cell reference returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVPA(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty cell reference returns #DIV/0!. 1 argument used.');
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVPA("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean values return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVPA(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Boolean. Boolean values return #VALUE!. 2 arguments used.');
		// Case #7: Ref3D. 3D reference to text cells returns #VALUE!.
		oParser = new parserFormula('STDEVPA(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to text cells returns #VALUE!.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVPA(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVPA(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #10: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEVPA(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(SQRT(-1),10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.');
		// Case #11: Number. All identical numbers return 0, but valid. 3 arguments used.
		oParser = new parserFormula('STDEVPA(0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. All identical numbers return 0, but valid. 3 arguments used.');
		// Case #12: Array. Array with booleans returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVPA({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA({TRUE,FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with booleans returns #VALUE!. 1 argument used.');
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		oParser = new parserFormula('STDEVPA(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.');
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVPA("1/1/2025","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA("1/1/2025","abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #15: Area3D. 3D range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVPA(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. 3D range with text returns #VALUE!. 1 argument used.');
		// Case #16: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEVPA(MMULT(1,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(MMULT(1,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.');
		// Case #17: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVPA(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(A106,A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.');
		// Case #18: Array. Single-element array returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVPA({10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA({10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Single-element array returns #DIV/0!. 1 argument used.');
		// Case #19: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVPA(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #20: Time. Single time value returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVPA(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Time. Single time value returns #DIV/0!. 1 argument used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.
		oParser = new parserFormula('STDEVPA(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.');
		// Case #1: Number. Smallest positive numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEVPA(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive numbers, returns 0. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEVPA(9.99999999999999E307,9.99999999999999E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(9.99999999999999E307,9.99999999999999E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.');
		// Case #3: Number. Smallest distinguishable difference near precision limit. 2 arguments used.
		oParser = new parserFormula('STDEVPA(1E-307,1.00000000000001E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVPA(1E-307,1.00000000000001E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest distinguishable difference near precision limit. 2 arguments used.');

		// Need to fix: string,boolean,area,error handle, ms result diff
		// Case #2: String. Strings convertible to numbers. 2 arguments used.
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		// Case #17: String. Numeric strings with decimal points. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		// Case #10: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		// Case #12: Array. Array with booleans returns #VALUE!. 1 argument used.
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
		// Case #17: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.

		testArrayFormula2(assert, "STDEVPA", 1, 8, null, true);
	});

	QUnit.test("Test: \"STDEVP\"", function (assert) {

		ws.getRange2("A103").setValue("1345");

		ws.getRange2("A104").setValue("1301");

		ws.getRange2("A105").setValue("1368");
		ws.getRange2("A106").setValue("1322");
		ws.getRange2("A107").setValue("1310");
		ws.getRange2("A108").setValue("1370");
		ws.getRange2("A109").setValue("1318");
		ws.getRange2("A110").setValue("1350");

		ws.getRange2("A111").setValue("1303");
		ws.getRange2("A112").setValue("1299");

		oParser = new parserFormula('STDEVP(A103:A112)', "AA2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 26.05456);


		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:F10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integers. 3 arguments used.
		oParser = new parserFormula('STDEVP(10,20,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(10,20,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.16496580927726, 'Test: Positive case: Number. Basic valid input: integers. 3 arguments used.');
		// Case #1: Number. Basic valid input: floats. 2 arguments used.
		oParser = new parserFormula('STDEVP(1.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(1.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Basic valid input: floats. 2 arguments used.');
		// Case #2: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('STDEVP("10","20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP("10","20") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #3: Formula. Nested formula returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVP(SQRT(16),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(SQRT(16),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested formula returning valid numbers. 2 arguments used.');
		// Case #4: Reference link. Reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVP(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. Reference to cells with valid numbers. 2 arguments used.');
		// Case #5: Area. Single-cell range expanded to two cells. 1 argument used.
		oParser = new parserFormula('STDEVP(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Single-cell range expanded to two cells. 1 argument used.');
		// Case #6: Array. Array with two valid elements. 1 argument used.
		oParser = new parserFormula('STDEVP({10,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP({10,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Array with two valid elements. 1 argument used.');
		// Case #7: Name. Named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVP(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Named range with valid numbers. 2 arguments used.');
		// Case #8: Name3D. 3D named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVP(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named range with valid numbers. 2 arguments used.');
		// Case #9: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVP(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.');
		// Case #10: Area3D. 3D range with two cells. 1 argument used.
		oParser = new parserFormula('STDEVP(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. 3D range with two cells. 1 argument used.');
		// Case #11: Table. Table structured reference with valid numbers. 1 argument used.
		oParser = new parserFormula('STDEVP(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference with valid numbers. 1 argument used.');
		// Case #12: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('STDEVP(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15.5, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #13: Time. Time values as fractions. 2 arguments used.
		oParser = new parserFormula('STDEVP(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.020833333333333315, 'Test: Positive case: Time. Time values as fractions. 2 arguments used.');
		// Case #14: Formula. Multiple nested formulas. 2 arguments used.
		oParser = new parserFormula('STDEVP(SUM(1,1),PRODUCT(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(SUM(1,1),PRODUCT(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Multiple nested formulas. 2 arguments used.');
		// Case #15: Formula. STDEV inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(STDEVP(10,20),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(STDEVP(10,20),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. STDEV inside SUM formula. 2 arguments used.');
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		oParser = new parserFormula('STDEVP(100,100.0000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(100,100.0000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Very close numbers for small standard deviation. 2 arguments used.');
		// Case #17: String. Numeric strings with decimal points. 2 arguments used.
		oParser = new parserFormula('STDEVP("1.5","2.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP("1.5","2.5") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Numeric strings with decimal points. 2 arguments used.');
		// Case #18: Array. Array with three valid elements. 1 argument used.
		oParser = new parserFormula('STDEVP({10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP({10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.16496580927726, 'Test: Positive case: Array. Array with three valid elements. 1 argument used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEVP(IF(TRUE,10,5),IF(FALSE,5,20))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(IF(TRUE,10,5),IF(FALSE,5,20)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 2 arguments used.');
		// Case #20: Number. Small integers including zero. 3 arguments used.
		oParser = new parserFormula('STDEVP(0,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(0,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.816496580927726, 'Test: Positive case: Number. Small integers including zero. 3 arguments used.');
		// Case #21: Area3D. 3D range with three cells. 1 argument used.
		oParser = new parserFormula('STDEVP(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. 3D range with three cells. 1 argument used.');
		// Case #22: Reference link. Reference to three cells with valid numbers. 3 arguments used.
		oParser = new parserFormula('STDEVP(A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Reference link. Reference to three cells with valid numbers. 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Single number returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVP(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Single number returns #DIV/0!. 1 argument used.');
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVP("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('STDEVP(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Single-cell range returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVP(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Single-cell range returns #DIV/0!. 1 argument used.');
		// Case #4: Empty. Empty cell reference returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVP(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty cell reference returns #DIV/0!. 1 argument used.');
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVP("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean values return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVP(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Boolean. Boolean values return #VALUE!. 2 arguments used.');
		// Case #7: Ref3D. 3D reference to text cells returns #VALUE!.
		oParser = new parserFormula('STDEVP(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Test: Negative case: Ref3D. 3D reference to text cells returns #VALUE!.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVP(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVP(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #10: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEVP(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.');
		// Case #11: Number. All identical numbers return 0, but valid. 3 arguments used.
		oParser = new parserFormula('STDEVP(0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. All identical numbers return 0, but valid. 3 arguments used.');
		// Case #12: Array. Array with booleans returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVP({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP({TRUE,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with booleans returns #VALUE!. 1 argument used.');
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		oParser = new parserFormula('STDEVP(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.');
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVP("1/1/2025","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP("1/1/2025","abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #15: Area3D. 3D range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVP(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with text returns #VALUE!. 1 argument used.');
		// Case #16: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEVP(MMULT(1,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(MMULT(1,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.');
		// Case #17: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEVP(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.');
		// Case #18: Array. Single-element array returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVP({10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP({10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Single-element array returns #DIV/0!. 1 argument used.');
		// Case #19: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEVP(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #20: Time. Single time value returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEVP(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Time. Single time value returns #DIV/0!. 1 argument used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.
		oParser = new parserFormula('STDEVP(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.');
		// Case #1: Number. Smallest positive numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEVP(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive numbers, returns 0. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEVP(9.99999999999999E307,9.99999999999999E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(9.99999999999999E307,9.99999999999999E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.');
		// Case #3: Number. Smallest distinguishable difference near precision limit. 2 arguments used.
		oParser = new parserFormula('STDEVP(1E-307,1.00000000000001E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEVP(1E-307,1.00000000000001E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest distinguishable difference near precision limit. 2 arguments used.');

		// Need to fix: area handle, different results from MS, string handle, error types diff
		// Case #2: String. Strings convertible to numbers. 2 arguments used.
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		// Case #17: String. Numeric strings with decimal points. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.

		testArrayFormula2(assert, "STDEVP", 1, 8, null, true);
	});

	QUnit.test("Test: \"STDEV2\"", function (assert) {

		ws.getRange2("A103").setValue("1345");

		ws.getRange2("A104").setValue("1301");

		ws.getRange2("A105").setValue("1368");
		ws.getRange2("A106").setValue("1322");
		ws.getRange2("A107").setValue("1310");
		ws.getRange2("A108").setValue("1370");
		ws.getRange2("A109").setValue("1318");
		ws.getRange2("A110").setValue("1350");

		ws.getRange2("A111").setValue("1303");
		ws.getRange2("A112").setValue("1299");

		oParser = new parserFormula('STDEV(A103:A112)', "AA2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 27.46392);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integers. 3 arguments used.
		oParser = new parserFormula('STDEV(10,20,30)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(10,20,30) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number. Basic valid input: integers. 3 arguments used.');
		// Case #1: Number. Basic valid input: floats. 2 arguments used.
		oParser = new parserFormula('STDEV(1.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(1.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Number. Basic valid input: floats. 2 arguments used.');
		// Case #2: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('STDEV("10","20")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV("10","20") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #3: Formula. Nested formula returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV(SQRT(16),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(SQRT(16),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Formula. Nested formula returning valid numbers. 2 arguments used.');
		// Case #4: Reference link. Reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Reference link. Reference to cells with valid numbers. 2 arguments used.');
		// Case #5: Area. Single-cell range expanded to two cells. 1 argument used.
		oParser = new parserFormula('STDEV(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Area. Single-cell range expanded to two cells. 1 argument used.');
		// Case #6: Array. Array with two valid elements. 1 argument used.
		oParser = new parserFormula('STDEV({10,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV({10,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Positive case: Array. Array with two valid elements. 1 argument used.');
		// Case #7: Name. Named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Name. Named range with valid numbers. 2 arguments used.');
		// Case #8: Name3D. 3D named range with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named range with valid numbers. 2 arguments used.');
		// Case #9: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. 2 arguments used.');
		// Case #10: Area3D. 3D range with two cells. 1 argument used.
		oParser = new parserFormula('STDEV(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Area3D. 3D range with two cells. 1 argument used.');
		// Case #11: Table. Table structured reference with valid numbers. 1 argument used.
		oParser = new parserFormula('STDEV(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured reference with valid numbers. 1 argument used.');
		// Case #12: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('STDEV(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21.920310216782973, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #13: Time. Time values as fractions. 2 arguments used.
		oParser = new parserFormula('STDEV(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.029462782549439452, 'Test: Positive case: Time. Time values as fractions. 2 arguments used.');
		// Case #14: Formula. Multiple nested formulas. 2 arguments used.
		oParser = new parserFormula('STDEV(SUM(1,1),PRODUCT(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(SUM(1,1),PRODUCT(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.4142135623730951, 'Test: Positive case: Formula. Multiple nested formulas. 2 arguments used.');
		// Case #15: Formula. STDEV inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(STDEV(10,20),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(STDEV(10,20),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.071067811865476, 'Test: Positive case: Formula. STDEV inside SUM formula. 2 arguments used.');
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		oParser = new parserFormula('STDEV(100,100.0000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(100,100.0000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Very close numbers for small standard deviation. 2 arguments used.');
		// Case #17: String. Numeric strings with decimal points. 2 arguments used.
		oParser = new parserFormula('STDEV("1.5","2.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV("1.5","2.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: String. Numeric strings with decimal points. 2 arguments used.');
		// Case #18: Array. Array with three valid elements. 1 argument used.
		oParser = new parserFormula('STDEV({10,20,30})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV({10,20,30}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Array. Array with three valid elements. 1 argument used.');
		// Case #19: Formula. Nested IF formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('STDEV(IF(TRUE,10,5),IF(FALSE,5,20))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(IF(TRUE,10,5),IF(FALSE,5,20)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 2 arguments used.');
		// Case #20: Number. Small integers including zero. 3 arguments used.
		oParser = new parserFormula('STDEV(0,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(0,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Small integers including zero. 3 arguments used.');
		// Case #21: Area3D. 3D range with three cells. 1 argument used.
		oParser = new parserFormula('STDEV(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Area3D. 3D range with three cells. 1 argument used.');
		// Case #22: Reference link. Reference to three cells with valid numbers. 3 arguments used.
		oParser = new parserFormula('STDEV(A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0606601717798212, 'Test: Positive case: Reference link. Reference to three cells with valid numbers. 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Single number returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Single number returns #DIV/0!. 1 argument used.');
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('STDEV(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(NA(),10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Single-cell range returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area. Single-cell range returns #DIV/0!. 1 argument used.');
		// Case #4: Empty. Empty cell reference returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty. Empty cell reference returns #DIV/0!. 1 argument used.');
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean values return #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(TRUE,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Negative case: Boolean. Boolean values return #VALUE!. 2 arguments used.');
		// Case #7: Ref3D. 3D reference to text cells returns #VALUE!.
		oParser = new parserFormula('STDEV(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(Sheet2!A3,Sheet2!A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to text cells returns #VALUE!.');
		// Case #8: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1313708498984762, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #10: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEV(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(SQRT(-1),10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.');
		// Case #11: Number. All identical numbers return 0, but valid. 3 arguments used.
		oParser = new parserFormula('STDEV(0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. All identical numbers return 0, but valid. 3 arguments used.');
		// Case #12: Array. Array with booleans returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV({TRUE,FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Array with booleans returns #VALUE!. 1 argument used.');
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		oParser = new parserFormula('STDEV(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.');
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV("1/1/2025","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV("1/1/2025","abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.');
		// Case #15: Area3D. 3D range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(Sheet2!A3:A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with text returns #VALUE!. 1 argument used.');
		// Case #16: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.
		oParser = new parserFormula('STDEV(MMULT(1,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(MMULT(1,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.0710678118654755, 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 2 arguments used.');
		// Case #17: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('STDEV(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(A106,A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.');
		// Case #18: Array. Single-element array returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV({10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV({10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Array. Single-element array returns #DIV/0!. 1 argument used.');
		// Case #19: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('STDEV(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1313708498984762, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #20: Time. Single time value returns #DIV/0!. 1 argument used.
		oParser = new parserFormula('STDEV(TIME(0,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(TIME(0,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Time. Single time value returns #DIV/0!. 1 argument used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.
		oParser = new parserFormula('STDEV(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid dataset: two identical numbers return 0. 2 arguments used.');
		// Case #1: Number. Smallest positive numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEV(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest positive numbers, returns 0. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.
		oParser = new parserFormula('STDEV(9.99999999999999E307,9.99999999999999E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(9.99999999999999E307,9.99999999999999E307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers, returns 0. 2 arguments used.');
		// Case #3: Number. Smallest distinguishable difference near precision limit. 2 arguments used.
		oParser = new parserFormula('STDEV(1E-307,1.00000000000001E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STDEV(1E-307,1.00000000000001E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest distinguishable difference near precision limit. 2 arguments used.');

		// Need to fix: ms results diff, error types diff, bool and string handle
		// Case #16: Number. Very close numbers for small standard deviation. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		// Case #5: String. Empty string returns #VALUE!. 1 argument used.
		// Case #7: Ref3D. 3D reference to text cells returns #VALUE!.
		// Case #9: Table. Table column with text returns #VALUE!. 1 argument used.
		// Case #10: Formula. Formula resulting in #NUM! propagates error. 2 arguments used.
		// Case #12: Array. Array with booleans returns #VALUE!. 1 argument used.
		// Case #13: Number. Numbers at Excelâ??s limit return #DIV/0! due to overflow. 2 arguments used.
		// Case #14: String. Mix of date string and non-numeric string returns #VALUE!. 2 arguments used.
		// Case #15: Area3D. 3D range with text returns #VALUE!. 1 argument used.
		// Case #17: Reference link. Reference to cells with text returns #VALUE!. 2 arguments used.

		testArrayFormula2(assert, "STDEV", 1, 8, null, true);
	});

	QUnit.test("Test: \"STEYX\"", function (assert) {
		ws.getRange2("A203").setValue("2");
		ws.getRange2("A204").setValue("3");
		ws.getRange2("A205").setValue("9");
		ws.getRange2("A206").setValue("1");
		ws.getRange2("A207").setValue("8");
		ws.getRange2("A208").setValue("7");
		ws.getRange2("A209").setValue("5");

		ws.getRange2("B203").setValue("6");
		ws.getRange2("B204").setValue("5");
		ws.getRange2("B205").setValue("11");
		ws.getRange2("B206").setValue("7");
		ws.getRange2("B207").setValue("5");
		ws.getRange2("B208").setValue("4");
		ws.getRange2("B209").setValue("4");

		oParser = new parserFormula("STEYX(A203:A209,B203:B209)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 3.305719);

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A104").setValue("5");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A105").setValue("6");
		ws.getRange2("A106").setValue("7");
		ws.getRange2("A107").setValue("8");
		ws.getRange2("A108").setValue("9");
		ws.getRange2("A109").setValue("10");
		ws.getRange2("A110").setValue("11");
		ws.getRange2("A111").setValue("11");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: arrays with numeric values, equal length, >=3 points.
		oParser = new parserFormula('STEYX({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: arrays with numeric values, equal length, >=3 points.');
		// Case #2: String. String representations of numbers, convertible to numbers.
		oParser = new parserFormula('STEYX({"1","2","3"},{"4","5","6"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({"1","2","3"},{"4","5","6"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. String representations of numbers, convertible to numbers.');
		// Case #3: Array. Simple arrays, no internal formulas as per requirement.
		oParser = new parserFormula('STEYX({1,22,33},{4,50,60})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,22,33},{4,50,60}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.046072483422175, 'Test: Positive case: Array. Simple arrays, no internal formulas as per requirement.');
		// Case #4: Reference link. Reference to cells with valid numbers, equal length ranges.
		oParser = new parserFormula('STEYX(A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(A100:A102,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cells with valid numbers, equal length ranges.');
		// Case #5: Area. Two-cell ranges with valid numbers, equal length.
		oParser = new parserFormula('STEYX(A100:A101,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(A100:A101,A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Two-cell ranges with valid numbers, equal length.');
		// Case #6: Array. Arrays with more than 3 points, valid numbers.
		oParser = new parserFormula('STEYX({1,2,3,0},{5,6,7,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3,0},{5,6,7,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2927700218845602, 'Test: Positive case: Array. Arrays with more than 3 points, valid numbers.');
		// Case #7: Name. Named ranges containing valid numeric arrays.
		oParser = new parserFormula('STEYX(TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(TestName1,TestName2) is parsed.');
		// ?assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Named ranges containing valid numeric arrays.');
		// Case #8: Name3D. 3D named ranges with valid numeric data.
		oParser = new parserFormula('STEYX(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named ranges with valid numeric data.');
		// Case #9: Ref3D. 3D references to cells with valid numbers.
		oParser = new parserFormula('STEYX(Sheet2!A1:A3,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(Sheet2!A1:A3,Sheet2!A4:A6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D. 3D references to cells with valid numbers.');
		// Case #10: Area3D. 3D single-cell ranges with valid numbers.
		oParser = new parserFormula('STEYX(Sheet2!A1:A2,Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(Sheet2!A1:A2,Sheet2!A4:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers.');
		// Case #11: Table. Table structured references with valid numeric data.
		oParser = new parserFormula('STEYX(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(Table1[Column1],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured references with valid numeric data.');
		// Case #12: Array. Simple arrays, no internal formulas.
		oParser = new parserFormula('STEYX({1,2,3,33,333,3333},{7,8,9,99,999,9999})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3,33,333,3333},{7,8,9,99,999,9999}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5886286094874186, 'Test: Positive case: Array. Simple arrays, no internal formulas.');
		// Case #13: Date. Dates as serial numbers, valid input.
		oParser = new parserFormula('STEYX({45658,45659,45660},{45661,45662,45663})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({45658,45659,45660},{45661,45662,45663}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date. Dates as serial numbers, valid input.');
		// Case #14: Time. Time values as fractions, valid input.
		oParser = new parserFormula('STEYX({0.04,0.08,0.125},{0.4,0.8,1.25})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({0.04,0.08,0.125},{0.4,0.8,1.25}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Time. Time values as fractions, valid input.');
		// Case #15: Formula. STEYX inside SUM formula, valid input, no internal array formulas.
		oParser = new parserFormula('SUM(STEYX({1,2,3},{4,5,6}),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(STEYX({1,2,3},{4,5,6}),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. STEYX inside SUM formula, valid input, no internal array formulas.');
		// Case #16: String. Numeric strings with decimal points, convertible to numbers.
		oParser = new parserFormula('STEYX({"1.5","2.5","4.5"},{"4.5","5.5","7.5"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({"1.5","2.5","4.5"},{"4.5","5.5","7.5"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Numeric strings with decimal points, convertible to numbers.');
		// Case #17: Array. Arrays with zeros, valid input, zeros included.
		oParser = new parserFormula('STEYX({1,2,3,0},{4,5,6,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3,0},{4,5,6,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5703518254720301, 'Test: Positive case: Array. Arrays with zeros, valid input, zeros included.');
		// Case #18: Reference link. Reference to cells with mixed data, non-numeric ignored.
		oParser = new parserFormula('STEYX(A106:A108,A109:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(A106:A108,A109:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7071067811865476, 'Test: Positive case: Reference link. Reference to cells with mixed data, non-numeric ignored.');
		// Case #19: Array. Simple arrays, no internal formulas, valid input.
		oParser = new parserFormula('STEYX({1,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Simple arrays, no internal formulas, valid input.');
		// Case #20: Array. Larger arrays with valid numeric data, equal length.
		oParser = new parserFormula('STEYX({1,2,3,4,5},{6,7,8,9,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3,4,5},{6,7,8,9,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Larger arrays with valid numeric data, equal length.');

		// Negative cases:
		// Case #1: Number. Arrays with less than 3 points, returns #DIV/0!.
		oParser = new parserFormula('STEYX({1,2},{3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2},{3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Arrays with less than 3 points, returns #DIV/0!.');
		// Case #2: Array. Mismatched array lengths, returns #N/A.
		oParser = new parserFormula('STEYX({1,2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Mismatched array lengths, returns #N/A.');
		// Case #3: String. Non-numeric string, returns #VALUE!.
		oParser = new parserFormula('STEYX({"abc","2","3"},{"4","5","6"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({"abc","2","3"},{"4","5","6"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String. Non-numeric string, returns #VALUE!.');
		// Case #4: Error. Error value in array, propagates #N/A.
		oParser = new parserFormula('STEYX(NA(),{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(NA(),{4,5,6}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value in array, propagates #N/A.');
		// Case #5: Empty. Empty arrays, returns #DIV/0!.
		oParser = new parserFormula('STEYX(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty arrays, returns #DIV/0!.');
		// Case #6: Reference link. Reference to cells with non-numeric data, returns #VALUE!.
		oParser = new parserFormula('STEYX(A109:A111,A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(A109:A111,A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.40824829046386296, 'Test: Negative case: Reference link. Reference to cells with non-numeric data, returns #VALUE!.');
		// Case #7: Area. Multi-cell range with text, returns #VALUE!.
		oParser = new parserFormula('STEYX(A100:A102,A106:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(A100:A102,A106:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area. Multi-cell range with text, returns #VALUE!.');
		// Case #8: Boolean. Boolean values ignored, less than 3 valid points, returns #DIV/0!.
		oParser = new parserFormula('STEYX({FALSE,TRUE,FALSE},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({FALSE,TRUE,FALSE},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean. Boolean values ignored, less than 3 valid points, returns #DIV/0!.');
		// Case #9: Reference link. Single-cell references, less than 3 points, returns #DIV/0!.
		oParser = new parserFormula('STEYX(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(A106,A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Single-cell references, less than 3 points, returns #DIV/0!.');
		// Case #10: Name. Named range with text, returns #VALUE!.
		oParser = new parserFormula('STEYX(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(TestNameArea2,TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Name. Named range with text, returns #VALUE!.');
		// Case #11: Name3D. 3D named range with text, returns #VALUE!.
		oParser = new parserFormula('STEYX(TestNameArea3D2,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(TestNameArea3D2,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Name3D. 3D named range with text, returns #VALUE!.');
		// Case #12: Ref3D. 3D reference to cells with text, returns #VALUE!.
		oParser = new parserFormula('STEYX(Sheet2!A7:A9,Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(Sheet2!A7:A9,Sheet2!A1:A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to cells with text, returns #VALUE!.');
		// Case #13: Area3D. 3D range with text, returns #VALUE!.
		oParser = new parserFormula('STEYX(Sheet2!A7:A8,Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(Sheet2!A7:A8,Sheet2!A1:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. 3D range with text, returns #VALUE!.');
		// Case #14: Table. Table column with text, returns #VALUE!.
		oParser = new parserFormula('STEYX(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Table. Table column with text, returns #VALUE!.');
		// Case #15: Array. Non-numeric string in array, returns #VALUE!.
		oParser = new parserFormula('STEYX({1,2,3},{4,5,6,"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3},{4,5,6,"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Non-numeric string in array, returns #VALUE!.');
		// Case #16: Empty. Empty cell references, returns #DIV/0!.
		oParser = new parserFormula('STEYX(A109:A111,A109:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(A109:A111,A109:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty cell references, returns #DIV/0!.');
		// Case #17: Number. All zeros in known_y\'s, valid but may cause issues in regression.
		oParser = new parserFormula('STEYX({0,0,0},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({0,0,0},{1,2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. All zeros in known_y\'s, valid but may cause issues in regression.');
		// Case #18: Array. Non-numeric in array with mismatched lengths, returns #N/A.
		oParser = new parserFormula('STEYX({1,2,3,"abc"},{4,5,6,7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3,"abc"},{4,5,6,7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array. Non-numeric in array with mismatched lengths, returns #N/A.');
		// Case #19: Reference link. Mismatched range lengths, returns #N/A.
		oParser = new parserFormula('STEYX(A100:A102,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX(A100:A102,A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link. Mismatched range lengths, returns #N/A.');
		// Case #20: Array. Error in known_x\'s array, propagates #N/A.
		oParser = new parserFormula('STEYX({1,2,3},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3},NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Error in known_x\'s array, propagates #N/A.');

		// Bounded cases:
		// Case #1: Number. Minimum valid number in array, processes without error.
		oParser = new parserFormula('STEYX({1E-307,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1E-307,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4082482904638634, 'Test: Bounded case: Number. Minimum valid number in array, processes without error.');
		// Case #2: Number. Maximum valid Excel number, processes without error.
		oParser = new parserFormula('STEYX({9.99999999999999E+307,2,3},{4,5,6})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({9.99999999999999E+307,2,3},{4,5,6}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel number, processes without error.');
		// Case #3: Array. Minimum valid number in known_x\'s, processes without error.
		oParser = new parserFormula('STEYX({1,2,3},{1E-307,4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3},{1E-307,4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.46291004988627565, 'Test: Bounded case: Array. Minimum valid number in known_x\'s, processes without error.');
		// Case #4: Array. Maximum valid number in known_x\'s, processes without error.
		oParser = new parserFormula('STEYX({1,2,3},{9.99999999999999E+307,4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: STEYX({1,2,3},{9.99999999999999E+307,4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array. Maximum valid number in known_x\'s, processes without error.');

		// Need to fix: area handle, diff results from MS, error types diff, #DIV/0 error
		// Case #5: Area. Two-cell ranges with valid numbers, equal length.
		// Case #7: Name. Named ranges containing valid numeric arrays.
		// Case #8: Name3D. 3D named ranges with valid numeric data.
		// Case #9: Ref3D. 3D references to cells with valid numbers.
		// Case #10: Area3D. 3D single-cell ranges with valid numbers.
		// Case #11: Table. Table structured references with valid numeric data.
		// Case #4: Error. Error value in array, propagates #N/A.
		// Case #9: Reference link. Single-cell references, less than 3 points, returns #DIV/0!.
		// Case #10: Name. Named range with text, returns #VALUE!.
		// Case #17: Number. All zeros in known_y\'s, valid but may cause issues in regression.
		// Case #20: Array. Error in known_x\'s array, propagates #N/A.


		testArrayFormula2(assert, "STEYX", 2, 2, null, true);
	});

	QUnit.test("Test: \"TDIST\"", function (assert) {
		oParser = new parserFormula("TDIST(60,1,2)", "A1", ws);
		assert.ok(oParser.parse(), "TDIST(60,1,2)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.010609347, "TDIST(60,1,2)");

		oParser = new parserFormula("TDIST(8,3,1)", "A1", ws);
		assert.ok(oParser.parse(), "TDIST(8,3,1)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.002038289, "TDIST(8,3,1)");

		ws.getRange2("A2").setValue("1.959999998");
		ws.getRange2("A3").setValue("60");

		oParser = new parserFormula("TDIST(A2,A3,2)", "A1", ws);
		assert.ok(oParser.parse(), "TDIST(A2,A3,2)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.054644930, "TDIST(A2,A3,2)");

		oParser = new parserFormula("TDIST(A2,A3,1)", "A1", ws);
		assert.ok(oParser.parse(), "TDIST(A2,A3,1)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.027322465, "TDIST(A2,A3,1)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("1");
		// For area
		ws.getRange2("A102").setValue("2.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:F10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(2), Boolean. Valid numeric inputs, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Positive case: Number(2), Boolean. Valid numeric inputs, cumulative TRUE. 3 of 3 arguments used.');
		// Case #2: Number(2), Boolean. Float x, integer deg_freedom, cumulative FALSE. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(1.5,5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(1.5,5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number(2), Boolean. Float x, integer deg_freedom, cumulative FALSE. 3 of 3 arguments used.');
		// Case #3: String(2), Boolean. String convertible to numbers, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST("2","10",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST("2","10",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Positive case: String(2), Boolean. String convertible to numbers, cumulative TRUE. 3 of 3 arguments used.');
		// Case #4: Formula(2), Boolean. Nested formulas for x and deg_freedom, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(SQRT(4),ROUND(10.7,0),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(SQRT(4),ROUND(10.7,0),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.035401977534017255, 'Test: Positive case: Formula(2), Boolean. Nested formulas for x and deg_freedom, cumulative TRUE. 3 of 3 arguments used.');
		// Case #5: Formula, Number, Boolean. Nested IF for x, valid deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(IF(TRUE,2,1),5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(IF(TRUE,2,1),5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.050969739414929174, 'Test: Positive case: Formula, Number, Boolean. Nested IF for x, valid deg_freedom. 3 of 3 arguments used.');
		// Case #6: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(A100,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(A100,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.313946803, 'Test: Positive case: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.');
		// Case #7: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,A101,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,A101,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.147583618, 'Test: Positive case: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.');
		// Case #8: Area, Number, Boolean. Single-cell range for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(A102:A102,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(A102:A102,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.313946803, 'Test: Positive case: Area, Number, Boolean. Single-cell range for x. 3 of 3 arguments used.');
		// Case #9: Number, Area, Boolean. Single-cell range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,A103:A103,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,A103:A103,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Area, Boolean. Single-cell range for deg_freedom. 3 of 3 arguments used.');
		// Case #10: Array, Number, Boolean. Single-element array for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST({2},10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST({2},10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Positive case: Array, Number, Boolean. Single-element array for x. 3 of 3 arguments used.');
		// Case #11: Number, Array, Boolean. Single-element array for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,{5},FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,{5},FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Array, Boolean. Single-element array for deg_freedom. 3 of 3 arguments used.');
		// Case #12: Name, Number, Boolean. Named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(TestName,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(TestName,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Number, Boolean. Named range for x. 3 of 3 arguments used.');
		// Case #13: Number, Name, Boolean. Named range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,TestName1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,TestName1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Name, Boolean. Named range for deg_freedom. 3 of 3 arguments used.');
		// Case #14: Ref3D, Number, Boolean. 3D reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(Sheet2!A1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(Sheet2!A1,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.17044656615103024, 'Test: Positive case: Ref3D, Number, Boolean. 3D reference for x. 3 of 3 arguments used.');
		// Case #15: Number, Ref3D, Boolean. 3D reference for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,Sheet2!A2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,Sheet2!A2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Ref3D, Boolean. 3D reference for deg_freedom. 3 of 3 arguments used.');
		// Case #16: Area3D, Number, Boolean. 3D single-cell range for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(Sheet2!A3:A3,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(Sheet2!A3:A3,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D, Number, Boolean. 3D single-cell range for x. 3 of 3 arguments used.');
		// Case #17: Number, Area3D, Boolean. 3D single-cell range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,Sheet2!A4:A4,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,Sheet2!A4:A4,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Area3D, Boolean. 3D single-cell range for deg_freedom. 3 of 3 arguments used.');
		// Case #18: Table, Number, Boolean. Table reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(Table1[Column1],10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(Table1[Column1],10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.17044656615103024, 'Test: Positive case: Table, Number, Boolean. Table reference for x. 3 of 3 arguments used.');
		// Case #19: Number, Table, Boolean. Table reference for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,Table1[Column1],FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,Table1[Column1],FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Table, Boolean. Table reference for deg_freedom. 3 of 3 arguments used.');
		// Case #20: Formula, Number, Boolean. T.DIST with nested SUM for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(SUM(1,1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(SUM(1,1),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Positive case: Formula, Number, Boolean. T.DIST with nested SUM for x. 3 of 3 arguments used.');
		// Case #21: Date, Number, Boolean. Date as serial number for x (large number). 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(DATE(2025,1,1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(DATE(2025,1,1),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.1253721746486217e-43, 'Test: Positive case: Date, Number, Boolean. Date as serial number for x (large number). 3 of 3 arguments used.');
		// Case #22: Time, Number, Boolean. Time adjusted to valid number for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(TIME(12,0,0)+1,5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(TIME(12,0,0)+1,5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09695184012123674, 'Test: Positive case: Time, Number, Boolean. Time adjusted to valid number for x. 3 of 3 arguments used.');
		// Case #23: Formula(3). All arguments as formulas. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(SQRT(4),ROUND(10.7,0),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(SQRT(4),ROUND(10.7,0),IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.035401977534017255, 'Test: Positive case: Formula(3). All arguments as formulas. 3 of 3 arguments used.');
		// Case #24: Number, Formula, Boolean. Formula for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,ABS(-5),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,ABS(-5),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.050969739414929174, 'Test: Positive case: Number, Formula, Boolean. Formula for deg_freedom. 3 of 3 arguments used.');
		// Case #25: Name3D, Number, Boolean. 3D named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(TestName3D,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(TestName3D,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Number, Boolean. 3D named range for x. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number(2), Boolean. deg_freedom < 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Boolean. deg_freedom < 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number, Empty, Boolean. Empty deg_freedom returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Boolean. Empty deg_freedom returns #VALUE!. 2 of 3 arguments used.');
		// Case #3: Empty, Number, Boolean. Empty x returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('TDIST(,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Empty, Number, Boolean. Empty x returns #VALUE!. 2 of 3 arguments used.');
		// Case #4: String, Number, Boolean. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST("abc",10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST("abc",10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Boolean. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #5: Number, String, Boolean. Non-numeric string for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,"abc",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,"abc",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Boolean. Non-numeric string for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Error, Number, Boolean. Propagates #N/A error for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(NA(),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(NA(),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Boolean. Propagates #N/A error for x. 3 of 3 arguments used.');
		// Case #7: Number, Error, Boolean. Propagates #N/A error for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,NA(),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,NA(),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Boolean. Propagates #N/A error for deg_freedom. 3 of 3 arguments used.');
		// Case #8: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(A104:A105,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(A104:A105,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,A106:A107,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,A106:A107,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Array, Number, Boolean. Multi-element array for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST({2,3},10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST({2,3},10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Negative case: Array, Number, Boolean. Multi-element array for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Number, Array, Boolean. Multi-element array for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,{5,10},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,{5,10},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.050969739414929174, 'Test: Negative case: Number, Array, Boolean. Multi-element array for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Name, Number, Boolean. Named range with area for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(TestNameArea2,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(TestNameArea2,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22115020957077075, 'Test: Negative case: Name, Number, Boolean. Named range with area for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,TestNameArea2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,TestNameArea2,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.147583618, 'Test: Negative case: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Ref3D, Number, Boolean. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(Sheet2!A5,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(Sheet2!A5,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Ref3D, Number, Boolean. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Number, Ref3D, Boolean. 3D ref to non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,Sheet2!A6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,Sheet2!A6,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Ref3D, Boolean. 3D ref to non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(Sheet2!A7:A8,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(Sheet2!A7:A8,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,Sheet2!A9:A10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,Sheet2!A9:A10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #18: Table, Number, Boolean. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(Table1[Column2],10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(Table1[Column2],10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table, Number, Boolean. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Number, Table, Boolean. Table column with non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,Table1[Column2],TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,Table1[Column2],TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Table, Boolean. Table column with non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Formula, Number, Boolean. Formula resulting in #NUM! error for x. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(SQRT(-1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(SQRT(-1),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number, Boolean. Formula resulting in #NUM! error for x. 3 of 3 arguments used.');
		// Case #21: Number(2), String. Non-boolean string for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,10,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,10,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String. Non-boolean string for cumulative returns #VALUE!. 3 of 3 arguments used.');
		// Case #22: Number(2), Empty. Missing cumulative argument returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('TDIST(2,10,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(2,10,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Empty. Missing cumulative argument returns #VALUE!. 2 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number(2), Boolean. Minimum deg_freedom (1), x at mean of distribution. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number(2), Boolean. Minimum deg_freedom (1), x at mean of distribution. 3 of 3 arguments used.');
		// Case #2: Number(2), Boolean. Smallest positive x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(1E-307,1E6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(1E-307,1E6,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number(2), Boolean. Smallest positive x, large deg_freedom. 3 of 3 arguments used.');
		// Case #3: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(1E+307,1E6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(1E+307,1E6,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.');
		// Case #4: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('TDIST(-1E+307,1E6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TDIST(-1E+307,1E6,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.');

		// Need to fix: string handle, results diff from MS, error types diff
		// Case #6: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.
		// Case #7: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.
		// Case #8: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		// Case #9: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #13: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #16: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		// Case #17: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #3: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.

		testArrayFormula2(assert, "TDIST", 3, 3);
	});

	QUnit.test("Test: \"T.DIST\"", function (assert) {
		oParser = new parserFormula("T.DIST(60,1,TRUE)", "A1", ws);
		assert.ok(oParser.parse(), "T.DIST(60,1,TRUE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.99469533, "T.DIST(60,1,TRUE)");

		oParser = new parserFormula("T.DIST(8,3,FALSE)", "A1", ws);
		assert.ok(oParser.parse(), "T.DIST(8,3,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.00073691, "T.DIST(8,3,FALSE)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("1");
		// For area
		ws.getRange2("A102").setValue("2.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(2), Boolean. Valid numeric inputs, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9633059826146299, 'Test: Positive case: Number(2), Boolean. Valid numeric inputs, cumulative TRUE. 3 of 3 arguments used.');
		// Case #2: Number(2), Boolean. Float x, integer deg_freedom, cumulative FALSE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(1.5,5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(1.5,5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12451734464635515, 'Test: Positive case: Number(2), Boolean. Float x, integer deg_freedom, cumulative FALSE. 3 of 3 arguments used.');
		// Case #3: String(2), Boolean. String convertible to numbers, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST("2","10",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST("2","10",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9633059826146299, 'Test: Positive case: String(2), Boolean. String convertible to numbers, cumulative TRUE. 3 of 3 arguments used.');
		// Case #4: Formula(2), Boolean. Nested formulas for x and deg_freedom, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(SQRT(4),ROUND(10.7,0),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(SQRT(4),ROUND(10.7,0),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9645980224659827, 'Test: Positive case: Formula(2), Boolean. Nested formulas for x and deg_freedom, cumulative TRUE. 3 of 3 arguments used.');
		// Case #5: Formula, Number, Boolean. Nested IF for x, valid deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(IF(TRUE,2,1),5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(IF(TRUE,2,1),5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9490302605850708, 'Test: Positive case: Formula, Number, Boolean. Nested IF for x, valid deg_freedom. 3 of 3 arguments used.');
		// Case #6: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(A100,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(A100,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.');
		// Case #7: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,A101,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,A101,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.');
		// Case #8: Area, Number, Boolean. Single-cell range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(A102:A102,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(A102:A102,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area, Number, Boolean. Single-cell range for x. 3 of 3 arguments used.');
		// Case #9: Number, Area, Boolean. Single-cell range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,A103:A103,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,A103:A103,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number, Area, Boolean. Single-cell range for deg_freedom. 3 of 3 arguments used.');
		// Case #10: Array, Number, Boolean. Single-element array for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST({2},10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST({2},10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9633059826146299, 'Test: Positive case: Array, Number, Boolean. Single-element array for x. 3 of 3 arguments used.');
		// Case #11: Number, Array, Boolean. Single-element array for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,{5},FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,{5},FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06509031032621646, 'Test: Positive case: Number, Array, Boolean. Single-element array for deg_freedom. 3 of 3 arguments used.');
		// Case #12: Name, Number, Boolean. Named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(TestName,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(TestName,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3139468028714863, 'Test: Positive case: Name, Number, Boolean. Named range for x. 3 of 3 arguments used.');
		// Case #13: Number, Name, Boolean. Named range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,TestName1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,TestName1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Name, Boolean. Named range for deg_freedom. 3 of 3 arguments used.');
		// Case #14: Ref3D, Number, Boolean. 3D reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(Sheet2!A1,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(Sheet2!A1,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8295534338489697, 'Test: Positive case: Ref3D, Number, Boolean. 3D reference for x. 3 of 3 arguments used.');
		// Case #15: Number, Ref3D, Boolean. 3D reference for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,Sheet2!A2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,Sheet2!A2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06804138174397718, 'Test: Positive case: Number, Ref3D, Boolean. 3D reference for deg_freedom. 3 of 3 arguments used.');
		// Case #16: Area3D, Number, Boolean. 3D single-cell range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(Sheet2!A3:A3,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(Sheet2!A3:A3,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D, Number, Boolean. 3D single-cell range for x. 3 of 3 arguments used.');
		// Case #17: Number, Area3D, Boolean. 3D single-cell range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,Sheet2!A4:A4,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,Sheet2!A4:A4,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number, Area3D, Boolean. 3D single-cell range for deg_freedom. 3 of 3 arguments used.');
		// Case #18: Table, Number, Boolean. Table reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(Table1[Column1],10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(Table1[Column1],10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8295534338489697, 'Test: Positive case: Table, Number, Boolean. Table reference for x. 3 of 3 arguments used.');
		// Case #19: Number, Table, Boolean. Table reference for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,Table1[Column2],FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,Table1[Column2],FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number, Table, Boolean. Table reference for deg_freedom. 3 of 3 arguments used.');
		// Case #20: Formula, Number, Boolean. T.DIST with nested SUM for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(SUM(1,1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(SUM(1,1),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9633059826146299, 'Test: Positive case: Formula, Number, Boolean. T.DIST with nested SUM for x. 3 of 3 arguments used.');
		// Case #21: Date, Number, Boolean. Date as serial number for x (large number). 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(DATE(2025,1,1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(DATE(2025,1,1),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date, Number, Boolean. Date as serial number for x (large number). 3 of 3 arguments used.');
		// Case #22: Time, Number, Boolean. Time adjusted to valid number for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(TIME(12,0,0)+1,5,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(TIME(12,0,0)+1,5,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9030481598787633, 'Test: Positive case: Time, Number, Boolean. Time adjusted to valid number for x. 3 of 3 arguments used.');
		// Case #23: Formula(3). All arguments as formulas. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(SQRT(4),ROUND(10.7,0),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(SQRT(4),ROUND(10.7,0),IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9645980224659827, 'Test: Positive case: Formula(3). All arguments as formulas. 3 of 3 arguments used.');
		// Case #24: Number, Formula, Boolean. Formula for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,ABS(-5),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,ABS(-5),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9490302605850708, 'Test: Positive case: Number, Formula, Boolean. Formula for deg_freedom. 3 of 3 arguments used.');
		// Case #25: Name3D, Number, Boolean. 3D named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(TestName3D,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(TestName3D,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3139468028714863, 'Test: Positive case: Name3D, Number, Boolean. 3D named range for x. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number(2), Boolean. deg_freedom < 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Boolean. deg_freedom < 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number, Empty, Boolean. Empty deg_freedom returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Boolean. Empty deg_freedom returns #VALUE!. 2 of 3 arguments used.');
		// Case #3: Empty, Number, Boolean. Empty x returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('T.DIST(,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Empty, Number, Boolean. Empty x returns #VALUE!. 2 of 3 arguments used.');
		// Case #4: String, Number, Boolean. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST("abc",10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST("abc",10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Boolean. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #5: Number, String, Boolean. Non-numeric string for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,"abc",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,"abc",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Boolean. Non-numeric string for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Error, Number, Boolean. Propagates #N/A error for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(NA(),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(NA(),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Boolean. Propagates #N/A error for x. 3 of 3 arguments used.');
		// Case #7: Number, Error, Boolean. Propagates #N/A error for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,NA(),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,NA(),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Boolean. Propagates #N/A error for deg_freedom. 3 of 3 arguments used.');
		// Case #8: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(A104:A105,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(A104:A105,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,A106:A107,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,A106:A107,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Array, Number, Boolean. Multi-element array for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST({2,3},10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST({2,3},10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9633059826146299, 'Test: Negative case: Array, Number, Boolean. Multi-element array for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Number, Array, Boolean. Multi-element array for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,{5,10},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,{5,10},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9490302605850708, 'Test: Negative case: Number, Array, Boolean. Multi-element array for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Name, Number, Boolean. Named range with area for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(TestNameArea2,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(TestNameArea2,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7788497904292293, 'Test: Negative case: Name, Number, Boolean. Named range with area for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,TestNameArea2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,TestNameArea2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Negative case: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Ref3D, Number, Boolean. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(Sheet2!A5,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(Sheet2!A5,10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Ref3D, Number, Boolean. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Number, Ref3D, Boolean. 3D ref to non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,Sheet2!A6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,Sheet2!A6,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Ref3D, Boolean. 3D ref to non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(Sheet2!A7:A8,10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(Sheet2!A7:A8,10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,Sheet2!A9:A10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,Sheet2!A9:A10,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #18: Table, Number, Boolean. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(Table1[Column2],10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(Table1[Column2],10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table, Number, Boolean. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Number, Table, Boolean. Table column with non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,Table1[Column2],TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,Table1[Column2],TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Table, Boolean. Table column with non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Formula, Number, Boolean. Formula resulting in #NUM! error for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(SQRT(-1),10,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(SQRT(-1),10,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number, Boolean. Formula resulting in #NUM! error for x. 3 of 3 arguments used.');
		// Case #21: Number(2), String. Non-boolean string for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,10,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,10,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String. Non-boolean string for cumulative returns #VALUE!. 3 of 3 arguments used.');
		// Case #22: Number(2), Empty. Missing cumulative argument returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('T.DIST(2,10,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(2,10,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06114576632121821, 'Test: Negative case: Number(2), Empty. Missing cumulative argument returns #VALUE!. 2 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number(2), Boolean. Minimum deg_freedom (1), x at mean of distribution. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(0,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(0,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number(2), Boolean. Minimum deg_freedom (1), x at mean of distribution. 3 of 3 arguments used.');
		// Case #2: Number(2), Boolean. Smallest positive x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(1E-307,1E6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(1E-307,1E6,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number(2), Boolean. Smallest positive x, large deg_freedom. 3 of 3 arguments used.');
		// Case #3: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(1E+307,1E6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(1E+307,1E6,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.');
		// Case #4: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST(-1E+307,1E6,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST(-1E+307,1E6,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.');

		// Need to fix: error types diff, area/ref handle
		// Case #6: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.
		// Case #7: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.
		// Case #8: Area, Number, Boolean. Single-cell range for x. 3 of 3 arguments used.
		// Case #9: Number, Area, Boolean. Single-cell range for deg_freedom. 3 of 3 arguments used.
		// Case #17: Number, Area3D, Boolean. 3D single-cell range for deg_freedom. 3 of 3 arguments used.
		// Case #9: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #16: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		// Case #17: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #3: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.
		// Case #4: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.


		testArrayFormula2(assert, "T.DIST", 3, 3);
	});

	QUnit.test("Test: \"T.DIST.2T\"", function (assert) {
		ws.getRange2("A2").setValue("1.959999998");
		ws.getRange2("A3").setValue("60");

		oParser = new parserFormula("T.DIST.2T(A2,A3)", "A1", ws);
		assert.ok(oParser.parse(), "T.DIST.2T(A2,A3)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.054644930, "T.DIST.2T(A2,A3)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:F10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(2), Boolean. Valid numeric inputs, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07338803477074037, 'Test: Positive case: Number(2), Boolean. Valid numeric inputs, cumulative TRUE. 3 of 3 arguments used.');
		// Case #2: Number(2), Boolean. Float x, integer deg_freedom, cumulative FALSE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(1.5,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(1.5,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.19390368024247348, 'Test: Positive case: Number(2), Boolean. Float x, integer deg_freedom, cumulative FALSE. 3 of 3 arguments used.');
		// Case #3: String(2), Boolean. String convertible to numbers, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T("2","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T("2","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07338803477074037, 'Test: Positive case: String(2), Boolean. String convertible to numbers, cumulative TRUE. 3 of 3 arguments used.');
		// Case #4: Formula(2), Boolean. Nested formulas for x and deg_freedom, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(SQRT(4),ROUND(10.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(SQRT(4),ROUND(10.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07080395506803451, 'Test: Positive case: Formula(2), Boolean. Nested formulas for x and deg_freedom, cumulative TRUE. 3 of 3 arguments used.');
		// Case #5: Formula, Number, Boolean. Nested IF for x, valid deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(IF(TRUE,2,1),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(IF(TRUE,2,1),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10193947882985835, 'Test: Positive case: Formula, Number, Boolean. Nested IF for x, valid deg_freedom. 3 of 3 arguments used.');
		// Case #6: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(A100,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(A100,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6278936057429726, 'Test: Positive case: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.');
		// Case #7: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.295167235, 'Test: Positive case: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.');
		// Case #8: Area, Number, Boolean. Single-cell range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(A102:A102,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(A102:A102,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6278936057429726, 'Test: Positive case: Area, Number, Boolean. Single-cell range for x. 3 of 3 arguments used.');
		// Case #9: Number, Area, Boolean. Single-cell range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Area, Boolean. Single-cell range for deg_freedom. 3 of 3 arguments used.');
		// Case #10: Array, Number, Boolean. Single-element array for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T({2},10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T({2},10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07338803477074037, 'Test: Positive case: Array, Number, Boolean. Single-element array for x. 3 of 3 arguments used.');
		// Case #11: Number, Array, Boolean. Single-element array for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,{5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,{5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10193947882985835, 'Test: Positive case: Number, Array, Boolean. Single-element array for deg_freedom. 3 of 3 arguments used.');
		// Case #12: Name, Number, Boolean. Named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(TestName,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(TestName,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Number, Boolean. Named range for x. 3 of 3 arguments used.');
		// Case #13: Number, Name, Boolean. Named range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Name, Boolean. Named range for deg_freedom. 3 of 3 arguments used.');
		// Case #14: Ref3D, Number, Boolean. 3D reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(Sheet2!A1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(Sheet2!A1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3408931323020605, 'Test: Positive case: Ref3D, Number, Boolean. 3D reference for x. 3 of 3 arguments used.');
		// Case #15: Number, Ref3D, Boolean. 3D reference for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.18350341907227397, 'Test: Positive case: Number, Ref3D, Boolean. 3D reference for deg_freedom. 3 of 3 arguments used.');
		// Case #16: Area3D, Number, Boolean. 3D single-cell range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(Sheet2!A3:A3,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(Sheet2!A3:A3,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D, Number, Boolean. 3D single-cell range for x. 3 of 3 arguments used.');
		// Case #17: Number, Area3D, Boolean. 3D single-cell range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Area3D, Boolean. 3D single-cell range for deg_freedom. 3 of 3 arguments used.');
		// Case #18: Table, Number, Boolean. Table reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(Table1[Column1],10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(Table1[Column1],10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3408931323020605, 'Test: Positive case: Table, Number, Boolean. Table reference for x. 3 of 3 arguments used.');
		// Case #19: Number, Table, Boolean. Table reference for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number, Table, Boolean. Table reference for deg_freedom. 3 of 3 arguments used.');
		// Case #20: Formula, Number, Boolean. T.DIST with nested SUM for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(SUM(1,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(SUM(1,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07338803477074037, 'Test: Positive case: Formula, Number, Boolean. T.DIST with nested SUM for x. 3 of 3 arguments used.');
		// Case #21: Date, Number, Boolean. Date as serial number for x (large number). 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(DATE(2025,1,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(DATE(2025,1,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.250744349297243e-43, 'Test: Positive case: Date, Number, Boolean. Date as serial number for x (large number). 3 of 3 arguments used.');
		// Case #22: Time, Number, Boolean. Time adjusted to valid number for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(TIME(12,0,0)+1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(TIME(12,0,0)+1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.19390368024247348, 'Test: Positive case: Time, Number, Boolean. Time adjusted to valid number for x. 3 of 3 arguments used.');
		// Case #23: Formula(3). All arguments as formulas. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(SQRT(4),ROUND(10.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(SQRT(4),ROUND(10.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07080395506803451, 'Test: Positive case: Formula(3). All arguments as formulas. 3 of 3 arguments used.');
		// Case #24: Number, Formula, Boolean. Formula for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,ABS(-5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,ABS(-5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10193947882985835, 'Test: Positive case: Number, Formula, Boolean. Formula for deg_freedom. 3 of 3 arguments used.');
		// Case #25: Name3D, Number, Boolean. 3D named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(TestName3D,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(TestName3D,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Number, Boolean. 3D named range for x. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number(2), Boolean. deg_freedom < 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Boolean. deg_freedom < 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number, Empty, Boolean. Empty deg_freedom returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Boolean. Empty deg_freedom returns #VALUE!. 2 of 3 arguments used.');
		// Case #3: Empty, Number, Boolean. Empty x returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty, Number, Boolean. Empty x returns #VALUE!. 2 of 3 arguments used.');
		// Case #4: String, Number, Boolean. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T("abc",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T("abc",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Boolean. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #5: Number, String, Boolean. Non-numeric string for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Boolean. Non-numeric string for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Error, Number, Boolean. Propagates #N/A error for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Boolean. Propagates #N/A error for x. 3 of 3 arguments used.');
		// Case #7: Number, Error, Boolean. Propagates #N/A error for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Boolean. Propagates #N/A error for deg_freedom. 3 of 3 arguments used.');
		// Case #8: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(A104:A105,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(A104:A105,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,A106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Array, Number, Boolean. Multi-element array for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T({2,3},10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T({2,3},10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07338803477074037, 'Test: Negative case: Array, Number, Boolean. Multi-element array for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Number, Array, Boolean. Multi-element array for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,{5,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,{5,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10193947882985835, 'Test: Negative case: Number, Array, Boolean. Multi-element array for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Name, Number, Boolean. Named range with area for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(TestNameArea2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(TestNameArea2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.4423004191415415, 'Test: Negative case: Name, Number, Boolean. Named range with area for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.295167235, 'Test: Negative case: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Ref3D, Number, Boolean. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(Sheet2!A5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(Sheet2!A5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D, Number, Boolean. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Number, Ref3D, Boolean. 3D ref to non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Ref3D, Boolean. 3D ref to non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(Sheet2!A7:A8,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(Sheet2!A7:A8,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,Sheet2!A9:A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,Sheet2!A9:A10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #18: Table, Number, Boolean. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(Table1[Column1],10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(Table1[Column1],10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3408931323020605, 'Test: Negative case: Table, Number, Boolean. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Number, Table, Boolean. Table column with non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Table, Boolean. Table column with non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Formula, Number, Boolean. Formula resulting in #NUM! error for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number, Boolean. Formula resulting in #NUM! error for x. 3 of 3 arguments used.');
		// Case #21: Number(2), String. Non-boolean string for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07338803477074037, 'Test: Negative case: Number(2), String. Non-boolean string for cumulative returns #VALUE!. 3 of 3 arguments used.');
		// Case #22: Number(2), Empty. Missing cumulative argument returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07338803477074037, 'Test: Negative case: Number(2), Empty. Missing cumulative argument returns #VALUE!. 2 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number(2), Boolean. Minimum deg_freedom (1), x at mean of distribution. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2), Boolean. Minimum deg_freedom (1), x at mean of distribution. 3 of 3 arguments used.');
		// Case #2: Number(2), Boolean. Smallest positive x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(1E-307,1E6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(1E-307,1E6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2), Boolean. Smallest positive x, large deg_freedom. 3 of 3 arguments used.');
		// Case #3: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(1E+307,1E6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(1E+307,1E6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.');
		// Case #4: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.2T(-1E+307,1E6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.2T(-1E+307,1E6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.');

		// Need to fix: area handle, error types diff, diff results from MS
		// Case #7: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.
		// Case #8: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		// Case #9: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #13: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #16: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		// Case #17: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #3: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.



		testArrayFormula2(assert, "T.DIST.2T", 2, 2);
	});

	QUnit.test("Test: \"T.DIST.RT\"", function (assert) {
		ws.getRange2("A2").setValue("1.959999998");
		ws.getRange2("A3").setValue("60");

		oParser = new parserFormula("T.DIST.RT(A2,A3)", "A1", ws);
		assert.ok(oParser.parse(), "T.DIST.RT(A2,A3)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.027322, "T.DIST.RT(A2,A3)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:F10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2



		// Positive cases:
		// Case #1: Number(2), Boolean. Valid numeric inputs, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Positive case: Number(2), Boolean. Valid numeric inputs, cumulative TRUE. 3 of 3 arguments used.');
		// Case #2: Number(2), Boolean. Float x, integer deg_freedom, cumulative FALSE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(1.5,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(1.5,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09695184012123674, 'Test: Positive case: Number(2), Boolean. Float x, integer deg_freedom, cumulative FALSE. 3 of 3 arguments used.');
		// Case #3: String(2), Boolean. String convertible to numbers, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT("2","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT("2","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Positive case: String(2), Boolean. String convertible to numbers, cumulative TRUE. 3 of 3 arguments used.');
		// Case #4: Formula(2), Boolean. Nested formulas for x and deg_freedom, cumulative TRUE. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(SQRT(4),ROUND(10.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(SQRT(4),ROUND(10.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.035401977534017255, 'Test: Positive case: Formula(2), Boolean. Nested formulas for x and deg_freedom, cumulative TRUE. 3 of 3 arguments used.');
		// Case #5: Formula, Number, Boolean. Nested IF for x, valid deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(IF(TRUE,2,1),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(IF(TRUE,2,1),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.050969739414929174, 'Test: Positive case: Formula, Number, Boolean. Nested IF for x, valid deg_freedom. 3 of 3 arguments used.');
		// Case #6: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(A100,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(A100,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3139468028714863, 'Test: Positive case: Reference link, Number, Boolean. Reference link for x, valid inputs. 3 of 3 arguments used.');
		// Case #7: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.147583618, 'Test: Positive case: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.');
		// Case #8: Area, Number, Boolean. Single-cell range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(A102:A102,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(A102:A102,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3139468028714863, 'Test: Positive case: Area, Number, Boolean. Single-cell range for x. 3 of 3 arguments used.');
		// Case #9: Number, Area, Boolean. Single-cell range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Area, Boolean. Single-cell range for deg_freedom. 3 of 3 arguments used.');
		// Case #10: Array, Number, Boolean. Single-element array for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT({2},10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT({2},10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Positive case: Array, Number, Boolean. Single-element array for x. 3 of 3 arguments used.');
		// Case #11: Number, Array, Boolean. Single-element array for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,{5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,{5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.050969739414929174, 'Test: Positive case: Number, Array, Boolean. Single-element array for deg_freedom. 3 of 3 arguments used.');
		// Case #12: Name, Number, Boolean. Named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(TestName,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(TestName,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6860531971285138, 'Test: Positive case: Name, Number, Boolean. Named range for x. 3 of 3 arguments used.');
		// Case #13: Number, Name, Boolean. Named range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Name, Boolean. Named range for deg_freedom. 3 of 3 arguments used.');
		// Case #14: Ref3D, Number, Boolean. 3D reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(Sheet2!A1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(Sheet2!A1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.17044656615103024, 'Test: Positive case: Ref3D, Number, Boolean. 3D reference for x. 3 of 3 arguments used.');
		// Case #15: Number, Ref3D, Boolean. 3D reference for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09175170953613698, 'Test: Positive case: Number, Ref3D, Boolean. 3D reference for deg_freedom. 3 of 3 arguments used.');
		// Case #16: Area3D, Number, Boolean. 3D single-cell range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(Sheet2!A3:A3,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(Sheet2!A3:A3,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D, Number, Boolean. 3D single-cell range for x. 3 of 3 arguments used.');
		// Case #17: Number, Area3D, Boolean. 3D single-cell range for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Area3D, Boolean. 3D single-cell range for deg_freedom. 3 of 3 arguments used.');
		// Case #18: Table, Number, Boolean. Table reference for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(Table1[Column1],10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(Table1[Column1],10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.17044656615103024, 'Test: Positive case: Table, Number, Boolean. Table reference for x. 3 of 3 arguments used.');
		// Case #19: Number, Table, Boolean. Table reference for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1475836176504333, 'Test: Positive case: Number, Table, Boolean. Table reference for deg_freedom. 3 of 3 arguments used.');
		// Case #20: Formula, Number, Boolean. T.DIST with nested SUM for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(SUM(1,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(SUM(1,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Positive case: Formula, Number, Boolean. T.DIST with nested SUM for x. 3 of 3 arguments used.');
		// Case #21: Date, Number, Boolean. Date as serial number for x (large number). 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(DATE(2025,1,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(DATE(2025,1,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.1253721746486217e-43, 'Test: Positive case: Date, Number, Boolean. Date as serial number for x (large number). 3 of 3 arguments used.');
		// Case #22: Time, Number, Boolean. Time adjusted to valid number for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(TIME(12,0,0)+1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(TIME(12,0,0)+1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09695184012123674, 'Test: Positive case: Time, Number, Boolean. Time adjusted to valid number for x. 3 of 3 arguments used.');
		// Case #23: Formula(3). All arguments as formulas. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(SQRT(4),ROUND(10.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(SQRT(4),ROUND(10.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.035401977534017255, 'Test: Positive case: Formula(3). All arguments as formulas. 3 of 3 arguments used.');
		// Case #24: Number, Formula, Boolean. Formula for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,ABS(-5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,ABS(-5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.050969739414929174, 'Test: Positive case: Number, Formula, Boolean. Formula for deg_freedom. 3 of 3 arguments used.');
		// Case #25: Name3D, Number, Boolean. 3D named range for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(TestName3D,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(TestName3D,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6860531971285138, 'Test: Positive case: Name3D, Number, Boolean. 3D named range for x. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number(2), Boolean. deg_freedom < 1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Boolean. deg_freedom < 1 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number, Empty, Boolean. Empty deg_freedom returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Boolean. Empty deg_freedom returns #VALUE!. 2 of 3 arguments used.');
		// Case #3: Empty, Number, Boolean. Empty x returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Empty, Number, Boolean. Empty x returns #VALUE!. 2 of 3 arguments used.');
		// Case #4: String, Number, Boolean. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT("abc",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT("abc",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number, Boolean. Non-numeric string for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #5: Number, String, Boolean. Non-numeric string for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Boolean. Non-numeric string for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Error, Number, Boolean. Propagates #N/A error for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Boolean. Propagates #N/A error for x. 3 of 3 arguments used.');
		// Case #7: Number, Error, Boolean. Propagates #N/A error for deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Boolean. Propagates #N/A error for deg_freedom. 3 of 3 arguments used.');
		// Case #8: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(A104:A105,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(A104:A105,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.829553434, 'Test: Negative case: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,A106:A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Array, Number, Boolean. Multi-element array for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT({2,3},10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT({2,3},10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Negative case: Array, Number, Boolean. Multi-element array for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Number, Array, Boolean. Multi-element array for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,{5,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,{5,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.050969739414929174, 'Test: Negative case: Number, Array, Boolean. Multi-element array for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Name, Number, Boolean. Named range with area for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(TestNameArea2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(TestNameArea2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22115020957077075, 'Test: Negative case: Name, Number, Boolean. Named range with area for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,TestNameArea2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.147583618, 'Test: Negative case: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Ref3D, Number, Boolean. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(Sheet2!A5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(Sheet2!A5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Ref3D, Number, Boolean. 3D ref to non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Number, Ref3D, Boolean. 3D ref to non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Ref3D, Boolean. 3D ref to non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(Sheet2!A7:A8,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(Sheet2!A7:A8,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,Sheet2!A9:A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,Sheet2!A9:A10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #18: Table, Number, Boolean. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(Table1[Column2],10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(Table1[Column2],10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table, Number, Boolean. Table column with non-numeric value returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Number, Table, Boolean. Table column with non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Table, Boolean. Table column with non-numeric value for deg_freedom returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Formula, Number, Boolean. Formula resulting in #NUM! error for x. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number, Boolean. Formula resulting in #NUM! error for x. 3 of 3 arguments used.');
		// Case #21: Number(2), String. Non-boolean string for cumulative returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Negative case: Number(2), String. Non-boolean string for cumulative returns #VALUE!. 3 of 3 arguments used.');
		// Case #22: Number(2), Empty. Missing cumulative argument returns #VALUE!. 2 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03669401738537018, 'Test: Negative case: Number(2), Empty. Missing cumulative argument returns #VALUE!. 2 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number(2), Boolean. Minimum deg_freedom (1), x at mean of distribution. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number(2), Boolean. Minimum deg_freedom (1), x at mean of distribution. 3 of 3 arguments used.');
		// Case #2: Number(2), Boolean. Smallest positive x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(1E-307,1E6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(1E-307,1E6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number(2), Boolean. Smallest positive x, large deg_freedom. 3 of 3 arguments used.');
		// Case #3: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(1E+307,1E6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(1E+307,1E6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.');
		// Case #4: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.
		oParser = new parserFormula('T.DIST.RT(-1E+307,1E6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.DIST.RT(-1E+307,1E6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.');


		// Need to fix: error types diff, diff results from MS in some cases
		// Case #7: Number, Reference link, Boolean. Reference link for deg_freedom. 3 of 3 arguments used.
		// Case #8: Area, Number, Boolean. Multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		// Case #9: Number, Area, Boolean. Multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #13: Number, Name, Boolean. Named range with area for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #16: Area3D, Number, Boolean. 3D multi-cell range for x returns #VALUE!. 3 of 3 arguments used.
		// Case #17: Number, Area3D, Boolean. 3D multi-cell range for deg_freedom returns #VALUE!. 3 of 3 arguments used.
		// Case #3: Number(2), Boolean. Largest valid x, large deg_freedom. 3 of 3 arguments used.
		// Case #4: Number(2), Boolean. Largest negative x, large deg_freedom. 3 of 3 arguments used.


		testArrayFormula2(assert, "T.DIST.RT", 2, 2);
	});

	QUnit.test("Test: \"TINV\"", function (assert) {

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: probability between 0 and 1, integer degrees of freedom. 2 arguments used.
		oParser = new parserFormula('TINV(0.05,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(0.05,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Number. Basic valid input: probability between 0 and 1, integer degrees of freedom. 2 arguments used.');
		// Case #2: Number. Valid input: high probability, small degrees of freedom. 2 arguments used.
		oParser = new parserFormula('TINV(0.95,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(0.95,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06591485539302193, 'Test: Positive case: Number. Valid input: high probability, small degrees of freedom. 2 arguments used.');
		// Case #3: Formula. Nested formula for probability. 2 arguments used.
		oParser = new parserFormula('TINV(SQRT(0.0025),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(SQRT(0.0025),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Formula. Nested formula for probability. 2 arguments used.');
		// Case #4: Formula. Nested formula for degrees of freedom. 2 arguments used.
		oParser = new parserFormula('TINV(0.05,ROUND(10.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(0.05,ROUND(10.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Formula. Nested formula for degrees of freedom. 2 arguments used.');
		// Case #5: String. String convertible to valid probability. 2 arguments used.
		oParser = new parserFormula('TINV("0.05",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV("0.05",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: String. String convertible to valid probability. 2 arguments used.');
		// Case #6: String. String convertible to valid degrees of freedom. 2 arguments used.
		oParser = new parserFormula('TINV(0.05,"10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(0.05,"10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: String. String convertible to valid degrees of freedom. 2 arguments used.');
		// Case #7: Reference link. Reference to cells with valid probability and degrees of freedom. 2 arguments used.
		oParser = new parserFormula('TINV(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1', 'Test: Positive case: Reference link. Reference to cells with valid probability and degrees of freedom. 2 arguments used.');
		// Case #8: Area. Single-cell range for both arguments. 2 arguments used.
		oParser = new parserFormula('TINV(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell range for both arguments. 2 arguments used.');
		// Case #9: Array. Array with single valid element for both arguments. 2 arguments used.
		oParser = new parserFormula('TINV({0.05},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV({0.05},{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Array. Array with single valid element for both arguments. 2 arguments used.');
		// Case #10: Name. Named range for both arguments. 2 arguments used.
		oParser = new parserFormula('TINV(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range for both arguments. 2 arguments used.');
		// Case #11: Name3D. 3D named range for both arguments. 2 arguments used.
		oParser = new parserFormula('TINV(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range for both arguments. 2 arguments used.');
		// Case #12: Ref3D. 3D reference to cells with valid values. 2 arguments used.
		oParser = new parserFormula('TINV(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to cells with valid values. 2 arguments used.');
		// Case #13: Area3D. 3D single-cell range for both arguments. 2 arguments used.
		oParser = new parserFormula('TINV(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell range for both arguments. 2 arguments used.');
		// Case #14: Table. Table structured reference with valid values. 2 arguments used.
		oParser = new parserFormula('TINV(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference with valid values. 2 arguments used.');
		// Case #15: Date. Date serial number adjusted to valid probability (<1). 2 arguments used.
		oParser = new parserFormula('TINV(DATE(2025,1,1)/1E+8,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(DATE(2025,1,1)/1E+8,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.111090357087565, 'Test: Positive case: Date. Date serial number adjusted to valid probability (<1). 2 arguments used.');
		// Case #16: Time. Time value adjusted to valid probability (<1). 2 arguments used.
		oParser = new parserFormula('TINV(TIME(12,0,0)/1E+5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(TIME(12,0,0)/1E+5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.812184876359131, 'Test: Positive case: Time. Time value adjusted to valid probability (<1). 2 arguments used.');
		// Case #17: Formula. T.INV inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(TINV(0.05,10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(TINV(0.05,10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.2281388519862753, 'Test: Positive case: Formula. T.INV inside SUM formula. 2 arguments used.');
		// Case #18: Number. Probability very close to 1. 2 arguments used.
		oParser = new parserFormula('TINV(0.999999999999999,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(0.999999999999999,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.28396e-15, 'Test: Positive case: Number. Probability very close to 1. 2 arguments used.');
		// Case #19: Formula. Nested IF returning valid probability. 2 arguments used.
		oParser = new parserFormula('TINV(IF(TRUE,0.05,0.5),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(IF(TRUE,0.05,0.5),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Formula. Nested IF returning valid probability. 2 arguments used.');
		// Case #20: Array. Multi-element array with valid values. 2 arguments used.
		oParser = new parserFormula('TINV({0.05,0.95},{10,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV({0.05,0.95},{10,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Array. Multi-element array with valid values. 2 arguments used.');
		// Case #21: String. String of very small valid probability. 2 arguments used.
		oParser = new parserFormula('TINV("0.000000000000001","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV("0.000000000000001","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 86.86532165324067, 'Test: Positive case: String. String of very small valid probability. 2 arguments used.');
		// Case #22: Formula. Formula converting negative to valid probability. 2 arguments used.
		oParser = new parserFormula('TINV(ABS(-0.05),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(ABS(-0.05),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Formula. Formula converting negative to valid probability. 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(0,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(0,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 0 returns #NUM!. 2 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Probability = 1 returns #NUM!. 2 arguments used.');
		// Case #3: Number. Negative probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(-0.05,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(-0.05,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 2 arguments used.');
		// Case #4: Number. Degrees of freedom = 0 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Degrees of freedom = 0 returns #NUM!. 2 arguments used.');
		// Case #5: Number. Negative degrees of freedom returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(0.05,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(0.05,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative degrees of freedom returns #NUM!. 2 arguments used.');
		// Case #6: String. Non-numeric string for probability returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TINV("abc",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV("abc",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for probability returns #VALUE!. 2 arguments used.');
		// Case #7: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('TINV(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #8: Area. Multi-cell range for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(A104:A105,A106:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(A104:A105,A106:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range for probability returns #NUM!. 2 arguments used.');
		// Case #9: Empty. Empty reference for probability returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TINV(A107,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(A107,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty reference for probability returns #VALUE!. 2 arguments used.');
		// Case #10: Boolean. Boolean TRUE for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(TRUE,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(TRUE,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean TRUE for probability returns #NUM!. 2 arguments used.');
		// Case #11: Ref3D. 3D ref to text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TINV(Sheet2!A5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(Sheet2!A5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 2 arguments used.');
		// Case #12: Name. Named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TINV(TestNameArea2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(TestNameArea2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2601848294920794, 'Test: Negative case: Name. Named range with text returns #VALUE!. 2 arguments used.');
		// Case #13: Name3D. 3D named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TINV(TestNameArea3D2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(TestNameArea3D2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2601848294920794, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 2 arguments used.');
		// Case #14: Table. Table column with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TINV(Table1[Column2],10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(Table1[Column2],10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 2 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 2 arguments used.
		oParser = new parserFormula('TINV(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 arguments used.');
		// Case #16: Array. Array with boolean for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV({FALSE},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV({FALSE},{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean for probability returns #NUM!. 2 arguments used.');
		// Case #17: Number. Probability slightly above 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(1.000000000000001,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(1.000000000000001,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Negative case: Number. Probability slightly above 1 returns #NUM!. 2 arguments used.');
		// Case #18: Number. Degrees of freedom too small returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(0.05,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(0.05,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Degrees of freedom too small returns #NUM!. 2 arguments used.');
		// Case #19: String. String convertible to probability > 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV("1.5",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV("1.5",10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.699812061, 'Test: Negative case: String. String convertible to probability > 1 returns #NUM!. 2 arguments used.');
		// Case #20: Date. Date serial number too large for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TINV(DATE(2025,1,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(DATE(2025,1,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date serial number too large for probability returns #NUM!. 2 arguments used.');
		// Case #21: Time. Time value (0.5) valid but tested for completeness. 2 arguments used.
		oParser = new parserFormula('TINV(TIME(12,0,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(TIME(12,0,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6998120613124318, 'Test: Negative case: Time. Time value (0.5) valid but tested for completeness. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability (>0) and minimum degrees of freedom (1). 2 arguments used.
		oParser = new parserFormula('TINV(1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(1E-307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6.3662e+306, 'Test: Bounded case: Number. Minimum valid probability (>0) and minimum degrees of freedom (1). 2 arguments used.');
		// Case #2: Number. Maximum valid probability (<1) and maximum degrees of freedom. 2 arguments used.
		oParser = new parserFormula('TINV(1-1E-307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TINV(1-1E-307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid probability (<1) and maximum degrees of freedom. 2 arguments used.');

		// Need to fix: string handle, results diff from MS, error types diff, bounded cases diff
		// Case #18: Number. Probability very close to 1. 2 arguments used.
		// Case #8: Area. Multi-cell range for probability returns #NUM!. 2 arguments used.
		// Case #18: Number. Degrees of freedom too small returns #NUM!. 2 arguments used.
		// Case #19: String. String convertible to probability > 1 returns #NUM!. 2 arguments used.
		// Case #1: Number. Minimum valid probability (>0) and minimum degrees of freedom (1). 2 arguments used.
		// Case #2: Number. Maximum valid probability (<1) and maximum degrees of freedom. 2 arguments used.


		testArrayFormula2(assert, "TINV", 2, 2, null, true);
	});

	QUnit.test("Test: \"T.INV\"", function (assert) {
		oParser = new parserFormula("T.INV(0.75,2)", "A1", ws);
		assert.ok(oParser.parse(), "T.INV(0.75,2)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.8164966, "T.INV(0.75,2)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: probability between 0 and 1, integer degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV(0.05,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(0.05,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8124611228116752, 'Test: Positive case: Number. Basic valid input: probability between 0 and 1, integer degrees of freedom. 2 arguments used.');
		// Case #2: Number. Valid input: high probability, small degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV(0.95,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(0.95,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.0150483733330233, 'Test: Positive case: Number. Valid input: high probability, small degrees of freedom. 2 arguments used.');
		// Case #3: Formula. Nested formula for probability. 2 arguments used.
		oParser = new parserFormula('T.INV(SQRT(0.0025),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(SQRT(0.0025),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8124611228116752, 'Test: Positive case: Formula. Nested formula for probability. 2 arguments used.');
		// Case #4: Formula. Nested formula for degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV(0.05,ROUND(10.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(0.05,ROUND(10.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8124611228116752, 'Test: Positive case: Formula. Nested formula for degrees of freedom. 2 arguments used.');
		// Case #5: String. String convertible to valid probability. 2 arguments used.
		oParser = new parserFormula('T.INV("0.05",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV("0.05",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8124611228116752, 'Test: Positive case: String. String convertible to valid probability. 2 arguments used.');
		// Case #6: String. String convertible to valid degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV(0.05,"10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(0.05,"10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8124611228116752, 'Test: Positive case: String. String convertible to valid degrees of freedom. 2 arguments used.');
		// Case #7: Reference link. Reference to cells with valid probability and degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cells with valid probability and degrees of freedom. 2 arguments used.');
		// Case #8: Area. Single-cell range for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell range for both arguments. 2 arguments used.');
		// Case #9: Array. Array with single valid element for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV({0.05},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV({0.05},{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8124611228116752, 'Test: Positive case: Array. Array with single valid element for both arguments. 2 arguments used.');
		// Case #10: Name. Named range for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV(TestName,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(TestName,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range for both arguments. 2 arguments used.');
		// Case #11: Name3D. 3D named range for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range for both arguments. 2 arguments used.');
		// Case #12: Ref3D. 3D reference to cells with valid values. 2 arguments used.
		oParser = new parserFormula('T.INV(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cells with valid values. 2 arguments used.');
		// Case #13: Area3D. 3D single-cell range for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell range for both arguments. 2 arguments used.');
		// Case #14: Table. Table structured reference with valid values. 2 arguments used.
		oParser = new parserFormula('T.INV(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with valid values. 2 arguments used.');
		// Case #15: Date. Date serial number adjusted to valid probability (<1). 2 arguments used.
		oParser = new parserFormula('T.INV(DATE(2025,1,1)/1E+8,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(DATE(2025,1,1)/1E+8,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4.646313650614316, 'Test: Positive case: Date. Date serial number adjusted to valid probability (<1). 2 arguments used.');
		// Case #16: Time. Time value adjusted to valid probability (<1). 2 arguments used.
		oParser = new parserFormula('T.INV(TIME(12,0,0)/1E+5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(TIME(12,0,0)/1E+5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -8.150286558897218, 'Test: Positive case: Time. Time value adjusted to valid probability (<1). 2 arguments used.');
		// Case #17: Formula. T.INV inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(T.INV(0.05,10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(T.INV(0.05,10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.8124611228116752, 'Test: Positive case: Formula. T.INV inside SUM formula. 2 arguments used.');
		// Case #18: Number. Probability very close to 1. 2 arguments used.
		oParser = new parserFormula('T.INV(0.999999999999999,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(0.999999999999999,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 81.04738019, 'Test: Positive case: Number. Probability very close to 1. 2 arguments used.');
		// Case #19: Formula. Nested IF returning valid probability. 2 arguments used.
		oParser = new parserFormula('T.INV(IF(TRUE,0.05,0.5),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(IF(TRUE,0.05,0.5),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8124611228116752, 'Test: Positive case: Formula. Nested IF returning valid probability. 2 arguments used.');
		// Case #20: Array. Multi-element array with valid values. 2 arguments used.
		oParser = new parserFormula('T.INV({0.05,0.95},{10,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV({0.05,0.95},{10,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8124611228116752, 'Test: Positive case: Array. Multi-element array with valid values. 2 arguments used.');
		// Case #21: String. String of very small valid probability. 2 arguments used.
		oParser = new parserFormula('T.INV("0.000000000000001","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV("0.000000000000001","10") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -81.04089088, 'Test: Positive case: String. String of very small valid probability. 2 arguments used.');
		// Case #22: Formula. Formula converting negative to valid probability. 2 arguments used.
		oParser = new parserFormula('T.INV(ABS(-0.05),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(ABS(-0.05),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8124611228116752, 'Test: Positive case: Formula. Formula converting negative to valid probability. 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(0,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(0,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 0 returns #NUM!. 2 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 1 returns #NUM!. 2 arguments used.');
		// Case #3: Number. Negative probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(-0.05,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(-0.05,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 2 arguments used.');
		// Case #4: Number. Degrees of freedom = 0 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Degrees of freedom = 0 returns #NUM!. 2 arguments used.');
		// Case #5: Number. Negative degrees of freedom returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(0.05,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(0.05,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative degrees of freedom returns #NUM!. 2 arguments used.');
		// Case #6: String. Non-numeric string for probability returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV("abc",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV("abc",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for probability returns #VALUE!. 2 arguments used.');
		// Case #7: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('T.INV(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #8: Area. Multi-cell range for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(A104:A105,A106:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(A104:A105,A106:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range for probability returns #NUM!. 2 arguments used.');
		// Case #9: Empty. Empty reference for probability returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV(A107,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(A107,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty reference for probability returns #VALUE!. 2 arguments used.');
		// Case #10: Boolean. Boolean TRUE for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(TRUE,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(TRUE,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean TRUE for probability returns #NUM!. 2 arguments used.');
		// Case #11: Ref3D. 3D ref to text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV(Sheet2!A5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(Sheet2!A5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 2 arguments used.');
		// Case #12: Name. Named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV(TestNameArea2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(TestNameArea2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8790578285505887, 'Test: Negative case: Name. Named range with text returns #VALUE!. 2 arguments used.');
		// Case #13: Name3D. 3D named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV(TestNameArea3D2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(TestNameArea3D2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8790578285505887, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 2 arguments used.');
		// Case #14: Table. Table column with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV(Table1[Column2],10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(Table1[Column2],10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 2 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 2 arguments used.
		oParser = new parserFormula('T.INV(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 arguments used.');
		// Case #16: Array. Array with boolean for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV({FALSE},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV({FALSE},{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean for probability returns #NUM!. 2 arguments used.');
		// Case #17: Number. Probability slightly above 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(1.000000000000001,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(1.000000000000001,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability slightly above 1 returns #NUM!. 2 arguments used.');
		// Case #18: Number. Degrees of freedom too small returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(0.05,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(0.05,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Degrees of freedom too small returns #NUM!. 2 arguments used.');
		// Case #19: String. String convertible to probability > 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV("1.5",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV("1.5",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String convertible to probability > 1 returns #NUM!. 2 arguments used.');
		// Case #20: Date. Date serial number too large for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV(DATE(2025,1,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(DATE(2025,1,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date serial number too large for probability returns #NUM!. 2 arguments used.');
		// Case #21: Time. Time value (0.5) valid but tested for completeness. 2 arguments used.
		oParser = new parserFormula('T.INV(TIME(12,0,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(TIME(12,0,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Time. Time value (0.5) valid but tested for completeness. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability (>0) and minimum degrees of freedom (1). 2 arguments used.
		oParser = new parserFormula('T.INV(1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(1E-307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -3.1831e+306, 'Test: Bounded case: Number. Minimum valid probability (>0) and minimum degrees of freedom (1). 2 arguments used.');
		// Case #2: Number. Maximum valid probability (<1) and maximum degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV(1-1E-307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV(1-1E-307,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid probability (<1) and maximum degrees of freedom. 2 arguments used.');

		// Need to fix: error types diff, results diff from MS
		// Case #18: Number. Probability very close to 1. 2 arguments used.
		// Case #21: String. String of very small valid probability. 2 arguments used.
		// Case #8: Area. Multi-cell range for probability returns #NUM!. 2 arguments used.
		// Case #18: Number. Degrees of freedom too small returns #NUM!. 2 arguments used.
		// Case #1: Number. Minimum valid probability (>0) and minimum degrees of freedom (1). 2 arguments used.

		testArrayFormula2(assert, "T.INV", 2, 2);
	});

	QUnit.test("Test: \"T.INV.2T\"", function (assert) {
		ws.getRange2("A2").setValue("0.546449");
		ws.getRange2("A3").setValue("60");

		oParser = new parserFormula("T.INV.2T(A2,A3)", "A1", ws);
		assert.ok(oParser.parse(), "T.INV.2T(A2,A3)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.606533, "T.INV.2T(A2,A3)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: probability between 0 and 1, integer degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(0.05,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(0.05,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Number. Basic valid input: probability between 0 and 1, integer degrees of freedom. 2 arguments used.');
		// Case #2: Number. Valid input: high probability, small degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(0.95,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(0.95,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06591485539302193, 'Test: Positive case: Number. Valid input: high probability, small degrees of freedom. 2 arguments used.');
		// Case #3: Formula. Nested formula for probability. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(SQRT(0.0025),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(SQRT(0.0025),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Formula. Nested formula for probability. 2 arguments used.');
		// Case #4: Formula. Nested formula for degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(0.05,ROUND(10.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(0.05,ROUND(10.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Formula. Nested formula for degrees of freedom. 2 arguments used.');
		// Case #5: String. String convertible to valid probability. 2 arguments used.
		oParser = new parserFormula('T.INV.2T("0.05",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T("0.05",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: String. String convertible to valid probability. 2 arguments used.');
		// Case #6: String. String convertible to valid degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(0.05,"10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(0.05,"10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: String. String convertible to valid degrees of freedom. 2 arguments used.');
		// Case #7: Reference link. Reference to cells with valid probability and degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(A100,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. Reference to cells with valid probability and degrees of freedom. 2 arguments used.');
		// Case #8: Area. Single-cell range for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell range for both arguments. 2 arguments used.');
		// Case #9: Array. Array with single valid element for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV.2T({0.05},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T({0.05},{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Array. Array with single valid element for both arguments. 2 arguments used.');
		// Case #10: Name. Named range for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range for both arguments. 2 arguments used.');
		// Case #11: Name3D. 3D named range for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range for both arguments. 2 arguments used.');
		// Case #12: Ref3D. 3D reference to cells with valid values. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to cells with valid values. 2 arguments used.');
		// Case #13: Area3D. 3D single-cell range for both arguments. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell range for both arguments. 2 arguments used.');
		// Case #14: Table. Table structured reference with valid values. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference with valid values. 2 arguments used.');
		// Case #15: Date. Date serial number adjusted to valid probability (<1). 2 arguments used.
		oParser = new parserFormula('T.INV.2T(DATE(2025,1,1)/1E+8,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(DATE(2025,1,1)/1E+8,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5.111090357087565, 'Test: Positive case: Date. Date serial number adjusted to valid probability (<1). 2 arguments used.');
		// Case #16: Time. Time value adjusted to valid probability (<1). 2 arguments used.
		oParser = new parserFormula('T.INV.2T(TIME(12,0,0)/1E+5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(TIME(12,0,0)/1E+5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.812184876359131, 'Test: Positive case: Time. Time value adjusted to valid probability (<1). 2 arguments used.');
		// Case #17: Formula. T.INV inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(T.INV.2T(0.05,10),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(T.INV.2T(0.05,10),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.2281388519862753, 'Test: Positive case: Formula. T.INV inside SUM formula. 2 arguments used.');
		// Case #18: Number. Probability very close to 1. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(0.999999999999999,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(0.999999999999999,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.28396e-15, 'Test: Positive case: Number. Probability very close to 1. 2 arguments used.');
		// Case #19: Formula. Nested IF returning valid probability. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(IF(TRUE,0.05,0.5),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(IF(TRUE,0.05,0.5),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Formula. Nested IF returning valid probability. 2 arguments used.');
		// Case #20: Array. Multi-element array with valid values. 2 arguments used.
		oParser = new parserFormula('T.INV.2T({0.05,0.95},{10,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T({0.05,0.95},{10,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Array. Multi-element array with valid values. 2 arguments used.');
		// Case #21: String. String of very small valid probability. 2 arguments used.
		oParser = new parserFormula('T.INV.2T("0.000000000000001","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T("0.000000000000001","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 86.86532165324067, 'Test: Positive case: String. String of very small valid probability. 2 arguments used.');
		// Case #22: Formula. Formula converting negative to valid probability. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(ABS(-0.05),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(ABS(-0.05),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.2281388519862753, 'Test: Positive case: Formula. Formula converting negative to valid probability. 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Probability = 0 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(0,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(0,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Probability = 0 returns #NUM!. 2 arguments used.');
		// Case #2: Number. Probability = 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Probability = 1 returns #NUM!. 2 arguments used.');
		// Case #3: Number. Negative probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(-0.05,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(-0.05,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative probability returns #NUM!. 2 arguments used.');
		// Case #4: Number. Degrees of freedom = 0 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Degrees of freedom = 0 returns #NUM!. 2 arguments used.');
		// Case #5: Number. Negative degrees of freedom returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(0.05,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(0.05,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative degrees of freedom returns #NUM!. 2 arguments used.');
		// Case #6: String. Non-numeric string for probability returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T("abc",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T("abc",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for probability returns #VALUE!. 2 arguments used.');
		// Case #7: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #8: Area. Multi-cell range for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(A104:A105,A106:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(A104:A105,A106:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range for probability returns #NUM!. 2 arguments used.');
		// Case #9: Empty. Empty reference for probability returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(A107,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(A107,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty reference for probability returns #VALUE!. 2 arguments used.');
		// Case #10: Boolean. Boolean TRUE for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(TRUE,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(TRUE,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean TRUE for probability returns #NUM!. 2 arguments used.');
		// Case #11: Ref3D. 3D ref to text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(Sheet2!A5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(Sheet2!A5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 2 arguments used.');
		// Case #12: Name. Named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(TestNameArea2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(TestNameArea2,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2601848294920794, 'Test: Negative case: Name. Named range with text returns #VALUE!. 2 arguments used.');
		// Case #13: Name3D. 3D named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(TestNameArea3D2,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(TestNameArea3D,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2601848294920794, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 2 arguments used.');
		// Case #14: Table. Table column with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(Table1[Column2],10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(Table1[Column2],10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 2 arguments used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 2 arguments used.');
		// Case #16: Array. Array with boolean for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T({FALSE},{10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T({FALSE},{10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with boolean for probability returns #NUM!. 2 arguments used.');
		// Case #17: Number. Probability slightly above 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(1.000000000000001,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(1.000000000000001,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Probability slightly above 1 returns #NUM!. 2 arguments used.');
		// Case #18: Number. Degrees of freedom too small returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(0.05,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(0.05,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Degrees of freedom too small returns #NUM!. 2 arguments used.');
		// Case #19: String. String convertible to probability > 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T("1.5",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T("1.5",10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.699812061, 'Test: Negative case: String. String convertible to probability > 1 returns #NUM!. 2 arguments used.');
		// Case #20: Date. Date serial number too large for probability returns #NUM!. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(DATE(2025,1,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(DATE(2025,1,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date serial number too large for probability returns #NUM!. 2 arguments used.');
		// Case #21: Time. Time value (0.5) valid but tested for completeness. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(TIME(12,0,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(TIME(12,0,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6998120613124318, 'Test: Negative case: Time. Time value (0.5) valid but tested for completeness. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid probability (>0) and minimum degrees of freedom (1). 2 arguments used.
		oParser = new parserFormula('T.INV.2T(1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(1E-307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 6.3662e+306, 'Test: Bounded case: Number. Minimum valid probability (>0) and minimum degrees of freedom (1). 2 arguments used.');
		// Case #2: Number. Maximum valid probability (<1) and maximum degrees of freedom. 2 arguments used.
		oParser = new parserFormula('T.INV.2T(1-1E-307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.INV.2T(1-1E-307,1E+307) is parsed.');
		// ?assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid probability (<1) and maximum degrees of freedom. 2 arguments used.');

		// Need to fix: string hablde, error types diff, results diff from MS
		// Case #7: Reference link. Reference to cells with valid probability and degrees of freedom. 2 arguments used.
		// Case #18: Number. Probability very close to 1. 2 arguments used.
		// Case #8: Area. Multi-cell range for probability returns #NUM!. 2 arguments used.
		// Case #17: Number. Probability slightly above 1 returns #NUM!. 2 arguments used.
		// Case #18: Number. Degrees of freedom too small returns #NUM!. 2 arguments used.
		// Case #19: String. String convertible to probability > 1 returns #NUM!. 2 arguments used.
		// Case #1: Number. Minimum valid probability (>0) and minimum degrees of freedom (1). 2 arguments used.
		// Case #2: Number. Maximum valid probability (<1) and maximum degrees of freedom. 2 arguments used.


		testArrayFormula2(assert, "T.INV.2T", 2, 2);
	});

	QUnit.test("Test: \"TRIMMEAN\"", function (assert) {
		ws.getRange2("A2").setValue("4");
		ws.getRange2("A3").setValue("5");
		ws.getRange2("A4").setValue("6");
		ws.getRange2("A5").setValue("7");
		ws.getRange2("A6").setValue("2");
		ws.getRange2("A7").setValue("3");
		ws.getRange2("A8").setValue("4");
		ws.getRange2("A9").setValue("5");
		ws.getRange2("A10").setValue("1");
		ws.getRange2("A11").setValue("2");
		ws.getRange2("A12").setValue("3");

		oParser = new parserFormula("TRIMMEAN(A2:A12,0.2)", "A1", ws);
		assert.ok(oParser.parse(), "TRIMMEAN(A2:A12,0.2)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 3.778, "TRIMMEAN(A2:A12,0.2)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Array, Number. Basic valid input: array of numbers, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3,4,5},0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3,4,5},0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array, Number. Basic valid input: array of numbers, percent as number. 2 arguments used.');
		// Case #2: Array, String. Array of numbers, percent as convertible string. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3,4,5},"0.2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3,4,5},"0.2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array, String. Array of numbers, percent as convertible string. 2 arguments used.');
		// Case #3: Range, Number. Range with valid numbers, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A100:A101,0.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A100:A101,0.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Range, Number. Range with valid numbers, percent as number. 2 arguments used.');
		// Case #4: Range, String. Range with valid numbers, percent as convertible string. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A100:A101,"0.4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A100:A101,"0.4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Range, String. Range with valid numbers, percent as convertible string. 2 arguments used.');
		// Case #5: Reference link, Number. Reference to single cell with valid number, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A100,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A100,0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Number. Reference to single cell with valid number, percent as number. 2 arguments used.');
		// Case #6: Reference link, Formula. Reference to single cell, percent via IF formula. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A100,IF(TRUE,0.2,0.1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A100,IF(TRUE,0.2,0.1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, Formula. Reference to single cell, percent via IF formula. 2 arguments used.');
		// Case #7: Name, Number. Named range with valid numbers, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(TestName,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(TestName,0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name, Number. Named range with valid numbers, percent as number. 2 arguments used.');
		// Case #8: Name3D, Number. 3D named range with valid numbers, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(TestName3D,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(TestName3D,0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D, Number. 3D named range with valid numbers, percent as number. 2 arguments used.');
		// Case #9: Ref3D, Number. 3D reference to cell with valid number, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(Sheet2!A1,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(Sheet2!A1,0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D, Number. 3D reference to cell with valid number, percent as number. 2 arguments used.');
		// Case #10: Area3D, Number. 3D range with valid numbers, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(Sheet2!A1:A2,0.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(Sheet2!A1:A2,0.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area3D, Number. 3D range with valid numbers, percent as number. 2 arguments used.');
		// Case #11: Table, Number. Table structured reference with valid numbers, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(Table1[Column1],0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(Table1[Column1],0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table, Number. Table structured reference with valid numbers, percent as number. 2 arguments used.');
		// Case #12: Date, Number. Dates as serial numbers, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({45658,45659},0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({45658,45659},0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658.5, 'Test: Positive case: Date, Number. Dates as serial numbers, percent as number. 2 arguments used.');
		// Case #13: Time, Number. Time adjusted to valid numbers, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2},0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2},0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Time, Number. Time adjusted to valid numbers, percent as number. 2 arguments used.');
		// Case #14: Array, Formula. Array of numbers, percent via ABS formula. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3,4},ABS(-0.2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3,4},ABS(-0.2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: Array, Formula. Array of numbers, percent via ABS formula. 2 arguments used.');
		// Case #15: Range, Formula. Range with valid numbers, percent via SQRT formula. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A100:A101,SQRT(0.16))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A100:A101,SQRT(0.16)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Range, Formula. Range with valid numbers, percent via SQRT formula. 2 arguments used.');
		// Case #16: Array, String. Array of numeric strings, percent as string. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({"1","2","3"},"0.2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({"1","2","3"},"0.2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Array, String. Array of numeric strings, percent as string. 2 arguments used.');
		// Case #17: Range, Number. Two-cell range with valid numbers, small percent value. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A102:A103,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A102:A103,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Range, Number. Two-cell range with valid numbers, small percent value. 2 arguments used.');
		// Case #18: Reference link, String. Reference to single cell, percent as convertible string. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A100,"0.3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A100,"0.3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link, String. Reference to single cell, percent as convertible string. 2 arguments used.');
		// Case #19: Array, Number. Array with larger numbers, percent as number. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({10,20,30,40,50},0.25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({10,20,30,40,50},0.25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Array, Number. Array with larger numbers, percent as number. 2 arguments used.');
		// Case #20: Range, Number. Range with valid numbers, precise percent value. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A104:A105,0.333333333333333)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A104:A105,0.333333333333333) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Range, Number. Range with valid numbers, precise percent value. 2 arguments used.');

		// Negative cases:
		// Case #1: Array, Number. Percent = 1 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3},1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Percent = 1 returns #NUM!. 2 arguments used.');
		// Case #2: Array, Number. Negative percent returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3},-0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3},-0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number. Negative percent returns #NUM!. 2 arguments used.');
		// Case #3: Array, String. Non-numeric percent string returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3},"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, String. Non-numeric percent string returns #VALUE!. 2 arguments used.');
		// Case #4: Array, Error. Percent as error propagates #N/A. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3},NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3},NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array, Error. Percent as error propagates #N/A. 2 arguments used.');
		// Case #5: Range, Number. Range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A106:A107,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A106:A107,0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Range, Number. Range with text returns #VALUE!. 2 arguments used.');
		// Case #6: Array, Number. Array with non-numeric element returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({"abc",1,2},0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({"abc",1,2},0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Array, Number. Array with non-numeric element returns #VALUE!. 2 arguments used.');
		// Case #7: Empty, Number. Empty reference returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A108,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A108,0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty reference returns #VALUE!. 2 arguments used.');
		// Case #8: Array, Boolean. Boolean percent returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Boolean. Boolean percent returns #NUM!. 2 arguments used.');
		// Case #9: Array, Empty. Missing percent argument returns #VALUE!. 1 of 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3},) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Array, Empty. Missing percent argument returns #VALUE!. 1 of 2 arguments used.');
		// Case #10: Name, Number. Named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(TestNameArea2,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(TestNameArea2,0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name, Number. Named range with text returns #VALUE!. 2 arguments used.');
		// Case #11: Name3D, Number. 3D named range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(TestNameArea3D2,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(TestNameArea3D2,0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D, Number. 3D named range with text returns #VALUE!. 2 arguments used.');
		// Case #12: Ref3D, Number. 3D reference to text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(Sheet2!A3,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(Sheet2!A3,0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D, Number. 3D reference to text returns #VALUE!. 2 arguments used.');
		// Case #13: Area3D, Number. 3D range with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(Sheet2!A3:A4,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(Sheet2!A3:A4,0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D, Number. 3D range with text returns #VALUE!. 2 arguments used.');
		// Case #14: Table, Number. Table column with text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(Table1[Column2],0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(Table1[Column2],0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table, Number. Table column with text returns #VALUE!. 2 arguments used.');
		// Case #15: Array, Number. Array with boolean returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({FALSE,1,2},0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({FALSE,1,2},0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Array, Number. Array with boolean returns #VALUE!. 2 arguments used.');
		// Case #16: Array, String. Negative percent string returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3},"-0.2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3},"-0.2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, String. Negative percent string returns #NUM!. 2 arguments used.');
		// Case #17: Range, Number. Multi-cell range (>2 cells) with valid numbers returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A100:A102,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A100:A102,0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8333333333333334, 'Test: Negative case: Range, Number. Multi-cell range (>2 cells) with valid numbers returns #VALUE!. 2 arguments used.');
		// Case #18: Array, Number. Array with single element returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1},0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1},0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array, Number. Array with single element returns #NUM!. 2 arguments used.');
		// Case #19: Array, Number. Percent too large for array size returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2},0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Negative case: Array, Number. Percent too large for array size returns #NUM!. 2 arguments used.');
		// Case #20: Array, Formula. Percent formula resulting in #NUM! returns #NUM!. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1,2,3},SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1,2,3},SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Formula. Percent formula resulting in #NUM! returns #NUM!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Array, Number. Largest valid array value, smallest valid percent. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({1.79769313486232E+308,2,3},1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({1.79769313486232E+308,2,3},1E-15) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5.9923e+306, 'Test: Bounded case: Array, Number. Largest valid array value, smallest valid percent. 2 arguments used.');
		// Case #2: Array, Number. Smallest valid array value, largest valid percent. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN({-1.79769313486232E+308,2,3},0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN({-1.79769313486232E+308,2,3},0.999999999999999) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Array, Number. Smallest valid array value, largest valid percent. 2 arguments used.');
		// Case #3: Range, Number. Range with largest valid numbers, smallest valid percent. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A109:A110,1E-15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A109:A110,1E-15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Range, Number. Range with largest valid numbers, smallest valid percent. 2 arguments used.');
		// Case #4: Range, Number. Range with valid numbers, largest valid percent. 2 arguments used.
		oParser = new parserFormula('TRIMMEAN(A109:A110,0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TRIMMEAN(A109:A110,0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Range, Number. Range with valid numbers, largest valid percent. 2 arguments used.');

		// Need to fix: error types diff, results diff from MS in many cases
		// Case #5: Reference link, Number. Reference to single cell with valid number, percent as number. 2 arguments used.
		// Case #6: Reference link, Formula. Reference to single cell, percent via IF formula. 2 arguments used.
		// Case #7: Name, Number. Named range with valid numbers, percent as number. 2 arguments used.
		// Case #8: Name3D, Number. 3D named range with valid numbers, percent as number. 2 arguments used.
		// Case #9: Ref3D, Number. 3D reference to cell with valid number, percent as number. 2 arguments used.
		// Case #11: Table, Number. Table structured reference with valid numbers, percent as number. 2 arguments used.
		// Case #18: Reference link, String. Reference to single cell, percent as convertible string. 2 arguments used.
		// Case #7: Empty, Number. Empty reference returns #VALUE!. 2 arguments used.
		// Case #12: Ref3D, Number. 3D reference to text returns #VALUE!. 2 arguments used.
		// Case #14: Table, Number. Table column with text returns #VALUE!. 2 arguments used.
		// Case #1: Array, Number. Largest valid array value, smallest valid percent. 2 arguments used.
		// Case #2: Array, Number. Smallest valid array value, largest valid percent. 2 arguments used.

		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "TRIMMEAN", 2, 2);
	});

	QUnit.test("Test: \"TREND\"", function (assert) {
		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number,Number,Number,Boolean. Basic valid input: arrays with numbers, const=TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2},{1,2},{3},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2},{1,2},{3},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Positive case: Number,Number,Number,Boolean. Basic valid input: arrays with numbers, const=TRUE. 4 of 4 arguments used.');
		// Case #2: Number,Number. Valid input: arrays with numbers, new_x\'s and const omitted. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2,3},{1,2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2,3},{1,2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1, 'Test: Positive case: Number,Number. Valid input: arrays with numbers, new_x\'s and const omitted. 2 of 4 arguments used.');
		// Case #3: Reference link,Reference link. Single-cell references for known_y\'s and known_x\'s. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(A100,A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link,Reference link. Single-cell references for known_y\'s and known_x\'s. 2 of 4 arguments used.');
		// Case #4: Area,Area. Two-cell ranges for known_y\'s and known_x\'s. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area,Area. Two-cell ranges for known_y\'s and known_x\'s. 2 of 4 arguments used.');
		// Case #5: String,String. Numeric strings converted to numbers. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({"1","2"},{"1","2"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({"1","2"},{"1","2"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String,String. Numeric strings converted to numbers. 2 of 4 arguments used.');
		// Case #6: Formula,Formula. Nested formulas evaluating to numbers. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(SUM(1,1),SUM(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(SUM(1,1),SUM(2,2)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula,Formula. Nested formulas evaluating to numbers. 2 of 4 arguments used.');
		// Case #7: Formula,Formula,Formula. Nested IF formulas returning valid arrays. 3 of 4 arguments used.
		oParser = new parserFormula('TREND(IF(TRUE, {1,2}, {3,4}),IF(TRUE, {1,2}, {3,4}),{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(IF(TRUE, {1,2}, {3,4}),IF(TRUE, {1,2}, {3,4}),{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0)	.getValue(), 3, 'Test: Positive case: Formula,Formula,Formula. Nested IF formulas returning valid arrays. 3 of 4 arguments used.');
		// Case #8: Date,Date. Dates as serial numbers. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({38777,38838},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({38777,38838},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 38777, 'Test: Positive case: Date,Date. Dates as serial numbers. 2 of 4 arguments used.');
		// Case #9: Time,Time. Time values as fractions. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({0.5,0.75},{0.5,0.75})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({0.5,0.75},{0.5,0.75}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.5, 'Test: Positive case: Time,Time. Time values as fractions. 2 of 4 arguments used.');
		// Case #10: Array,Array,Array. Multi-element arrays with new_x\'s. 3 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2,3},{1,2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2,3},{1,2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 4, 'Test: Positive case: Array,Array,Array. Multi-element arrays with new_x\'s. 3 of 4 arguments used.');
		// Case #11: Name,Name. Named ranges with valid numbers. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name,Name. Named ranges with valid numbers. 2 of 4 arguments used.');
		// Case #12: Name3D,Name3D. 3D named ranges with valid numbers. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(TestName3D,TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D,Name3D. 3D named ranges with valid numbers. 2 of 4 arguments used.');
		// Case #13: Ref3D,Ref3D. 3D references to cells with valid numbers. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(Sheet2!A1,Sheet2!A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D,Ref3D. 3D references to cells with valid numbers. 2 of 4 arguments used.');
		// Case #14: Area3D,Area3D. 3D two-cell ranges. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D,Area3D. 3D two-cell ranges. 2 of 4 arguments used.');
		// Case #15: Table,Table. Table structured references with valid numbers. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table,Table. Table structured references with valid numbers. 2 of 4 arguments used.');
		// Case #16: Number,Number,Number. Float numbers in arrays. 3 of 4 arguments used.
		oParser = new parserFormula('TREND({1.5,2.5},{1,2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1.5,2.5},{1,2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3.5, 'Test: Positive case: Number,Number,Number. Float numbers in arrays. 3 of 4 arguments used.');
		// Case #18: Array,Array,Array,Boolean. Arrays with const=FALSE (zero intercept). 4 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2},{1,2},{3},FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2},{1,2},{3},FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Positive case: Array,Array,Array,Boolean. Arrays with const=FALSE (zero intercept). 4 of 4 arguments used.');
		// Case #19: String,Number. Numeric strings for known_y\'s. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({"1.5","2.5"},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({"1.5","2.5"},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String,Number. Numeric strings for known_y\'s. 2 of 4 arguments used.');
		// Case #20: Reference link,Reference link,Reference link. References with two-cell ranges and single-cell new_x\'s. 3 of 4 arguments used.
		oParser = new parserFormula('TREND(A100:A101,A102:A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(A100:A101,A102:A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link,Reference link,Reference link. References with two-cell ranges and single-cell new_x\'s. 3 of 4 arguments used.');
		// Case #21: Formula,Formula,Formula,Formula. All arguments as formulas. 4 of 4 arguments used.
		oParser = new parserFormula('TREND(ABS({-1,-2}),ABS({-1,-2}),ABS(3),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(ABS({-1,-2}),ABS({-1,-2}),ABS(3),IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Positive case: Formula,Formula,Formula,Formula. All arguments as formulas. 4 of 4 arguments used.');
		// Case #22: Array,Array. Arrays with boolean elements (converted to 1/0). 2 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2,TRUE},{1,2,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2,TRUE},{1,2,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Array,Array. Arrays with boolean elements (converted to 1/0). 2 of 4 arguments used.');
		// Case #23: Number,Number,Number. Larger numbers in known_y\'s. 3 of 4 arguments used.
		oParser = new parserFormula('TREND({10,20},{1,2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({10,20},{1,2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 30, 'Test: Positive case: Number,Number,Number. Larger numbers in known_y\'s. 3 of 4 arguments used.');
		// Case #24: Area,Area,Area. Two-cell ranges for all arguments. 3 of 4 arguments used.
		oParser = new parserFormula('TREND(A100:A101,A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(A100:A101,A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area,Area,Area. Two-cell ranges for all arguments. 3 of 4 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND("abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 of 4 arguments used.');
		// Case #2: Number. Single number (not array/range) returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number. Single number (not array/range) returns #NUM!. 1 of 4 arguments used.');
		// Case #3: Empty. Empty reference returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty. Empty reference returns #NUM!. 1 of 4 arguments used.');
		// Case #4: Error. Propagates #N/A error. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 of 4 arguments used.');
		// Case #5: String,Number. Non-numeric string in known_y\'s returns #VALUE!. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({"abc","2"},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({"abc","2"},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Number. Non-numeric string in known_y\'s returns #VALUE!. 2 of 4 arguments used.');
		// Case #6: Number,Number. Collinear points return #NUM!. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({1,1},{1,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,1},{1,1}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number,Number. Collinear points return #NUM!. 2 of 4 arguments used.');
		// Case #7: Area. Multi-cell range with invalid data returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0.8333333333333334, 'Test: Negative case: Area. Multi-cell range with invalid data returns #VALUE!. 1 of 4 arguments used.');
		// Case #8: Boolean. Boolean FALSE (0) returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE (0) returns #NUM!. 1 of 4 arguments used.');
		// Case #9: Ref3D. 3D ref to text returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 1 of 4 arguments used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(1), '0.8', 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 of 4 arguments used.');
		// Case #11: Table. Table column with text returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 of 4 arguments used.');
		// Case #12: Formula. Formula resulting in #NUM! error. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 of 4 arguments used.');
		// Case #13: Array. Array with boolean returns #NUM!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #NUM!. 1 of 4 arguments used.');
		// Case #14: Number,Number,Number. Large negative numbers in known_y\'s return #NUM!. 3 of 4 arguments used.
		oParser = new parserFormula('TREND({-1E+307,-1E+307},{1,2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({-1E+307,-1E+307},{1,2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), -1e+307, 'Test: Negative case: Number,Number,Number. Large negative numbers in known_y\'s return #NUM!. 3 of 4 arguments used.');
		// Case #15: Area,Area. Mismatched range sizes return #NUM!. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(A100:A102,A103:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(A100:A102,A103:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area,Area. Mismatched range sizes return #NUM!. 2 of 4 arguments used.');
		// Case #16: String. Empty string returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 1 of 4 arguments used.');
		// Case #17: Formula,Number,Number,Number. Invalid const (number) returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2},{1,2},{3},1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2},{1,2},{3},1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Negative case: Formula,Number,Number,Number. Invalid const (number) returns #VALUE!. 4 of 4 arguments used.');
		// Case #18: Array,Array. Mismatched array sizes return #NUM!. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({1},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1},{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array,Array. Mismatched array sizes return #NUM!. 2 of 4 arguments used.');
		// Case #19: Name3D. 3D named range with text returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue().toFixed(1), '0.8', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 of 4 arguments used.');
		// Case #20: Area3D. 3D range with invalid data returns #VALUE!. 1 of 4 arguments used.
		oParser = new parserFormula('TREND(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D range with invalid data returns #VALUE!. 1 of 4 arguments used.');
		// Case #21: Formula,Number. Formula resulting in #DIV/0! propagates error. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(MMULT(1,0),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(MMULT(1,0),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Formula,Number. Formula resulting in #DIV/0! propagates error. 2 of 4 arguments used.');
		// Case #22: Number,Number,Empty. Empty new_x\'s reference returns #NUM!. 3 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2},{1,2},A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2},{1,2},A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), '#VALUE!', 'Test: Negative case: Number,Number,Empty. Empty new_x\'s reference returns #NUM!. 3 of 4 arguments used.');
		// Case #23: Number,Number,String. Non-numeric new_x\'s returns #VALUE!. 3 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2},{1,2},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2},{1,2},"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Number,String. Non-numeric new_x\'s returns #VALUE!. 3 of 4 arguments used.');
		// Case #24: Area3D,Area3D. 3D ranges with mismatched sizes return #NUM!. 2 of 4 arguments used.
		oParser = new parserFormula('TREND(Sheet2!A1:A3,Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND(Sheet2!A1:A3,Sheet2!A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D,Area3D. 3D ranges with mismatched sizes return #NUM!. 2 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number,Number. Max valid Excel number for known_y\'s. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({9.99999999999999E+307},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({9.99999999999999E+307},{1}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number,Number. Max valid Excel number for known_y\'s. 2 of 4 arguments used.');
		// Case #2: Number,Number. Min positive Excel number for known_y\'s. 2 of 4 arguments used.
		oParser = new parserFormula('TREND({2.2250738585072014E-308},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({2.2250738585072014E-308},{1}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number,Number. Min positive Excel number for known_y\'s. 2 of 4 arguments used.');
		// Case #3: Number,Number,Number,Boolean. Max valid new_x\'s value. 4 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2},{1,2},{9.99999999999999E+307},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2},{1,2},{9.99999999999999E+307},TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 1e+308, 'Test: Bounded case: Number,Number,Number,Boolean. Max valid new_x\'s value. 4 of 4 arguments used.');
		// Case #4: Number,Number,Number,Boolean. Min positive new_x\'s value with const=FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('TREND({1,2},{1,2},{2.2250738585072014E-308},FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TREND({1,2},{1,2},{2.2250738585072014E-308},FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Bounded case: Number,Number,Number,Boolean. Min positive new_x\'s value with const=FALSE. 4 of 4 arguments used.');

		// Need to fix: many different results from ms, error types diff and args handle
		// Case #3: Reference link,Reference link. Single-cell references for known_y\'s and known_x\'s. 2 of 4 arguments used.
		// Case #6: Formula,Formula. Nested formulas evaluating to numbers. 2 of 4 arguments used.
		// Case #11: Name,Name. Named ranges with valid numbers. 2 of 4 arguments used.
		// Case #12: Name3D,Name3D. 3D named ranges with valid numbers. 2 of 4 arguments used.
		// Case #13: Ref3D,Ref3D. 3D references to cells with valid numbers. 2 of 4 arguments used.
		// Case #15: Table,Table. Table structured references with valid numbers. 2 of 4 arguments used.
		// Case #1: String. Non-numeric string returns #VALUE!. 1 of 4 arguments used.
		// Case #2: Number. Single number (not array/range) returns #NUM!. 1 of 4 arguments used.
		// Case #6: Number,Number. Collinear points return #NUM!. 2 of 4 arguments used.
		// Case #8: Boolean. Boolean FALSE (0) returns #NUM!. 1 of 4 arguments used.
		// Case #16: String. Empty string returns #VALUE!. 1 of 4 arguments used.
		// Case #18: Array,Array. Mismatched array sizes return #NUM!. 2 of 4 arguments used.
		// Case #21: Formula,Number. Formula resulting in #DIV/0! propagates error. 2 of 4 arguments used.

	});

	QUnit.test("Test: \"TREND2\"", function (assert) {

		ws.getRange2("A2").setValue("11");
		ws.getRange2("A3").setValue("12");
		ws.getRange2("A4").setValue("13");
		ws.getRange2("A5").setValue("14");
		ws.getRange2("A6").setValue("15");
		ws.getRange2("A7").setValue("16");

		ws.getRange2("B2").setValue("33100");
		ws.getRange2("B3").setValue("47300");
		ws.getRange2("B4").setValue("69000");
		ws.getRange2("B5").setValue("102000");
		ws.getRange2("B6").setValue("150000");
		ws.getRange2("B7").setValue("220000");

		ws.getRange2("C2").setValue("32618");
		ws.getRange2("C3").setValue("47729");
		ws.getRange2("C4").setValue("69841");
		ws.getRange2("C5").setValue("102197");
		ws.getRange2("C6").setValue("149542");
		ws.getRange2("C7").setValue("218822");

		ws.getRange2("A9").setValue("17");
		ws.getRange2("A10").setValue("18");

		oParser = new parserFormula("TREND(B2:B7,A2:A7,A9:A10)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 231126.67);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(2) - 0, 267572.38);

		oParser = new parserFormula("TREND(B2:B7,A2:A7)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 12452.38);
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(2) - 0, 48898.1);
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue().toFixed(2) - 0, 85343.81);
		assert.strictEqual(oParser.calculate().getElementRowCol(3, 0).getValue().toFixed(2) - 0, 121789.52);
		assert.strictEqual(oParser.calculate().getElementRowCol(4, 0).getValue().toFixed(2) - 0, 158235.24);
		assert.strictEqual(oParser.calculate().getElementRowCol(5, 0).getValue().toFixed(2) - 0, 194680.95);

		oParser = new parserFormula("TREND(A2:C2,A3:C4,A5:C6,1)", "A2", ws);
		assert.ok(oParser.parse(), "TREND(A2:C2,A3:C4,A5:C6,1)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 15.74, "Result of TREND(A2:C2,A3:C4,A5:C6,1)[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(2) - 0, 67013.18, "Result of TREND(A2:C2,A3:C4,A5:C6,1)[0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 2).getValue().toFixed(2) - 0, 69861.01, "Result of TREND(A2:C2,A3:C4,A5:C6,1)[0,2]");

		oParser = new parserFormula("TREND(A3:C3,A4:C5,A6:C7,1)", "A2", ws);
		assert.ok(oParser.parse(), "TREND(A3:C3,A4:C5,A6:C7,1)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 13.24, "Result of TREND(A3:C3,A4:C5,A6:C7,1)[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(2) - 0, 102576.47, "Result of TREND(A3:C3,A4:C5,A6:C7,1)[0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 2).getValue().toFixed(2) - 0, 102191.92, "Result of TREND(A3:C3,A4:C5,A6:C7,1)[0,2]");


		oParser = new parserFormula("TREND(A3:C3,A4:C5,A6:C7,0)", "A2", ws);
		assert.ok(oParser.parse(), "TREND(A3:C3,A4:C5,A6:C7,0)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 9.41, "Result of TREND(A3:C3,A4:C5,A6:C7,0)[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(2) - 0, 102580.9, "Result of TREND(A3:C3,A4:C5,A6:C7,0)[0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 2).getValue().toFixed(2) - 0, 102196.32, "Result of TREND(A3:C3,A4:C5,A6:C7,0)[0,2]");

		oParser = new parserFormula("TREND({1,2,3},A4:C5,A6:C7,1)", "A2", ws);
		assert.ok(oParser.parse(), "TREND({1,2,3},A4:C5,A6:C7,1)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 1, "Result of TREND({1,2,3},A4:C5,A6:C7,1)[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(2) - 0, 4.82, "Result of TREND({1,2,3},A4:C5,A6:C7,1)[0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 2).getValue().toFixed(2) - 0, 5.29, "Result of TREND({1,2,3},A4:C5,A6:C7,1)[0,2]");

		ws.getRange2("A20").setValue("1");
		ws.getRange2("B20").setValue("2");

		oParser = new parserFormula("TREND(A20:B20)", "A2", ws);
		assert.ok(oParser.parse(), "TREND(A20:B20)");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 1, "Result of TREND(A20:B20)[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(2) - 0, 2, "Result of TREND(A20:B20)[0,1]");

		oParser = new parserFormula("TREND({1;2})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 1, "Result of TREND({1;2})[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(2) - 0, 2, "Result of TREND({1;2})[1,0]");

		oParser = new parserFormula("TREND({1,2})", "A2", ws);
		assert.ok(oParser.parse(), "TREND({1,2})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 1, "Result of TREND({1,2})[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(2) - 0, 2, "Result of TREND({1,2})[0,1]");

		ws.getRange2("A20").setValue("1");
		ws.getRange2("A21").setValue("2");
		ws.getRange2("A22").setValue("3");
		ws.getRange2("B20").setValue("1");
		ws.getRange2("B21").setValue("2");
		ws.getRange2("B22").setValue("3");
		ws.getRange2("C20").setValue("1");
		ws.getRange2("C21").setValue("2");
		ws.getRange2("C22").setValue("3");

		// different matrix length tests
		oParser = new parserFormula("TREND(A20:A21,A20:C20)", "A2", ws);
		assert.ok(oParser.parse(), "TREND(A20:A21,A20:C20)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of TREND(A20:A21,A20:C20)");

		oParser = new parserFormula("TREND(A20:A22,A20:C20)", "A2", ws);
		assert.ok(oParser.parse(), "TREND(A20:A22,A20:C20)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of TREND(A20:A22,A20:C20)");

		oParser = new parserFormula("TREND(A20:B21,A20:C21)", "A2", ws);
		assert.ok(oParser.parse(), "TREND(A20:B21,A20:C21)");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of TREND(A20:B21,A20:C21)");

		oParser = new parserFormula("TREND({1,2,3},{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "TREND({1,2,3},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of TREND({1,2,3},{1,2})");

		oParser = new parserFormula("TREND({1,2,3},{1,2,3,4})", "A2", ws);
		assert.ok(oParser.parse(), "TREND({1,2,3},{1,2,3,4})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of TREND({1,2,3},{1,2,3,4})");

		oParser = new parserFormula("TREND({1,2;1,2},{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "TREND({1,2;1,2},{1,2})");
		assert.strictEqual(oParser.calculate().getValue(), "#REF!", "Result of TREND({1,2;1,2},{1,2})");

		oParser = new parserFormula("TREND(A20:B20,{1,2})", "A2", ws);
		assert.ok(oParser.parse(), "TREND(A20:B20,{1,2})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue(), 1, "Result of TREND(A20:B20,{1,2})[0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue(), 1, "Result of TREND(A20:B20,{1,2})[0,1]");

		// identical X-trend tests
		oParser = new parserFormula("TREND({1,1},{0,0})", "A2", ws);
		assert.ok(oParser.parse(), "TREND({1,1},{0,0})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 1, "Result of TREND({1,1},{0,0}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 1, "Result of TREND({1,1},{0,0}) [0,1]");

		oParser = new parserFormula("TREND({123,123},{123,123})", "A2", ws);
		assert.ok(oParser.parse(), "TREND({123,123},{123,123})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 123, "Result of TREND({123,123},{123,123}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 123, "Result of TREND({123,123},{123,123}) [0,1]");

		oParser = new parserFormula("TREND({2,8},{1,1})", "A2", ws);
		assert.ok(oParser.parse(), "TREND({2,8},{1,1})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 5, "Result of TREND({2,8},{1,1}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 5, "Result of TREND({2,8},{1,1}) [0,1]");

		oParser = new parserFormula("TREND({2,8;1,1},{1,1;1,1})", "A2", ws);
		assert.ok(oParser.parse(), "TREND({2,8;1,1},{1,1;1,1})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(8) - 0, 3, "Result of TREND({2,8;1,1},{1,1;1,1}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(4) - 0, 3, "Result of TREND({2,8;1,1},{1,1;1,1}) [0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(8) - 0, 3, "Result of TREND({2,8;1,1},{1,1;1,1}) [1,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue().toFixed(4) - 0, 3, "Result of TREND({2,8;1,1},{1,1;1,1}) [1,1]");

		oParser = new parserFormula("TREND({2,8;2,2;10,10},{1,1;1,1;1,1})", "A2", ws);
		assert.ok(oParser.parse(), "TREND({2,8;2,2;10,10},{1,1;1,1;1,1})");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 0).getValue().toFixed(2) - 0, 5.67, "Result of TREND({2,8;2,2;10,10},{1,1;1,1;1,1}) [0,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(0, 1).getValue().toFixed(2) - 0, 5.67, "Result of TREND({2,8;2,2;10,10},{1,1;1,1;1,1}) [0,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 0).getValue().toFixed(2) - 0, 5.67, "Result of TREND({2,8;2,2;10,10},{1,1;1,1;1,1}) [1,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(1, 1).getValue().toFixed(2) - 0, 5.67, "Result of TREND({2,8;2,2;10,10},{1,1;1,1;1,1}) [1,1]");
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 0).getValue().toFixed(2) - 0, 5.67, "Result of TREND({2,8;2,2;10,10},{1,1;1,1;1,1}) [2,0]");
		assert.strictEqual(oParser.calculate().getElementRowCol(2, 1).getValue().toFixed(2) - 0, 5.67, "Result of TREND({2,8;2,2;10,10},{1,1;1,1;1,1}) [2,1]");

	});

	QUnit.test("Test: \"TTEST\"", function (assert) {
		ws.getRange2("A2").setValue("3");
		ws.getRange2("A3").setValue("4");
		ws.getRange2("A4").setValue("5");
		ws.getRange2("A5").setValue("8");
		ws.getRange2("A6").setValue("9");
		ws.getRange2("A7").setValue("1");
		ws.getRange2("A8").setValue("2");
		ws.getRange2("A9").setValue("4");
		ws.getRange2("A10").setValue("5");

		ws.getRange2("B2").setValue("6");
		ws.getRange2("B3").setValue("19");
		ws.getRange2("B4").setValue("3");
		ws.getRange2("B5").setValue("2");
		ws.getRange2("B6").setValue("14");
		ws.getRange2("B7").setValue("4");
		ws.getRange2("B8").setValue("5");
		ws.getRange2("B9").setValue("17");
		ws.getRange2("B10").setValue("1");

		oParser = new parserFormula("TTEST(A2:A10,B2:B10,2,1)", "A1", ws);
		assert.ok(oParser.parse(), "TTEST(A2:A10,B2:B10,2,1)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.196016, "TTEST(A2:A10,B2:B10,2,1)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number, Number, Number, Number. Basic valid input: two arrays with numbers, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2,3},{4,5,6},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2,3},{4,5,6},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number, Number, Number, Number. Basic valid input: two arrays with numbers, one-tailed paired test. 4 of 4 arguments used.');
		// Case #2: Number, Number, Number, Number. Float numbers in arrays, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1.5,2.5,3.5},{4.5,5.5,6.5},2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1.5,2.5,3.5},{4.5,5.5,6.5},2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.021311641128756713, 'Test: Positive case: Number, Number, Number, Number. Float numbers in arrays, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #3: String, String, Number, Number. String arrays convertible to numbers, one-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST("1,2,3","4,5,6",1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST("1,2,3","4,5,6",1,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String, String, Number, Number. String arrays convertible to numbers, one-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #4: Reference link, Reference link, Number, Number. Reference link to cells with valid arrays, two-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(A100,A101,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(A100,A101,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link, Reference link, Number, Number. Reference link to cells with valid arrays, two-tailed paired test. 4 of 4 arguments used.');
		// Case #5: Area, Area, Number, Number. Single-cell ranges, one-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(A102:A103,A104:A105,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(A102:A103,A104:A105,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area, Area, Number, Number. Single-cell ranges, one-tailed equal variance test. 4 of 4 arguments used.');
		// Case #6: Array, Array, Number, Number. Arrays with multiple elements, two-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10557280900008414, 'Test: Positive case: Array, Array, Number, Number. Arrays with multiple elements, two-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #7: Name, Name, Number, Number. Named ranges with valid arrays, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(TestName1,TestName2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(TestName1,TestName2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name, Name, Number, Number. Named ranges with valid arrays, one-tailed paired test. 4 of 4 arguments used.');
		// Case #8: Name3D, Name3D, Number, Number. 3D named ranges, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(TestName3D,TestName3D,2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(TestName3D,TestName3D,2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Test: Positive case: Name3D, Name3D, Number, Number. 3D named ranges, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #9: Ref3D, Ref3D, Number, Number. 3D references to cells, one-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(Sheet2!A1,Sheet2!A2,1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(Sheet2!A1,Sheet2!A2,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D, Ref3D, Number, Number. 3D references to cells, one-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #10: Area3D, Area3D, Number, Number. 3D single-cell ranges, two-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(Sheet2!A3:A4,Sheet2!A5:A6,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(Sheet2!A3:A4,Sheet2!A5:A6,2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D, Area3D, Number, Number. 3D single-cell ranges, two-tailed paired test. 4 of 4 arguments used.');
		// Case #11: Table, Table, Number, Number. Table structured references, one-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(Table1[Column1],Table1[Column1],1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(Table1[Column1],Table1[Column1],1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Test: Positive case: Table, Table, Number, Number. Table structured references, one-tailed equal variance test. 4 of 4 arguments used.');
		// Case #12: Date, Date, Number, Number. Date serial numbers as arrays, two-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({45658,45659},{45660,45661},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({45658,45659},{45660,45661},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10557280900008414, 'Test: Positive case: Date, Date, Number, Number. Date serial numbers as arrays, two-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #13: Time, Time, Number, Number. Time values adjusted to valid numbers, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Time, Time, Number, Number. Time values adjusted to valid numbers, one-tailed paired test. 4 of 4 arguments used.');
		// Case #14: Formula, Formula, Number, Number. Nested IF for arrays, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(IF(TRUE,{1,2,3},{4,5,6}),IF(TRUE,{7,8,9},{10,11,12}),2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(IF(TRUE,{1,2,3},{4,5,6}),IF(TRUE,{7,8,9},{10,11,12}),2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.001826261, 'Test: Positive case: Formula, Formula, Number, Number. Nested IF for arrays, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #15: Number, Number, Formula, Number. Nested formula for tails, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},ABS(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},ABS(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number, Number, Formula, Number. Nested formula for tails, one-tailed paired test. 4 of 4 arguments used.');
		// Case #16: Number, Number, Number, Formula. Nested formula for type, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},1,ROUND(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},1,ROUND(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number, Number, Number, Formula. Nested formula for type, one-tailed paired test. 4 of 4 arguments used.');
		// Case #17: String, String, String, String. All arguments as strings convertible to numbers, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST("1,2,3","4,5,6","1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST("1,2,3","4,5,6","1","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String, String, String, String. All arguments as strings convertible to numbers, one-tailed paired test. 4 of 4 arguments used.');
		// Case #18: Array, Array, Array, Array. Arrays for all arguments, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2,3},{4,5,6},{2},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2,3},{4,5,6},{2},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.021311641128756713, 'Test: Positive case: Array, Array, Array, Array. Arrays for all arguments, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #19: Formula, Formula, Formula, Formula. All arguments filled with formulas, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(VALUE("1,2"),VALUE("3,4"),ABS(-2),ROUND(2,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(VALUE("1,2"),VALUE("3,4"),ABS(-2),ROUND(2,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula, Formula, Formula, Formula. All arguments filled with formulas, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #20: Formula, Formula, Number, Number. TTEST inside SUM formula, one-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(SUM({1,2},1),SUM({3,4},1),1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(SUM({1,2},1),SUM({3,4},1),1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Formula, Formula, Number, Number. TTEST inside SUM formula, one-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #21: Number, Number, Number, Number. Larger numbers in arrays, one-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({10,20,30},{40,50,60},1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({10,20,30},{40,50,60},1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.010655820564378356, 'Test: Positive case: Number, Number, Number, Number. Larger numbers in arrays, one-tailed equal variance test. 4 of 4 arguments used.');
		// Case #22: Reference link, Reference link, Formula, Number. Reference link with nested IF for tails, one-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(A106,A107,IF(TRUE,1,2),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(A106,A107,IF(TRUE,1,2),3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link, Reference link, Formula, Number. Reference link with nested IF for tails, one-tailed unequal variance test. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Empty, Number, Number, Number. First array empty, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(,{1,2,3},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(,{1,2,3},1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty, Number, Number, Number. First array empty, returns #N/A. 4 of 4 arguments used.');
		// Case #2: Number, Empty, Number, Number. Second array empty, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2,3},,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2,3},,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Empty, Number, Number. Second array empty, returns #N/A. 4 of 4 arguments used.');
		// Case #3: Number, Number, Number, Number. Single-element arrays for paired test, returns #DIV/0!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1},{2},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1},{2},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Number, Number, Number. Single-element arrays for paired test, returns #DIV/0!. 4 of 4 arguments used.');
		// Case #4: Number, Number, Number, Number. Arrays with zero variance, returns #DIV/0!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,1},{2,2},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,1},{2,2},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Number, Number, Number. Arrays with zero variance, returns #DIV/0!. 4 of 4 arguments used.');
		// Case #5: String, String, Number, Number. Non-numeric strings in arrays, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST("abc","def",1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST("abc","def",1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String, String, Number, Number. Non-numeric strings in arrays, returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: Error, Number, Number, Number. First array with error, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(NA(),{1,2,3},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(NA(),{1,2,3},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Number, Number. First array with error, returns #N/A. 4 of 4 arguments used.');
		// Case #7: Number, Error, Number, Number. Second array with error, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2,3},NA(),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2,3},NA(),1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number, Number. Second array with error, returns #N/A. 4 of 4 arguments used.');
		// Case #8: Area, Area, Number, Number. Multi-cell ranges with invalid data, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(A108:A110,A108:A110,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(A108:A110,A108:A110,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Area, Number, Number. Multi-cell ranges with invalid data, returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Number, Number, String, Number. Tails as non-numeric string, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},"abc",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},"abc",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String, Number. Tails as non-numeric string, returns #VALUE!. 4 of 4 arguments used.');
		// Case #10: Number, Number, Number, String. Type as non-numeric string, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},1,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Number, String. Type as non-numeric string, returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Number, Number, Number, Number. Tails is 0, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number. Tails is 0, returns #NUM!. 4 of 4 arguments used.');
		// Case #12: Number, Number, Number, Number. Tails is 3, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number. Tails is 3, returns #NUM!. 4 of 4 arguments used.');
		// Case #13: Number, Number, Number, Number. Type is 0, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number. Type is 0, returns #NUM!. 4 of 4 arguments used.');
		// Case #14: Number, Number, Number, Number. Type is 4, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3,4},1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3,4},1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number. Type is 4, returns #NUM!. 4 of 4 arguments used.');
		// Case #15: Boolean, Number, Number, Number. First array as boolean, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(TRUE,{1,2,3},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(TRUE,{1,2,3},1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean, Number, Number, Number. First array as boolean, returns #VALUE!. 4 of 4 arguments used.');
		// Case #16: Number, Boolean, Number, Number. Second array as boolean, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2,3},FALSE,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2,3},FALSE,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Boolean, Number, Number. Second array as boolean, returns #VALUE!. 4 of 4 arguments used.');
		// Case #17: Name, Name, Number, Number. Named range with invalid data, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(TestNameArea2,TestNameArea2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(TestNameArea2,TestNameArea2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name, Name, Number, Number. Named range with invalid data, returns #VALUE!. 4 of 4 arguments used.');
		// Case #18: Name3D, Name3D, Number, Number. 3D named range with invalid data, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(TestNameArea3D2,TestNameArea3D2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(TestNameArea3D2,TestNameArea3D2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D, Name3D, Number, Number. 3D named range with invalid data, returns #VALUE!. 4 of 4 arguments used.');
		// Case #19: Ref3D, Ref3D, Number, Number. 3D references with invalid data, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST(Sheet2!A7,Sheet2!A8,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST(Sheet2!A7,Sheet2!A8,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Ref3D, Number, Number. 3D references with invalid data, returns #VALUE!. 4 of 4 arguments used.');
		// Case #20: Number, Number, Number, Number. Arrays of unequal length for paired test, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,2},{3},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,2},{3},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Number, Number, Number. Arrays of unequal length for paired test, returns #N/A. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number, Number, Number, Number. Minimum valid numbers in arrays, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1E-307,1E-307},{1E-307,1E-307},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1E-307,1E-307},{1E-307,1E-307},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number, Number, Number, Number. Minimum valid numbers in arrays, one-tailed paired test. 4 of 4 arguments used.');
		// Case #2: Number, Number, Number, Number. Maximum valid numbers in arrays, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({9.99999999999999E+307,9.99999999999999E+307},{9.99999999999999E+307,9.99999999999999E+307},2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({9.99999999999999E+307,9.99999999999999E+307},{9.99999999999999E+307,9.99999999999999E+307},2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number, Number, Number. Maximum valid numbers in arrays, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #3: Number, Number, Number, Number. Identical arrays with zero variance, one-tailed equal variance test (edge case). 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1,1,1},{1,1,1},1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1,1,1},{1,1,1},1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number, Number, Number, Number. Identical arrays with zero variance, one-tailed equal variance test (edge case). 4 of 4 arguments used.');
		// Case #4: Number, Number, Number, Number. Minimum valid numbers with slight differences, two-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('TTEST({1E-307,2E-307},{3E-307,4E-307},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TTEST({1E-307,2E-307},{3E-307,4E-307},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number, Number, Number, Number. Minimum valid numbers with slight differences, two-tailed unequal variance test. 4 of 4 arguments used.');

		// Need to fix: diff error types, ms results diff, string and boolean handle
		// Case #3: String, String, Number, Number. String arrays convertible to numbers, one-tailed unequal variance test. 4 of 4 arguments used.
		// Case #5: Area, Area, Number, Number. Single-cell ranges, one-tailed equal variance test. 4 of 4 arguments used.
		// Case #10: Area3D, Area3D, Number, Number. 3D single-cell ranges, two-tailed paired test. 4 of 4 arguments used.
		// Case #14: Formula, Formula, Number, Number. Nested IF for arrays, two-tailed equal variance test. 4 of 4 arguments used.
		// Case #17: String, String, String, String. All arguments as strings convertible to numbers, one-tailed paired test. 4 of 4 arguments used.
		// Case #22: Reference link, Reference link, Formula, Number. Reference link with nested IF for tails, one-tailed unequal variance test. 4 of 4 arguments used.
		// Case #1: Empty, Number, Number, Number. First array empty, returns #N/A. 4 of 4 arguments used.
		// Case #2: Number, Empty, Number, Number. Second array empty, returns #N/A. 4 of 4 arguments used.
		// Case #5: String, String, Number, Number. Non-numeric strings in arrays, returns #VALUE!. 4 of 4 arguments used.
		// Case #8: Area, Area, Number, Number. Multi-cell ranges with invalid data, returns #VALUE!. 4 of 4 arguments used.
		// Case #15: Boolean, Number, Number, Number. First array as boolean, returns #VALUE!. 4 of 4 arguments used.
		// Case #16: Number, Boolean, Number, Number. Second array as boolean, returns #VALUE!. 4 of 4 arguments used.
		// Case #19: Ref3D, Ref3D, Number, Number. 3D references with invalid data, returns #VALUE!. 4 of 4 arguments used.


		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "TTEST", 4, 4, null, true);
	});

	QUnit.test("Test: \"T.TEST\"", function (assert) {
		ws.getRange2("A2").setValue("3");
		ws.getRange2("A3").setValue("4");
		ws.getRange2("A4").setValue("5");
		ws.getRange2("A5").setValue("8");
		ws.getRange2("A6").setValue("9");
		ws.getRange2("A7").setValue("1");
		ws.getRange2("A8").setValue("2");
		ws.getRange2("A9").setValue("4");
		ws.getRange2("A10").setValue("5");

		ws.getRange2("B2").setValue("6");
		ws.getRange2("B3").setValue("19");
		ws.getRange2("B4").setValue("3");
		ws.getRange2("B5").setValue("2");
		ws.getRange2("B6").setValue("14");
		ws.getRange2("B7").setValue("4");
		ws.getRange2("B8").setValue("5");
		ws.getRange2("B9").setValue("17");
		ws.getRange2("B10").setValue("1");

		oParser = new parserFormula("T.TEST(A2:A10,B2:B10,2,1)", "A1", ws);
		assert.ok(oParser.parse(), "T.TEST(A2:A10,B2:B10,2,1)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 0.19602, "T.TEST(A2:A10,B2:B10,2,1)");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number, Number, Number, Number. Basic valid input: two arrays with numbers, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2,3},{4,5,6},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2,3},{4,5,6},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number, Number, Number, Number. Basic valid input: two arrays with numbers, one-tailed paired test. 4 of 4 arguments used.');
		// Case #2: Number, Number, Number, Number. Float numbers in arrays, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1.5,2.5,3.5},{4.5,5.5,6.5},2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1.5,2.5,3.5},{4.5,5.5,6.5},2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.021311641128756713, 'Test: Positive case: Number, Number, Number, Number. Float numbers in arrays, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #3: String, String, Number, Number. String arrays convertible to numbers, one-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST("1,2,3","4,5,6",1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST("1,2,3","4,5,6",1,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String, String, Number, Number. String arrays convertible to numbers, one-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #4: Reference link, Reference link, Number, Number. Reference link to cells with valid arrays, two-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(A100,A101,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(A100,A101,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link, Reference link, Number, Number. Reference link to cells with valid arrays, two-tailed paired test. 4 of 4 arguments used.');
		// Case #5: Area, Area, Number, Number. Single-cell ranges, one-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(A102:A103,A104:A105,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(A102:A103,A104:A105,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area, Area, Number, Number. Single-cell ranges, one-tailed equal variance test. 4 of 4 arguments used.');
		// Case #6: Array, Array, Number, Number. Arrays with multiple elements, two-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10557280900008414, 'Test: Positive case: Array, Array, Number, Number. Arrays with multiple elements, two-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #7: Name, Name, Number, Number. Named ranges with valid arrays, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(TestName1,TestName2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(TestName1,TestName2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name, Name, Number, Number. Named ranges with valid arrays, one-tailed paired test. 4 of 4 arguments used.');
		// Case #8: Name3D, Name3D, Number, Number. 3D named ranges, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(TestName3D,TestName3D,2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(TestName3D,TestName3D,2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Test: Positive case: Name3D, Name3D, Number, Number. 3D named ranges, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #9: Ref3D, Ref3D, Number, Number. 3D references to cells, one-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(Sheet2!A1,Sheet2!A2,1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(Sheet2!A1,Sheet2!A2,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D, Ref3D, Number, Number. 3D references to cells, one-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #10: Area3D, Area3D, Number, Number. 3D single-cell ranges, two-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(Sheet2!A3:A4,Sheet2!A5:A6,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(Sheet2!A3:A4,Sheet2!A5:A6,2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D, Area3D, Number, Number. 3D single-cell ranges, two-tailed paired test. 4 of 4 arguments used.');
		// Case #11: Table, Table, Number, Number. Table structured references, one-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(Table1[Column1],Table1[Column1],1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(Table1[Column1],Table1[Column1],1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Test: Positive case: Table, Table, Number, Number. Table structured references, one-tailed equal variance test. 4 of 4 arguments used.');
		// Case #12: Date, Date, Number, Number. Date serial numbers as arrays, two-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({45658,45659},{45660,45661},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({45658,45659},{45660,45661},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10557280900008414, 'Test: Positive case: Date, Date, Number, Number. Date serial numbers as arrays, two-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #13: Time, Time, Number, Number. Time values adjusted to valid numbers, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Time, Time, Number, Number. Time values adjusted to valid numbers, one-tailed paired test. 4 of 4 arguments used.');
		// Case #14: Formula, Formula, Number, Number. Nested IF for arrays, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(IF(TRUE,{1,2,3},{4,5,6}),IF(TRUE,{7,8,9},{10,11,12}),2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(IF(TRUE,{1,2,3},{4,5,6}),IF(TRUE,{7,8,9},{10,11,12}),2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.001826261, 'Test: Positive case: Formula, Formula, Number, Number. Nested IF for arrays, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #15: Number, Number, Formula, Number. Nested formula for tails, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},ABS(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},ABS(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number, Number, Formula, Number. Nested formula for tails, one-tailed paired test. 4 of 4 arguments used.');
		// Case #16: Number, Number, Number, Formula. Nested formula for type, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},1,ROUND(1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},1,ROUND(1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number, Number, Number, Formula. Nested formula for type, one-tailed paired test. 4 of 4 arguments used.');
		// Case #17: String, String, String, String. All arguments as strings convertible to numbers, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST("1,2,3","4,5,6","1","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST("1,2,3","4,5,6","1","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String, String, String, String. All arguments as strings convertible to numbers, one-tailed paired test. 4 of 4 arguments used.');
		// Case #18: Array, Array, Array, Array. Arrays for all arguments, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2,3},{4,5,6},{2},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2,3},{4,5,6},{2},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.021311641128756713, 'Test: Positive case: Array, Array, Array, Array. Arrays for all arguments, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #19: Formula, Formula, Formula, Formula. All arguments filled with formulas, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(VALUE("1,2"),VALUE("3,4"),ABS(-2),ROUND(2,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(VALUE("1,2"),VALUE("3,4"),ABS(-2),ROUND(2,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula, Formula, Formula, Formula. All arguments filled with formulas, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #20: Formula, Formula, Number, Number. T.TEST inside SUM formula, one-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(SUM({1,2},1),SUM({3,4},1),1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(SUM({1,2},1),SUM({3,4},1),1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Formula, Formula, Number, Number. T.TEST inside SUM formula, one-tailed unequal variance test. 4 of 4 arguments used.');
		// Case #21: Number, Number, Number, Number. Larger numbers in arrays, one-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({10,20,30},{40,50,60},1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({10,20,30},{40,50,60},1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.010655820564378356, 'Test: Positive case: Number, Number, Number, Number. Larger numbers in arrays, one-tailed equal variance test. 4 of 4 arguments used.');
		// Case #22: Reference link, Reference link, Formula, Number. Reference link with nested IF for tails, one-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(A106,A107,IF(TRUE,1,2),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(A106,A107,IF(TRUE,1,2),3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link, Reference link, Formula, Number. Reference link with nested IF for tails, one-tailed unequal variance test. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Empty, Number, Number, Number. First array empty, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(,{1,2,3},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(,{1,2,3},1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty, Number, Number, Number. First array empty, returns #N/A. 4 of 4 arguments used.');
		// Case #2: Number, Empty, Number, Number. Second array empty, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2,3},,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2,3},,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Empty, Number, Number. Second array empty, returns #N/A. 4 of 4 arguments used.');
		// Case #3: Number, Number, Number, Number. Single-element arrays for paired test, returns #DIV/0!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1},{2},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1},{2},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Number, Number, Number. Single-element arrays for paired test, returns #DIV/0!. 4 of 4 arguments used.');
		// Case #4: Number, Number, Number, Number. Arrays with zero variance, returns #DIV/0!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,1},{2,2},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,1},{2,2},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Number, Number, Number. Arrays with zero variance, returns #DIV/0!. 4 of 4 arguments used.');
		// Case #5: String, String, Number, Number. Non-numeric strings in arrays, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST("abc","def",1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST("abc","def",1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String, String, Number, Number. Non-numeric strings in arrays, returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: Error, Number, Number, Number. First array with error, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(NA(),{1,2,3},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(NA(),{1,2,3},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Number, Number. First array with error, returns #N/A. 4 of 4 arguments used.');
		// Case #7: Number, Error, Number, Number. Second array with error, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2,3},NA(),1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2,3},NA(),1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number, Number. Second array with error, returns #N/A. 4 of 4 arguments used.');
		// Case #8: Area, Area, Number, Number. Multi-cell ranges with invalid data, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(A108:A110,A108:A110,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(A108:A110,A108:A110,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Area, Number, Number. Multi-cell ranges with invalid data, returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Number, Number, String, Number. Tails as non-numeric string, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},"abc",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},"abc",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String, Number. Tails as non-numeric string, returns #VALUE!. 4 of 4 arguments used.');
		// Case #10: Number, Number, Number, String. Type as non-numeric string, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},1,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, Number, String. Type as non-numeric string, returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Number, Number, Number, Number. Tails is 0, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number. Tails is 0, returns #NUM!. 4 of 4 arguments used.');
		// Case #12: Number, Number, Number, Number. Tails is 3, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number. Tails is 3, returns #NUM!. 4 of 4 arguments used.');
		// Case #13: Number, Number, Number, Number. Type is 0, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number. Type is 0, returns #NUM!. 4 of 4 arguments used.');
		// Case #14: Number, Number, Number, Number. Type is 4, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3,4},1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3,4},1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number. Type is 4, returns #NUM!. 4 of 4 arguments used.');
		// Case #15: Boolean, Number, Number, Number. First array as boolean, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(TRUE,{1,2,3},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(TRUE,{1,2,3},1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean, Number, Number, Number. First array as boolean, returns #VALUE!. 4 of 4 arguments used.');
		// Case #16: Number, Boolean, Number, Number. Second array as boolean, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2,3},FALSE,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2,3},FALSE,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Boolean, Number, Number. Second array as boolean, returns #VALUE!. 4 of 4 arguments used.');
		// Case #17: Name, Name, Number, Number. Named range with invalid data, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(TestNameArea2,TestNameArea2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(TestNameArea2,TestNameArea2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name, Name, Number, Number. Named range with invalid data, returns #VALUE!. 4 of 4 arguments used.');
		// Case #18: Name3D, Name3D, Number, Number. 3D named range with invalid data, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(TestNameArea3D2,TestNameArea3D2,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(TestNameArea3D2,TestNameArea3D2,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D, Name3D, Number, Number. 3D named range with invalid data, returns #VALUE!. 4 of 4 arguments used.');
		// Case #19: Ref3D, Ref3D, Number, Number. 3D references with invalid data, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST(Sheet2!A7,Sheet2!A8,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST(Sheet2!A7,Sheet2!A8,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Ref3D, Number, Number. 3D references with invalid data, returns #VALUE!. 4 of 4 arguments used.');
		// Case #20: Number, Number, Number, Number. Arrays of unequal length for paired test, returns #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,2},{3},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,2},{3},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Number, Number, Number. Arrays of unequal length for paired test, returns #N/A. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number, Number, Number, Number. Minimum valid numbers in arrays, one-tailed paired test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1E-307,1E-307},{1E-307,1E-307},1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1E-307,1E-307},{1E-307,1E-307},1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number, Number, Number, Number. Minimum valid numbers in arrays, one-tailed paired test. 4 of 4 arguments used.');
		// Case #2: Number, Number, Number, Number. Maximum valid numbers in arrays, two-tailed equal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({9.99999999999999E+307,9.99999999999999E+307},{9.99999999999999E+307,9.99999999999999E+307},2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({9.99999999999999E+307,9.99999999999999E+307},{9.99999999999999E+307,9.99999999999999E+307},2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number, Number, Number. Maximum valid numbers in arrays, two-tailed equal variance test. 4 of 4 arguments used.');
		// Case #3: Number, Number, Number, Number. Identical arrays with zero variance, one-tailed equal variance test (edge case). 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1,1,1},{1,1,1},1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1,1,1},{1,1,1},1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number, Number, Number, Number. Identical arrays with zero variance, one-tailed equal variance test (edge case). 4 of 4 arguments used.');
		// Case #4: Number, Number, Number, Number. Minimum valid numbers with slight differences, two-tailed unequal variance test. 4 of 4 arguments used.
		oParser = new parserFormula('T.TEST({1E-307,2E-307},{3E-307,4E-307},2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: T.TEST({1E-307,2E-307},{3E-307,4E-307},2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number, Number, Number, Number. Minimum valid numbers with slight differences, two-tailed unequal variance test. 4 of 4 arguments used.');

		// Need to fix: diff error types, ms results diff, string and boolean handle
		// Case #3: String, String, Number, Number. String arrays convertible to numbers, one-tailed unequal variance test. 4 of 4 arguments used.
		// Case #5: Area, Area, Number, Number. Single-cell ranges, one-tailed equal variance test. 4 of 4 arguments used.
		// Case #10: Area3D, Area3D, Number, Number. 3D single-cell ranges, two-tailed paired test. 4 of 4 arguments used.
		// Case #14: Formula, Formula, Number, Number. Nested IF for arrays, two-tailed equal variance test. 4 of 4 arguments used.
		// Case #17: String, String, String, String. All arguments as strings convertible to numbers, one-tailed paired test. 4 of 4 arguments used.
		// Case #22: Reference link, Reference link, Formula, Number. Reference link with nested IF for tails, one-tailed unequal variance test. 4 of 4 arguments used.
		// Case #1: Empty, Number, Number, Number. First array empty, returns #N/A. 4 of 4 arguments used.
		// Case #2: Number, Empty, Number, Number. Second array empty, returns #N/A. 4 of 4 arguments used.
		// Case #5: String, String, Number, Number. Non-numeric strings in arrays, returns #VALUE!. 4 of 4 arguments used.
		// Case #8: Area, Area, Number, Number. Multi-cell ranges with invalid data, returns #VALUE!. 4 of 4 arguments used.
		// Case #15: Boolean, Number, Number, Number. First array as boolean, returns #VALUE!. 4 of 4 arguments used.
		// Case #16: Number, Boolean, Number, Number. Second array as boolean, returns #VALUE!. 4 of 4 arguments used.
		// Case #19: Ref3D, Ref3D, Number, Number. 3D references with invalid data, returns #VALUE!. 4 of 4 arguments used.


	});

	QUnit.test("Test: \"VAR\"", function (assert) {

		function _var(x) {

			var sumSQRDeltaX = 0, _x = 0, xLength = 0, standDev = 0, sumSQRDeltaXDivstandDev = 0;
			for (var i = 0; i < x.length; i++) {
				_x += x[i];
				xLength++;
			}

			_x /= xLength;

			for (var i = 0; i < x.length; i++) {
				sumSQRDeltaX += Math.pow(x[i] - _x, 2);
			}

			return toFixed(sumSQRDeltaX / (xLength - 1))

		}

		oParser = new parserFormula("VAR(10.5,12.4,19.4,23.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), _var([10.5, 12.4, 19.4, 23.2]));

		oParser = new parserFormula("VAR(10.5,{12.4,19.4},23.2)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), _var([10.5, 12.4, 19.4, 23.2]));

		oParser = new parserFormula("VAR(10.5,12.4,19.4)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), _var([10.5, 12.4, 19.4]));

		oParser = new parserFormula("VAR(1)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		oParser = new parserFormula("VAR({1})", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		ws.getRange2("A202").setValue("1345");
		ws.getRange2("A203").setValue("");
		ws.getRange2("A204").setValue("");

		oParser = new parserFormula("VAR(A202)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		oParser = new parserFormula("VAR(A202:A204)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		oParser = new parserFormula("VAR(#REF!)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#REF!");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Two valid number inputs. 2 arguments used.
		oParser = new parserFormula('VAR(10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Two valid number inputs. 2 arguments used.');
		// Case #2: Number. Multiple valid number inputs. 4 arguments used.
		oParser = new parserFormula('VAR(2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6666666666666667, 'Test: Positive case: Number. Multiple valid number inputs. 4 arguments used.');
		// Case #3: Formula. Two nested formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(SQRT(16),POWER(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(SQRT(16),POWER(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.5, 'Test: Positive case: Formula. Two nested formulas returning valid numbers. 2 arguments used.');
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VAR("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR("2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #5: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VAR(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3333333333333333, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #6: Reference link. References to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. References to cells with valid numbers. 2 arguments used.');
		// Case #7: Area. Two single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Two single-cell ranges with valid numbers. 2 arguments used.');
		// Case #8: Array. Two arrays with single valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR({2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR({2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Two arrays with single valid numbers. 2 arguments used.');
		// Case #9: Name. Two named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Two named ranges with valid numbers. 2 arguments used.');
		// Case #10: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.');
		// Case #11: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.');
		// Case #12: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.');
		// Case #13: Table. Two table structured references with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Two table structured references with valid numbers. 2 arguments used.');
		// Case #14: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('VAR(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 480.5, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #15: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.
		oParser = new parserFormula('VAR(TIME(12,0,0)+1,TIME(13,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(TIME(12,0,0)+1,TIME(13,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0008680555555555494, 'Test: Positive case: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.');
		// Case #16: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VAR(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #17: Number. Two numbers, one slightly above 1. 2 arguments used.
		oParser = new parserFormula('VAR(1.000000000000001,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(1.000000000000001,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Number. Two numbers, one slightly above 1. 2 arguments used.');
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VAR("12/12","12/13")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR("12/12","12/13") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Short date strings convertible to numbers. 2 arguments used.');
		// Case #19: Array. Two arrays with multiple valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR({2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR({2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6666666666666667, 'Test: Positive case: Array. Two arrays with multiple valid numbers. 2 arguments used.');
		// Case #20: Area. Two two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.33333333333333337, 'Test: Positive case: Area. Two two-cell ranges with valid numbers. 2 arguments used.');
		// Case #21: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VAR("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('VAR(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Two multi-cell ranges with non-numeric values return #VALUE!.
		oParser = new parserFormula('VAR(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0833333333333335, 'Test: Negative case: Area. Two multi-cell ranges with non-numeric values return #VALUE!.');
		// Case #4: Empty. References to empty cells return #DIV/0!.
		oParser = new parserFormula('VAR(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Empty. References to empty cells return #DIV/0!.');
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VAR("","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR("","") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty strings return #VALUE!. 2 arguments used.');
		// Case #6: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.
		oParser = new parserFormula('VAR(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.');
		// Case #7: Ref3D. Two 3D references to cells with text return #VALUE!.
		oParser = new parserFormula('VAR(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. Two 3D references to cells with text return #VALUE!.');
		// Case #8: Name. Two named ranges with text return #VALUE!.
		oParser = new parserFormula('VAR(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8533333333333335, 'Test: Negative case: Name. Two named ranges with text return #VALUE!.');
		// Case #9: Table. Two table columns with text return #VALUE!.
		oParser = new parserFormula('VAR(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(Table1[Column2],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Two table columns with text return #VALUE!.');
		// Case #10: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.
		oParser = new parserFormula('VAR(SQRT(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(SQRT(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.');
		// Case #11: Array. Array with booleans and numbers returns valid variance. 2 arguments used.
		oParser = new parserFormula('VAR({FALSE,TRUE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR({FALSE,TRUE},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Array. Array with booleans and numbers returns valid variance. 2 arguments used.');
		// Case #12: Number. Identical numbers return 0 (no variance). 2 arguments used.
		oParser = new parserFormula('VAR(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Identical numbers return 0 (no variance). 2 arguments used.');
		// Case #13: Time. Time values return valid variance. 2 arguments used.
		oParser = new parserFormula('VAR(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.000868055555555554, 'Test: Negative case: Time. Time values return valid variance. 2 arguments used.');
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		oParser = new parserFormula('VAR("-1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR("-1","2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4.5, 'Test: Negative case: String. Strings convertible to numbers (negative and positive). 2 arguments used.');
		// Case #15: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.
		oParser = new parserFormula('VAR(MMULT(1,2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(MMULT(1,2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.');
		// Case #16: Name3D. Two 3D named ranges with text return #VALUE!.
		oParser = new parserFormula('VAR(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8533333333333335, 'Test: Negative case: Name3D. Two 3D named ranges with text return #VALUE!.');
		// Case #17: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.
		oParser = new parserFormula('VAR(Sheet2!A4:A5,Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(Sheet2!A4:A5,Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.');
		// Case #18: Reference link. References to cells with errors return #N/A.
		oParser = new parserFormula('VAR(A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. References to cells with errors return #N/A.');
		// Case #19: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.
		oParser = new parserFormula('VAR({1,"abc"},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR({1,"abc"},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VAR(1E-307,1E-307+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(1E-307,1E-307+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Minimum positive numbers return calculable variance. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VAR(9.99999999999999E+307,9.99999999999998E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(9.99999999999999E+307,9.99999999999998E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.');
		// Case #3: Array. Arrays with minimum positive numbers. 2 arguments used.
		oParser = new parserFormula('VAR({1E-307,1E-307},{1E-307,1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR({1E-307,1E-307},{1E-307,1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Arrays with minimum positive numbers. 2 arguments used.');
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR(1E+307/SQRT(10),1E+307/SQRT(10)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR(1E+307/SQRT(10),1E+307/SQRT(10)+1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.');

		// Need to fix: string handle, error types diff
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		// Case #9: Table. Two table columns with text return #VALUE!.
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.

	});

	QUnit.test("Test: \"VAR.P\"", function (assert) {

		ws.getRange2("A202").setValue("1345");
		ws.getRange2("A203").setValue("1301");
		ws.getRange2("A204").setValue("1368");
		ws.getRange2("A205").setValue("1322");

		ws.getRange2("A206").setValue("1310");
		ws.getRange2("A207").setValue("1370");
		ws.getRange2("A208").setValue("1318");
		ws.getRange2("A209").setValue("1350");

		ws.getRange2("A210").setValue("1303");
		ws.getRange2("A211").setValue("1299");

		oParser = new parserFormula("VAR.P(A202:A211)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 678.84);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Two valid number inputs. 2 arguments used.
		oParser = new parserFormula('VAR.P(10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number. Two valid number inputs. 2 arguments used.');
		// Case #2: Number. Multiple valid number inputs. 4 arguments used.
		oParser = new parserFormula('VAR.P(2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Positive case: Number. Multiple valid number inputs. 4 arguments used.');
		// Case #3: Formula. Two nested formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(SQRT(16),POWER(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(SQRT(16),POWER(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.25, 'Test: Positive case: Formula. Two nested formulas returning valid numbers. 2 arguments used.');
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P("2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #5: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VAR.P(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #6: Reference link. References to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Reference link. References to cells with valid numbers. 2 arguments used.');
		// Case #7: Area. Two single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Area. Two single-cell ranges with valid numbers. 2 arguments used.');
		// Case #8: Array. Two arrays with single valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P({2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P({2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Array. Two arrays with single valid numbers. 2 arguments used.');
		// Case #9: Name. Two named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Name. Two named ranges with valid numbers. 2 arguments used.');
		// Case #10: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.');
		// Case #11: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.');
		// Case #12: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.');
		// Case #13: Table. Two table structured references with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Two table structured references with valid numbers. 2 arguments used.');
		// Case #14: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 240.25, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #15: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.
		oParser = new parserFormula('VAR.P(TIME(12,0,0)+1,TIME(13,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(TIME(12,0,0)+1,TIME(13,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0004340277777777747, 'Test: Positive case: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.');
		// Case #16: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VAR.P(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #17: Number. Two numbers, one slightly above 1. 2 arguments used.
		oParser = new parserFormula('VAR.P(1.000000000000001,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(1.000000000000001,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.25', 'Test: Positive case: Number. Two numbers, one slightly above 1. 2 arguments used.');
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P("12/12","12/13")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P("12/12","12/13") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: String. Short date strings convertible to numbers. 2 arguments used.');
		// Case #19: Array. Two arrays with multiple valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P({2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P({2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Positive case: Array. Two arrays with multiple valid numbers. 2 arguments used.');
		// Case #20: Area. Two two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22222222222222224, 'Test: Positive case: Area. Two two-cell ranges with valid numbers. 2 arguments used.');
		// Case #21: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VAR.P("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('VAR.P(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Two multi-cell ranges with non-numeric values return #VALUE!.
		oParser = new parserFormula('VAR.P(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7222222222222223, 'Test: Negative case: Area. Two multi-cell ranges with non-numeric values return #VALUE!.');
		// Case #4: Empty. References to empty cells return #DIV/0!.
		oParser = new parserFormula('VAR.P(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. References to empty cells return #DIV/0!.');
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VAR.P("","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P("","") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty strings return #VALUE!. 2 arguments used.');
		// Case #6: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.
		oParser = new parserFormula('VAR.P(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.');
		// Case #7: Ref3D. Two 3D references to cells with text return #VALUE!.
		oParser = new parserFormula('VAR.P(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. Two 3D references to cells with text return #VALUE!.');
		// Case #8: Name. Two named ranges with text return #VALUE!.
		oParser = new parserFormula('VAR.P(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.64', 'Test: Negative case: Name. Two named ranges with text return #VALUE!.');
		// Case #9: Table. Two table columns with text return #VALUE!.
		oParser = new parserFormula('VAR.P(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(Table1[Column2],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Two table columns with text return #VALUE!.');
		// Case #10: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.
		oParser = new parserFormula('VAR.P(SQRT(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(SQRT(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.');
		// Case #11: Array. Array with booleans and numbers returns valid variance. 2 arguments used.
		oParser = new parserFormula('VAR.P({FALSE,TRUE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P({FALSE,TRUE},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Array. Array with booleans and numbers returns valid variance. 2 arguments used.');
		// Case #12: Number. Identical numbers return 0 (no variance). 2 arguments used.
		oParser = new parserFormula('VAR.P(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Identical numbers return 0 (no variance). 2 arguments used.');
		// Case #13: Time. Time values return valid variance. 2 arguments used.
		oParser = new parserFormula('VAR.P(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.000434027777777777, 'Test: Negative case: Time. Time values return valid variance. 2 arguments used.');
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		oParser = new parserFormula('VAR.P("-1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P("-1","2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Negative case: String. Strings convertible to numbers (negative and positive). 2 arguments used.');
		// Case #15: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.
		oParser = new parserFormula('VAR.P(MMULT(1,2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(MMULT(1,2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.');
		// Case #16: Name3D. Two 3D named ranges with text return #VALUE!.
		oParser = new parserFormula('VAR.P(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.64', 'Test: Negative case: Name3D. Two 3D named ranges with text return #VALUE!.');
		// Case #17: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.
		oParser = new parserFormula('VAR.P(Sheet2!A4:A5,Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(Sheet2!A4:A5,Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.');
		// Case #18: Reference link. References to cells with errors return #N/A.
		oParser = new parserFormula('VAR.P(A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. References to cells with errors return #N/A.');
		// Case #19: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.
		oParser = new parserFormula('VAR.P({1,"abc"},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P({1,"abc"},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6666666666666666, 'Test: Negative case: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VAR.P(1E-307,1E-307+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(1E-307,1E-307+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Bounded case: Number. Minimum positive numbers return calculable variance. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VAR.P(9.99999999999999E+307,9.99999999999998E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(9.99999999999999E+307,9.99999999999998E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.');
		// Case #3: Array. Arrays with minimum positive numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P({1E-307,1E-307},{1E-307,1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P({1E-307,1E-307},{1E-307,1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Arrays with minimum positive numbers. 2 arguments used.');
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.P(1E+307/SQRT(10),1E+307/SQRT(10)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.P(1E+307/SQRT(10),1E+307/SQRT(10)+1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.');

		// Need to fix: empty handle, error types diff
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		// Case #9: Table. Two table columns with text return #VALUE!.
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.

		testArrayFormula2(assert, "VAR.P", 1, 8, null, true);
	});

	QUnit.test("Test: \"VAR.S\"", function (assert) {

		ws.getRange2("A202").setValue("1345");
		ws.getRange2("A203").setValue("1301");
		ws.getRange2("A204").setValue("1368");
		ws.getRange2("A205").setValue("1322");

		ws.getRange2("A206").setValue("1310");
		ws.getRange2("A207").setValue("1370");
		ws.getRange2("A208").setValue("1318");
		ws.getRange2("A209").setValue("1350");

		ws.getRange2("A210").setValue("1303");
		ws.getRange2("A211").setValue("1299");

		oParser = new parserFormula("VAR.S(A202:A211)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 754.27);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Two valid number inputs. 2 arguments used.
		oParser = new parserFormula('VAR.S(10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Two valid number inputs. 2 arguments used.');
		// Case #2: Number. Multiple valid number inputs. 4 arguments used.
		oParser = new parserFormula('VAR.S(2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6666666666666667, 'Test: Positive case: Number. Multiple valid number inputs. 4 arguments used.');
		// Case #3: Formula. Two nested formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(SQRT(16),POWER(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(SQRT(16),POWER(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.5, 'Test: Positive case: Formula. Two nested formulas returning valid numbers. 2 arguments used.');
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S("2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #5: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VAR.S(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3333333333333333, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #6: Reference link. References to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. References to cells with valid numbers. 2 arguments used.');
		// Case #7: Area. Two single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Two single-cell ranges with valid numbers. 2 arguments used.');
		// Case #8: Array. Two arrays with single valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S({2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S({2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Two arrays with single valid numbers. 2 arguments used.');
		// Case #9: Name. Two named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Two named ranges with valid numbers. 2 arguments used.');
		// Case #10: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.');
		// Case #11: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.');
		// Case #12: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.');
		// Case #13: Table. Two table structured references with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Two table structured references with valid numbers. 2 arguments used.');
		// Case #14: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 480.5, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #15: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.
		oParser = new parserFormula('VAR.S(TIME(12,0,0)+1,TIME(13,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(TIME(12,0,0)+1,TIME(13,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0008680555555555494, 'Test: Positive case: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.');
		// Case #16: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VAR.S(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #17: Number. Two numbers, one slightly above 1. 2 arguments used.
		oParser = new parserFormula('VAR.S(1.000000000000001,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(1.000000000000001,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Number. Two numbers, one slightly above 1. 2 arguments used.');
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S("12/12","12/13")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S("12/12","12/13") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Short date strings convertible to numbers. 2 arguments used.');
		// Case #19: Array. Two arrays with multiple valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S({2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S({2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6666666666666667, 'Test: Positive case: Array. Two arrays with multiple valid numbers. 2 arguments used.');
		// Case #20: Area. Two two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.33333333333333337, 'Test: Positive case: Area. Two two-cell ranges with valid numbers. 2 arguments used.');
		// Case #21: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VAR.S("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('VAR.S(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Two multi-cell ranges with non-numeric values return #VALUE!.
		oParser = new parserFormula('VAR.S(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0833333333333335, 'Test: Negative case: Area. Two multi-cell ranges with non-numeric values return #VALUE!.');
		// Case #4: Empty. References to empty cells return #DIV/0!.
		oParser = new parserFormula('VAR.S(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Empty. References to empty cells return #DIV/0!.');
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VAR.S("","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S("","") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty strings return #VALUE!. 2 arguments used.');
		// Case #6: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.
		oParser = new parserFormula('VAR.S(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.');
		// Case #7: Ref3D. Two 3D references to cells with text return #VALUE!.
		oParser = new parserFormula('VAR.S(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. Two 3D references to cells with text return #VALUE!.');
		// Case #8: Name. Two named ranges with text return #VALUE!.
		oParser = new parserFormula('VAR.S(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8533333333333335, 'Test: Negative case: Name. Two named ranges with text return #VALUE!.');
		// Case #9: Table. Two table columns with text return #VALUE!.
		oParser = new parserFormula('VAR.S(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(Table1[Column2],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Two table columns with text return #VALUE!.');
		// Case #10: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.
		oParser = new parserFormula('VAR.S(SQRT(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(SQRT(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.');
		// Case #11: Array. Array with booleans and numbers returns valid variance. 2 arguments used.
		oParser = new parserFormula('VAR.S({FALSE,TRUE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S({FALSE,TRUE},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Array. Array with booleans and numbers returns valid variance. 2 arguments used.');
		// Case #12: Number. Identical numbers return 0 (no variance). 2 arguments used.
		oParser = new parserFormula('VAR.S(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Identical numbers return 0 (no variance). 2 arguments used.');
		// Case #13: Time. Time values return valid variance. 2 arguments used.
		oParser = new parserFormula('VAR.S(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.000868055555555554, 'Test: Negative case: Time. Time values return valid variance. 2 arguments used.');
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		oParser = new parserFormula('VAR.S("-1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S("-1","2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4.5, 'Test: Negative case: String. Strings convertible to numbers (negative and positive). 2 arguments used.');
		// Case #15: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.
		oParser = new parserFormula('VAR.S(MMULT(1,2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(MMULT(1,2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.');
		// Case #16: Name3D. Two 3D named ranges with text return #VALUE!.
		oParser = new parserFormula('VAR.S(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8533333333333335, 'Test: Negative case: Name3D. Two 3D named ranges with text return #VALUE!.');
		// Case #17: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.
		oParser = new parserFormula('VAR.S(Sheet2!A4:A5,Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(Sheet2!A4:A5,Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.');
		// Case #18: Reference link. References to cells with errors return #N/A.
		oParser = new parserFormula('VAR.S(A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. References to cells with errors return #N/A.');
		// Case #19: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.
		oParser = new parserFormula('VAR.S({1,"abc"},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S({1,"abc"},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VAR.S(1E-307,1E-307+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(1E-307,1E-307+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Minimum positive numbers return calculable variance. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VAR.S(9.99999999999999E+307,9.99999999999998E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(9.99999999999999E+307,9.99999999999998E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.');
		// Case #3: Array. Arrays with minimum positive numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S({1E-307,1E-307},{1E-307,1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S({1E-307,1E-307},{1E-307,1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Arrays with minimum positive numbers. 2 arguments used.');
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.
		oParser = new parserFormula('VAR.S(1E+307/SQRT(10),1E+307/SQRT(10)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VAR.S(1E+307/SQRT(10),1E+307/SQRT(10)+1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.');

		// Need to fix: empty handle, string handle, error types diff
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		// Case #9: Table. Two table columns with text return #VALUE!.
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.


		testArrayFormula2(assert, "VAR.S", 1, 8, null, true);

	});

	QUnit.test("Test: \"VARA\"", function (assert) {
		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Two valid number inputs. 2 arguments used.
		oParser = new parserFormula('VARA(10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number. Two valid number inputs. 2 arguments used.');
		// Case #2: Number. Multiple valid number inputs. 4 arguments used.
		oParser = new parserFormula('VARA(2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6666666666666667, 'Test: Positive case: Number. Multiple valid number inputs. 4 arguments used.');
		// Case #3: Formula. Two nested formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(SQRT(16),POWER(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(SQRT(16),POWER(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.5, 'Test: Positive case: Formula. Two nested formulas returning valid numbers. 2 arguments used.');
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VARA("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA("2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #5: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VARA(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3333333333333333, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #6: Reference link. References to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link. References to cells with valid numbers. 2 arguments used.');
		// Case #7: Area. Two single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area. Two single-cell ranges with valid numbers. 2 arguments used.');
		// Case #8: Array. Two arrays with single valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA({2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA({2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Two arrays with single valid numbers. 2 arguments used.');
		// Case #9: Name. Two named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Two named ranges with valid numbers. 2 arguments used.');
		// Case #10: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.');
		// Case #11: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.');
		// Case #12: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.');
		// Case #13: Table. Two table structured references with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Two table structured references with valid numbers. 2 arguments used.');
		// Case #14: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('VARA(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 480.5, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #15: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.
		oParser = new parserFormula('VARA(TIME(12,0,0)+1,TIME(13,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(TIME(12,0,0)+1,TIME(13,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0008680555555555494, 'Test: Positive case: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.');
		// Case #16: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VARA(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #17: Number. Two numbers, one slightly above 1. 2 arguments used.
		oParser = new parserFormula('VARA(1.000000000000001,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(1.000000000000001,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Number. Two numbers, one slightly above 1. 2 arguments used.');
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VARA("12/12","12/13")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA("12/12","12/13") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String. Short date strings convertible to numbers. 2 arguments used.');
		// Case #19: Array. Two arrays with multiple valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA({2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA({2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6666666666666667, 'Test: Positive case: Array. Two arrays with multiple valid numbers. 2 arguments used.');
		// Case #20: Area. Two two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.33333333333333337, 'Test: Positive case: Area. Two two-cell ranges with valid numbers. 2 arguments used.');
		// Case #21: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.');

		// Negative cases
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VARA("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('VARA(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(NA(),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Two multi-cell ranges with non-numeric values return #VALUE!.
		oParser = new parserFormula('VARA(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0833333333333335, 'Test: Negative case: Area. Two multi-cell ranges with non-numeric values return #VALUE!.');
		// Case #4: Empty. References to empty cells return #DIV/0!.
		oParser = new parserFormula('VARA(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Empty. References to empty cells return #DIV/0!.');
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VARA("","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA("","") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty strings return #VALUE!. 2 arguments used.');
		// Case #6: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.
		oParser = new parserFormula('VARA(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.');
		// Case #7: Ref3D. Two 3D references to cells with text return #VALUE!.
		oParser = new parserFormula('VARA(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(Sheet2!A3,Sheet2!A4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. Two 3D references to cells with text return #VALUE!.');
		// Case #8: Name. Two named ranges with text return #VALUE!.
		oParser = new parserFormula('VARA(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8533333333333335, 'Test: Negative case: Name. Two named ranges with text return #VALUE!.');
		// Case #9: Table. Two table columns with text return #VALUE!.
		oParser = new parserFormula('VARA(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(Table1[Column2],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Two table columns with text return #VALUE!.');
		// Case #10: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.
		oParser = new parserFormula('VARA(SQRT(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(SQRT(-1),1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.');
		// Case #11: Array. Array with booleans and numbers returns valid variance. 2 arguments used.
		oParser = new parserFormula('VARA({FALSE,TRUE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA({FALSE,TRUE},{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Array. Array with booleans and numbers returns valid variance. 2 arguments used.');
		// Case #12: Number. Identical numbers return 0 (no variance). 2 arguments used.
		oParser = new parserFormula('VARA(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Identical numbers return 0 (no variance). 2 arguments used.');
		// Case #13: Time. Time values return valid variance. 2 arguments used.
		oParser = new parserFormula('VARA(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.000868055555555554, 'Test: Negative case: Time. Time values return valid variance. 2 arguments used.');
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		oParser = new parserFormula('VARA("-1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA("-1","2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 4.5, 'Test: Negative case: String. Strings convertible to numbers (negative and positive). 2 arguments used.');
		// Case #15: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.
		oParser = new parserFormula('VARA(MMULT(1,2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(MMULT(1,2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.');
		// Case #16: Name3D. Two 3D named ranges with text return #VALUE!.
		oParser = new parserFormula('VARA(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8533333333333335, 'Test: Negative case: Name3D. Two 3D named ranges with text return #VALUE!.');
		// Case #17: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.
		oParser = new parserFormula('VARA(Sheet2!A4:A5,Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(Sheet2!A4:A5,Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.');
		// Case #18: Reference link. References to cells with errors return #N/A.
		oParser = new parserFormula('VARA(A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(A105,A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. References to cells with errors return #N/A.');
		// Case #19: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.
		oParser = new parserFormula('VARA({1,"abc"},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA({1,"abc"},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VARA(1E-307,1E-307+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(1E-307,1E-307+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Number. Minimum positive numbers return calculable variance. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VARA(9.99999999999999E+307,9.99999999999998E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(9.99999999999999E+307,9.99999999999998E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.');
		// Case #3: Array. Arrays with minimum positive numbers. 2 arguments used.
		oParser = new parserFormula('VARA({1E-307,1E-307},{1E-307,1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA({1E-307,1E-307},{1E-307,1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Arrays with minimum positive numbers. 2 arguments used.');
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.
		oParser = new parserFormula('VARA(1E+307/SQRT(10),1E+307/SQRT(10)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARA(1E+307/SQRT(10),1E+307/SQRT(10)+1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.');

		// Need to fix: empty handle, string handle, error handle, error types diff, ms result diff
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		// Case #7: Ref3D. Two 3D references to cells with text return #VALUE!.
		// Case #9: Table. Two table columns with text return #VALUE!.
		// Case #10: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.
		// Case #11: Array. Array with booleans and numbers returns valid variance. 2 arguments used.
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		// Case #18: Reference link. References to cells with errors return #N/A.
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.

	});

	QUnit.test("Test: \"VARP\"", function (assert) {
		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Two valid number inputs. 2 arguments used.
		oParser = new parserFormula('VARP(10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number. Two valid number inputs. 2 arguments used.');
		// Case #2: Number. Multiple valid number inputs. 4 arguments used.
		oParser = new parserFormula('VARP(2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Positive case: Number. Multiple valid number inputs. 4 arguments used.');
		// Case #3: Formula. Two nested formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(SQRT(16),POWER(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(SQRT(16),POWER(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.25, 'Test: Positive case: Formula. Two nested formulas returning valid numbers. 2 arguments used.');
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VARP("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP("2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #5: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VARP(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #6: Reference link. References to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Reference link. References to cells with valid numbers. 2 arguments used.');
		// Case #7: Area. Two single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Area. Two single-cell ranges with valid numbers. 2 arguments used.');
		// Case #8: Array. Two arrays with single valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP({2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP({2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Array. Two arrays with single valid numbers. 2 arguments used.');
		// Case #9: Name. Two named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Name. Two named ranges with valid numbers. 2 arguments used.');
		// Case #10: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.');
		// Case #11: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.');
		// Case #12: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.');
		// Case #13: Table. Two table structured references with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Two table structured references with valid numbers. 2 arguments used.');
		// Case #14: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('VARP(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 240.25, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #15: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.
		oParser = new parserFormula('VARP(TIME(12,0,0)+1,TIME(13,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(TIME(12,0,0)+1,TIME(13,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0004340277777777747, 'Test: Positive case: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.');
		// Case #16: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VARP(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #17: Number. Two numbers, one slightly above 1. 2 arguments used.
		oParser = new parserFormula('VARP(1.000000000000001,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(1.000000000000001,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.25', 'Test: Positive case: Number. Two numbers, one slightly above 1. 2 arguments used.');
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VARP("12/12","12/13")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP("12/12","12/13") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: String. Short date strings convertible to numbers. 2 arguments used.');
		// Case #19: Array. Two arrays with multiple valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP({2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP({2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Positive case: Array. Two arrays with multiple valid numbers. 2 arguments used.');
		// Case #20: Area. Two two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22222222222222224, 'Test: Positive case: Area. Two two-cell ranges with valid numbers. 2 arguments used.');
		// Case #21: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VARP("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('VARP(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Two multi-cell ranges with non-numeric values return #VALUE!.
		oParser = new parserFormula('VARP(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7222222222222223, 'Test: Negative case: Area. Two multi-cell ranges with non-numeric values return #VALUE!.');
		// Case #4: Empty. References to empty cells return #DIV/0!.
		oParser = new parserFormula('VARP(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. References to empty cells return #DIV/0!.');
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VARP("","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP("","") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty strings return #VALUE!. 2 arguments used.');
		// Case #6: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.
		oParser = new parserFormula('VARP(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.');
		// Case #7: Ref3D. Two 3D references to cells with text return #VALUE!.
		oParser = new parserFormula('VARP(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. Two 3D references to cells with text return #VALUE!.');
		// Case #8: Name. Two named ranges with text return #VALUE!.
		oParser = new parserFormula('VARP(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.64', 'Test: Negative case: Name. Two named ranges with text return #VALUE!.');
		// Case #9: Table. Two table columns with text return #VALUE!.
		oParser = new parserFormula('VARP(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(Table1[Column2],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Two table columns with text return #VALUE!.');
		// Case #10: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.
		oParser = new parserFormula('VARP(SQRT(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(SQRT(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.');
		// Case #11: Array. Array with booleans and numbers returns valid variance. 2 arguments used.
		oParser = new parserFormula('VARP({FALSE,TRUE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP({FALSE,TRUE},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Array. Array with booleans and numbers returns valid variance. 2 arguments used.');
		// Case #12: Number. Identical numbers return 0 (no variance). 2 arguments used.
		oParser = new parserFormula('VARP(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Identical numbers return 0 (no variance). 2 arguments used.');
		// Case #13: Time. Time values return valid variance. 2 arguments used.
		oParser = new parserFormula('VARP(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.000434027777777777, 'Test: Negative case: Time. Time values return valid variance. 2 arguments used.');
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		oParser = new parserFormula('VARP("-1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP("-1","2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Negative case: String. Strings convertible to numbers (negative and positive). 2 arguments used.');
		// Case #15: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.
		oParser = new parserFormula('VARP(MMULT(1,2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(MMULT(1,2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.');
		// Case #16: Name3D. Two 3D named ranges with text return #VALUE!.
		oParser = new parserFormula('VARP(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.64', 'Test: Negative case: Name3D. Two 3D named ranges with text return #VALUE!.');
		// Case #17: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.
		oParser = new parserFormula('VARP(Sheet2!A4:A5,Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(Sheet2!A4:A5,Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.');
		// Case #18: Reference link. References to cells with errors return #N/A.
		oParser = new parserFormula('VARP(A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. References to cells with errors return #N/A.');
		// Case #19: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.
		oParser = new parserFormula('VARP({1,"abc"},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP({1,"abc"},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6666666666666666, 'Test: Negative case: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VARP(1E-307,1E-307+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(1E-307,1E-307+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Bounded case: Number. Minimum positive numbers return calculable variance. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VARP(9.99999999999999E+307,9.99999999999998E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(9.99999999999999E+307,9.99999999999998E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.');
		// Case #3: Array. Arrays with minimum positive numbers. 2 arguments used.
		oParser = new parserFormula('VARP({1E-307,1E-307},{1E-307,1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP({1E-307,1E-307},{1E-307,1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Arrays with minimum positive numbers. 2 arguments used.');
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.
		oParser = new parserFormula('VARP(1E+307/SQRT(10),1E+307/SQRT(10)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARP(1E+307/SQRT(10),1E+307/SQRT(10)+1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.');


		// Need to fix: empty handle, string handle, error handle, error types diff, ms result diff
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		// Case #9: Table. Two table columns with text return #VALUE!.
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.


	});

	QUnit.test("Test: \"VARPA\"", function (assert) {

		ws.getRange2("A202").setValue("1345");
		ws.getRange2("A203").setValue("1301");
		ws.getRange2("A204").setValue("1368");
		ws.getRange2("A205").setValue("1322");

		ws.getRange2("A206").setValue("1310");
		ws.getRange2("A207").setValue("1370");
		ws.getRange2("A208").setValue("1318");
		ws.getRange2("A209").setValue("1350");

		ws.getRange2("A210").setValue("1303");
		ws.getRange2("A211").setValue("1299");

		oParser = new parserFormula("VARPA(A202:A211)", "A1", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 678.84);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Two valid number inputs. 2 arguments used.
		oParser = new parserFormula('VARPA(10,20)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(10,20) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number. Two valid number inputs. 2 arguments used.');
		// Case #2: Number. Multiple valid number inputs. 4 arguments used.
		oParser = new parserFormula('VARPA(2,3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(2,3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Positive case: Number. Multiple valid number inputs. 4 arguments used.');
		// Case #3: Formula. Two nested formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(SQRT(16),POWER(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(SQRT(16),POWER(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.25, 'Test: Positive case: Formula. Two nested formulas returning valid numbers. 2 arguments used.');
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VARPA("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA("2","3") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: String. Strings convertible to numbers. 2 arguments used.');
		// Case #5: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VARPA(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(ABS(-4),SQRT(9),ROUND(2.7,0),POWER(2,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #6: Reference link. References to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Reference link. References to cells with valid numbers. 2 arguments used.');
		// Case #7: Area. Two single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Area. Two single-cell ranges with valid numbers. 2 arguments used.');
		// Case #8: Array. Two arrays with single valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA({2},{3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA({2},{3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Array. Two arrays with single valid numbers. 2 arguments used.');
		// Case #9: Name. Two named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Name. Two named ranges with valid numbers. 2 arguments used.');
		// Case #10: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. Two 3D named ranges with valid numbers. 2 arguments used.');
		// Case #11: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Ref3D. Two 3D references to cells with valid numbers. 2 arguments used.');
		// Case #12: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: Area3D. Two 3D single-cell ranges with valid numbers. 2 arguments used.');
		// Case #13: Table. Two table structured references with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Two table structured references with valid numbers. 2 arguments used.');
		// Case #14: Date. Dates as serial numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(DATE(2025,1,1),DATE(2025,2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(DATE(2025,1,1),DATE(2025,2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 240.25, 'Test: Positive case: Date. Dates as serial numbers. 2 arguments used.');
		// Case #15: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.
		oParser = new parserFormula('VARPA(TIME(12,0,0)+1,TIME(13,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(TIME(12,0,0)+1,TIME(13,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0004340277777777747, 'Test: Positive case: Time. Time values adjusted to valid numbers (>=1). 2 arguments used.');
		// Case #16: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.
		oParser = new parserFormula('VARPA(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(IF(TRUE,2,1),AVERAGE(2,4,6),SUM(1,1),COUNT(1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Formula. Multiple nested formulas returning valid numbers. 4 arguments used.');
		// Case #17: Number. Two numbers, one slightly above 1. 2 arguments used.
		oParser = new parserFormula('VARPA(1.000000000000001,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(1.000000000000001,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.25', 'Test: Positive case: Number. Two numbers, one slightly above 1. 2 arguments used.');
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('VARPA("12/12","12/13")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA("12/12","12/13") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Positive case: String. Short date strings convertible to numbers. 2 arguments used.');
		// Case #19: Array. Two arrays with multiple valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA({2,3},{4,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA({2,3},{4,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Positive case: Array. Two arrays with multiple valid numbers. 2 arguments used.');
		// Case #20: Area. Two two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(A100:A101,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(A100:A101,A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22222222222222224, 'Test: Positive case: Area. Two two-cell ranges with valid numbers. 2 arguments used.');
		// Case #21: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(Sheet2!A1:A2,Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(Sheet2!A1:A2,Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6666666666666666, 'Test: Positive case: Area3D. Two 3D two-cell ranges with valid numbers. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VARPA("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA("abc","def") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric strings return #VALUE!. 2 arguments used.');
		// Case #2: Error. Propagates #N/A error. 2 arguments used.
		oParser = new parserFormula('VARPA(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 2 arguments used.');
		// Case #3: Area. Two multi-cell ranges with non-numeric values return #VALUE!.
		oParser = new parserFormula('VARPA(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7222222222222223, 'Test: Negative case: Area. Two multi-cell ranges with non-numeric values return #VALUE!.');
		// Case #4: Empty. References to empty cells return #DIV/0!.
		oParser = new parserFormula('VARPA(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. References to empty cells return #DIV/0!.');
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		oParser = new parserFormula('VARPA("","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA("","") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty strings return #VALUE!. 2 arguments used.');
		// Case #6: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.
		oParser = new parserFormula('VARPA(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(FALSE,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Boolean. Boolean values (0, 1) return valid variance. 2 arguments used.');
		// Case #7: Ref3D. Two 3D references to cells with text return #VALUE!.
		oParser = new parserFormula('VARPA(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. Two 3D references to cells with text return #VALUE!.');
		// Case #8: Name. Two named ranges with text return #VALUE!.
		oParser = new parserFormula('VARPA(TestNameArea2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(TestNameArea2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.64', 'Test: Negative case: Name. Two named ranges with text return #VALUE!.');
		// Case #9: Table. Two table columns with text return #VALUE!.
		oParser = new parserFormula('VARPA(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(Table1[Column2],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Two table columns with text return #VALUE!.');
		// Case #10: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.
		oParser = new parserFormula('VARPA(SQRT(-1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(SQRT(-1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error propagates error. 2 arguments used.');
		// Case #11: Array. Array with booleans and numbers returns valid variance. 2 arguments used.
		oParser = new parserFormula('VARPA({FALSE,TRUE},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA({FALSE,TRUE},{1,2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Array. Array with booleans and numbers returns valid variance. 2 arguments used.');
		// Case #12: Number. Identical numbers return 0 (no variance). 2 arguments used.
		oParser = new parserFormula('VARPA(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Identical numbers return 0 (no variance). 2 arguments used.');
		// Case #13: Time. Time values return valid variance. 2 arguments used.
		oParser = new parserFormula('VARPA(TIME(12,0,0),TIME(13,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(TIME(12,0,0),TIME(13,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.000434027777777777, 'Test: Negative case: Time. Time values return valid variance. 2 arguments used.');
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		oParser = new parserFormula('VARPA("-1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA("-1","2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.25, 'Test: Negative case: String. Strings convertible to numbers (negative and positive). 2 arguments used.');
		// Case #15: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.
		oParser = new parserFormula('VARPA(MMULT(1,2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(MMULT(1,2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Negative case: Formula. Formula resulting in #DIV/0! error propagates error. 2 arguments used.');
		// Case #16: Name3D. Two 3D named ranges with text return #VALUE!.
		oParser = new parserFormula('VARPA(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.64', 'Test: Negative case: Name3D. Two 3D named ranges with text return #VALUE!.');
		// Case #17: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.
		oParser = new parserFormula('VARPA(Sheet2!A4:A5,Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(Sheet2!A4:A5,Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D. Two 3D ranges with mixed valid/invalid values return #VALUE!.');
		// Case #18: Reference link. References to cells with errors return #N/A.
		oParser = new parserFormula('VARPA(A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. References to cells with errors return #N/A.');
		// Case #19: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.
		oParser = new parserFormula('VARPA({1,"abc"},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA({1,"abc"},{2,3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.666666667, 'Test: Negative case: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Minimum positive numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VARPA(1E-307,1E-307+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(1E-307,1E-307+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.25, 'Test: Bounded case: Number. Minimum positive numbers return calculable variance. 2 arguments used.');
		// Case #2: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.
		oParser = new parserFormula('VARPA(9.99999999999999E+307,9.99999999999998E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(9.99999999999999E+307,9.99999999999998E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid Excel numbers return calculable variance. 2 arguments used.');
		// Case #3: Array. Arrays with minimum positive numbers. 2 arguments used.
		oParser = new parserFormula('VARPA({1E-307,1E-307},{1E-307,1E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA({1E-307,1E-307},{1E-307,1E-307}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Array. Arrays with minimum positive numbers. 2 arguments used.');
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.
		oParser = new parserFormula('VARPA(1E+307/SQRT(10),1E+307/SQRT(10)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VARPA(1E+307/SQRT(10),1E+307/SQRT(10)+1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.');

		// Need to fix: empty handle, string handle, error handle, error types diff, ms result diff
		// Case #4: String. Strings convertible to numbers. 2 arguments used.
		// Case #18: String. Short date strings convertible to numbers. 2 arguments used.
		// Case #1: String. Non-numeric strings return #VALUE!. 2 arguments used.
		// Case #5: String. Empty strings return #VALUE!. 2 arguments used.
		// Case #9: Table. Two table columns with text return #VALUE!.
		// Case #11: Array. Array with booleans and numbers returns valid variance. 2 arguments used.
		// Case #14: String. Strings convertible to numbers (negative and positive). 2 arguments used.
		// Case #19: Array. Arrays with mixed numeric and non-numeric values return #VALUE!.
		// Case #4: Formula. Formulas yielding near-maximum valid numbers. 2 arguments used.


		testArrayFormula2(assert, "VARPA", 1, 8, null, true);
	});

	QUnit.test("Test: \"WEIBULL\"", function (assert) {

		ws.getRange2("A2").setValue("105");
		ws.getRange2("A3").setValue("20");
		ws.getRange2("A4").setValue("100");

		oParser = new parserFormula("WEIBULL(A2,A3,A4,TRUE)", "A20", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.929581);

		oParser = new parserFormula("WEIBULL(A2,A3,A4,FALSE)", "A20", ws);
		assert.ok(oParser.parse(), "WEIBULL(A2,A3,A4,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.035589);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(4). Basic valid input: all numbers, cumulative TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Number(4). Basic valid input: all numbers, cumulative TRUE. 4 of 4 arguments used.');
		// Case #2: Number(4). Basic valid input: all numbers, cumulative FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.27590958087858175, 'Test: Positive case: Number(4). Basic valid input: all numbers, cumulative FALSE. 4 of 4 arguments used.');
		// Case #3: String(4). String inputs convertible to numbers and boolean. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL("2","1.5","2","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL("2","1.5","2","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: String(4). String inputs convertible to numbers and boolean. 4 of 4 arguments used.');
		// Case #4: Formula(4). All arguments filled with formulas. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(SQRT(4),SQRT(2.25),SQRT(4),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(SQRT(4),SQRT(2.25),SQRT(4),IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Formula(4). All arguments filled with formulas. 4 of 4 arguments used.');
		// Case #5: Reference link(4). All arguments as cell references. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.103638323514327, 'Test: Positive case: Reference link(4). All arguments as cell references. 4 of 4 arguments used.');
		// Case #6: Area(4). All arguments as single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.103638323514327, 'Test: Positive case: Area(4). All arguments as single-cell ranges. 4 of 4 arguments used.');
		// Case #7: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL({2},{1.5},{2},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL({2},{1.5},{2},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #8: Name(4). All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(TestName,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(TestName,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(4). All arguments as named ranges. 4 of 4 arguments used.');
		// Case #9: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #10: Ref3D(4). All arguments as 3D cell references. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(4). All arguments as 3D cell references. 4 of 4 arguments used.');
		// Case #11: Area3D(4). All arguments as 3D single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(4). All arguments as 3D single-cell ranges. 4 of 4 arguments used.');
		// Case #12: Table(4). All arguments as table references. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Table(4). All arguments as table references. 4 of 4 arguments used.');
		// Case #13: Date(3),Boolean. Date serial numbers as valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1265769814688118, 'Test: Positive case: Date(3),Boolean. Date serial numbers as valid numbers. 4 of 4 arguments used.');
		// Case #14: Time,Number(2),Boolean. Time adjusted to valid number (>0). 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(TIME(12,0,0)+2,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(TIME(12,0,0)+2,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7527962752955224, 'Test: Positive case: Time,Number(2),Boolean. Time adjusted to valid number (>0). 4 of 4 arguments used.');
		// Case #15: Formula,Number(3). WEIBULL.DIST with x as SUM formula. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(SUM(1,1),1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(SUM(1,1),1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Formula,Number(3). WEIBULL.DIST with x as SUM formula. 4 of 4 arguments used.');
		// Case #16: Number(3),String. Cumulative as string convertible to boolean. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,2,"FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,2,"FALSE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.275909581, 'Test: Positive case: Number(3),String. Cumulative as string convertible to boolean. 4 of 4 arguments used.');
		// Case #17: String(3),Number. Strings convertible to numbers, cumulative as number (1=TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL("2","1.5","2",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL("2","1.5","2",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: String(3),Number. Strings convertible to numbers, cumulative as number (1=TRUE). 4 of 4 arguments used.');
		// Case #18: Array(3),Boolean. Multi-element arrays with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL({2,3},{1.5,2},{2,3},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL({2,3},{1.5,2},{2,3},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Array(3),Boolean. Multi-element arrays with valid values. 4 of 4 arguments used.');
		// Case #19: Formula(3),Boolean. Nested IF formulas returning valid values. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(IF(TRUE,2,1),IF(TRUE,1.5,1),IF(TRUE,2,1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(IF(TRUE,2,1),IF(TRUE,1.5,1),IF(TRUE,2,1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Formula(3),Boolean. Nested IF formulas returning valid values. 4 of 4 arguments used.');
		// Case #20: Number,Formula(2),Boolean. Alpha and beta as formulas. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,SQRT(2.25),SQRT(4),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,SQRT(2.25),SQRT(4),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Number,Formula(2),Boolean. Alpha and beta as formulas. 4 of 4 arguments used.');
		// Case #21: String(3),Number. Short date string convertible to number. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL("12/12","1.5","2",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL("12/12","1.5","2",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String(3),Number. Short date string convertible to number. 4 of 4 arguments used.');
		// Case #22: Formula,Number(3). x as ABS formula converting negative to positive. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(ABS(-2),1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(ABS(-2),1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Formula,Number(3). x as ABS formula converting negative to positive. 4 of 4 arguments used.');
		// Case #23: Formula,Number(3). WEIBULL.DIST nested in SUM as x argument. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(SUM(WEIBULL(2,1.5,2,TRUE),1),1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(SUM(WEIBULL(2,1.5,2,TRUE),1),1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5215466959729514, 'Test: Positive case: Formula,Number(3). WEIBULL.DIST nested in SUM as x argument. 4 of 4 arguments used.');
		// Case #24: Number(3),Formula. Cumulative as nested IF formula. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,2,IF(1>0,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,2,IF(1>0,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Number(3),Formula. Cumulative as nested IF formula. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number(4). Negative x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(-1,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(-1,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Negative x returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number(4). Alpha <= 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,0,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,0,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Alpha <= 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number(4). Beta <= 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Beta <= 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #4: String(4). Non-numeric string for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL("abc","1.5","2","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL("abc","1.5","2","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: String(4). Non-numeric string for alpha returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL("2","abc","2","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL("2","abc","2","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string for alpha returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: String(4). Non-numeric string for beta returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL("2","1.5","abc","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL("2","1.5","abc","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string for beta returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: String(4). Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL("2","1.5","2","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL("2","1.5","2","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.');
		// Case #8: Error,Number(3). Error input propagates #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(NA(),1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(NA(),1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(3). Error input propagates #N/A. 4 of 4 arguments used.');
		// Case #9: Area(4). Multi-cell range for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(A100:A101,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(A100:A101,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.103638324, 'Test: Negative case: Area(4). Multi-cell range for x returns #NUM!. 4 of 4 arguments used.');
		// Case #10: Number,Area(3). Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,A101:A102,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,A101:A102,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.002012776, 'Test: Negative case: Number,Area(3). Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #11: Number(2),Area(2). Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,A102:A103,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,A102:A103,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.002012776, 'Test: Negative case: Number(2),Area(2). Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.');
		// Case #12: Number(3),Area. Multi-cell range for cumulative returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,2,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,2,A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.275909581, 'Test: Negative case: Number(3),Area. Multi-cell range for cumulative returns #NUM!. 4 of 4 arguments used.');
		// Case #13: Empty,Number(3). Empty x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty,Number(3). Empty x returns #NUM!. 4 of 4 arguments used.');
		// Case #14: Number,Empty,Number(2). Empty alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Empty,Number(2). Empty alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #15: Number(2),Empty,Number. Empty beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2),Empty,Number. Empty beta returns #NUM!. 4 of 4 arguments used.');
		// Case #16: Number(3),Empty. Empty cumulative returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.27590958087858175, 'Test: Negative case: Number(3),Empty. Empty cumulative returns #NUM!. 4 of 4 arguments used.');
		// Case #17: Array(4). Array with invalid data for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL({FALSE},{1.5},{2},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL({FALSE},{1.5},{2},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array(4). Array with invalid data for x returns #NUM!. 4 of 4 arguments used.');
		// Case #18: Name,Number(3). Name with area for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(TestNameArea2,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(TestNameArea2,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22351830687438223, 'Test: Negative case: Name,Number(3). Name with area for x returns #NUM!. 4 of 4 arguments used.');
		// Case #19: Number,Name,Number(2). Name with area for alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,TestNameArea2,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,TestNameArea2,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Negative case: Number,Name,Number(2). Name with area for alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #20: Number(2),Name,Number. Name with area for beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,TestNameArea2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,TestNameArea2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9808000398449904, 'Test: Negative case: Number(2),Name,Number. Name with area for beta returns #NUM!. 4 of 4 arguments used.');
		// Case #21: Number(3),Name. Name with area for cumulative returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(2,1.5,2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(2,1.5,2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Negative case: Number(3),Name. Name with area for cumulative returns #NUM!. 4 of 4 arguments used.');
		// Case #22: Ref3D(4). 3D ref to invalid data (e.g., text) returns #VALUE!.
		oParser = new parserFormula('WEIBULL(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(4). 3D ref to invalid data (e.g., text) returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number(4). Minimum valid values: x=0, alpha and beta near Excelâ??s smallest positive number. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(0,1E-307,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(0,1E-307,1E-307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(4). Minimum valid values: x=0, alpha and beta near Excelâ??s smallest positive number. 4 of 4 arguments used.');
		// Case #2: Number(4). Maximum valid Excel numbers for x, alpha, beta. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL(9.99999999999999E+307,1E+307,1E+307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL(9.99999999999999E+307,1E+307,1E+307,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(4). Maximum valid Excel numbers for x, alpha, beta. 4 of 4 arguments used.');

		// Need to fix: area handle, string and bool handle, boundary result diff from MS
		// Case #3: String(4). String inputs convertible to numbers and boolean. 4 of 4 arguments used.
		// Case #16: Number(3),String. Cumulative as string convertible to boolean. 4 of 4 arguments used.
		// Case #9: Area(4). Multi-cell range for x returns #NUM!. 4 of 4 arguments used.
		// Case #10: Number,Area(3). Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.
		// Case #11: Number(2),Area(2). Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.
		// Case #12: Number(3),Area. Multi-cell range for cumulative returns #NUM!. 4 of 4 arguments used.
		// Case #2: Number(4). Maximum valid Excel numbers for x, alpha, beta. 4 of 4 arguments used.

		testArrayFormula2(assert, "WEIBULL", 4, 4);
	});

	QUnit.test("Test: \"WEIBULL.DIST\"", function (assert) {

		ws.getRange2("A2").setValue("105");
		ws.getRange2("A3").setValue("20");
		ws.getRange2("A4").setValue("100");

		oParser = new parserFormula("WEIBULL.DIST(A2,A3,A4,TRUE)", "A20", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.929581);

		oParser = new parserFormula("WEIBULL.DIST(A2,A3,A4,FALSE)", "A20", ws);
		assert.ok(oParser.parse(), "WEIBULL.DIST(A2,A3,A4,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.035589);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(4). Basic valid input: all numbers, cumulative TRUE. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Number(4). Basic valid input: all numbers, cumulative TRUE. 4 of 4 arguments used.');
		// Case #2: Number(4). Basic valid input: all numbers, cumulative FALSE. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.27590958087858175, 'Test: Positive case: Number(4). Basic valid input: all numbers, cumulative FALSE. 4 of 4 arguments used.');
		// Case #3: String(4). String inputs convertible to numbers and boolean. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST("2","1.5","2","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST("2","1.5","2","TRUE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: String(4). String inputs convertible to numbers and boolean. 4 of 4 arguments used.');
		// Case #4: Formula(4). All arguments filled with formulas. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(SQRT(4),SQRT(2.25),SQRT(4),IF(TRUE,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(SQRT(4),SQRT(2.25),SQRT(4),IF(TRUE,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Formula(4). All arguments filled with formulas. 4 of 4 arguments used.');
		// Case #5: Reference link(4). All arguments as cell references. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.103638323514327, 'Test: Positive case: Reference link(4). All arguments as cell references. 4 of 4 arguments used.');
		// Case #6: Area(4). All arguments as single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.103638323514327, 'Test: Positive case: Area(4). All arguments as single-cell ranges. 4 of 4 arguments used.');
		// Case #7: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST({2},{1.5},{2},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST({2},{1.5},{2},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #8: Name(4). All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(TestName,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(TestName,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(4). All arguments as named ranges. 4 of 4 arguments used.');
		// Case #9: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #10: Ref3D(4). All arguments as 3D cell references. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(4). All arguments as 3D cell references. 4 of 4 arguments used.');
		// Case #11: Area3D(4). All arguments as 3D single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(4). All arguments as 3D single-cell ranges. 4 of 4 arguments used.');
		// Case #12: Table(4). All arguments as table references. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Table(4). All arguments as table references. 4 of 4 arguments used.');
		// Case #13: Date(3),Boolean. Date serial numbers as valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(DATE(2025,1,1),DATE(2025,1,2),DATE(2025,1,3),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1265769814688118, 'Test: Positive case: Date(3),Boolean. Date serial numbers as valid numbers. 4 of 4 arguments used.');
		// Case #14: Time,Number(2),Boolean. Time adjusted to valid number (>0). 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(TIME(12,0,0)+2,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(TIME(12,0,0)+2,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7527962752955224, 'Test: Positive case: Time,Number(2),Boolean. Time adjusted to valid number (>0). 4 of 4 arguments used.');
		// Case #15: Formula,Number(3). WEIBULL.DIST with x as SUM formula. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(SUM(1,1),1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(SUM(1,1),1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Formula,Number(3). WEIBULL.DIST with x as SUM formula. 4 of 4 arguments used.');
		// Case #16: Number(3),String. Cumulative as string convertible to boolean. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,2,"FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,2,"FALSE") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.275909581, 'Test: Positive case: Number(3),String. Cumulative as string convertible to boolean. 4 of 4 arguments used.');
		// Case #17: String(3),Number. Strings convertible to numbers, cumulative as number (1=TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST("2","1.5","2",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST("2","1.5","2",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: String(3),Number. Strings convertible to numbers, cumulative as number (1=TRUE). 4 of 4 arguments used.');
		// Case #18: Array(3),Boolean. Multi-element arrays with valid values. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST({2,3},{1.5,2},{2,3},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST({2,3},{1.5,2},{2,3},TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Array(3),Boolean. Multi-element arrays with valid values. 4 of 4 arguments used.');
		// Case #19: Formula(3),Boolean. Nested IF formulas returning valid values. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(IF(TRUE,2,1),IF(TRUE,1.5,1),IF(TRUE,2,1),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(IF(TRUE,2,1),IF(TRUE,1.5,1),IF(TRUE,2,1),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Formula(3),Boolean. Nested IF formulas returning valid values. 4 of 4 arguments used.');
		// Case #20: Number,Formula(2),Boolean. Alpha and beta as formulas. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,SQRT(2.25),SQRT(4),TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,SQRT(2.25),SQRT(4),TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Number,Formula(2),Boolean. Alpha and beta as formulas. 4 of 4 arguments used.');
		// Case #21: String(3),Number. Short date string convertible to number. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST("12/12","1.5","2",TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST("12/12","1.5","2",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String(3),Number. Short date string convertible to number. 4 of 4 arguments used.');
		// Case #22: Formula,Number(3). x as ABS formula converting negative to positive. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(ABS(-2),1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(ABS(-2),1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Formula,Number(3). x as ABS formula converting negative to positive. 4 of 4 arguments used.');
		// Case #23: Formula,Number(3). WEIBULL.DIST nested in SUM as x argument. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(SUM(WEIBULL.DIST(2,1.5,2,TRUE),1),1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(SUM(WEIBULL.DIST(2,1.5,2,TRUE),1),1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5215466959729514, 'Test: Positive case: Formula,Number(3). WEIBULL.DIST nested in SUM as x argument. 4 of 4 arguments used.');
		// Case #24: Number(3),Formula. Cumulative as nested IF formula. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,2,IF(1>0,TRUE,FALSE))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,2,IF(1>0,TRUE,FALSE)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Positive case: Number(3),Formula. Cumulative as nested IF formula. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number(4). Negative x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(-1,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(-1,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Negative x returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number(4). Alpha <= 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,0,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,0,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Alpha <= 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number(4). Beta <= 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Beta <= 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #4: String(4). Non-numeric string for x returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST("abc","1.5","2","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST("abc","1.5","2","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string for x returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: String(4). Non-numeric string for alpha returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST("2","abc","2","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST("2","abc","2","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string for alpha returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: String(4). Non-numeric string for beta returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST("2","1.5","abc","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST("2","1.5","abc","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric string for beta returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: String(4). Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST("2","1.5","2","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST("2","1.5","2","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-boolean string for cumulative returns #VALUE!. 4 of 4 arguments used.');
		// Case #8: Error,Number(3). Error input propagates #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(NA(),1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(NA(),1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(3). Error input propagates #N/A. 4 of 4 arguments used.');
		// Case #9: Area(4). Multi-cell range for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(A100:A101,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(A100:A101,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.103638324, 'Test: Negative case: Area(4). Multi-cell range for x returns #NUM!. 4 of 4 arguments used.');
		// Case #10: Number,Area(3). Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,A101:A102,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,A101:A102,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.002012776, 'Test: Negative case: Number,Area(3). Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #11: Number(2),Area(2). Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,A102:A103,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,A102:A103,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.002012776, 'Test: Negative case: Number(2),Area(2). Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.');
		// Case #12: Number(3),Area. Multi-cell range for cumulative returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,2,A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,2,A103:A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.275909581, 'Test: Negative case: Number(3),Area. Multi-cell range for cumulative returns #NUM!. 4 of 4 arguments used.');
		// Case #13: Empty,Number(3). Empty x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty,Number(3). Empty x returns #NUM!. 4 of 4 arguments used.');
		// Case #14: Number,Empty,Number(2). Empty alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Empty,Number(2). Empty alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #15: Number(2),Empty,Number. Empty beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2),Empty,Number. Empty beta returns #NUM!. 4 of 4 arguments used.');
		// Case #16: Number(3),Empty. Empty cumulative returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.27590958087858175, 'Test: Negative case: Number(3),Empty. Empty cumulative returns #NUM!. 4 of 4 arguments used.');
		// Case #17: Array(4). Array with invalid data for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST({FALSE},{1.5},{2},{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST({FALSE},{1.5},{2},{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array(4). Array with invalid data for x returns #NUM!. 4 of 4 arguments used.');
		// Case #18: Name,Number(3). Name with area for x returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(TestNameArea2,1.5,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(TestNameArea2,1.5,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22351830687438223, 'Test: Negative case: Name,Number(3). Name with area for x returns #NUM!. 4 of 4 arguments used.');
		// Case #19: Number,Name,Number(2). Name with area for alpha returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,TestNameArea2,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,TestNameArea2,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Negative case: Number,Name,Number(2). Name with area for alpha returns #NUM!. 4 of 4 arguments used.');
		// Case #20: Number(2),Name,Number. Name with area for beta returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,TestNameArea2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,TestNameArea2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9808000398449904, 'Test: Negative case: Number(2),Name,Number. Name with area for beta returns #NUM!. 4 of 4 arguments used.');
		// Case #21: Number(3),Name. Name with area for cumulative returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(2,1.5,2,TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(2,1.5,2,TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6321205588285577, 'Test: Negative case: Number(3),Name. Name with area for cumulative returns #NUM!. 4 of 4 arguments used.');
		// Case #22: Ref3D(4). 3D ref to invalid data (e.g., text) returns #VALUE!.
		oParser = new parserFormula('WEIBULL.DIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(4). 3D ref to invalid data (e.g., text) returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number(4). Minimum valid values: x=0, alpha and beta near Excelâ??s smallest positive number. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(0,1E-307,1E-307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(0,1E-307,1E-307,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(4). Minimum valid values: x=0, alpha and beta near Excelâ??s smallest positive number. 4 of 4 arguments used.');
		// Case #2: Number(4). Maximum valid Excel numbers for x, alpha, beta. 4 of 4 arguments used.
		oParser = new parserFormula('WEIBULL.DIST(9.99999999999999E+307,1E+307,1E+307,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: WEIBULL.DIST(9.99999999999999E+307,1E+307,1E+307,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(4). Maximum valid Excel numbers for x, alpha, beta. 4 of 4 arguments used.');

		// Need to fix: string handle, area handle, NUM err, boundary case diff
		// Case #3: String(4). String inputs convertible to numbers and boolean. 4 of 4 arguments used.
		// Case #16: Number(3),String. Cumulative as string convertible to boolean. 4 of 4 arguments used.
		// Case #9: Area(4). Multi-cell range for x returns #NUM!. 4 of 4 arguments used.
		// Case #10: Number,Area(3). Multi-cell range for alpha returns #NUM!. 4 of 4 arguments used.
		// Case #11: Number(2),Area(2). Multi-cell range for beta returns #NUM!. 4 of 4 arguments used.
		// Case #12: Number(3),Area. Multi-cell range for cumulative returns #NUM!. 4 of 4 arguments used.\
		// Case #2: Number(4). Maximum valid Excel numbers for x, alpha, beta. 4 of 4 arguments used.


		testArrayFormula2(assert, "WEIBULL.DIST", 4, 4);
	});

	QUnit.test("Test: \"ZTEST\"", function (assert) {
		ws.getRange2("A2").setValue("3");
		ws.getRange2("A3").setValue("6");
		ws.getRange2("A4").setValue("7");
		ws.getRange2("A5").setValue("8");
		ws.getRange2("A6").setValue("6");
		ws.getRange2("A7").setValue("5");
		ws.getRange2("A8").setValue("4");
		ws.getRange2("A9").setValue("2");
		ws.getRange2("A10").setValue("1");
		ws.getRange2("A11").setValue("9");

		oParser = new parserFormula("ZTEST(A2:A11,4)", "A1", ws);
		assert.ok(oParser.parse(), "ZTEST(A2:A11,4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.090574, "ZTEST(A2:A11,4)");

		oParser = new parserFormula("2 * MIN(ZTEST(A2:A11,4), 1 - ZTEST(A2:A11,4))", "A1", ws);
		assert.ok(oParser.parse(), "2 * MIN(ZTEST(A2:A11,4), 1 - ZTEST(A2:A11,4))");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.181148, "2 * MIN(ZTEST(A2:A11,4), 1 - ZTEST(A2:A11,4))");

		oParser = new parserFormula("ZTEST(A2:A11,6)", "A1", ws);
		assert.ok(oParser.parse(), "ZTEST(A2:A11,6)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.863043, "ZTEST(A2:A11,6)");

		oParser = new parserFormula("2 * MIN(ZTEST(A2:A11,6), 1 - ZTEST(A2:A11,6))", "A1", ws);
		assert.ok(oParser.parse(), "2 * MIN(ZTEST(A2:A11,6), 1 - ZTEST(A2:A11,6))");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.273913, "2 * MIN(ZTEST(A2:A11,6), 1 - ZTEST(A2:A11,6))");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Basic valid input: array of numbers, x as number, sigma provided. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1,2,3},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1,2,3},2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Basic valid input: array of numbers, x as number, sigma provided. 3 of 3 arguments used.');
		// Case #1: Number,Number. Array of numbers, x as number, sigma omitted. 2 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1,2,3},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1,2,3},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number,Number. Array of numbers, x as number, sigma omitted. 2 of 3 arguments used.');
		// Case #2: Reference link. Reference link to range with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(A100:A102,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(A100:A102,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.978345928594604, 'Test: Positive case: Reference link. Reference link to range with valid numbers. 3 of 3 arguments used.');
		// Case #3: Area. Single-cell range, x and sigma as numbers. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(A100:A100,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(A100:A100,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area. Single-cell range, x and sigma as numbers. 3 of 3 arguments used.');
		// Case #4: String. String array and arguments convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({"1","2","3"},"2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({"1","2","3"},"2","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. String array and arguments convertible to numbers. 3 of 3 arguments used.');
		// Case #5: Formula. Nested formula for x. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1,2,3},AVERAGE(1,2,3),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1,2,3},AVERAGE(1,2,3),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested formula for x. 3 of 3 arguments used.');
		// Case #6: Array. Larger array of numbers. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1,2,3,4,5},3,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1,2,3,4,5},3,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Larger array of numbers. 3 of 3 arguments used.');
		// Case #7: Reference link,Number. Reference link for array and x, sigma omitted. 2 of 3 arguments used.
		oParser = new parserFormula('ZTEST(A100:A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(A100:A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.006209665325776159, 'Test: Positive case: Reference link,Number. Reference link for array and x, sigma omitted. 2 of 3 arguments used.');
		// Case #8: Name. Named range with valid array. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(TestName,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(TestName,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Named range with valid array. 3 of 3 arguments used.');
		// Case #9: Name3D. 3D named range with valid array. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(TestName3D,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(TestName3D,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named range with valid array. 3 of 3 arguments used.');
		// Case #10: Ref3D. 3D reference to range with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(Sheet2!A1:A3,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(Sheet2!A1:A3,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7602499389068355, 'Test: Positive case: Ref3D. 3D reference to range with valid numbers. 3 of 3 arguments used.');
		// Case #11: Area3D. 3D single-cell range. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(Sheet2!A1:A1,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(Sheet2!A1:A1,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D single-cell range. 3 of 3 arguments used.');
		// Case #12: Table. Table structured reference with valid array. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(Table1[Column1],2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(Table1[Column1],2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured reference with valid array. 3 of 3 arguments used.');
		// Case #13: Date. Date serial numbers in array. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({38777,38778,38779},38778,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({38777,38778,38779},38778,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Date. Date serial numbers in array. 3 of 3 arguments used.');
		// Case #14: Time. Time values (fractions) in array. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({0.5,0.6,0.7},0.6,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({0.5,0.6,0.7},0.6,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Time. Time values (fractions) in array. 3 of 3 arguments used.');
		// Case #15: Formula. ZTEST inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(ZTEST({1,2,3},2,1),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(ZTEST({1,2,3},2,1),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. ZTEST inside SUM formula. 3 of 3 arguments used.');
		// Case #16: Number. Array with value slightly above 1. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1.000000000000001,2,3},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1.000000000000001,2,3},2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Number. Array with value slightly above 1. 3 of 3 arguments used.');
		// Case #17: String. Numeric strings in array and arguments. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({"1.5","2.5","3.5"},"2.5","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({"1.5","2.5","3.5"},"2.5","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Numeric strings in array and arguments. 3 of 3 arguments used.');
		// Case #18: Array. Two-element array. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1,2},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1,2},2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7602499389068355, 'Test: Positive case: Array. Two-element array. 3 of 3 arguments used.');
		// Case #19: Formula. Nested IF returning valid array. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(IF(TRUE,{1,2,3},{4,5,6}),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(IF(TRUE,{1,2,3},{4,5,6}),2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested IF returning valid array. 3 of 3 arguments used.');
		// Case #20: Reference link,Formula,Number. Reference link and nested formula for x. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(A100:A102,AVERAGE(A100:A102),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(A100:A102,AVERAGE(A100:A102),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link,Formula,Number. Reference link and nested formula for x. 3 of 3 arguments used.');
		// Case #21: Area3D. 3D multi-cell range (two cells). 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(Sheet2!A1:A2,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(Sheet2!A1:A2,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7602499389068355, 'Test: Positive case: Area3D. 3D multi-cell range (two cells). 3 of 3 arguments used.');
		// Case #22: Number,Formula. Date as x, large sigma. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1,2,3},DATE(2025,1,1),1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1,2,3},DATE(2025,1,1),1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number,Formula. Date as x, large sigma. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Sigma is zero, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({0.5,0.6,0.7},0.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({0.5,0.6,0.7},0.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Sigma is zero, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #2: Number. Negative numbers in array, valid for ZTEST but testing edge case. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({-1,-2,-3},-1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({-1,-2,-3},-1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9583677416682248, 'Test: Negative case: Number. Negative numbers in array, valid for ZTEST but testing edge case. 3 of 3 arguments used.');
		// Case #3: String. Non-numeric strings in array, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({"abc","def","ghi"},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({"abc","def","ghi"},2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Non-numeric strings in array, returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: String. String convertible to numbers, but sigma is zero, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({"0.5","0.6","0.7"},"0.5","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({"0.5","0.6","0.7"},"0.5","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. String convertible to numbers, but sigma is zero, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #5: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(NA(),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(NA(),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #6: Area. Multi-cell range with non-numeric data, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(A100:A101,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(A100:A101,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9213503964748575, 'Test: Negative case: Area. Multi-cell range with non-numeric data, returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Empty. Empty reference link, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(A103,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(A103,2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Empty reference link, returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: String. Empty string in array, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({""},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({""},2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Empty string in array, returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Boolean. Boolean values in array, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({FALSE,TRUE,FALSE},0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({FALSE,TRUE,FALSE},0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean. Boolean values in array, returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Ref3D. 3D reference to cell with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(Sheet2!A4,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(Sheet2!A4,2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D. 3D reference to cell with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Name. Named range with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(TestNameArea2,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(TestNameArea2,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9976611325094764, 'Test: Negative case: Name. Named range with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Table. Table column with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(Table1[Column2],2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(Table1[Column2],2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(SQRT(-1),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(SQRT(-1),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #14: Number. Zero variance in array and sigma=0, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({0,0,0},0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({0,0,0},0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero variance in array and sigma=0, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #15: Array. Array with boolean, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({FALSE},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({FALSE},2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Array with boolean, returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Number. Negative sigma, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1,2,3},1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1,2,3},1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative sigma, returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Number. Array with value exceeding Excel limit, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1E+307,2,3},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1E+307,2,3},2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Array with value exceeding Excel limit, returns #NUM!. 3 of 3 arguments used.');
		// Case #18: String. Date string converting to negative number, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({"-01/01/2025"},"2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({"-01/01/2025"},"2","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Date string converting to negative number, returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Time. Time value for x, sigma=0, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({0.5,0.6,0.7},TIME(12,0,0),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({0.5,0.6,0.7},TIME(12,0,0),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time value for x, sigma=0, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #20: Area3D. 3D multi-cell range with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST(Sheet2!A1:A2,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST(Sheet2!A1:A2,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7602499389068355, 'Test: Negative case: Area3D. 3D multi-cell range with text, returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid values for array, x, and sigma. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1E-307,2E-307,3E-307},1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1E-307,2E-307,3E-307},1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.041632258331775196, 'Test: Bounded case: Number. Minimum valid values for array, x, and sigma. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid values for array, x, and sigma. 3 of 3 arguments used.
		oParser = new parserFormula('ZTEST({1E+307,0.5E+307,0.25E+307},1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ZTEST({1E+307,0.5E+307,0.25E+307},1E+307,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7647567889710651, 'Test: Bounded case: Number. Maximum valid values for array, x, and sigma. 3 of 3 arguments used.');

		// Need to fix: many problems with #N/A err, different results from MS
		// Case #4: String. String array and arguments convertible to numbers. 3 of 3 arguments used.
		// Case #17: String. Numeric strings in array and arguments. 3 of 3 arguments used.
		// Case #19: Formula. Nested IF returning valid array. 3 of 3 arguments used.
		// Case #3: String. Non-numeric strings in array, returns #VALUE!. 3 of 3 arguments used.
		// Case #4: String. String convertible to numbers, but sigma is zero, returns #DIV/0!. 3 of 3 arguments used.
		// Case #7: Empty. Empty reference link, returns #VALUE!. 3 of 3 arguments used.
		// Case #8: String. Empty string in array, returns #VALUE!. 3 of 3 arguments used.
		// Case #9: Boolean. Boolean values in array, returns #VALUE!. 3 of 3 arguments used.
		// Case #10: Ref3D. 3D reference to cell with text, returns #VALUE!. 3 of 3 arguments used.
		// Case #12: Table. Table column with text, returns #VALUE!. 3 of 3 arguments used.
		// Case #15: Array. Array with boolean, returns #VALUE!. 3 of 3 arguments used.
		// Case #18: String. Date string converting to negative number, returns #VALUE!. 3 of 3 arguments used.


		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "Z.TEST", 2, 3, null, true);
	});

	QUnit.test("Test: \"Z.TEST\"", function (assert) {
		ws.getRange2("A2").setValue("3");
		ws.getRange2("A3").setValue("6");
		ws.getRange2("A4").setValue("7");
		ws.getRange2("A5").setValue("8");
		ws.getRange2("A6").setValue("6");
		ws.getRange2("A7").setValue("5");
		ws.getRange2("A8").setValue("4");
		ws.getRange2("A9").setValue("2");
		ws.getRange2("A10").setValue("1");
		ws.getRange2("A11").setValue("9");

		oParser = new parserFormula("Z.TEST(A2:A11,4)", "A1", ws);
		assert.ok(oParser.parse(), "Z.TEST(A2:A11,4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.090574, "Z.TEST(A2:A11,4)");

		oParser = new parserFormula("2 * MIN(Z.TEST(A2:A11,4), 1 - Z.TEST(A2:A11,4))", "A1", ws);
		assert.ok(oParser.parse(), "2 * MIN(Z.TEST(A2:A11,4), 1 - Z.TEST(A2:A11,4))");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.181148, "2 * MIN(Z.TEST(A2:A11,4), 1 - Z.TEST(A2:A11,4))");

		oParser = new parserFormula("Z.TEST(A2:A11,6)", "A1", ws);
		assert.ok(oParser.parse(), "Z.TEST(A2:A11,6)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.863043, "Z.TEST(A2:A11,6)");

		oParser = new parserFormula("2 * MIN(Z.TEST(A2:A11,6), 1 - Z.TEST(A2:A11,6))", "A1", ws);
		assert.ok(oParser.parse(), "2 * MIN(Z.TEST(A2:A11,6), 1 - Z.TEST(A2:A11,6))");
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.273913, "2 * MIN(Z.TEST(A2:A11,6), 1 - Z.TEST(A2:A11,6))");

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: array of numbers, x as number, sigma provided. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1,2,3},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1,2,3},2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number. Basic valid input: array of numbers, x as number, sigma provided. 3 of 3 arguments used.');
		// Case #1: Number,Number. Array of numbers, x as number, sigma omitted. 2 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1,2,3},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1,2,3},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Number,Number. Array of numbers, x as number, sigma omitted. 2 of 3 arguments used.');
		// Case #2: Reference link. Reference link to range with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(A100:A102,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(A100:A102,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.978345928594604, 'Test: Positive case: Reference link. Reference link to range with valid numbers. 3 of 3 arguments used.');
		// Case #3: Area. Single-cell range, x and sigma as numbers. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(A100:A100,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(A100:A100,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area. Single-cell range, x and sigma as numbers. 3 of 3 arguments used.');
		// Case #4: String. String array and arguments convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({"1","2","3"},"2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({"1","2","3"},"2","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. String array and arguments convertible to numbers. 3 of 3 arguments used.');
		// Case #5: Formula. Nested formula for x. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1,2,3},AVERAGE(1,2,3),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1,2,3},AVERAGE(1,2,3),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested formula for x. 3 of 3 arguments used.');
		// Case #6: Array. Larger array of numbers. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1,2,3,4,5},3,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1,2,3,4,5},3,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Array. Larger array of numbers. 3 of 3 arguments used.');
		// Case #7: Reference link,Number. Reference link for array and x, sigma omitted. 2 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(A100:A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(A100:A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.006209665325776159, 'Test: Positive case: Reference link,Number. Reference link for array and x, sigma omitted. 2 of 3 arguments used.');
		// Case #8: Name. Named range with valid array. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(TestName,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(TestName,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name. Named range with valid array. 3 of 3 arguments used.');
		// Case #9: Name3D. 3D named range with valid array. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(TestName3D,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(TestName3D,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D. 3D named range with valid array. 3 of 3 arguments used.');
		// Case #10: Ref3D. 3D reference to range with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(Sheet2!A1:A3,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(Sheet2!A1:A3,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7602499389068355, 'Test: Positive case: Ref3D. 3D reference to range with valid numbers. 3 of 3 arguments used.');
		// Case #11: Area3D. 3D single-cell range. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(Sheet2!A1:A1,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(Sheet2!A1:A1,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D single-cell range. 3 of 3 arguments used.');
		// Case #12: Table. Table structured reference with valid array. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(Table1[Column1],2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(Table1[Column1],2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Table. Table structured reference with valid array. 3 of 3 arguments used.');
		// Case #13: Date. Date serial numbers in array. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({38777,38778,38779},38778,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({38777,38778,38779},38778,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Date. Date serial numbers in array. 3 of 3 arguments used.');
		// Case #14: Time. Time values (fractions) in array. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({0.5,0.6,0.7},0.6,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({0.5,0.6,0.7},0.6,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Time. Time values (fractions) in array. 3 of 3 arguments used.');
		// Case #15: Formula. Z.TEST inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(Z.TEST({1,2,3},2,1),0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(Z.TEST({1,2,3},2,1),0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Z.TEST inside SUM formula. 3 of 3 arguments used.');
		// Case #16: Number. Array with value slightly above 1. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1.000000000000001,2,3},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1.000000000000001,2,3},2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.5', 'Test: Positive case: Number. Array with value slightly above 1. 3 of 3 arguments used.');
		// Case #17: String. Numeric strings in array and arguments. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({"1.5","2.5","3.5"},"2.5","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({"1.5","2.5","3.5"},"2.5","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: String. Numeric strings in array and arguments. 3 of 3 arguments used.');
		// Case #18: Array. Two-element array. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1,2},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1,2},2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7602499389068355, 'Test: Positive case: Array. Two-element array. 3 of 3 arguments used.');
		// Case #19: Formula. Nested IF returning valid array. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(IF(TRUE,{1,2,3},{4,5,6}),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(IF(TRUE,{1,2,3},{4,5,6}),2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Formula. Nested IF returning valid array. 3 of 3 arguments used.');
		// Case #20: Reference link,Formula,Number. Reference link and nested formula for x. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(A100:A102,AVERAGE(A100:A102),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(A100:A102,AVERAGE(A100:A102),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Reference link,Formula,Number. Reference link and nested formula for x. 3 of 3 arguments used.');
		// Case #21: Area3D. 3D multi-cell range (two cells). 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(Sheet2!A1:A2,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(Sheet2!A1:A2,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7602499389068355, 'Test: Positive case: Area3D. 3D multi-cell range (two cells). 3 of 3 arguments used.');
		// Case #22: Number,Formula. Date as x, large sigma. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1,2,3},DATE(2025,1,1),1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1,2,3},DATE(2025,1,1),1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number,Formula. Date as x, large sigma. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Sigma is zero, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({0.5,0.6,0.7},0.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({0.5,0.6,0.7},0.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Sigma is zero, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #2: Number. Negative numbers in array, valid for Z.TEST but testing edge case. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({-1,-2,-3},-1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({-1,-2,-3},-1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9583677416682248, 'Test: Negative case: Number. Negative numbers in array, valid for Z.TEST but testing edge case. 3 of 3 arguments used.');
		// Case #3: String. Non-numeric strings in array, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({"abc","def","ghi"},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({"abc","def","ghi"},2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Non-numeric strings in array, returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: String. String convertible to numbers, but sigma is zero, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({"0.5","0.6","0.7"},"0.5","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({"0.5","0.6","0.7"},"0.5","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. String convertible to numbers, but sigma is zero, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #5: Error. Propagates #N/A error. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(NA(),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(NA(),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 3 of 3 arguments used.');
		// Case #6: Area. Multi-cell range with non-numeric data, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(A100:A101,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(A100:A101,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9213503964748575, 'Test: Negative case: Area. Multi-cell range with non-numeric data, returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Empty. Empty reference link, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(A103,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(A103,2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Empty reference link, returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: String. Empty string in array, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({""},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({""},2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Empty string in array, returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Boolean. Boolean values in array, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({FALSE,TRUE,FALSE},0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({FALSE,TRUE,FALSE},0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Boolean. Boolean values in array, returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Ref3D. 3D reference to cell with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(Sheet2!A4,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(Sheet2!A4,2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Ref3D. 3D reference to cell with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Name. Named range with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(TestNameArea2,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(TestNameArea2,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9976611325094764, 'Test: Negative case: Name. Named range with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Table. Table column with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(Table1[Column2],2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(Table1[Column2],2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(SQRT(-1),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(SQRT(-1),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 3 of 3 arguments used.');
		// Case #14: Number. Zero variance in array and sigma=0, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({0,0,0},0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({0,0,0},0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero variance in array and sigma=0, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #15: Array. Array with boolean, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({FALSE},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({FALSE},2,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Array. Array with boolean, returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Number. Negative sigma, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1,2,3},1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1,2,3},1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative sigma, returns #NUM!. 3 of 3 arguments used.');
		// Case #17: Number. Array with value exceeding Excel limit, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1E+307,2,3},2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1E+307,2,3},2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Array with value exceeding Excel limit, returns #NUM!. 3 of 3 arguments used.');
		// Case #18: String. Date string converting to negative number, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({"-01/01/2025"},"2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({"-01/01/2025"},"2","1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String. Date string converting to negative number, returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Time. Time value for x, sigma=0, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({0.5,0.6,0.7},TIME(12,0,0),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({0.5,0.6,0.7},TIME(12,0,0),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time value for x, sigma=0, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #20: Area3D. 3D multi-cell range with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST(Sheet2!A1:A2,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST(Sheet2!A1:A2,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7602499389068355, 'Test: Negative case: Area3D. 3D multi-cell range with text, returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid values for array, x, and sigma. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1E-307,2E-307,3E-307},1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1E-307,2E-307,3E-307},1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.041632258331775196, 'Test: Bounded case: Number. Minimum valid values for array, x, and sigma. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid values for array, x, and sigma. 3 of 3 arguments used.
		oParser = new parserFormula('Z.TEST({1E+307,0.5E+307,0.25E+307},1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Z.TEST({1E+307,0.5E+307,0.25E+307},1E+307,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7647567889710651, 'Test: Bounded case: Number. Maximum valid values for array, x, and sigma. 3 of 3 arguments used.');

		// Need to fix: many problems with #N/A err, different results from MS
		// Case #4: String. String array and arguments convertible to numbers. 3 of 3 arguments used.
		// Case #17: String. Numeric strings in array and arguments. 3 of 3 arguments used.
		// Case #19: Formula. Nested IF returning valid array. 3 of 3 arguments used.
		// Case #3: String. Non-numeric strings in array, returns #VALUE!. 3 of 3 arguments used.
		// Case #4: String. String convertible to numbers, but sigma is zero, returns #DIV/0!. 3 of 3 arguments used.
		// Case #7: Empty. Empty reference link, returns #VALUE!. 3 of 3 arguments used.
		// Case #8: String. Empty string in array, returns #VALUE!. 3 of 3 arguments used.
		// Case #9: Boolean. Boolean values in array, returns #VALUE!. 3 of 3 arguments used.
		// Case #10: Ref3D. 3D reference to cell with text, returns #VALUE!. 3 of 3 arguments used.
		// Case #12: Table. Table column with text, returns #VALUE!. 3 of 3 arguments used.
		// Case #15: Array. Array with boolean, returns #VALUE!. 3 of 3 arguments used.
		// Case #18: String. Date string converting to negative number, returns #VALUE!. 3 of 3 arguments used.

		//TODO нужна другая функция для тестирования
		//testArrayFormula2(assert, "Z.TEST", 2, 3, null, true);
	});



	wb.dependencyFormulas.unlockRecal();
});
