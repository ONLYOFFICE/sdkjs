/*
 * (c) Copyright Ascensio System SIA 2010-2025
 *
 * This program is a free software product. You can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License (AGPL)
 * version 3 as published by the Free Software Foundation. In accordance with
 * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect
 * that Ascensio System SIA expressly excludes the warranty of non-infringement
 * of any third-party rights.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For
 * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html
 *
 * You can contact Ascensio System SIA at 20A-6 Ernesta Birznieka-Upish
 * street, Riga, Latvia, EU, LV-1050.
 *
 * The  interactive user interfaces in modified source and object code versions
 * of the Program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU AGPL version 3.
 *
 * Pursuant to Section 7(b) of the License you must retain the original Product
 * logo when distributing the program. Pursuant to Section 7(e) we decline to
 * grant you any rights under trademark law for use of our trademarks.
 *
 * All the Product's GUI elements, including illustrations and icon sets, as
 * well as technical writing content are licensed under the terms of the
 * Creative Commons Attribution-ShareAlike 4.0 International. See the License
 * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode
 *
 */


$(function () {
	// Mocks for API Testing
	Asc.spreadsheet_api.prototype._init = function () {
		this._loadModules();
	};
	Asc.spreadsheet_api.prototype._loadFonts = function (fonts, callback) {
		callback();
	};
	AscCommonExcel.WorkbookView.prototype._calcMaxDigitWidth = function () {
	};
	AscCommonExcel.WorkbookView.prototype._init = function () {
	};
	AscCommonExcel.WorkbookView.prototype._isLockedUserProtectedRange = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorkbookView.prototype._onWSSelectionChanged = function () {
	};
	AscCommonExcel.WorkbookView.prototype.showWorksheet = function () {
	};
	AscCommonExcel.WorkbookView.prototype.recalculateDrawingObjects = function () {
	};
	AscCommonExcel.WorkbookView.prototype.restoreFocus = function () {
	};
	AscCommonExcel.WorksheetView.prototype._init = function () {
	};
	AscCommonExcel.WorksheetView.prototype.updateRanges = function () {
	};
	AscCommonExcel.WorksheetView.prototype._autoFitColumnsWidth = function () {
	};
	AscCommonExcel.WorksheetView.prototype.cleanSelection = function () {
	};
	AscCommonExcel.WorksheetView.prototype._drawSelection = function () {
	};
	AscCommonExcel.WorksheetView.prototype._scrollToRange = function () {
	};
	AscCommonExcel.WorksheetView.prototype.draw = function () {
	};
	AscCommonExcel.WorksheetView.prototype._prepareDrawingObjects = function () {
	};
	AscCommonExcel.WorksheetView.prototype._initCellsArea = function () {
	};
	AscCommonExcel.WorksheetView.prototype.getZoom = function () {
	};
	AscCommonExcel.WorksheetView.prototype._prepareCellTextMetricsCache = function () {
	};

	AscCommon.baseEditorsApi.prototype._onEndLoadSdk = function () {
	};

	AscCommon.baseEditorsApi.prototype._onEndLoadSdk = function () {
	};
	Asc.ReadDefTableStyles = function () {
	};
	AscCommonExcel.WorksheetView.prototype._isLockedCells = function (oFromRange, subType, callback) {
		callback(true);
		return true;
	};
	AscCommonExcel.WorksheetView.prototype._isLockedAll = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorksheetView.prototype._isLockedFrozenPane = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorksheetView.prototype._updateVisibleColsCount = function () {
	};
	AscCommonExcel.WorksheetView.prototype._calcActiveCellOffset = function () {
	};

	// Init basic data
	const parserFormula = AscCommonExcel.parserFormula;
	const g_oIdCounter = AscCommon.g_oIdCounter;
    const c_msPerDay = AscCommonExcel.c_msPerDay;
	const GetDiffDate360 = AscCommonExcel.GetDiffDate360;
	const fSortAscending = AscCommon.fSortAscending;
	const ParseResult = AscCommonExcel.ParseResult;
	const c_oAscError = Asc.c_oAscError;

	let oParser, wb, ws, sData = AscCommon.getEmpty(), tmp, dif = 1e-9;
	if (AscCommon.c_oSerFormat.Signature === sData.substring(0, AscCommon.c_oSerFormat.Signature.length)) {

		Asc.spreadsheet_api.prototype._init = function() {
			this.isLoadFullApi = true;
		};


		let api = new Asc.spreadsheet_api({
			'id-view': 'editor_sdk'
		});
		api.FontLoader = {
			LoadDocumentFonts: function () {
			}
		};

		let docInfo = new Asc.asc_CDocInfo();
		docInfo.asc_putTitle("TeSt.xlsx");
		api.DocInfo = docInfo;


		window["Asc"]["editor"] = api;
		AscCommon.g_oTableId.init(api);
		api._onEndLoadSdk();
		api.isOpenOOXInBrowser = false;
		api.OpenDocumentFromBin(null, AscCommon.getEmpty());
		api.initCollaborativeEditing({});
		wb = new AscCommonExcel.Workbook(new AscCommonExcel.asc_CHandlersList(), api, true);
		api.wbModel = wb;
		api.wb = new AscCommonExcel.WorkbookView(api.wbModel, api.controller, api.handlers, api.HtmlElement,
			api.topLineEditorElement, api, api.collaborativeEditing, api.fontRenderingMode);
		AscCommon.History.init(wb);
		// There is no operation with history, disabled to avoid unnecessary serializations.
		AscCommon.History.TurnOff();
		wb.maxDigitWidth = 7;
		wb.paddingPlusBorder = 5;

		api.initCollaborativeEditing({});

		if (this.User) {
			g_oIdCounter.Set_UserId(this.User.asc_getId());
		}

		AscCommonExcel.g_oUndoRedoCell = new AscCommonExcel.UndoRedoCell(wb);
		AscCommonExcel.g_oUndoRedoWorksheet = new AscCommonExcel.UndoRedoWoorksheet(wb);
		AscCommonExcel.g_oUndoRedoWorkbook = new AscCommonExcel.UndoRedoWorkbook(wb);
		AscCommonExcel.g_oUndoRedoCol = new AscCommonExcel.UndoRedoRowCol(wb, false);
		AscCommonExcel.g_oUndoRedoRow = new AscCommonExcel.UndoRedoRowCol(wb, true);
		AscCommonExcel.g_oUndoRedoComment = new AscCommonExcel.UndoRedoComment(wb);
		AscCommonExcel.g_oUndoRedoAutoFilters = new AscCommonExcel.UndoRedoAutoFilters(wb);
		AscCommonExcel.g_DefNameWorksheet = new AscCommonExcel.Worksheet(wb, -1);
		g_oIdCounter.Set_Load(false);

		const oBinaryFileReader = new AscCommonExcel.BinaryFileReader();
		oBinaryFileReader.Read(sData, wb);
		ws = wb.getWorksheet(wb.getActive());
		AscCommonExcel.getFormulasInfo();
	}

	// Init basic functions
	function testArrayFormula(assert, func, dNotSupportAreaArg) {

		const getValue = function (ref) {
			oParser = new parserFormula(func + "(" + ref + ")", "A2", ws);
			assert.ok(oParser.parse(), 'Formula is parsed');
			return oParser.calculate().getValue();
		};
		const description = `Test: testArrayFormula. ${func}. `;

		//***array-formula***
		ws.getRange2("A100").setValue("1");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("C100").setValue("-4");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B101").setValue("4");
		ws.getRange2("C101").setValue("5");


		oParser = new parserFormula(func + "(A100:C101)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
		assert.ok(oParser.parse(), 'Formula is parsed.');
		let array = oParser.calculate();
		if (AscCommonExcel.cElementType.array === array.type) {
			assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue("A100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue("B100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue("C100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 0).getValue(), getValue("A101"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 1).getValue(), getValue("B101"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 2).getValue(), getValue("C101"), description + 'Reference Link. Area.');
		} else {
			if (!dNotSupportAreaArg) {
				assert.strictEqual(false, true, 'func: ' + func + ' don\'t support area argument.');
			}
			//consoleLog("func: " + func + " don't return area array");
		}

		oParser = new parserFormula(func + "({1,2,-3})", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
		assert.ok(oParser.parse(), 'Formula is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue(1), description + 'Number.');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue(2), description + 'Number.');
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue(-3), description + 'Number.');
	}
	//returnOnlyValue - those functions that must always be fed arrays as input and that return a single value
	function testArrayFormula2(assert, func, minArgCount, maxArgCount, dNotSupportAreaArg, returnOnlyValue) {

		const getValue = function (ref, countArg) {
			let argStr = "(";
			for (let j = 1; j <= countArg; j++) {
				argStr += ref;
				if (i !== j) {
					argStr += ",";
				} else {
					argStr += ")";
				}
			}
			oParser = new parserFormula(func + argStr, "A2", ws);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + argStr + ' is parsed.');
			return oParser.calculate().getValue();
		};


		//***array-formula***
		ws.getRange2("A100").setValue("1");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("C100").setValue("-4");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B101").setValue("4");
		ws.getRange2("C101").setValue("5");

		//формируем массив значений
		const randomArray = [];
		let randomStrArray = "{";
		let maxArg = 4;
		for (let i = 1; i <= maxArg; i++) {
			let randVal = Math.random();
			randomArray.push(randVal);
			randomStrArray += randVal;
			if (i !== maxArg) {
				randomStrArray += ",";
			} else {
				randomStrArray += "}";
			}
		}

		for (var i = minArgCount; i <= maxArgCount; i++) {
			let argStrArr = "(";
			let randomArgStrArr = "(";
			for (let j = 1; j <= i; j++) {
				argStrArr += "A100:C101";
				randomArgStrArr += randomStrArray;
				if (i !== j) {
					argStrArr += ",";
					randomArgStrArr += ",";
				} else {
					argStrArr += ")";
					randomArgStrArr += ")";
				}
			}

			oParser = new parserFormula(func + argStrArr, "A1", ws);
			oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + argStrArr + ' is parsed.');
			let array = oParser.calculate();
			if (AscCommonExcel.cElementType.array === array.type) {
				assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue("A100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue("B100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue("C100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 0).getValue(), getValue("A101", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 1).getValue(), getValue("B101", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 2).getValue(), getValue("C101", i), 'Test: testArrayFormula2. Area.');
			} else {
				if (!(dNotSupportAreaArg || returnOnlyValue)) {
					assert.strictEqual(false, true);
				}
				//consoleLog("func: " + func + " don't return area array");
			}

			oParser = new parserFormula(func + randomArgStrArr, "A1", ws);
			oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + randomArgStrArr + ' is parsed.');
			array = oParser.calculate();
			if (AscCommonExcel.cElementType.array === array.type) {
				assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue(randomArray[0], i), 'Test: testArrayFormula2. Random array');
				assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue(randomArray[1], i), 'Test: testArrayFormula2. Random array');
				assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue(randomArray[2], i), 'Test: testArrayFormula2. Random array');
			} else {
				if (!returnOnlyValue) {
					assert.strictEqual(false, true);
				}
				//consoleLog("func: " + func + " don't return array");
			}
		}
	}

    function testArrayFormulaEqualsValues(assert, str, formula, isNotLowerCase) {
		//***array-formula***
		ws.getRange2("A1").setValue("1");
		ws.getRange2("B1").setValue("3.123");
		ws.getRange2("C1").setValue("-4");
		ws.getRange2("A2").setValue("2");
		ws.getRange2("B2").setValue("4");
		ws.getRange2("C2").setValue("5");

		oParser = new parserFormula(formula, "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E6:H8").bbox);
		assert.ok(oParser.parse());
		var array = oParser.calculate();

		var splitStr = str.split(";");

		for (var i = 0; i < splitStr.length; i++) {
			var subSplitStr = splitStr[i].split(",");
			for (var j = 0; j < subSplitStr.length; j++) {
				var valMs = subSplitStr[j];
				var element;
				if (array.getElementRowCol) {
					var row = 1 === array.array.length ? 0 : i;
					var col = 1 === array.array[0].length ? 0 : j;
					if (array.array[row] && array.array[row][col]) {
						element = array.getElementRowCol(row, col);
					} else {
						element = new window['AscCommonExcel'].cError(window['AscCommonExcel'].cErrorType.not_available);
					}
				} else {
					element = array;
				}
				var ourVal = element && undefined != element.value ? element.value.toString() : "#N/A";
				if (!isNotLowerCase) {
					valMs = valMs.toLowerCase();
					ourVal = ourVal.toLowerCase();
				}
				assert.strictEqual(valMs, ourVal, "formula: " + formula + " i: " + i + " j: " + j)
			}
		}
	}

	function _getYield(nSettle, nMat, fCoup, fPrice, fRedemp, nFreq, nBase) {
		var fRate = fCoup, fPriceN = 0.0, fYield1 = 0.0, fYield2 = 1.0;
		var fPrice1 = _getprice(nSettle, nMat, fRate, fYield1, fRedemp, nFreq, nBase);
		var fPrice2 = _getprice(nSettle, nMat, fRate, fYield2, fRedemp, nFreq, nBase);
		var fYieldN = (fYield2 - fYield1) * 0.5;

		for (var nIter = 0; nIter < 100 && fPriceN != fPrice; nIter++) {
			fPriceN = _getprice(nSettle, nMat, fRate, fYieldN, fRedemp, nFreq, nBase);

			if (fPrice == fPrice1) {
				return fYield1;
			} else if (fPrice == fPrice2) {
				return fYield2;
			} else if (fPrice == fPriceN) {
				return fYieldN;
			} else if (fPrice < fPrice2) {
				fYield2 *= 2.0;
				fPrice2 = _getprice(nSettle, nMat, fRate, fYield2, fRedemp, nFreq, nBase);

				fYieldN = (fYield2 - fYield1) * 0.5;
			} else {
				if (fPrice < fPriceN) {
					fYield1 = fYieldN;
					fPrice1 = fPriceN;
				} else {
					fYield2 = fYieldN;
					fPrice2 = fPriceN;
				}

				fYieldN = fYield2 - (fYield2 - fYield1) * ((fPrice - fPrice2) / (fPrice1 - fPrice2));
			}
		}

		if (Math.abs(fPrice - fPriceN) > fPrice / 100.0) {
			return "#NUM!";
		}		// result not precise enough

		return fYieldN;
	}

    function _coupnum(settlement, maturity, frequency, basis) {

		basis = (basis !== undefined ? basis : 0);

		var n = new cDate(maturity);
		_lcl_GetCouppcd(settlement, n, frequency);
		var nMonths = (maturity.getFullYear() - n.getFullYear()) * 12 + maturity.getMonth() - n.getMonth();
		return nMonths * frequency / 12;

	}

	function _duration(settlement, maturity, coupon, yld, frequency, basis) {
		var dbc = AscCommonExcel.getcoupdaybs(new cDate(settlement), new cDate(maturity), frequency, basis),
			coupD = AscCommonExcel.getcoupdays(new cDate(settlement), new cDate(maturity), frequency, basis),
			numCoup = AscCommonExcel.getcoupnum(new cDate(settlement), new cDate(maturity), frequency);

		if (settlement >= maturity || basis < 0 || basis > 4 || (frequency != 1 && frequency != 2 && frequency != 4) || yld < 0 || coupon < 0) {
			return "#NUM!";
		}

		var duration = 0, p = 0;

		var dsc = coupD - dbc;
		var diff = dsc / coupD - 1;
		yld = yld / frequency + 1;


		coupon *= 100 / frequency;

		for (var index = 1; index <= numCoup; index++) {
			var di = index + diff;

			var yldPOW = Math.pow(yld, di);

			duration += di * coupon / yldPOW;

			p += coupon / yldPOW;
		}

		duration += (diff + numCoup) * 100 / Math.pow(yld, diff + numCoup);
		p += 100 / Math.pow(yld, diff + numCoup);

		return duration / p / frequency;
	}

	function _getyieldmat(nSettle, nMat, nIssue, fRate, fPrice, nBase) {

		var fIssMat = _yearFrac(nIssue, nMat, nBase);
		var fIssSet = _yearFrac(nIssue, nSettle, nBase);
		var fSetMat = _yearFrac(nSettle, nMat, nBase);

		var y = 1.0 + fIssMat * fRate;
		y /= fPrice / 100.0 + fIssSet * fRate;
		y--;
		y /= fSetMat;

		return y;

	}

	function _yearFrac(d1, d2, mode) {
		var date1 = d1.getDate(), month1 = d1.getMonth() + 1, year1 = d1.getFullYear(), date2 = d2.getDate(), month2 = d2.getMonth() + 1, year2 = d2.getFullYear();

		switch (mode) {
			case 0:
				return Math.abs(GetDiffDate360(date1, month1, year1, date2, month2, year2, true)) / 360;
			case 1:
				var yc = /*Math.abs*/(year2 - year1), sd = year1 > year2 ? new cDate(d2) : new cDate(d1), yearAverage = sd.isLeapYear() ? 366 : 365,
					dayDiff = /*Math.abs*/(d2 - d1);
				for (var i = 0; i < yc; i++) {
					sd.addYears(1);
					yearAverage += sd.isLeapYear() ? 366 : 365;
				}
				yearAverage /= (yc + 1);
				dayDiff /= (yearAverage * c_msPerDay);
				return dayDiff;
			case 2:
				var dayDiff = Math.abs(d2 - d1);
				dayDiff /= (360 * c_msPerDay);
				return dayDiff;
			case 3:
				var dayDiff = Math.abs(d2 - d1);
				dayDiff /= (365 * c_msPerDay);
				return dayDiff;
			case 4:
				return Math.abs(GetDiffDate360(date1, month1, year1, date2, month2, year2, false)) / 360;
			default:
				return "#NUM!";
		}
	}

    function _getprice(nSettle, nMat, fRate, fYield, fRedemp, nFreq, nBase) {

		var fdays = AscCommonExcel.getcoupdays(new cDate(nSettle), new cDate(nMat), nFreq, nBase),
			fdaybs = AscCommonExcel.getcoupdaybs(new cDate(nSettle), new cDate(nMat), nFreq, nBase), fnum = AscCommonExcel.getcoupnum(new cDate(nSettle), (nMat), nFreq, nBase),
			fdaysnc = (fdays - fdaybs) / fdays, fT1 = 100 * fRate / nFreq, fT2 = 1 + fYield / nFreq, res = fRedemp / (Math.pow(1 + fYield / nFreq, fnum - 1 + fdaysnc));

		/*var fRet = fRedemp / ( Math.pow( 1.0 + fYield / nFreq, fnum - 1.0 + fdaysnc ) );
        fRet -= 100.0 * fRate / nFreq * fdaybs / fdays;

        var fT1 = 100.0 * fRate / nFreq;
        var fT2 = 1.0 + fYield / nFreq;

        for( var fK = 0.0 ; fK < fnum ; fK++ ){
            fRet += fT1 / Math.pow( fT2, fK + fdaysnc );
        }

        return fRet;*/

		if (fnum == 1) {
			return (fRedemp + fT1) / (1 + fdaysnc * fYield / nFreq) - 100 * fRate / nFreq * fdaybs / fdays;
		}

		res -= 100 * fRate / nFreq * fdaybs / fdays;

		for (var i = 0; i < fnum; i++) {
			res += fT1 / Math.pow(fT2, i + fdaysnc);
		}

		return res;
	}

	function _getPMT(fZins, fZzr, fBw, fZw, nF) {
		var fRmz;
		if (fZins == 0.0) {
			fRmz = (fBw + fZw) / fZzr;
		} else {
			var fTerm = Math.pow(1.0 + fZins, fZzr);
			if (nF > 0) {
				fRmz = (fZw * fZins / (fTerm - 1.0) + fBw * fZins / (1.0 - 1.0 / fTerm)) / (1.0 + fZins);
			} else {
				fRmz = fZw * fZins / (fTerm - 1.0) + fBw * fZins / (1.0 - 1.0 / fTerm);
			}
		}

		return -fRmz;
	}

	function difBetween(a, b) {
		return Math.abs(a - b) < dif
	}

    function _getDDB(cost, salvage, life, period, factor) {
		var ddb, ipmt, oldCost, newCost;
		ipmt = factor / life;
		if (ipmt >= 1) {
			ipmt = 1;
			if (period == 1) {
				oldCost = cost;
			} else {
				oldCost = 0;
			}
		} else {
			oldCost = cost * Math.pow(1 - ipmt, period - 1);
		}
		newCost = cost * Math.pow(1 - ipmt, period);

		if (newCost < salvage) {
			ddb = oldCost - salvage;
		} else {
			ddb = oldCost - newCost;
		}
		if (ddb < 0) {
			ddb = 0;
		}
		return ddb;
	}

	function _getdiffdate(d1, d2, nMode) {
		var bNeg = d1 > d2;

		if (bNeg) {
			var n = d2;
			d2 = d1;
			d1 = n;
		}

		var nRet, pOptDaysIn1stYear;

		var nD1 = d1.getDate(), nM1 = d1.getMonth(), nY1 = d1.getFullYear(), nD2 = d2.getDate(), nM2 = d2.getMonth(), nY2 = d2.getFullYear();

		switch (nMode) {
			case 0:			// 0=USA (NASD) 30/360
			case 4:			// 4=Europe 30/360
			{
				var bLeap = d1.isLeapYear();
				var nDays, nMonths/*, nYears*/;

				nMonths = nM2 - nM1;
				nDays = nD2 - nD1;

				nMonths += (nY2 - nY1) * 12;

				nRet = nMonths * 30 + nDays;
				if (nMode == 0 && nM1 == 2 && nM2 != 2 && nY1 == nY2) {
					nRet -= bLeap ? 1 : 2;
				}

				pOptDaysIn1stYear = 360;
			}
				break;
			case 1:			// 1=exact/exact
				pOptDaysIn1stYear = d1.isLeapYear() ? 366 : 365;
				nRet = d2 - d1;
				break;
			case 2:			// 2=exact/360
				nRet = d2 - d1;
				pOptDaysIn1stYear = 360;
				break;
			case 3:			//3=exact/365
				nRet = d2 - d1;
				pOptDaysIn1stYear = 365;
				break;
		}

		return (bNeg ? -nRet : nRet) / c_msPerDay / pOptDaysIn1stYear;
	}

	function _getIPMT(rate, per, pv, type, pmt) {
		var ipmt;

		if (per == 1) {
			if (type > 0) {
				ipmt = 0;
			} else {
				ipmt = -pv;
			}
		} else {
			if (type > 0) {
				ipmt = _getFV(rate, per - 2, pmt, pv, 1) - pmt;
			} else {
				ipmt = _getFV(rate, per - 1, pmt, pv, 0);
			}
		}
		return ipmt * rate
	}

	function _getFV(fZins, fZzr, fRmz, fBw, nF) {
		var fZw;
		if (fZins == 0.0) {
			fZw = fBw + fRmz * fZzr;
		} else {
			var fTerm = Math.pow(1.0 + fZins, fZzr);
			if (nF > 0) {
				fZw = fBw * fTerm + fRmz * (1.0 + fZins) * (fTerm - 1.0) / fZins;
			} else {
				fZw = fBw * fTerm + fRmz * (fTerm - 1.0) / fZins;
			}
		}

		return -fZw;
	}

	function _lcl_GetCoupncd(settl, matur, freq) {
		matur.setFullYear(settl.getFullYear());
		if (matur > settl) {
			matur.addYears(-1);
		}
		while (matur <= settl) {
			matur.addMonths(12 / freq);
		}
	}

	function _getcoupdaybs(settl, matur, frequency, basis) {
		_lcl_GetCouppcd(settl, matur, frequency);
		return _diffDate(settl, matur, basis);
	}

	function _getcoupdays(settl, matur, frequency, basis) {
		_lcl_GetCouppcd(settl, matur, frequency);
		var n = new cDate(matur);
		n.addMonths(12 / frequency);
		return _diffDate(matur, n, basis);
	}

	function _lcl_GetCouppcd(settl, matur, freq) {
		matur.setFullYear(settl.getFullYear());
		if (matur < settl) {
			matur.addYears(1);
		}
		while (matur > settl) {
			matur.addMonths(-12 / freq);
		}
	}

	/**
	 * Function creates table or edit existed table.
	 * * Creating happened when the function was called for the first time in the code totally.
	 * In that case, you should set range coordinates like you're creating table, select needed range.
	 * * For editing table you should consider that you have constant row with header and one data row as minimum required.
	 * In that case your minimum row coordinates must be equal 2 rows.
	 * For filling data use cells A601:L6**
	 * @param {number} r1
	 * @param {number} c1
	 * @param {number} r2
	 * @param {number} c2
	 * @returns {TablePart}
	 */
	function getTableType(r1, c1, r2, c2) {
		const range = new window["Asc"].Range(c1, r1, c2, r2);
		const  tableName = 'Table1';
		const tableParts = ws.TableParts;
		/** @type {TablePart} */
		const foundedTable = tableParts.find(function(table) { return table.DisplayName === tableName});
		if (foundedTable) {
			// Change table
			ws.autoFilters.changeTableRange(tableName, range);
			return foundedTable;
		}
		// Create table
		const tableOptFormat = ws.autoFilters.getAddFormatTableOptions(range);
		const styleName = 'TableStyleMedium2';
		ws.autoFilters.addAutoFilter(styleName, range, tableOptFormat);

		return tableParts[tableParts.length - 1]
	}
	function getSecondSheet () {
		let ws2 = wb.getWorksheetByName('Sheet2');
		if (!ws2) {
			ws2 = wb.createWorksheet(null, 'Sheet2');
		}

		return ws2;
	}
	function initDefNames() {
		const defName = new Asc.asc_CDefName('TestName', ws.getName() + '!$A$201');
		const defName2 = new Asc.asc_CDefName('TestName1', ws.getName() + '!$A$202');
		const defName3 = new Asc.asc_CDefName('TestName2', ws.getName() + '!$A$203');
		const defName4 = new Asc.asc_CDefName('TestName3', ws.getName() + '!$A$204');
		const defName5 = new Asc.asc_CDefName('TestName4', ws.getName() + '!$A$205');
		const defNameArea = new Asc.asc_CDefName('TestNameArea', ws.getName() + '!$A$206:$A$207');
		const defNameArea2 = new Asc.asc_CDefName('TestNameArea2', ws.getName() + '!$A$208:$B$208');
		const ws2 = getSecondSheet();
		const defName3D = new Asc.asc_CDefName('TestName3D', ws2.getName() + '!$A$11');
		const defName3D2 = new Asc.asc_CDefName('TestName3D1', ws2.getName() + '!$A$12');
		const defName3D3 = new Asc.asc_CDefName('TestName3D2', ws2.getName() + '!$A$13');
		const defName3D4 = new Asc.asc_CDefName('TestName3D3', ws2.getName() + '!$A$14');
		const defName3D5 = new Asc.asc_CDefName('TestName3D4', ws2.getName() + '!$A$15');
		const defNameArea3D = new Asc.asc_CDefName('TestNameArea3D', ws2.getName() + '!$A$16:$A$17');
		const defNameArea3D2 = new Asc.asc_CDefName('TestNameArea3D2', ws2.getName() + '!$A$18:$B$18');

		wb.editDefinesNames(null, defName);
		wb.editDefinesNames(null, defName2);
		wb.editDefinesNames(null, defName3);
		wb.editDefinesNames(null, defName4);
		wb.editDefinesNames(null, defName5);
		wb.editDefinesNames(null, defNameArea);
		wb.editDefinesNames(null, defNameArea2);
		wb.editDefinesNames(null, defName3D);
		wb.editDefinesNames(null, defName3D2);
		wb.editDefinesNames(null, defName3D3);
		wb.editDefinesNames(null, defName3D4);
		wb.editDefinesNames(null, defName3D5);
		wb.editDefinesNames(null, defNameArea3D);
		wb.editDefinesNames(null, defNameArea3D2);
	}

	wb.dependencyFormulas.lockRecal();
	getTableType(599, 0, 599, 0); // Init table
	initDefNames();

	QUnit.module('Financial formulas');

    QUnit.test("Test: \"ACCRINT\"", function (assert) {
		// Positive cases:

		// Case #1: Date (3), Number (4). Dates are correct, Issue < Settlement, Rate > 0, Par > 0, Basis correct, Frequency correct. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(DATE(2006,3,1),DATE(2006,9,1),DATE(2006,5,1),0.1,1100,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2006,3,1),DATE(2006,9,1),DATE(2006,5,1),0.1,1100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.333333333333332, 'Test: Positive case: Date (3), Number(4). 7 of 8 arguments used. Issue < Settlement, Basis correct, Frequency correct.');
		// Case #2: Date (3), Number, Empty, Number(2). Dates are correct, Issue < Settlement, Rate > 0, Par is empty, Frequency correct, Basis correct. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(DATE(2006,3,1),DATE(2006,9,1),DATE(2006,5,1),0.1,,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2006,3,1),DATE(2006,9,1),DATE(2006,5,1),0.1,,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16.666666666666664, 'Test: Positive case: Date (3),Number, Empty, Number(2). Issue < Settlement, Par is empty, Frequency correct, Basis correct. 7 of 8 argument used.');
		// Case #3: Date (3), Number(4). Dates are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2008,3,1),DATE(2008,8,31),DATE(2010,5,1),0.1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2008,3,1),DATE(2008,8,31),DATE(2010,5,1),0.1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 216.94444444444444, 'Test: Positive case: Date (3), Number(4). Dates are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct. 7 of 8 arguments used.');
		// Case #4: Date (3), Number(4), Boolean. Dates are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2008,3,1),DATE(2008,8,31),DATE(2010,5,1),0.1,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2008,3,1),DATE(2008,8,31),DATE(2010,5,1),0.1,1000,2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 216.94444444444444, 'Test: Positive case: Date (3), Number(4), Boolean. Dates are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 arguments used.');
		// Case #5: Date (3), Number(4), Boolean.  Dates are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - FALSE. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2008,3,1),DATE(2008,8,31),DATE(2010,5,1),0.1,1000,2,0,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2008,3,1),DATE(2008,8,31),DATE(2010,5,1),0.1,1000,2,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 216.66666666666666, 'Test: Positive case: Date (3), Number(4), Boolean. Dates are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - FALSE. 8 of 8 arguments used.');
		// Case #6: Number (7). Dates are correct in number format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number (7). Dates are correct in number format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct. 7 of 8 argument used.');
		// Case #7: Number(7), Boolean. Dates are correct in number format,  Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - FALSE. 8 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,2,0,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,2,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, 'Test: Positive case: Number(7), Boolean. Dates are correct in number format,  Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - FALSE. 7 of 8 argument used.');
		// Case #8: Number(7), Boolean. Dates are correct in number format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number (7), Boolean. Dates are correct in number format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.');
		// Case #9: Number (7). Dates are correct in number format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(2500,2700,2800,0.1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(2500,2700,2800,0.1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 82.50, 'Test: Positive case: Number (7). Dates are correct in number format, Issue < Settlement,  Rate > 0, Par > 0, Frequency correct, Basis correct. 7 of 8 argument used.');
		// Case #10: Number (7), Boolean. Dates are correct in number format, Issue < Settlement,  Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - FALSE. 8 of 8 argument used.
		oParser = new parserFormula("ACCRINT(2500,2700,2800,0.1,1000,2,0,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(2500,2700,2800,0.1,1000,2,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 82.50, 'Test: Positive case: Number (7), Boolean. Dates are correct in number format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - FALSE. 8 of 8 argument used.');
		// Case #11: Number (7), Boolean. Dates are correct in nunber format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.
		oParser = new parserFormula("ACCRINT(2500,2700,2800,0.1,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(2500,2700,2800,0.1,1000,2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 82.50, 'Test: Positive case: Number (7), Boolean. Dates are correct in number format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.');
		// Case #12: String (3), Number(4), Boolean. Dates are correct in string format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.
		oParser = new parserFormula("ACCRINT(\"03/01/2006\",\"09/01/2006\",\"05/01/2006\",0.1,1100,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINT(\"03/01/2006\",\"09/01/2006\",\"05/01/2006\",0.1,1100,2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.333333333333332, 'Test: Positive case: String (3), Number(4), Boolean. Dates are correct in string format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.');
		// Case #13: String (3), Number(4), Boolean. Dates are correct in string format. Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.
		oParser = new parserFormula("ACCRINT(\"03/01\",\"09/01\",\"05/01\",0.1,1100,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(\"03/01\",\"09/01\",\"05/01\",0.1,1100,2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.333333333333332, 'Test: Positive case: String (3), Number(4), Boolean. Dates are correct in string format, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.');
		// Case #14: String (3), Number (5). Date are correct in string shorty format. Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - 1. 8 of 8 argument used.
		oParser = new parserFormula("ACCRINT(\"3/1\",\"9/1\",\"5/1\",0.1,1100,1,0,1)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(\"3/1\",\"9/1\",\"5/1\",0.1,1100,1,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.333333333333332, 'Test: Positive case: String (3), Number (5). Date are correct in string shorty format. Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - 1. 8 of 8 argument used.' )
		// Case #15: String (3), Number (5).  Date are correct in string shorty format. Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - 0. 8 of 8 argument used.
		oParser = new parserFormula("ACCRINT(\"3/1\",\"9/1\",\"5/1\",0.1,1100,2,0,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(\"3/1\",\"9/1\",\"5/1\",0.1,1100,2,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.333333333333332,'Test: Positive case: String (3), Number (5). Date are correct in string shorty format. Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - 0. 8 of 8 argument used.');
		// Case #16: Reference links. Date are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.
		ws.getRange2("A100").setValue("03/01/2000");
		ws.getRange2("A101").setValue("09/01/2000");
		ws.getRange2("A102").setValue("05/01/2000");
		ws.getRange2("A103").setValue("0.1");
		ws.getRange2("A104").setValue("1100");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("0");
		ws.getRange2("A107").setValue("TRUE");
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A107)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.333333333333332, 'Test: Positive case: Reference links. Date are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE. 8 of 8 argument used.')

		// Data for reference link test.
		ws.getRange2("A100").setValue("39508");
		ws.getRange2("A101").setValue("39691");
		ws.getRange2("A102").setValue("39769");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A104").setValue("1000");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("0");
		ws.getRange2("A107").setValue("TRUE");
		ws.getRange2("A108").setValue("FALSE");
		ws.getRange2("A109").setValue("0");
		ws.getRange2("A110").setValue("1");
		ws.getRange2("A111").setValue("1s2p");
		ws.getRange2("A220").setValue("0");
		ws.getRange2("A220").setNumFormat("@");
		ws.getRange2("A221").setValue("1");
		ws.getRange2("A221").setNumFormat("@");

		// Test of arg[0]
		// Case #17: Array, Number(6). Test of arg[0]: Issue is array with valid single number. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT({1},39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT({1},39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array, Number(6). Test of arg[0]: Non-standard case. Issue is array with minimum accepted date. 7 of 8 argument used.');
		// Case #18: Array, Number(6). Test of arg[0]: Issue is array with multiple valid numbers. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT({1000;1200},39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT({1000;1200},39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 106136.11, 'Test: Positive case: Array, Number(6). Test of arg[0]: Non-standard case. Issue is array with multiple valid numbers. 7 of 8 argument used.');
		// Case #19: Array, Number(6). Test of arg[0]: Issue is array with valid number and extras. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT({39508;1000;1200;1400},39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT({39508;1000;1200;1400},39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Array, Number(6). Test of arg[0]: Non-standard case. Issue is array with valid date number and extras. 7 of 8 argument used.');
		// Case #20: Area, Number(6). Test of arg[0]: Issue is area with valid value. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(A100:A100,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100:A100,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Area, Number(6). Test of arg[0]: Non-standard case. Issue is area with valid value. 7 of 8 argument used.');
		// Case #21: Reference link, Number(6). Test of arg[0]: Issue is area with valid single cell. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(A100,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Reference link, Number(6). Test of arg[0]: Non-standard case. Issue is area with valid single cell. 7 of 8 argument used.');
		// Case #22: Number, Array, Number(5). Test of arg[1]: Valid array value {1} for settlement. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,{1},39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,{1},39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, 'Test: Positive case: Number, Array, Number(5). Test of arg[1]: Valid array value {1} for settlement. 7 of 8 argument used.');
		// Case #23: Number, Array, Number(5). Test of arg[1]: Valid array value {1000;1200} for settlement. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,{1000;1200},39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,{1000;1200},39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, 'Test: Positive case: Number, Array, Number(5). Test of arg[1]: Valid array value {1000;1200} for settlement. 7 of 8 argument used.');
		// Case #24: Number, Array, Number(5). Test of arg[1]: Valid array value {39691;1000;1200;1400} for settlement. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,{39691;1000;1200;1400},39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,{39691;1000;1200;1400},39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number, Array, Number(5). Test of arg[1]: Valid array value {39691;1000;1200;1400} for settlement. 7 of 8 argument used.');
		// Case #25: Number, Ref, Number(5). Test of arg[1]: Valid reference A100:A100 for settlement. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,A101:A101,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,A101:A101,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number, Ref, Number(5). Test of arg[1]: Valid reference A100:A100 for settlement. 7 of 8 argument used.');
		// Case #26: Number, Ref, Number(5). Test of arg[1]: Valid reference A101 for settlement. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,A101,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,A101,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number, Ref, Number(5). Test of arg[1]: Valid reference A101 for settlement. 7 of 8 argument used.');
		// Test of arg[2]
		// Case #27: Number(7). Test of arg[2]: Settlement is large number within acceptable range (100000). 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,100000,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,100000,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 165622.22, 'Test: Positive case: Number(7). Test of arg[2]: Settlement is large number within acceptable range. 7 of 8 arguments used.');
		// Case #28: Number(2), Array, Number(4). Test of arg[2]: Settlement is array {100000;1200}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,{100000;1200},1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,{100000;1200},1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 165622.22, 'Test: Positive case: Number(2), Array, Number(4). Test of arg[2]: Settlement is array {100000;1200}. 7 of 8 arguments used.');
		// Case #29: Number(2), Array, Number(4). Test of arg[2]: Settlement is array {39769;1000;1200}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,{39769;1000;1200},1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,{39769;1000;1200},1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number(2), Array, Number(4). Test of arg[2]: Settlement is array {39769;1000;1200}. 7 of 8 arguments used.');
		// Case #30: Number, Reference link, Area, Number(4). Test of arg[2]: Settlement is range A102:A102. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,A101,A102:A102,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,A101,A102:A102,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number, Reference link, Area, Number(4). Test of arg[2]: Settlement is range A102:A102. 7 of 8 arguments used.');
		// Test of arg[3]
		// Case #31: Number. Test of arg[3]: Rate is 1. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number. Test of arg[3]: Rate is 1. 7 of 8 arguments used.');
		// Case #32: Number. Test of arg[3]: Rate is 0.75. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,0.75,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,0.75,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 535.42, 'Test: Positive case: Number. Test of arg[3]: Rate is 0.75. 7 of 8 arguments used.');
		// Case #33: Number. Test of arg[3]: Rate is large number (100000). 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,100000,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,100000,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 71388888.89, 'Test: Positive case: Number. Test of arg[3]: Rate is large number. 7 of 8 arguments used.');
		// Case #34: Number. Test of arg[3]: Rate is very large number (999...999). 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,999999999999999999999,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,999999999999999999999,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.138888888888889e+23, 'Test: Positive case: Number. Test of arg[3]: Rate is very large number. 7 of 8 arguments used.');
		// Case #35: Array. Test of arg[3]: Rate is array {1}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,{1},1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,{1},1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Array. Test of arg[3]: Rate is array {1}. 7 of 8 arguments used.');
		// Case #36: Array. Test of arg[3]: Rate is array {1000;1200}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,{1000;1200},1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,{1000;1200},1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713888.89, 'Test: Positive case: Array. Test of arg[3]: Rate is array {1000;1200}. 7 of 8 arguments used.');
		// Case #37: Area. Test of arg[3]: Rate is range A103:A103. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103:A103,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103:A103,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Area. Test of arg[3]: Rate is range A103:A103. 7 of 8 arguments used.');
		// Case #38: Reference link. Test of arg[3]: Rate is Reference link A103. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,1000,2,0) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Reference link. Test of arg[3]: Rate is Reference link A103. 7 of 8 arguments used.");
		// Test of arg[4]
		// Case #39: Number. Test of arg[4]: Par is 0.75. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,0.75,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,0.75,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.535417, 'Test: Positive case: Number. Test of arg[4]: Par is 0.75. 7 of 8 arguments used.');
		// Case #40: Number. Test of arg[4]: Par is large number (100000). 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,100000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,100000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 71388.89, 'Test: Positive case: Number. Test of arg[4]: Par is large number. 7 of 8 arguments used.');
		// Case #41: Number. Test of arg[4]: Par is very large number (999...999). 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,999999999999999999999,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,999999999999999999999,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 713888888888888900000, 'Test: Positive case: Number. Test of arg[4]: Par is very large number. 7 of 8 arguments used.');
		// Case #42: Empty. Test of arg[4]: Par is empty. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Empty. Test of arg[4]: Par is empty (defaulted). 7 of 8 arguments used.');
		// Case #43: Array. Test of arg[4]: Par is array {1}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,{1},2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,{1},2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 0.7139, 'Test: Positive case: Array. Test of arg[4]: Par is array {1}. 7 of 8 arguments used.');
		// Case #44: Array. Test of arg[4]: Par is array {1000;1200}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,{1000;1200},2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,{1000;1200},2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Array. Test of arg[4]: Par is array {1000;1200}. 7 of 8 arguments used.');
		// Case #45: Area. Test of arg[4]: Par is range A104:A104. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104:A104,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A104:A104,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Area. Test of arg[4]: Par is range A104:A104. 7 of 8 arguments used.');
		// Case #46: Reference link. Test of arg[4]: Par is reference A104. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A104,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Reference link. Test of arg[4]: Par is reference A104. 7 of 8 arguments used.');
		// Test of arg[5]
		// Case #47: Number. Test of arg[5]: Frequency is 2 (Semi-Annual). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number. Frequency is 2 (Semi-Annual). 7 of 8 argument used.');
		// Case #48: Reference link. Test of arg[5]: Frequency from reference A105 is 2. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Reference link. Frequency from A105 is 2. 7 of 8 argument used.');
		// Case #49: Array. Test of arg[5]: Frequency is {1}. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,{1},0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,{1},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Array. Frequency is {1}. 7 of 8 argument used.');
		// Case #50: Area. Test of arg[5]: Frequency is A105:A105. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105:A105,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105:A105,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Area. Frequency is A105:A105 = 2. 7 of 8 argument used.');
		// Test of arg[6]
		// Case #51: Number. Test of arg[6]: Basis is 0. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number. Test of arg[6]: Basis is 0. 7 of 8 arguments used.');
		// Case #52: Number. Test of arg[6]: Basis is 0.75. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0.75)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number. Test of arg[6]: Basis is 0.75. 7 of 8 arguments used.');
		// Case #53: Empty. Test of arg[6]: Basis is empty. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,,)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Empty. Test of arg[6]: Basis is empty. 8 of 8 arguments used.');
		// Case #54: Array. Test of arg[6]: Basis is {0}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,{0})", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Array. Test of arg[6]: Basis is {0}. 7 of 8 arguments used.');
		// Case #55: Area. Test of arg[6]: Basis is A106:A106. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106:A106)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Area. Test of arg[6]: Basis is A106:A106. 7 of 8 arguments used.');
		// Case #56: Number. Test of arg[6]: Basis is cell A106. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Positive case: Number. Test of arg[6]: Basis is cell A106. 7 of 8 arguments used.');
		// Test of arg[7]
		// Case #57: Boolean. Test of arg[7]: Calc_method is TRUE with ';' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0;TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0;TRUE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Boolean. Calc_method is TRUE with ';' divide between arguments. 8 of 8 arguments used.");
		// Case #58: Boolean. Test of arg[7]: Calc_method is FALSE with ';' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0;FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0;FALSE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, "Test: Positive case: Boolean. Calc_method is FALSE with ';' divide between arguments. 8 of 8 arguments used.");
		// Case #59: Boolean. Test of arg[7]: Calc_method is TRUE with ';' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0;TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0;TRUE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Boolean. Calc_method is TRUE with ';' divide between arguments. 8 of 8 arguments used.");
		// Case #60: Boolean. Test of arg[7]: Calc_method is FALSE with ';' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0;FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0;FALSE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, "Test: Positive case: Boolean. Calc_method is FALSE with ';' divide between arguments. 8 of 8 arguments used.");
		// Case #61: Boolean. Test of arg[7]: Calc_method is TRUE with ',' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0,TRUE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Boolean. Calc_method is TRUE with ',' divide between arguments. 8 of 8 arguments used.");
		// Case #62: Boolean. Test of arg[7]: Calc_method is FALSE with ',' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0,FALSE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, "Test: Positive case: Boolean. Calc_method is FALSE with ',' divide between arguments. 8 of 8 arguments used.");
		// Case #63: Empty. Test of arg[7]: Calc_method is empty with ';' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0;)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0;) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Empty. Calc_method is empty with ';' divide between arguments. 8 of 8 arguments used.");
		// Case #64: Empty. Test of arg[7]: Calc_method is empty with ',' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0,)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0,) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Empty. Calc_method is empty with ';' divide between arguments. 8 of 8 arguments used.");
		// Case #65: Number. Test of arg[7]: Calc_method is 1 with ';' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0;1)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0;1) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Number. Calc_method is 1 with ';' divide between arguments. 8 of 8 arguments used.");
		// Case #66: Number. Test of arg[7]: Calc_method is -1 with ';' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0;-1)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0;-1) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Number. Calc_method is -1 with ';' divide between arguments. 8 of 8 arguments used.");
		// Case #67: Number. Test of arg[7]: Calc_method is 1 with ',' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0,1) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Number. Calc_method is 1 with ',' divide between arguments. 8 of 8 arguments used.");
		// Case #68: Number. Test of arg[7]: Calc_method is -1 with ',' divide between arguments. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0,-1)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0,-1) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Number. Calc_method is -1 with ',' divide between arguments. 8 of 8 arguments used.");
		// Case #69: Array. Test of arg[7]: Calc_method is {TRUE;2500}. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0,{TRUE;2500})", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0,{TRUE;2500}) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Array. Calc_method is {TRUE;2500}. 8 of 8 arguments used.");
		// Case #70: Area. Test of arg[7]: Calc_method is A107:A107. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A107:A107)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A107:A107) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Area. Calc_method is A107:A107. 8 of 8 arguments used.");
		// Case #71: Area. Test of arg[7]: Calc_method is A220. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A220)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A220) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, "Test: Positive case: Area. Calc_method is A220. 8 of 8 arguments used.");
		// Case #72: Area. Test of arg[7]: Calc_method is A221. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A221)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A221) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Area. Calc_method is A221. 8 of 8 arguments used.");
		// Case #73: Area. Test of arg[7]: Calc_method is A109. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A109)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A109) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, "Test: Positive case: Area. Calc_method is A109. 8 of 8 arguments used.");
		// Case #74: Area. Test of arg[7]: Calc_method is A110. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A110)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A110) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Area. Calc_method is A110. 8 of 8 arguments used.");
		// Case #75: Area. Test of arg[7]: Calc_method is A107. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A107)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A107) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Area. Calc_method is A107. 8 of 8 arguments used.");
		// Case #76: Empty. Test of arg[7]: Calc_method is missing. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, "Test: Positive case: Empty. Calc_method is missing. 7 of 8 arguments used.");
		// in these cases (arg[1] >= arg[2]) while loop is not executed and the result is correct
		// Case #77: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 0. 7 of 8 agruments used.
		oParser = new parserFormula("ACCRINT(44562,44621,44576,0.05,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2022,1,1),DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 1.944, 'Test: Positive case: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 0. 7 of 8 agruments used.');
		// Case #78: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 1. 7 of 8 agruments used.
		oParser = new parserFormula("ACCRINT(44562,44621,44576,0.05,1000,2,1)", "A2", ws);
		assert.ok(oParser.parse(), 'Formula ACCRINT(DATE(2022,1,1),DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.933701657, 'Test: Positive case: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 1. 7 of 8 agruments used.');
		// Case #79: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 2. 7 of 8 agruments used.
		oParser = new parserFormula("ACCRINT(44562,44621,44576,0.05,1000,2,2)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2022,1,1),DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,2) is parsed');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 1.944, 'Test: Positive case: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 2. 7 of 8 agruments used.');
		// Case #80: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 3. 7 of 8 agruments used.
		oParser = new parserFormula("ACCRINT(44562,44621,44576,0.05,1000,2,3)", "A2", ws);
		assert.ok(oParser.parse(), 'ACCRINT(DATE(2022,1,1),DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,3)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.917808219, 'Test: Positive case: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 3. 7 of 8 agruments used.');
		// Case #81: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 4. 7 of 8 agruments used.
		oParser = new parserFormula("ACCRINT(44562,44621,44576,0.05,1000,2,4)", "A2", ws);
		assert.ok(oParser.parse(), ' Formula ACCRINT(DATE(2022,1,1),DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 1.944, 'Test: Positive case: Number (7). Date are correct in number format arg[1] >= arg[2], Basis is 4. 7 of 8 agruments used.');
		// ---
		// Case #82: Number (7). Issue date 28.01.1900, all dates are correct in number format, basis - 0. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(59,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(59,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 108713.89, 'Test: Positive case: Number (7). Issue date 28.01.1900, all dates is correct in number format, basis - 0. 7 of 8 arguments used.');
		// Case #83: Date (formula)(3), Number (3). All dates are correct created by DATE formula. 6 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 10, 'Test: Positive case: Date (formula)(3), Number (3). All dates are correct created by DATE formula. 6 of 8 arguments used.');
		// Case #84: Date (formula)(3), Number (4). All dates are correct created by DATE formula. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 10, 'Test: Positive case: Date (formula)(3), Number (4). All dates are correct created by DATE formula. 7 of 8 arguments used.');
		// Case #85: Date (formula)(3), Number (4). All dates are correct created by DATE formula, Basis is 4. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,4)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 9.97, 'Test: Positive case: Date (formula)(3), Number (4). All dates are correct created by DATE formula, Basis is 4. 7 of 8 arguments used.');
		// Case #86: Number (7). All dates are correct in number format. Basis is 4. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,4)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, 'Test: Positive case: Number (7). All dates are correct in number format. Basis is 4. 7 of 8 arguments used.');
		// Case #87: Number(7). All dates are correct in number format.  Basis is 0. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(44562,44576,44621,0.05,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2022,1,1),DATE(2022,1,15),DATE(2022,3,1),0.05,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 8.333, 'Test: Positive case: Number(7). All dates are correct in number format.  Basis is 0. 7 of 8 arguments used.');
		// Case #88: Number (7). All dates are correct in number format.  Basis is 4. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(44562,44576,44621,0.05,1000,2,4)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2022,1,1),DATE(2022,1,15),DATE(2022,3,1),0.05,1000,2,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 8.333, 'Test: Positive case: Number (7). All dates are correct in number format.  Basis is 4. 7 of 8 arguments used.');
		// Case #89: Number, Formula(2),Number(3), Boolean. Issue is 01.03.1900 all dates are correct, calc_method - FALSE. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(61,DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,0,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(61,44261,44567,0.05,1000,2,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 18.611, 'Test: Positive case: Number, Formula(2),Number(3), Boolean. Issue is 01.03.1900 all dates are correct, calc_method - FALSE. 8 of 8 arguments used.');
		// Case #90: Number, Formula(2), Number(4), Boolean. Issue is 01.03.1900 all dates are correct, calc_method - TRUE. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(61,DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(61,DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,0,TRUE) is parsed');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 6093.611, 'Test: Positive case: Number, Formula(2), Number(4), Boolean. Issue is 01.03.1900 all dates are correct, calc_method - TRUE. 8 of 8 arguments used.');
		// Case #91: Formula(3), Number(4). All dates are correct created by DATE formula. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2012,8,1),DATE(2013,3,1),DATE(2012,8,30),0.05,100,2,1)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2012,8,1),DATE(2013,3,1),DATE(2012,8,30),0.05,100,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.394, 'Test: Positive case: Formula(3), Number(4). All dates are correct created by DATE formula. 7 of 8 arguments used.');
		// Case #92: Formula(3), Number(4). All dates are correct created by DATE formula. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2012,8,1),DATE(2013,3,1),DATE(2012,8,31),0.05,100,2,1)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2012,8,1),DATE(2013,3,1),DATE(2012,8,31),0.05,100,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.407, 'Test: Positive case: Formula(3), Number(4). All dates are correct created by DATE formula. 7 of 8 arguments used.');
		// Case #93: Formula (3), Number (4). All dates are correct created by DATE formula. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2012,8,1),DATE(2013,3,1),DATE(2012,9,1),0.05,100,2,1)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2012,8,1),DATE(2013,3,1),DATE(2012,9,1),0.05,100,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.421, 'Test: Positive case: Formula (3), Number (4). All dates are correct created by DATE formula. 7 of 8 arguments used.');
		// Case #94: Positive case. Settlement is 500. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2008,4,5),500,DATE(2008,5,1),0.1,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(DATE(2008,4,5),500,DATE(2008,5,1),0.1,1000,2,0,TRUE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 7.22, "Test: Positive case. Settlement is 500. 8 of 8 arguments used.");
		// Case #95: Positive case. Settlement is 50000. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2008,4,5),50000,DATE(2008,5,1),0.1,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(DATE(2008,4,5),50000,DATE(2008,5,1),0.1,1000,2,0,TRUE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 7.22, "Test: Positive case. Settlement is 50000. 8 of 8 arguments used.");
		// Case #96: Positive case. All arguments are standard. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2008,4,5),DATE(2008,8,31),DATE(2008,5,1),0.1,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(DATE(2008,4,5),DATE(2008,8,31),DATE(2008,5,1),0.1,1000,2,0,TRUE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 7.22, "Test: Positive case. All arguments are standard. 8 of 8 arguments used.");

		// Negative cases:

		// Case #1: Boolean, Number(6). Test of arg[0]: Issue is boolean. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(TRUE,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(TRUE,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(6). Test of arg[0]: Issue is boolean. 7 of 8 argument used.');
		// Case #2: Boolean, Number(6). Test of arg[0]: Issue is boolean. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(FALSE,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(FALSE,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(6). Test of arg[0]: Issue is boolean. 7 of 8 argument used.');
		// Case #3: Number (7). Test of arg[0]: Issue is zero date in number format.
		oParser = new parserFormula("ACCRINT(0,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(0,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number (7). Test of arg[0]: Issue is zero date in number format.');
		// Case #4: String(8). Date are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE, All args in string. 8 of 8 argument used.
		oParser = new parserFormula("ACCRINT(\"03/01/2006\",\"09/01/2006\",\"05/01/2006\",\"0.1\",\"1100\",\"2\",\"0\",\"TRUE\")", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(\"03/01/2006\",\"09/01/2006\",\"05/01/2006\",\"0.1\",\"1100\",\"2\",\"0\",\"TRUE\") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(8). Date are correct, Issue < Settlement, Rate > 0, Par > 0, Frequency correct, Basis correct, Calc_method - TRUE, All args in string. 8 of 8 argument used.');
		// Case #5: Number (7). Test of arg[0]: Issue is fractional number format. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(0.75,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(0.75,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number (7). Test of arg[0]: Issue is fractional number format. 7 of 8 argument used.');
		// Case #6: Number (7). Test of arg[0]: Issue is negative number format. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(-1,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(-1,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number (7). Test of arg[0]: Issue is negative number format. 7 of 8 argument used.');
		// Case #7: Number (7). Test of arg[0]: Issue is negative fractional number format. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(-0.75,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(-0.75,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number (7). Test of arg[0]: Issue is negative fractional number format. 7 of 8 argument used.');
		// Case #8: String, Number(6). Test of arg[0]: Issue is string. 7 of 8 argument used.
		oParser = new parserFormula('ACCRINT("str",39691,39769,1,1000,2,0)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT("str",39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(6). Test of arg[0]: Issue is string. 7 of 8 argument used.');
		// Case #9: Empty, Number(6). Test of arg[0]: Issue is empty. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(6). Test of arg[0]: Issue is empty. 7 of 8 argument used.');
		// Case #10: Array, Number(6). Test of arg[0]: Issue is array with TRUE. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT({TRUE;2500},39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT({TRUE;2500},39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Number(6). Test of arg[0]: Issue is array with TRUE. 7 of 8 argument used.');
		// Case #11: Array, Number(6). Test of arg[0]: Issue is array with negative number. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT({-1},39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT({-1},39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number(6). Test of arg[0]: Issue is array with negative number. 7 of 8 argument used.');
		// Case #12: Area, Number(6). Test of arg[0]: Issue is area with invalid type (area with invalid value). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(A100:A102,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100:A102,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(6). Test of arg[0]: Issue is area with invalid type. 7 of 8 argument used.');
		// Test of arg[1]
		// Case #13: Number, Boolean, Number(5). Test of arg[1]: First_interest is Boolean value. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,TRUE,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,TRUE,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(5). Test of arg[1]: First_interest is Boolean value. 7 of 8 argument used.');
		// Case #14: Number, Boolean, Number(5). Test of arg[1]: First_interest is Boolean value. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,FALSE,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,FALSE,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(5). Test of arg[1]: First_interest is Boolean value. 7 of 8 argument used.');
		// Case #15: Number, Number, Number(5). Test of arg[1]: First_interest is zero date. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,0,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,0,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number(5). Test of arg[1]: First_interest is zero date. 7 of 8 argument used.');
		// Case #16: Number, Number, Number(5). Test of arg[1]: First_interest is invalid numeric value (0.75). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,0.75,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,0.75,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number(5). Test of arg[1]: First_interest is invalid numeric value (0.75). 7 of 8 argument used.');
		// Case #17: Number, Number, Number(5). Test of arg[1]: First_interest is negative value (-1). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,-1,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,-1,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number(5). Test of arg[1]: First_interest is negative value (-1). 7 of 8 argument used.');
		// Case #18: Number, Number, Number(5). Test of arg[1]: First_interest is negative value (-0.75). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,-0.75,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,-0.75,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number(5). Test of arg[1]: First_interest is negative value (-0.75). 7 of 8 argument used.');
		// Case #19: Number, String, Number(5). Test of arg[1]: First_interest is string value. 7 of 8 argument used.
		oParser = new parserFormula('ACCRINT(39508,"str",39769,1,1000,2,0)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,"str",39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(5). Test of arg[1]: First_interest is string value. 7 of 8 argument used.');
		// Case #20: Number, Empty, Number(5). Test of arg[1]: First_interest is empty value. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,,39769,1,1000,2,0) is parsed');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number(5). Test of arg[1]: First_interest is empty value. 7 of 8 argument used.');
		// Case #21: Number, Array, Number(5). Test of arg[1]: First_interest is array with invalid value {-1}. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,{-1},39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,{-1},39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Array, Number(5). Test of arg[1]: First_interest is array with invalid value {-1}. 7 of 8 argument used.');
		// Case #22: Number, Array, Number(5). Test of arg[1]: First_interest is array with mixed invalid type {TRUE;2500}. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,{TRUE;2500},39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,{TRUE;2500},39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Array, Number(5). Test of arg[1]: First_interest is array with mixed invalid type {TRUE;2500}. 7 of 8 argument used.');
		// Case #23: Number, Area, Number(5). Test of arg[1]: First_interest is reference with invalid type A100:A102. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,A100:A102,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,A100:A102,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(5). Test of arg[1]: First_interest is reference with invalid type A100:A102. 7 of 8 argument used.');
		//Test of arg[2]
		// Case #24: Number(2), Boolean, Number(4). Test of arg[2]: Settlement is boolean TRUE. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,TRUE,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,TRUE,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number(4). Test of arg[2]: Settlement is boolean TRUE. 7 of 8 arguments used.');
		// Case #25: Number(2), Boolean, Number(4). Test of arg[2]: Settlement is boolean FALSE. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,FALSE,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,FALSE,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number(4). Test of arg[2]: Settlement is boolean FALSE. 7 of 8 arguments used.');
		// Case #26: Number(7). Test of arg[2]: Settlement is zero date in number format. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,0,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,0,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Zero. Test of arg[2]: Settlement is zero date in number format. 7 of 8 arguments used.');
		// Case #27: Number(7). Test of arg[2]: Settlement is 1 and settlement < issue. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,1,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,1,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Test of arg[2]: Settlement is 1 and settlement < issue. 7 of 8 arguments used.');
		// Case #28: Number(7). Test of arg[2]: Settlement is -1. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,-1,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,-1,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Test of arg[2]: Settlement is -1. 7 of 8 arguments used.');
		// Case #29: Number(7). Test of arg[2]: Settlement is decimal 0.75. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,0.75,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,0.75,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Test of arg[2]: Settlement is decimal 0.75. 7 of 8 arguments used.');
		// Case #30: Number(7). Test of arg[2]: Settlement is decimal -0.75. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,-0.75,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,-0.75,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Test of arg[2]: Settlement is decimal -0.75. 7 of 8 arguments used.');
		// Case #31: Number(7). Test of arg[2]: Settlement is too large. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,999999999999999999999,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,999999999999999999999,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Test of arg[2]: Settlement is too large. 7 of 8 arguments used.');
		// Case #32: Number(2), String, Number (4). Test of arg[2]: Settlement is string. 7 of 8 arguments used.
		oParser = new parserFormula('ACCRINT(39508,39691,"str",1,1000,2,0)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,"str",1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Test of arg[2]: Settlement is string. 7 of 8 arguments used.');
		// Case #33: Number(2),Empty, Number(4). Test of arg[2]: Settlement is empty. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Test of arg[2]: Settlement is empty. 7 of 8 arguments used.');
		// Case #34: Number(2), Array, Number(4). Test of arg[2]: Settlement is array {1}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,{1},1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,{1},1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Test of arg[2]: Settlement is array {1}. 7 of 8 arguments used.');
		// Case #35: Number(2), Array, Number(4). Test of arg[2]: Settlement is array {-1}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,{-1},1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,{-1},1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Test of arg[2]: Settlement is array {-1}. 7 of 8 arguments used.');
		// Case #36: Number(2), Array, Number(4). Test of arg[2]: Settlement is array {TRUE;2500}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,{TRUE;2500},1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,{TRUE;2500},1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Test of arg[2]: Settlement is array {TRUE;2500}. 7 of 8 arguments used.');
		// Case #37: Number, Reference link, Area, Number(4). Test of arg[2]: Settlement is range A100:A102. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,A101,A100:A102,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,A101,A100:A102,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Test of arg[2]: Settlement is range A100:A102. 7 of 8 arguments used.');
		// Test of arg[3]
		// Case #38: Boolean. Test of arg[3]: Rate is boolean TRUE. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,TRUE,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,TRUE,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Test of arg[3]: Rate is boolean TRUE. 7 of 8 arguments used.');
		// Case #39: Boolean. Test of arg[3]: Rate is boolean FALSE. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,FALSE,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,FALSE,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Test of arg[3]: Rate is boolean FALSE. 7 of 8 arguments used.');
		// Case #40: Number. Test of arg[3]: Rate is zero. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,0,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,0,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[3]: Rate is zero. 7 of 8 arguments used.');
		// Case #41: Number. Test of arg[3]: Rate is negative integer -1. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,-1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,-1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[3]: Rate is negative integer -1. 7 of 8 arguments used.');
		// Case #42: Number. Test of arg[3]: Rate is negative decimal -0.75. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,-0.75,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,-0.75,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[3]: Rate is negative decimal -0.75. 7 of 8 arguments used.');
		// Case #43: String. Test of arg[3]: Rate is string. 7 of 8 arguments used.
		oParser = new parserFormula('ACCRINT(39508,39691,39769,"str",1000,2,0)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,"str",1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Test of arg[3]: Rate is string. 7 of 8 arguments used.');
		// Case #44: Empty. Test of arg[3]: Rate is empty. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Test of arg[3]: Rate is empty. 7 of 8 arguments used.');
		// Case #45: Array. Test of arg[3]: Rate is array {TRUE;2500}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,{TRUE;2500},1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,{TRUE;2500},1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Test of arg[3]: Rate is array {TRUE;2500}. 7 of 8 arguments used.');
		// Case #46: Area. Test of arg[3]: Rate is range A101:A104. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A101:A104,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A101:A104,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Test of arg[3]: Rate is range A101:A104. 7 of 8 arguments used.');
		// Test of arg[4]
		// Case #47: Boolean. Test of arg[4]: Par is boolean TRUE. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,TRUE,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,TRUE,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Test of arg[4]: Par is boolean TRUE. 7 of 8 arguments used.');
		// Case #48: Boolean. Test of arg[4]: Par is boolean FALSE. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,FALSE,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,FALSE,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Test of arg[4]: Par is boolean FALSE. 7 of 8 arguments used.');
		// Case #49: Number. Test of arg[4]: Par is zero. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,0,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,0,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[4]: Par is zero. 7 of 8 arguments used.');
		// Case #50: Number. Test of arg[4]: Par is negative integer -1. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,-1,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,-1,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[4]: Par is negative integer -1. 7 of 8 arguments used.');
		// Case #51: Number. Test of arg[4]: Par is negative decimal -0.75. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,-0.75,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,-0.75,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[4]: Par is negative decimal -0.75. 7 of 8 arguments used.');
		// Case #52: String. Test of arg[4]: Par is string. 7 of 8 arguments used.
		oParser = new parserFormula('ACCRINT(39508,39691,39769,1,"str",2,0)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,"str",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Test of arg[4]: Par is string. 7 of 8 arguments used.');
		// Case #53: Array. Test of arg[4]: Par is array {TRUE;2500}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,{TRUE;2500},2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,{TRUE;2500},2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Test of arg[4]: Par is array {TRUE;2500}. 7 of 8 arguments used.');
		// Case #54: Reference link. Test of arg[4]: Par is range A100:A104. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A100:A104,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A100:A104,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link. Test of arg[4]: Par is range A100:A104. 7 of 8 arguments used.');
		// Test of arg[5]
		// Case #55: Boolean. Test of arg[5]: Frequency is TRUE. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,TRUE,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,TRUE,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Test of arg[5]: Frequency is TRUE. 7 of 8 argument used.');
		// Case #56: Boolean. Test of arg[5]: Frequency is FALSE. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,FALSE,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,FALSE,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Test of arg[5]: Frequency is FALSE. 7 of 8 argument used.');
		// Case #57: Number. Test of arg[5]: Frequency is 0 (below allowed range). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,0,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[5]: Frequency is 0 (below allowed range). 7 of 8 argument used.');
		// Case #58: Number. Test of arg[5]: Frequency is 8 (above allowed range). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,8,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,8,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[5]: Frequency is 8 (above allowed range). 7 of 8 argument used.');
		// Case #59: Number. Test of arg[5]: Frequency is -1 (negative value). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,-1,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,-1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[5]: Frequency is -1 (negative value). 7 of 8 argument used.');
		// Case #60: Number. Test of arg[5]: Frequency is 0.75 (non-integer). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,0.75,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,0.75,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[5]: Frequency is 0.75 (non-integer). 7 of 8 argument used.');
		// Case #61: Number. Test of arg[5]: Frequency is -0.75 (non-integer). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,-0.75,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,-0.75,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[5]: Frequency is -0.75 (non-integer). 7 of 8 argument used.');
		// Case #62: Number. Test of arg[5]: Frequency is 100000 (large value). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,100000,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,100000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[5]: Frequency is 100000 (large value). 7 of 8 argument used.');
		// Case #63: Number. Test of arg[5]: Frequency is 999999999999999999999 (very large). 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,999999999999999999999,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,999999999999999999999,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[5]: Frequency is 999999999999999999999 (very large). 7 of 8 argument used.');
		// Case #64: String. Test of arg[5]: Frequency is "str". 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,\"str\",0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,"str",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Test of arg[5]: Frequency is "str". 7 of 8 argument used.');
		// Case #65: Empty. Test of arg[5]: Frequency is empty. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Test of arg[5]: Frequency is empty. 7 of 8 argument used.');
		// Case #66: Array. Test of arg[5]: Frequency is {-1}. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,{-1},0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,{-1},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Test of arg[5]: Frequency is {-1}. 7 of 8 argument used.');
		// Case #67: Array. Test of arg[5]: Frequency is {1000;1200}. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,{1000;1200},0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,{1000;1200},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Test of arg[5]: Frequency is {1000;1200}. 7 of 8 argument used.');
		// Case #68: Array. Test of arg[5]: Frequency is {TRUE;2500}. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,{TRUE;2500},0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,{TRUE;2500},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Mixed array. Test of arg[5]: Frequency is {TRUE;2500}. 7 of 8 argument used.');
		// Case #69: Area. Test of arg[5]: Frequency is A101:A105. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A101:A105,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A104,A101:A105,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Test of arg[5]: Frequency is A101:A105. 7 of 8 argument used.');
		// Test of arg[6]
		// Case #70: Boolean. Test of arg[6]: Basis is TRUE. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Test of arg[6]: Basis is TRUE. 7 of 8 arguments used.');
		// Case #71: Boolean. Test of arg[6]: Basis is FALSE. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Test of arg[6]: Basis is FALSE. 7 of 8 arguments used.');
		// Case #72: Number. Test of arg[6]: Basis is -1. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,-1)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[6]: Basis is -1. 7 of 8 arguments used.');
		// Case #73: Number. Test of arg[6]: Basis is -0.75. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,-0.75)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,-0.75) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[6]: Basis is -0.75. 7 of 8 arguments used.');
		// Case #74: Number. Test of arg[6]: Basis is 100000. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,100000)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,100000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[6]: Basis is 100000. 7 of 8 arguments used.');
		// Case #75: Number. Test of arg[6]: Basis is 999999999999999999999. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,999999999999999999999)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,999999999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Test of arg[6]: Basis is 999999999999999999999. 7 of 8 arguments used.');
		// Case #76: String. Test of arg[6]: Basis is "str". 7 of 8 arguments used.
		oParser = new parserFormula('ACCRINT(39508,39691,39769,1,1000,1,"str")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,"str") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Test of arg[6]: Basis is "str". 7 of 8 arguments used.');
		// Case #77: Array. Test of arg[6]: Basis is {-1}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,{-1})", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,{-1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Test of arg[6]: Basis is {-1}. 7 of 8 arguments used.');
		// Case #78: Array. Test of arg[6]: Basis is {1000;1200}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,{1000;1200})", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,{1000;1200}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Test of arg[6]: Basis is {1000;1200}. 7 of 8 arguments used.');
		// Case #79: Array. Test of arg[6]: Basis is {TRUE;2500}. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,{TRUE;2500})", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,{TRUE;2500}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Test of arg[6]: Basis is {TRUE;2500}. 7 of 8 arguments used.');
		// Case #80: Area. Test of arg[6]: Basis is A101:A106. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A101:A106)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A101:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Test of arg[6]: Basis is A101:A106. 7 of 8 arguments used.');
		// Test of arg[7]
		// Case #81: String. Test of arg[7]: Calc_method is \"str\". 8 of 8 arguments used.
		oParser = new parserFormula('ACCRINT(39508,39691,39769,1,1000,1,0;"str")', "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0;\"str\") is parsed.");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Test: Negative case: String. Calc_method is \"str\". 8 of 8 arguments used.");
		// Case #82: Area. Test of arg[7]: Calc_method is A101:A107. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A101:A107)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A101:A107) is parsed.");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Test: Negative case: Area. Calc_method is A101:A107. 8 of 8 arguments used.");
		// Case #83: Area. Test of arg[7]: Calc_method is A107:A108. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A107:A108)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A107:A108) is parsed.");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Test: Negative case: Area. Calc_method is A107:A108. 8 of 8 arguments used.");
		// Case #84: Area. Test of arg[7]: Calc_method is A111. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(A100,A101,A102,A103,A104,A105,A106,A111)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(A100,A101,A102,A103,A104,A105,A106,A111) is parsed.");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Test: Negative case: Area. Calc_method is A111. 8 of 8 arguments used.");
		// Case #85: Negative case. Settlement is greater than maximum date. 8 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2008,4,5),DATE(9999,12,31)+1,DATE(2008,5,1),0.1,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "Test: Formula ACCRINT(DATE(2008,4,5),DATE(9999,12,31)+1,DATE(2008,5,1),0.1,1000,2,0,TRUE) is parsed.");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Test: Negative case. Settlement is greater than maximum date. 8 of 8 arguments used.");

		// Bounded cases:

		// Case #1: Number (7). Test of arg[0]: Issue is minimum accepted date in number format. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(1,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(1,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number (7). Test of arg[0]: Issue is minimum accepted date in number format. 7 of 8 argument used.');
		// Case #2: Number(7). Test of arg[1]: First_interest is minimum accepted date in number format. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,1,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,1,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 711.11, 'Test: Bounded case: Number, Number, Number(5). Test of arg[1]: Valid numeric value (1) for settlement. 7 of 8 argument used.');
		// Case #3: String(3), Number(4). Maximum accepted dates in string. 7 of 8 agrument used.
		oParser = new parserFormula("ACCRINT(\"12/30/9999\",\"12/31/9999\",\"12/31/9999\",1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(\"12/30/9999\",\"12/31/9999\",\"12/31/9999\",1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: String(3), Number(4). Maximum accepted dates. 7 of 8 agrument used.');
		// Case #4: Number(7). Test of arg[2]: Settlement is minimum accepted date in number format (1), but Settlement < Issue. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,1,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,1,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(7). Test of arg[2]: Settlement is minimum accepted date in number format, but Settlement < Issue. 7 of 8 arguments used.');
		// Case #5: Number(7). Test of arg[3]: Rate is minimum accepted number. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1E-307,1100,1,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1E-307,1100,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.852777777777777e-305, 'Test: Bounded case: Number(7). Test of arg[3]: Rate is minimum accepted number. 7 of 8 arguments used.');
		// Case #6: Date (formula), Number(6). Test of arg[3]: Rate is maximum accepted number. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(DATE(2008,3,5),39691,39569,1E+305,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2008,3,5),39691,39569,1E+305,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5555555555555556e+307, 'Test: Bounded case: Date (formula), Number(6). Test of arg[3]; Rate is maximum accepted number. 7 of 8 arguments used.');
		// Case #7: Number(7). Test of arg[4]: Par is minumum accepted number. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 0.7139, 'Test: Bounded case: Number. Test of arg[4]: Par is minumum accepted number. 7 of 8 arguments used.');
		// Case #8: Number(7). Test of arg[4]: Par is maximum accepted number. 7 of 8 arguments used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,9.99999999999999E+307,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,9.99999999999999E+307,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.138888888888882e+307, 'Test: Bounded case: Number(7). Test of arg[4]: Par is maximum accepted number. 7 of 8 arguments used.');
		// Case #9: Number(7). Test of arg[5]: Frequency is minumum accepted value. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Bounded case: Number(7). Frequency = minumum accepted value. 7 of 8 argument used.');
		// Case #10: Number(7). Test of arg[5]: Frequency is maximum accepted value. 7 of 8 argument used.
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,4,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,4,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Bounded case: Number(7). Frequency is maximum accepted value. 7 of 8 argument used.');

		// Need to fix:

		// bug cases
		// TODO fix the calculation of the coupon period when receiving the date 1900,1,29(60). Need to fix it incorrect results
		//  Different result with MS
		oParser = new parserFormula("ACCRINT(58,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(58,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Need to fix: Result of ACCRINT(58,39691,39769,1,1000,2,0)'); // must be #NUM!
		// Different result with MS
		oParser = new parserFormula("ACCRINT(60,39691,39769,1,1000,2,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(60,39691,39769,1,1000,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 108713.89, 'Test: Need to fix: Issue is 02/29/1900, Basis is 0'); //108719.44
		// Different result with MS
		oParser = new parserFormula("ACCRINT(60,39691,39769,1,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(60,39691,39769,1,1000,2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 108713.89, 'Test: Need to fix: Issue is 02/29/1900, Basis is 0, Calc_method is TRUE');	// 108719.44
		// Different result with MS
		oParser = new parserFormula("ACCRINT(60,39691,39769,1,1000,2,0,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(60,39691,39769,1,1000,2,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 1213.89, 'Test: Need to fix: Issue is 02/29/1900, Basis is 0, Calc_method is FALSE');	// 1219.44
		// Different result with MS
		oParser = new parserFormula("ACCRINT(60,39691,39769,1,1000,2,1,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(60,39691,39769,1,1000,2,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 1198.37, 'Test: Need to fix: Issue is 02/29/1900, Basis is 1, Calc_method is FALSE');	// 1209.25
		// Different result with MS
		oParser = new parserFormula("ACCRINT(60,39691,39769,1,1000,2,2,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(60,39691,39769,1,1000,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 1213.95, 'Test: Need to fix: Issue is 02/29/1900, Basis is 2, Calc_method is FALSE');	// 1238.89
		// Different result with MS
		oParser = new parserFormula("ACCRINT(60,39691,39769,1,1000,2,3,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(60,39691,39769,1,1000,2,3,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 1208.22, 'Test: Need to fix: Issue is 02/29/1900, Basis is 3, Calc_method is FALSE');	// 1221.92
		// Different result with MS
		oParser = new parserFormula("ACCRINT(60,39691,39769,1,1000,2,4,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(60,39691,39769,1,1000,2,4,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 1208.42, 'Test: Need to fix: Issue is 02/29/1900, Basis is 4, Calc_method is FALSE');	// 1213.92
		// Different result with MS
		oParser = new parserFormula("ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,1)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 10.01, 'Test: Need to fix: Dates are correct, basis is 1. 7 of 8 arguments used.');	// 9.97
		// Different result with MS
		oParser = new parserFormula("ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,2)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 9.94, 'Test: Need to fix. All dates are correct. 7 of 8 arguments used.');	// 10.14
		// Different result with MS
		oParser = new parserFormula("ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,3)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2020,1,1),DATE(2020,7,1),DATE(2020,12,31),0.1,100,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 10.03, 'Test: Need to fix. All dates are correct. 7 of 8 arguments used.');	// 10
		// Different result with MS
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,1)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 724.66, 'Test: Need to fix. All dates are correct. 7 of 8 arguments used.');	// 713.11
		// Different result with MS
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,{1})", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, 725, 'Test: Need to fix. All dates are correct. 7 of 8 arguments used.'); // 713.11
		// Different result with MS
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,2)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 713.89, 'Test: Need to fix. All dates are correct. 7 of 8 arguments used.');	// 725
		// Different result with MS
		oParser = new parserFormula("ACCRINT(39508,39691,39769,1,1000,1,3)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(39508,39691,39769,1,1000,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 726.03, 'Test: Need to fix. All dates are correct. 7 of 8 arguments used.');	// 715.07
		// Different result with MS
		oParser = new parserFormula("ACCRINT(44562,44576,44621,0.05,1000,2,1)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2022,1,1),DATE(2022,1,15),DATE(2022,3,1),0.05,1000,2,1)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 8.696, 'Test: Need to fix. All dates are correct. 7 of 8 arguments used.');	// 8.016
		// Different result with MS
		oParser = new parserFormula("ACCRINT(44562,44576,44621,0.05,1000,2,2)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2022,1,1),DATE(2022,1,15),DATE(2022,3,1),0.05,1000,2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 8.291, 'Test: Need to fix. All dates are correct. 7 of 8 arguments used.');	// 8.194
		// Different result with MS
		oParser = new parserFormula("ACCRINT(44562,44576,44621,0.05,1000,2,3)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2022,1,1),DATE(2022,1,15),DATE(2022,3,1),0.05,1000,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 8.562, 'Test: Need to fix. All dates are correct. 7 of 8 arguments used.');	// 8.082
		// Different result with MS
		oParser = new parserFormula("ACCRINT(60,DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,0,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(60,DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,0,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.61111111111111, 'Test: Need to fix. All dates are correct. 8 of 8 arguments used.'); // 0
		// Different result with MS
		oParser = new parserFormula("ACCRINT(60,DATE(2022,3,1),DATE(2022,1,15),0.05,1000,2,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(60,44261,44567,0.05,1000,2,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6093.611111111111, 'Test: Need to fix. All dates are correct. 8 of 8 arguments used.'); // 0
		// Different result with MS
		oParser = new parserFormula("ACCRINT(DATE(2000,9,1),DATE(2014,3,1),DATE(2014,2,1),0.05,100,2,1,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2000,9,1),DATE(2014,3,1),DATE(2014,2,1),0.05,100,2,1,TRUE)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 67.07, 'Test: Need to fix. All dates are correct. 8 of 8 arguments used.'); // 67.11
		// Different result with MS
		oParser = new parserFormula("ACCRINT(DATE(2000,9,1),DATE(2014,3,1),DATE(2014,2,1),0.05,100,2,1,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINT(DATE(2000,9,1),DATE(2014,3,1),DATE(2014,2,1),0.05,100,2,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 2.07, 'Test: Need to fix. All dates are correct. 8 of 8 arguments used.'); // 2.11

		testArrayFormula2(assert, "ACCRINT", 6, 8, true);
	});

	QUnit.test("Test: \"ACCRINTM\"", function (assert) {
		// Data for reference link test.
		// Dates
		ws.getRange2("A100").setValue("05/20/2025");
		ws.getRange2("A101").setValue("06/20/2025");
		ws.getRange2("A102").setValue("38777");
		ws.getRange2("A103").setValue("38838");
		// Rate
		ws.getRange2("A104").setValue("0.01");
		ws.getRange2("A105").setValue("1");
		// Par
		ws.getRange2("A106").setValue("1500");
		ws.getRange2("A107").setValue("1100");
		//Basis
		ws.getRange2("A108").setValue("0");
		ws.getRange2("A109").setValue("3");
		// Unexpected data for formula
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("Str");
		// Table type
		let table1 = getTableType(599, 0, 600, 4);
		ws.getRange2("A601").setValue("39539"); // Issue (Column1)
		ws.getRange2("B601").setValue("39614"); // Settlement (Column2)
		ws.getRange2("C601").setValue("0.1"); // Rate (Column3)
		ws.getRange2("D601").setValue("1000"); // Par (Column4)
		ws.getRange2("E601").setValue("3"); // Basis (Column5)
		// 3D links
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("45797");
		ws2.getRange2("B1").setValue("45828");
		ws2.getRange2("C1").setValue("0.01");
		ws2.getRange2("D1").setValue("1100");
		ws2.getRange2("E1").setValue("3");
		// DefNames
		let defName = new Asc.asc_CDefName("Issue", ws.getName() + "!$A$112");
		let defName3D = new Asc.asc_CDefName("Issue3D", ws2.getName() + "!$A$2");
		let defName2 = new Asc.asc_CDefName("Settlement", ws.getName() + "!$B$112");
		let defName3D2 = new Asc.asc_CDefName("Settlement3D", ws2.getName() + "!$B$2");
		let defName3 = new Asc.asc_CDefName("Rate", ws.getName() + "!$C$112");
		let defName3D3 = new Asc.asc_CDefName("Rate3D", ws2.getName() + "!$C$2");
		let defName4 = new Asc.asc_CDefName("Par", ws.getName() + "!$D$112");
		let defName3D4 = new Asc.asc_CDefName("Par3D", ws2.getName() + "!$D$2");
		let defName5 = new Asc.asc_CDefName("Basis", ws.getName() + "!$E$112");
		let defName3D5 = new Asc.asc_CDefName("Basis3D", ws2.getName() + "!$E$2");
		let defNameArea = new Asc.asc_CDefName("NameArea", ws.getName() + "!$B$112:$E$112");
		let defNameAreaBug = new Asc.asc_CDefName("NameAreaBug", ws.getName() + "!$A$112:$E$112");
		wb.editDefinesNames(null, defName);
		wb.editDefinesNames(null, defName3D);
		wb.editDefinesNames(null, defName2);
		wb.editDefinesNames(null, defName3D2);
		wb.editDefinesNames(null, defName3);
		wb.editDefinesNames(null, defName3D3);
		wb.editDefinesNames(null, defName4);
		wb.editDefinesNames(null, defName3D4);
		wb.editDefinesNames(null, defName5);
		wb.editDefinesNames(null, defName3D5);
		wb.editDefinesNames(null, defNameArea);
		wb.editDefinesNames(null, defNameAreaBug);
		ws.getRange2("A112").setValue("39539");
		ws2.getRange2("A2").setValue("39539");
		ws.getRange2("B112").setValue("39614");
		ws2.getRange2("B2").setValue("39614");
		ws.getRange2("C112").setValue("0.1");
		ws2.getRange2("C2").setValue("0.1");
		ws.getRange2("D112").setValue("1000");
		ws2.getRange2("D2").setValue("1000");
		ws.getRange2("E112").setValue("3");
		ws2.getRange2("E2").setValue("3");

		// Positive cases:

		// Case #1: Formula(2), Number(3). All arguments are correct and have expected type of arguments. 5 of 5 arguments used.
		oParser = new parserFormula("ACCRINTM(DATE(2006,3,1),DATE(2006,5,1),0.1,1100,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(DATE(2006,3,1),DATE(2006,5,1),0.1,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.333333333333332, 'Test: Positive case: Formula(2), Number(3). All arguments are correct and have expected type of arguments. 5 of 5 arguments used.');
		// Case #2: Formula(2), Number, Empty, Number. Dates are correct filled by formula DATE, Rate > 0, Par is empty, Basis - 0. 5 of 5 arguments used.
		oParser = new parserFormula("ACCRINTM(DATE(2006,3,1),DATE(2006,5,1),0.1,,0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(DATE(2006,3,1),DATE(2006,5,1),0.1,,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16.666666666666664, 'Test: Positive case: Formula(2), Number, Empty, Number. Dates are correct filled by formula DATE, Rate > 0, Par is empty, Basis - 0. 5 of 5 arguments used.');
		// Case #3: Formula (2), Number, Empty. Dates are correct filled by formula DATE, Rate > 0, Par and Basis aren't fill. 4 of 5 arguments filled.
		oParser = new parserFormula("ACCRINTM(DATE(2006,3,1),DATE(2006,5,1),0.1,)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(DATE(2006,3,1),DATE(2006,5,1),0.1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16.666666666666664, 'Test: Positive case: Formula (2), Number, Empty. Dates are correct filled by formula DATE, Rate > 0, Par and Basis aren\'t fill. 4 of 5 arguments filled.');
		// Case #4: Date in String(2), Number(3). Dates as string format. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("03/01/2006","05/01/2006",0.1,1100,0)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("03/01/2006","05/01/2006",0.1,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.333333333333332, 'Test: Positive case: String(2), Number(3). Dates in string format. 5 of 5 arguments used.');
		// Case #5: Formula(2), Number(3). Issue filled via IF formula. 5 of 5 arguments used.
		oParser = new parserFormula("ACCRINTM(IF(TRUE, DATE(2006,3,1), DATE(2000,1,1)), DATE(2006,5,1), 0.1, 1100, 0)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(IF(TRUE, DATE(2006,3,1), DATE(2000,1,1)), DATE(2006,5,1), 0.1, 1100, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18.333333333333332, 'Test: Positive case:  Formula(2), Number(3). Nested formula IF for issue date. 5 of 5 arguments used.');
		// Case #6: String (4). All requirement arguments in string type, basis omitted. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("03/01/2006","05/01/2006","0.1","1")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("03/01/2006","05/01/2006","0.1","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.016666666666666666, 'Test: Positive case: String (4). All requirement arguments in string type, basis omitted. 4 of 5 arguments used.');
		// Case #7: Formula, Number. Formula inside parent SUM(). 5 of 5 arguments used.
		oParser = new parserFormula("SUM(ACCRINTM(DATE(2006,3,1),DATE(2006,5,1),0.1,1100,0), 10)", "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(ACCRINTM(DATE(2006,3,1),DATE(2006,5,1),0.1,1100,0), 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 28.333333333333332, 'Test: Positive case: Fourmula, Number. Formula inside parent SUM(). 5 of 5 arguments used.');
		// Case #8: Number(5). Dates are correct in number format, Rate is large number. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,999999999,1000,0)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,999999999,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.666666665e+11, 'Test: Positive case: Number(5). Dates are correct in number format. Rate is large number. 5 of 5 arguments used.');
		// Case #9: Number(5). Dates are correct in number format, Rate is small number, Basis - 1. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,0.0000000001,1100,1)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,0.0000000001,1100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.838356164383562e-8, 'Test: Positive case: Number(5). Dates are correct in number format, Rate is small number, Basis - 1. 5 of 5 arguments used.');
		// Case #10: Number, Formula, Formula, Number (2). Issue is date in number format, Settlement filled by DATE formula, Rate filled by formula, Basis - 2. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(45792,DATE(2025,6,30),((110-100)+5)/100,1100,2)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(45792,DATE(2025,6,30),((110-100)+5)/100,1100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 21.083, 'Test: Positive case: Number, Formula, Formula, Number (2). Issue is date in number format, Settlement filled by DATE formula, Rate filled by formula, Basis - 2. 5 of 5 arguments used.');
		// Case #11: Reference link (5). All arguments in Ref link, basis - 3. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(A100,A101,A104,A107,A109)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(A100,A101,A104,A107,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.934, 'Test: Positive case: Reference link (5). All arguments in Ref link, basis - 3. 5 of 5 arguments used.');
		// Case #12: String(2), Number(3). Dates are in short format in string type, basis - 4. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("5/5","6/5",0.1,1100,4)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM("5/5","6/5",0.1,1100,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 9.167, 'Test: Positive case: String(2), Number(3). Dates are in short format in string type, basis - 4. 5 of 5 arguments used.');
		// Case #13: Area(5). All arguments are area with single cell. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(A102:A102,A103:A103,A105:A105,A106:A106,A108:A108)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(A102:A102,A103:A103,A105:A105,A106:A106,A108:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 250, 'Test: Positive case: Area(5). All arguments are area with single cell. 5 of 5 arguments used.');
		// Case #14: Array(5). All arguments are array with single element. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM({38777},{38838},{0.01},{1000},{2})', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM({38777},{38838},{0.01},{1000},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 1.694, 'Test: Positive case: Area(5). All arguments are area with single cell. 5 of 5 arguments used.');
		// Case #15: Array(5). All arguments are array with multiple elements. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM({38777,TRUE},{38838,FALSE},{0.01,TRUE},{1000,FALSE},{2,TRUE})', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM({38777,TRUE},{38838,FALSE},{0.01,TRUE},{1000,FALSE},{2,TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 1.694, 'Test: Positive case: Array(5). All arguments are array with multiple elements. 5 of 5 arguments used.');
		// Case #16: Reference link, Formula, String, Number. Dates are correct, Rate in string, Per is large number, Basis omitted. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(A100,DATE(2025,6,20),"10",999999999)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(A100,DATE(2025,6,20),"10",999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 833333332.500, 'Test: Positive case: Reference link, Formula, String, Number. Dates are correct, Rate in string, Per is large number, Basis omitted. 4 of 5 arguments used.');
		// Case #17: Number(4). Dates are correct in number format, Per is too small number, Basis omitted. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,0.0001,0.0000000001)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,0.0001,0.0000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6666666666666668e-15, 'Test: Positive case: Number(4). Dates are correct in number format, Per is too small number, Basis omitted. 4 of 5 arguments used.');
		// Case #18: Array(5). All arguments are array with multiple correct elements. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM({38777,45792},{38838,45793},{0.001,1};{1100,1000},{0,1})', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM({38777,45792},{38838,45793},{0.001,1};{1100,1000},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.183, 'Test: Positive case: Array(5). All arguments are array with multiple correct elements. 5 of 5 arguments used.');
		// Case #19: Number(5). All arguments are float number. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777.5,38838.5,0.75,0.75,2.5)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777.5,38838.5,0.75,0.75,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.095, 'Test: Positive case: Number(5). All arguments are float number. 5 of 5 arguments used.');
		// Case #20: Formula(5). All agruments filled with formula. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(DATE(2025,5,20), DATE(2025,6,30),SQRT(144),ROUND(1000,0),ABS(-1))', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(DATE(2025,5,20), DATE(2025,6,30),SQRT(144),ROUND(1000,0),ABS(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 1347.945, 'Test: Positive case: Formula(5). All agruments filled with formula. 5 of 5 arguments used.');
		// Case #21: Number(3), Empty(2). Per and Basis are empty. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,0.5,,)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,0.5,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 83.333, 'Test: Positive case: Number(3), Empty(2). Per and Basis are empty. 5 of 5 arguments used.');
		// Case #22: Number(2), Formula(2). Rate and Par filled by DATE and TIME formulas. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,DATE(2025,6,6),TIME(15,15,15))', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,DATE(2025,6,6),TIME(15,15,15)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 4853.155, 'Test: Positive case: Number(2), Formula(2). Rate and Par filled by DATE and TIME formulas. 4 of 5 arguments used.');
		// Case #23: Number(2), Formula(2). Rate and Par filled by TIME and DATE formulas. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,TIME(15,15,15),DATE(2025,6,6))', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,TIME(15,15,15),DATE(2025,6,6)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 4853.155, 'Test: Positive case: Number(2), Formula(2). Rate and Par filled by TIME and DATE formulas. 4 of 5 arguments used.');
		// Case #23: Name(5). All arguments in Name type. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(Issue,Settlement,Rate,Par,Basis)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(Issue,Settlement,Rate,Par,Basis) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 20.54794521, 'Test: Positive case: Name(5). All arguments in Name type. 5 of 5 arguments used.');
		// Case #24: Name3D(5). All arguments in Name3D type. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(Issue3D,Settlement3D,Rate3D,Par3D,Basis3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(Issue3D,Settlement3D,Rate3D,Par3D,Basis3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 20.54794521, 'Test: Positive case: Name3D(5). All arguments in Name3D type. 5 of 5 arguments used.');
		// Case #25: Ref3D(5). All arguments in Ref3D type. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(Sheet2!A1,Sheet2!B1,Sheet2!C1,Sheet2!D1,Sheet2!E1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(Sheet2!A1,Sheet2!B1,Sheet2!C1,Sheet2!D1,Sheet2!E1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.934246575, 'Test: Positive case: Ref3D(5). All arguments in Ref3D type. 5 of 5 arguments used.');
		// Case #26: Area3D(5). All arguments in Area3D type. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(Sheet2!A1:Sheet2!A1,Sheet2!B1:Sheet2!B1,Sheet2!C1:Sheet2!C1,Sheet2!D1:Sheet2!D1,Sheet2!E1:Sheet2!E1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(Sheet2!A1:Sheet2!A1,Sheet2!B1:Sheet2!B1,Sheet2!C1:Sheet2!C1,Sheet2!D1:Sheet2!D1,Sheet2!E1:Sheet2!E1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.934246575, 'Test: Positive case: Area3D(5). All arguments in Area3D type. 5 of 5 arguments used.');
		// Case #27: Table. All arguments in Table. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 20.54794521, 'Test: Positive case: Table. All arguments in Table. 5 of 5 arguments used.');

		// Negative cases:

		// Case #1: String (3), Boolean. Rate as string, par as boolean TRUE, basis omitted. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("03/01/2006","05/01/2006","0.1",TRUE)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("03/01/2006","05/01/2006","0.1",TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String (3), Boolean. Rate as string, par as boolean TRUE, basis omitted. 4 of 5 arguments used.');
		// Case #2: Number(2), Boolean, Number. Dates as number, Rate as boolean, Per as number. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,TRUE, 1)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,TRUE,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case:  Number(2), Boolean, Number. Dates as number, Rate as boolean, Per as number. 4 of 5 arguments used.');
		// Case #3: Number(4), Boolean. Dates as number, Rate as number, Per as number, Basis as Boolean. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,0.1,1,TRUE)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,0.1,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case:  Number(4), Boolean. Dates as number, Rate as number, Per as number, Basis as Boolean. 5 of 5 arguments used.');
		// Case #4: Number, Boolean, Number(2). Issue as number, Settlement as Boolean, Rate as number, Per as number. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,FALSE,0.1,1)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,FALSE,0.1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(2). Issue as number, Settlement as Boolean, Rate as number, Per as number. 4 of 5 arguments used.');
		// Case #5: Boolean, Number(3). Issue as Boolean, Settlement as number, Rate as number, Per as number. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(TRUE,38838,0.1,1)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(TRUE,38838,0.1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(3). Issue as Boolean, Settlement as number, Rate as number, Per as number. 4 of 5 arguments used.');
		// Case #6: Empty, Number(3). Issue is empty. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(,"05/20/2020",1500,0.1)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(,"05/20/2020",1500,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(3). Issue is empty. 4 of 5 arguments used.');
		// Case #7: Number, Empty, Number(2). Settlement is empty. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,,0.5,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,,0.5,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number(2). Settlement is empty. 4 of 5 arguments used.');
		// Case #8: Number(2),Empty,Number. Rate is empty. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2),Empty,Number. Rate is empty. 4 of 5 arguments used.');
		// Case #9: Number(4). Issue and Settlement are zero date. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(0;0;0,1;1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(0;0;0,1;1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Issue and Settlement are zero date. 4 of 5 arguments used.');
		// Case #10: Number(4). Settlement is zero date, issue >= settlement. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,0,0.1,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,0,0.1,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement is zero date, issue >= settlement. 4 of 5 arguments used.');
		// Case #11: Formula(2), Number(2). Issue >= settlement. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(DATE(2025,6,27),DATE(2025,5,27),0.5,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(DATE(2025,6,27),DATE(2025,5,27),0.5,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(2). Issue >= settlement. 4 of 5 arguments used.');
		// Case #12: String, Formula, Number(2). Issue is incorrect date. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("13/01/2025", DATE(2026,10,1),0.5,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("13/01/2025", DATE(2026,10,1),0.5,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Formula, Number(2). Issue is incorrect date. 4 of 5 arguments used.');
		// Case #13: Formula, String, Number(2). Settlement is incorrect date. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(DATE(2025,12,1),"13/01/2025",0.5,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(DATE(2025,12,1),"13/01/2025",0.5,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula, String, Number(2). Settlement is incorrect date. 4 of 5 arguments used.');
		// Case #14: Number(4). Rate is negative number. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838, -1,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838, -1,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Rate is negative number. 4 of 5 arguments used.');
		// Case #15: Number(4). Per is negative number. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,0.5,-1)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,0.5,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Per is negative number. 4 of 5 arguments used.');
		// Case #16. Number(5). Basis is out of allowed numbers - -1. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,0.5,1500,-1)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,0.5,1500,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Basis is out of allowed numbers - -1. 5 of 5 arguments used.');
		// Case #17. Number(5). Basis is out of allowed diapason of numbers - 5. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,0.5,1500,5)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,0.5,1500,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Basis is out of allowed diapason of numbers - 5. 5 of 5 arguments used.');
		// Case #18: String(4). Issue is empty string. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("","05/20/2025","1.5","1000")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("","05/20/2025","1.5","1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Issue is empty string. 4 of 5 arguments used.');
		// Case #19: String(4). Issue has text string. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("Str","05/20/2025","1.5","1000")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("Str","05/20/2025","1.5","1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Issue has text string. 4 of 5 arguments used.');
		// Case #20: String(4). Settlement is empty string. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("05/20/2025","","1","1000")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("05/20/2025","","1","1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Settlement is empty string. 4 of 5 arguments used.');
		// Case #21: String(4). Settlement has text string. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("05/20/2025","Str","1","1000")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("05/20/2025","Str","1","1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Settlement has text string. 4 of 5 arguments used.');
		// Case #22: String(3), Empty. Rate is empty string. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("05/20/2025","06/20/2025","",)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("05/20/2025","06/20/2025","",) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case:  String(3), Empty. Rate is empty string. 4 of 5 arguments used.');
		// Case #23: String(3), Empty. Rate has text string. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("05/20/2025","06/20/2025","Str",)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("05/20/2025","06/20/2025","Str",) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3), Empty. Rate has text string. 4 of 5 arguments used.');
		// Case #24: String(4). Per is empty string. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("05/20/2025","06/20/2025","1","")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("05/20/2025","06/20/2025","1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Per is empty string. 4 of 5 arguments used.');
		// Case #25: String(4). Per has text string. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("05/20/2025","06/20/2025","1","Str")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("05/20/2025","06/20/2025","1","Str") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Per has text string. 4 of 5 arguments used.');
		// Case #26: String(5). Basis is empty string. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("05/20/2025","06/20/2025","1","1000","")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("05/20/2025","06/20/2025","1","1000","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Basis is empty string. 5 of 5 arguments used.');
		// Case #27: String(5). Basis has text string. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM("05/20/2025","06/20/2025","1","1000","Str")', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM("05/20/2025","06/20/2025","1","1000","Str") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Basis has text string. 5 of 5 arguments used.');
		// Case #28: Number(4). Rate is 0. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,0,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,0,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Rate is 0. 4 of 5 arguments used.');
		// Case #29: Number(4). Per is 0. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,0.5,0)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,0.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Per is 0. 4 of 5 arguments used.');
		// Case #30: Formula(2), Number(2). Issue maximum unaccepted date. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(DATE(9999,12,31)+1,DATE(9999,12,31),1,1000)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(DATE(9999,12,31)+1,DATE(9999,12,31),1,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(2). Issue maximum unaccepted date. 4 of 5 arguments used.');
		// Case #31: Formula(2), Number(2). Settlement maximum unaccepted date. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(DATE(9999,12,30),DATE(9999,12,32),1,1000)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(DATE(9999,12,31),DATE(9999,12,32),1,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(2). Settlement maximum unaccepted date. 4 of 5 arguments used.');
		// Case #32: Number(4). Rate maximum unaccepted date. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,1E+308,10)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,1E+308,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Rate maximum unaccepted date. 4 of 5 arguments used.');
		// Case #33: Number(4). Per maximum unaccepted date. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,10,9.99999999999999E+307)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,10,9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Per maximum unaccepted date. 4 of 5 arguments used.');
		// Case #34: Array, Number(3). Issue is array with unexpected data. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM({TRUE},38838,1,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM({TRUE},38838,1,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Number(3). Issue is array with unexpected data. 4 of 5 arguments used.');
		// Case #35: Area, Number(3). Issue is area with unexpected data. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(A110:A111,38838,1,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(A110:A111,38838,1,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case:Area, Number(3). Issue is area with unexpected data. 4 of 5 arguments used.');
		// Case #36: Number, Array, Number(2). Settlement is array with unexpected data. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,{TRUE},1,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,{TRUE},1,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Array, Number(2). Settlement is array with unexpected data. 4 of 5 arguments used.');
		// Case #37: Number, Area, Number(2). Settlement is area with unexpected data. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,A110:A111,1,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,A110:A111,1,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(2). Settlement is area with unexpected data. 4 of 5 arguments used.');
		// Case #38: Number(2), Array, Number. Rate is array with unexpected data. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,{FALSE},1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,{FALSE},1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Array, Number. Rate is array with unexpected data. 4 of 5 arguments used.');
		// Case #39: Number(2), Area, Number. Rate is area with unexpected data. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,A110:A111,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,A110:A111,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number. Rate is area with unexpected data. 4 of 5 arguments used.');
		// Case #40: Number(3), Array. Per is array with unexpected data. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,1,{TRUE})', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,1,{TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Array. Per is array with unexpected data. 4 of 5 arguments used.');
		// Case #41: Number(3), Area. Per is area with unexpected data. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,1,A110:A111)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,1,A110:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Array. Per is array with unexpected data. 4 of 5 arguments used.');
		// Case #42: Number(4), Array. Basis is array with unexpected data. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,1,1500,{FALSE})', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,1,1500,{FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Array. Basis is array with unexpected data. 5 of 5 arguments used.');
		// Case #43: Number(4), Area. Basis is area with unexpected data. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,1,1500,A110:A111)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(38777,38838,1,1500,A110:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Area. Basis is area with unexpected data. 5 of 5 arguments used.');
		// Case #44: Area3D, Number(3). Issue is Area3D. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(Sheet2!A5:A6,38838,1,15000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(Sheet2!A5:A6,38838,1,15000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number(3). Issue is Area3D. 4 of 5 arguments used.');
		// Different result with MS TODO Need to fix. Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bug #1
		/*// Case #45: Number, Area3D, Number(2). Settlement is Area3D. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,Sheet2!A1:B1,1,15000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,Sheet2!A1:B1,1,15000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D, Number(2). Settlement is Area3D. 4 of 5 arguments used.');
		// Case #46: Number(2), Area3D, Number. Rate is Area3D. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,Sheet2!A1:A2,15000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,Sheet2!A1:B1,15000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area3D, Number. Rate is Area3D. 4 of 5 arguments used.');*/
		// Case #47: Number(3), Area3D. Par is Area3D. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,1,Sheet2!B1:C1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,1,Sheet2!B1:C1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area3D. Par is Area3D. 4 of 5 arguments used.');
		// Case #48: Number(4), Area3D. Basis ia Area3D. 5 of 5 agruments
		oParser = new parserFormula('ACCRINTM(38777,38838,1,15000; Sheet2!B2:C2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,1,15000; Sheet2!B2:C2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Area3D. Basis ia Area3D. 5 of 5 agruments');
		// Different result with MS TODO Need to fix. Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bug #1
		// Case #49: Name, Number(3). Issue is Name  with Area. 4 of 5 arguments used.
		/*oParser = new parserFormula('ACCRINTM(NameAreaBug,38838,1,15000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(NameAreaBug,38838,1,15000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number(3). Issue is Name  with Area. 4 of 5 arguments used.');*/
		// Case #50: Number, Name, Number(2). Settlement is Name with Area. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,NameArea,1,15000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,NameArea,1,15000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name, Number(2). Settlement is Name with Area. 4 of 5 arguments used.');
		// Case #51: Number(2), Name, Number. Rate is Name with Area. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,NameArea,15000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,NameArea,15000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Name, Number. Rate is Name with Area. 4 of 5 arguments used.');
		// Case #52: Number(3),Name. Par is Name with Area. 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,1,NameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,1,NameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3),Name. Par is Name with Area. 4 of 5 arguments used.');
		// Case #53: Number(4),Name. Basis is Name with Area. 5 of 5 agruments used.
		oParser = new parserFormula('ACCRINTM(38777,38838,1,15000,NameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(38777,38838,1,15000,NameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4),Name. Basis is Name with Area. 5 of 5 agruments used.');
		// Case #54: Table. All arguments in table with 2 columns. 5 of 5 arguments used.
		getTableType(599, 0, 601, 4);
		oParser = new parserFormula('ACCRINTM(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. All arguments in table with 2 columns. 5 of 5 arguments used.');

		// Bounded cases:
		// Case #2: Number(5). All arguments are minimum accepted value. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(1,2,1E-152,1E-152,0)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(1,2,1E-152,1E-152,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.7777777777777786e-307, 'Test: Bounded case: Number(5). All arguments are minimum accepted value. 5 of 5 arguments used.');
		// Case #3: Formula(2), Number(3). All arguments are maximum accepted value. 5 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(DATE(9999,12,30);DATE(9999,12,31),1E+152,1E+152,4)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: Formula ACCRINTM(DATE(9999,12,30);DATE(9999,12,31),1E+152,1E+152,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Formula(2), Number(3). All arguments are maximum accepted value. 5 of 5 arguments used.');

		// Need to fix:
		// Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs #3
		// Different result with MS and LO
		// Case #1: Number, String, Number(2). Issue is zero date(minimum accepted value). 4 of 5 arguments used.
		oParser = new parserFormula('ACCRINTM(0,"12/12/2000",0.1,1500)', "A2", ws);
		assert.ok(oParser.parse(), 'Test: ACCRINTM(0,"12/12/2000",0.1,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 15130.000, 'Test: Need to fix: Number, String, Number(2). Issue is zero date (minimum accepted value). 4 of 5 arguments used.'); // 15142.5

		testArrayFormula2(assert, "ACCRINTM", 4, 5, true)
		// Clean define name
		wb.delDefinesNames(defName);
		wb.delDefinesNames(defName3D);
		wb.delDefinesNames(defName2);
		wb.delDefinesNames(defName3D2);
		wb.delDefinesNames(defName3);
		wb.delDefinesNames(defName3D3);
		wb.delDefinesNames(defName4);
		wb.delDefinesNames(defName3D4);
		wb.delDefinesNames(defName5);
		wb.delDefinesNames(defName3D5);
		wb.delDefinesNames(defNameArea);
		wb.delDefinesNames(defNameAreaBug);
	});

	QUnit.test("Test: \"AMORDEGRC\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2400");
		ws.getRange2("A101").setValue("39679");
		ws.getRange2("A102").setValue("39813");
		ws.getRange2("A103").setValue("300");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("0.15");
		ws.getRange2("A106").setValue("1");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 6);
		ws.getRange2("A601").setValue("2400"); // Column1
		ws.getRange2("B601").setValue("39679"); // Column2
		ws.getRange2("C601").setValue("39813"); // Column3
		ws.getRange2("D601").setValue("300"); // Column4
		ws.getRange2("E601").setValue("1"); // Column5
		ws.getRange2("F601").setValue("0.15"); // Column6
		ws.getRange2("G601").setValue("1"); // Column7
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("2400");
		ws2.getRange2("A2").setValue("39679");
		ws2.getRange2("A3").setValue("39813");
		ws2.getRange2("A4").setValue("300");
		ws2.getRange2("A5").setValue("1");
		ws2.getRange2("A6").setValue("0.15");
		ws2.getRange2("A7").setValue("1");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("39679"); // TestName
		ws.getRange2("A202").setValue("0.3"); // TestName1
		ws.getRange2("A203").setValue("39813"); // TestName2
		ws.getRange2("A204").setValue("300"); // TestName3
		ws.getRange2("A205").setValue("3"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("39679") // TestName3D
		ws2.getRange2("A12").setValue("0.3") // TestName3D1
		ws2.getRange2("A13").setValue("39813") // TestName3D2
		ws2.getRange2("A14").setValue("300") // TestName3D3
		ws2.getRange2("A15").setValue("3") // TestName3D4

		// Positive cases:

		// Case #1: Number, Formula(2), Number(4). Standard expected input data. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Number, Formula(2), Number(4). Standard expected input data. 7 of 7 arguments used.');
		// Case #2: Number, Formula(2), Number(4). Standard expected input data. Rate had different value (0.20). 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Link to https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#19
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.20,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.20,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 819, 'Test: Positive case: Number, Formula(2), Number(4). Standard expected input data. Rate had different value (0.20). 7 of 7 arguments used.'); // Must be 820
		// Case #3: Number, Formula(2), Number(4). Standard expected input data. Rate had different value (0.33). 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Link to https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#19
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.33,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.33,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 972, 'Test: Positive case: Number, Formula(2), Number(4). Standard expected input data. Rate had different value (0.33). 7 of 7 arguments used.'); // Must be 973
		// Case #4: Number, Formula(2), Number(3). Basis omitted, defaults to 0. 6 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Number, Formula(2), Number(3). Basis omitted, defaults to 0. 6 of 7 arguments used.');
		// Case #5: Number(7). Dates represented as serial numbers. Basis - 0 (US 30/360). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,39679,39813,300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,39679,39813,300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Number(7). Dates represented as serial numbers. Basis - 0 (US 30/360). 7 of 7 arguments used.');
		// Case #6: String(2), Number(5). Cost and date_purchased as strings convertible to numbers. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC("2400","39679",39813,300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC("2400","39679",39813,300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: String(2), Number(5). Cost and date_purchased as strings convertible to numbers. 7 of 7 arguments used.');
		// Case #7: String(4), Number(3). First 4 arguments as strings convertible to numbers. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC("2400","39679","39813","300",1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC("2400","39679","39813","300",1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: String(4), Number(3). First 4 arguments as strings convertible to numbers. 7 of 7 arguments used.');
		// Case #8: Formula(2), Number(5). Cost and date_purchased as formulas returning numbers. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(SUM(1200,1200),DATE(2008,8,19),39813,300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(SUM(1200,1200),DATE(2008,8,19),39813,300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Formula(2), Number(5). Cost and date_purchased as formulas returning numbers. 7 of 7 arguments used.');
		// Case #9: Number(5), Formula(2). Rate and basis as formulas returning numbers. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,39679,39813,300,1,ROUND(0.15,2),INT(0.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,39679,39813,300,1,ROUND(0.15,2),INT(0.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Number(5), Formula(2). Rate and basis as formulas returning numbers. 7 of 7 arguments used.');
		// Case #10: Reference link(7). All arguments as reference links. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(A100,A101,A102,A103,A104,A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(A100,A101,A102,A103,A104,A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Reference link(7). All arguments as reference links. 7 of 7 arguments used.');
		// Case #11: Area(7). All arguments as single-cell areas. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Area(7). All arguments as single-cell areas. 7 of 7 arguments used.');
		// Case #12: Array(7). All arguments as single-element arrays. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC({2400},{39679},{39813},{300},{1},{0.15},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC({2400},{39679},{39813},{300},{1},{0.15},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Array(7). All arguments as single-element arrays. 7 of 7 arguments used.');
		// Case #13: Name(7). All arguments as named ranges. 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Link to https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#19
		oParser = new parserFormula('AMORDEGRC(TestName,TestName,TestName2,TestName3,TestName4,TestName1,TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(TestName,TestName,TestName2,TestName3,TestName4,TestName1,TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4509, 'Test: Positive case: Name(7). All arguments as named ranges. 7 of 7 arguments used.'); // Must be 9109
		// Case #14: Name3D(7). All arguments as 3D named ranges. 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Link to https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#19
		oParser = new parserFormula('AMORDEGRC(TestName3D,TestName3D,TestName3D2,TestName3D3,TestName3D4,TestName3D1,TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(TestName3D,TestName3D,TestName3D2,TestName3D3,TestName3D4,TestName3D1,TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4509, 'Test: Positive case: Name3D(7). All arguments as 3D named ranges. 7 of 7 arguments used.'); // Must be 9109
		// Case #15: Ref3D(7). All arguments as 3D references. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Ref3D(7). All arguments as 3D references. 7 of 7 arguments used.');
		// Case #16: Area3D(7). All arguments as 3D single-cell areas. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Area3D(7). All arguments as 3D single-cell areas. 7 of 7 arguments used.');
		// Case #17: Table(7). All arguments as table references. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6],Table1[Column7])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6],Table1[Column7]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Table(7). All arguments as table references. 7 of 7 arguments used.');
		// Case #18: Number, Formula(2), Number(4). Period = 2, basis = 3 (European 30/360). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,2,0.15,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,2,0.15,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 485, 'Test: Positive case: Number, Formula(2), Number(4). Period = 2, basis = 3 (European 30/360). 7 of 7 arguments used.');
		// Case #19: Number, Formula(2), Number(4). Period = 3, basis = 3 (Actual/365). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,3,0.15,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,3,0.15,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 303, 'Test: Positive case: Number, Formula(2), Number(4). Period = 3, basis = 3 (Actual/365). 7 of 7 arguments used.');
		// Case #20: Number, Formula(2), Number(4). Period = 4, basis = 4 (European 30/360). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,4,0.15,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,4,0.15,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 190, 'Test: Positive case: Number, Formula(2), Number(4). Period = 4, basis = 4 (European 30/360). 7 of 7 arguments used.');
		// Case #21: Number, Formula(2), Number(4). Higher rate (25%), larger cost value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(10000,DATE(2012,1,1),DATE(2012,12,31),1000,1,0.25,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(10000,DATE(2012,1,1),DATE(2012,12,31),1000,1,0.25,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2344, 'Test: Positive case: Number, Formula(2), Number(4). Higher rate (25%), larger cost value. 7 of 7 arguments used.');
		// Case #22: Formula. AMORDEGRC used inside SUM formula. 7 of 7 arguments used.
		oParser = new parserFormula('SUM(AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 876, 'Test: Positive case: Formula. AMORDEGRC used inside SUM formula. 7 of 7 arguments used.');
		// Case #23: Number(7). All numeric arguments with decimal values (will be rounded or truncated as needed). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400.5,39679.25,39813.75,300.5,1.9,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400.5,39679.25,39813.75,300.5,1.9,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Number(7). All numeric arguments with decimal values (will be rounded or truncated as needed). 7 of 7 arguments used.');
		// Case #24: Number(6), Empty. Basis argument empty (defaults to 0). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,39679,39813,300,1,0.15,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,39679,39813,300,1,0.15,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Number(6), Empty. Basis argument empty (defaults to 0). 7 of 7 arguments used.');
		// Case #27: Number, Formula(2), Number(4). Large gap between purchase date and first period date. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2020,12,31),300,10,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2020,12,31),300,10,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Formula(2), Number(4). Large gap between purchase date and first period date. 7 of 7 arguments used.');
		// Case #28: Formula(4), Number(3). First 4 arguments as formulas returning valid values. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(ROUND(2400,0),DATEVALUE("2008-08-19"),DATEVALUE("2008-12-31"),ROUND(300,0),1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(ROUND(2400,0),DATEVALUE("2008-08-19"),DATEVALUE("2008-12-31"),ROUND(300,0),1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Formula(4), Number(3). First 4 arguments as formulas returning valid values. 7 of 7 arguments used.');
		// Case #29: String(4), Formula(3). Mixed string and formula arguments. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC("2400","08/19/2008","12/31/2008","300",INT(1.9),ROUND(0.15,2),INT(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC("2400","08/19/2008","12/31/2008","300",INT(1.9),ROUND(0.15,2),INT(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: String(4), Formula(3). Mixed string and formula arguments. 7 of 7 arguments used.');
		// Case #30: Number, Formula(2), Number(4). Salvage value is 0 (complete depreciation). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),0,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),0,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Number, Formula(2), Number(4). Salvage value is 0 (complete depreciation). 7 of 7 arguments used.');
		// Case #31: Number, Formula(2), Number(4). Salvage value close to cost (minimal depreciation). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),2399,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),2399,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 900, 'Test: Positive case: Number, Formula(2), Number(4). Salvage value close to cost (minimal depreciation). 7 of 7 arguments used.');
		// Case #32: Number, Formula(2), Number(4). Period is 0 (first period). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,0,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,0,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 330, 'Test: Positive case: Number, Formula(2), Number(4). Period is 0 (first period). 7 of 7 arguments used.');
		// Case #33: Array, Formula(2), Number(4). Cost as multi-element array. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC({2400,2500},DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC({2400,2500},DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Array, Formula(2), Number(4). Cost as multi-element array. 7 of 7 arguments used.');
		// Case #34: Number, Array, Formula, Number(4). Date_purchased as multi-element array. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,{"08/19/2008","09/19/2008"},DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,{"08/19/2008","09/19/2008"},DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 776, 'Test: Positive case: Number, Array, Formula, Number(4). Date_purchased as multi-element array. 7 of 7 arguments used.');

		// Negative cases:

		// Case #1: Number, Formula(2), Number(4). Rate is not correct. 7 of 7 arguments used. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.50,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.50,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Rate is not correct. 7 of 7 arguments used. 7 of 7 arguments used.');
		// Case #1(2): Empty, Formula(2), Number(4). Cost argument is missing. 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#20
		/*oParser = new parserFormula('AMORDEGRC(,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Formula(2), Number(4). Cost argument is missing. 7 of 7 arguments used.');
		// Case #2: Number, Empty, Formula, Number(4). Date_purchased argument is missing. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,,DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,,DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Formula, Number(4). Date_purchased argument is missing. 7 of 7 arguments used.');
		// Case #3: Number, Formula, Empty, Number(4). First_period argument is missing. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),,300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),,300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Formula, Empty, Number(4). First_period argument is missing. 7 of 7 arguments used.');
		// Case #4: Number, Formula(2), Empty, Number(3). Salvage argument is missing. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Formula(2), Empty, Number(3). Salvage argument is missing. 7 of 7 arguments used.');
		// Case #5: Number, Formula(2), Number, Empty, Number(2). Period argument is missing. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Formula(2), Number, Empty, Number(2). Period argument is missing. 7 of 7 arguments used.');
		// Case #6: Number, Formula(2), Number(2), Empty, Number. Rate argument is missing. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Formula(2), Number(2), Empty, Number. Rate argument is missing. 7 of 7 arguments used.');*/
		// Case #7: Number, Formula(2), Number(4). Negative cost value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(-2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(-2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Negative cost value. 7 of 7 arguments used.');
		// Case #8: Number, Formula(2), Number(4). Negative salvage value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),-300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),-300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Negative salvage value. 7 of 7 arguments used.');
		// Case #9: Number, Formula(2), Number(4). Negative period value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,-1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,-1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Negative period value. 7 of 7 arguments used.');
		// Case #10: Number, Formula(2), Number(4). Negative rate value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,-0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,-0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Negative rate value. 7 of 7 arguments used.');
		// Case #11: Number, Formula(2), Number(4). Negative basis value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Negative basis value. 7 of 7 arguments used.');
		// Case #12: Number, Formula(2), Number(4). Basis value out of range (0-4). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Basis value out of range (0-4). 7 of 7 arguments used.');
		// Case #13: Number, Formula(2), Number(4). First_period earlier than date_purchased.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,12,31),DATE(2008,8,19),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,12,31),DATE(2008,8,19),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). First_period earlier than date_purchased.');
		// Case #14: Number, Formula(2), Number(4). Salvage value greater than cost. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),2500,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),2500,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Salvage value greater than cost. 7 of 7 arguments used.');
		// Case #15: String,  Formula(2), Number(4). Cost as non-numeric string. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC("text",DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC("text",DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,  Formula(2), Number(4). Cost as non-numeric string. 7 of 7 arguments used.');
		// Case #16: Number, String, Number(5). Date_purchased as non-date string. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,"text",DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,"text",DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(5). Date_purchased as non-date string. 7 of 7 arguments used.');
		// Case #17: Number, Formula, String, Number(4). First_period as non-date string. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),"text",300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),"text",300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula, String, Number(4). First_period as non-date string. 7 of 7 arguments used.');
		// Case #18: Number, Formula(2), String, Number(3). Salvage as non-numeric string. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),"text",1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),"text",1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula(2), String, Number(3). Salvage as non-numeric string. 7 of 7 arguments used.');
		// Case #19: Number, Formula(2), Number, String, Number(2). Period as non-numeric string. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,"text",0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,"text",0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula(2), Number, String, Number(2). Period as non-numeric string. 7 of 7 arguments used.');
		// Case #20: Number, Formula(2), Number(2), String, Number. Rate as non-numeric string. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,"text",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,"text",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula(2), Number(2), String, Number. Rate as non-numeric string. 7 of 7 arguments used.');
		// Case #21: Number, Formula(2), Number(3), String. Basis as non-numeric string. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula(2), Number(3), String. Basis as non-numeric string. 7 of 7 arguments used.');
		// Case #22: Error, Formula(2), Number(4). Cost as error value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(NA(),DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(NA(),DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Formula(2), Number(4). Cost as error value. 7 of 7 arguments used.');
		// Case #23: Number, Error, Formula, Number(4). Date_purchased as error value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,NA(),DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,NA(),DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Formula, Number(4). Date_purchased as error value. 7 of 7 arguments used.');
		// Case #24: Number, Formula, Error, Number(4). First_period as error value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),NA(),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),NA(),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Formula, Error, Number(4). First_period as error value. 7 of 7 arguments used.');
		// Case #25: Area, Formula(2), Number(4). Cost as multi-cell area. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(A100:A101,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(A100:A101,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Formula(2), Number(4). Cost as multi-cell area. 7 of 7 arguments used.');
		// Case #26: Number, Formula,Area, Number(4). First_period as multi-cell area. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),A101:A102,300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),A101:A102,300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula,Area, Number(4). First_period as multi-cell area. 7 of 7 arguments used.');
		// Case #27: Number, Area, Formula, Number(4). Date_purchased as multi-cell area. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,A101:A102,DATE(2008,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,A101:A102,DATE(2008,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Formula, Number(4). Date_purchased as multi-cell area. 7 of 7 arguments used.');
		// Case #28: Number, Formula(2), Area, Number(3). Salvage as multi-cell area. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),A103:A104,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),A103:A104,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula(2), Area, Number(3). Salvage as multi-cell area. 7 of 7 arguments used.');
		// Case #29: Number, Formula(2), Number(4). Zero cost value. 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#24
		/*oParser = new parserFormula('AMORDEGRC(0,DATE(2008,8,19),DATE(2008,12,31),0,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(0,DATE(2008,8,19),DATE(2008,12,31),0,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Zero cost value. 7 of 7 arguments used.');*/
		// Case #30: Number, Formula(2), Number(4). Zero rate value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(4). Zero rate value. 7 of 7 arguments used.');
		// Case #31: Table(7). Table with 2 rows. 7 of 7 argumenrs used.
		getTableType(599, 0, 601, 6);
		oParser = new parserFormula('AMORDEGRC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6],Table1[Column7])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6],Table1[Column7]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table(7). Table with 2 rows. 7 of 7 argumenrs used.');

		// Bounded cases:

		// Case #1: Number, Formula(2), Number(4). Minimum positive values for numeric arguments, earliest dates. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(0.000000001,DATE(1900,1,1),DATE(1900,1,2),0,0,0.000000001,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(0.000000001,DATE(1900,1,1),DATE(1900,1,2),0,0,0.000000001,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Formula(2), Number(4). Minimum positive values for numeric arguments, earliest dates. 7 of 7 arguments used.');
		// Case #2: Number, Formula(2), Number(4). Maximum numeric values, latest valid dates. 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#25
		/*oParser = new parserFormula('AMORDEGRC(9.99999E+307,DATE(9999,12,30),DATE(9999,12,31),1,1,0.49,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(9.99999E+307,DATE(9999,12,30),DATE(9999,12,31),1,1,0.49,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9477e+307, 'Test: Bounded case: Number, Formula(2), Number(4). Maximum numeric values, latest valid dates. 7 of 7 arguments used.');
		*/// Case #3: Number, Formula(2), Number(4). Minimum rate that produces non-zero depreciation). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,1E-307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,1E-307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Formula(2), Number(4). Minimum rate that produces non-zero depreciation). 7 of 7 arguments used.');
		// Case #4: Number, Formula(2), Number(4). Maximum common rate value (49%). 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#25
		/*oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.49,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.49,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 877, 'Test: Bounded case: Number, Formula(2), Number(4). Maximum common rate value (49%). 7 of 7 arguments used.');*/
		// Case #5: Number, Formula(2), Number(4). Minimum time between date_purchased and first_period (1 day). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,8,20),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,8,20),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 899, 'Test: Bounded case: Number, Formula(2), Number(4). Minimum time between date_purchased and first_period (1 day). 7 of 7 arguments used.');
		// Case #6: Number, Formula(2), Number(4). Salvage value approaches cost. 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),2399.999,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),2399.999,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 900, 'Test: Bounded case: Number, Formula(2), Number(4). Salvage value approaches cost. 7 of 7 arguments used.');
		// Case #7: Number, Formula(2), Number(4). High period number (past normal life). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,20,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,20,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Formula(2), Number(4). High period number (past normal life). 7 of 7 arguments used.');
		// Case #8: Number, Formula(2), Number(4). High rate value (49.9%) just below threshold where formula behavior changes. 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#25
		/*oParser = new parserFormula('AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.499,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.499,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 871, 'Test: Bounded case: Number, Formula(2), Number(4). High rate value (49.9%) just below threshold where formula behavior changes. 7 of 7 arguments used.');*/
		// Case #9: Number, Formula(2), Number(4). Earliest valid date (1900-01-01). 7 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#19
		/*oParser = new parserFormula('AMORDEGRC(2400,DATE(1900,1,1),DATE(1900,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(1900,1,1),DATE(1900,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 563, 'Test: Bounded case: Number, Formula(2), Number(4). Earliest valid date (1900-01-01). 7 of 7 arguments used.');
		*/// Case #10: Number, Formula(2), Number(4). Latest valid date (9999-12-31). 7 of 7 arguments used.
		oParser = new parserFormula('AMORDEGRC(2400,DATE(9999,12,30),DATE(9999,12,31),300,1,0.15,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORDEGRC(2400,DATE(9999,12,30),DATE(9999,12,31),300,1,0.15,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 563, 'Test: Bounded case: Number, Formula(2), Number(4). Latest valid date (9999-12-31). 7 of 7 arguments used.');

		testArrayFormula2(assert, "AMORDEGRC", 6, 7, true);
	});

	QUnit.test("Test: \"AMORLINC\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2400");
		ws.getRange2("A101").setValue("39679");
		ws.getRange2("A102").setValue("39813");
		ws.getRange2("A103").setValue("300");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("0.15");
		ws.getRange2("A106").setValue("1");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 6);
		ws.getRange2("A601").setValue("2400"); // Column1
		ws.getRange2("B601").setValue("39679"); // Column2
		ws.getRange2("C601").setValue("39813"); // Column3
		ws.getRange2("D601").setValue("300"); // Column4
		ws.getRange2("E601").setValue("1"); // Column5
		ws.getRange2("F601").setValue("0.15"); // Column6
		ws.getRange2("G601").setValue("1"); // Column7
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("2400");
		ws2.getRange2("A2").setValue("39679");
		ws2.getRange2("A3").setValue("39813");
		ws2.getRange2("A4").setValue("300");
		ws2.getRange2("A5").setValue("1");
		ws2.getRange2("A6").setValue("0.15");
		ws2.getRange2("A7").setValue("1");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("39679"); // TestName
		ws.getRange2("A202").setValue("39813"); // TestName1
		ws.getRange2("A203").setValue("300"); // TestName2
		ws.getRange2("A204").setValue("0.15"); // TestName3
		ws.getRange2("A205").setValue("1"); // TestName4
		ws.getRange2("A206").setValue("2400"); // TestNameArea
		ws.getRange2("A207").setValue("150000"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("39679") // TestName3D
		ws2.getRange2("A12").setValue("39813") // TestName3D1
		ws2.getRange2("A13").setValue("300") // TestName3D2
		ws2.getRange2("A14").setValue("0.15") // TestName3D3
		ws2.getRange2("A15").setValue("1") // TestName3D4

		// Positive cases:

		// Case #1: Number, Formula(2), Number(4). Basic example. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.15,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Number, Formula(2), Number(4). Basic example. 7 of 7 arguments used.');
		// Case #2: Number, Formula(2), Number(4). Rate is 0.70. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.70,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(2400,DATE(2008,8,19),DATE(2008,12,31),300,1,0.70,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 1484.918033, 'Test: Positive case: Number, Formula(2), Number(4). Rate is 0.70. 7 of 7 arguments used.');
		// Case #3: Number, Formula(2), Number(3). All required arguments. Optional basis argument omitted. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3). All required arguments. Optional basis argument omitted. 6 of 7 arguments used.');
		// Case #4: Number, Formula(2), Number(3), Number. All arguments with basis = 0 (30/360 day basis). 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3), Number. All arguments with basis = 0 (30/360 day basis). 7 of 7 arguments used.');
		// Case #5: Number, Formula(2), Number(3), Number. All arguments with basis = 1 (Actual/actual day basis). 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3), Number. All arguments with basis = 1 (Actual/actual day basis). 7 of 7 arguments used.');
		// Case #6: Number, Formula(2), Number(3), Number. All arguments with basis = 3 (Actual/365 day basis). 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3), Number. All arguments with basis = 3 (Actual/365 day basis). 7 of 7 arguments used.');
		// Case #7: Number, Formula(2), Number(3), Number. All arguments with basis = 4 (European 30/360 day basis). 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3), Number. All arguments with basis = 4 (European 30/360 day basis). 7 of 7 arguments used.');
		// Case #8: String, Formula(2), String(3). Numeric strings converted to numbers. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC("150000", DATE(2008,8,1), DATE(2008,12,31), "15000", "1", "0.2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC("150000", DATE(2008,8,1), DATE(2008,12,31), "15000", "1", "0.2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: String, Formula(2), String(3). Numeric strings converted to numbers. 6 of 7 arguments used.');
		// Case #9: Formula(6). Formula expressions for all numeric arguments. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(SUM(100000,50000), DATE(2008,8,1), DATE(2008,12,31), 15000*0.1, ROUND(0.8,0), 20/100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(SUM(100000,50000), DATE(2008,8,1), DATE(2008,12,31), 15000*0.1, ROUND(0.8,0), 20/100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Formula(6). Formula expressions for all numeric arguments. 6 of 7 arguments used.');
		// Case #10: Number, String(2), Number(3). Dates provided as strings. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, "8/1/2008", "12/31/2008", 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, "8/1/2008", "12/31/2008", 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, String(2), Number(3). Dates provided as strings. 6 of 7 arguments used.');
		// Case #11: Number, Formula(2), Number, Formula(2). Nested IF formulas for period and rate. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, IF(TRUE,1,2), IF(TRUE,0.2,0.3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, IF(TRUE,1,2), IF(TRUE,0.2,0.3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number, Formula(2). Nested IF formulas for period and rate. 6 of 7 arguments used.');
		// Case #12: Reference link(7). All arguments as reference links. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(A100, A101, A102, A103, A104, A105, A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(A100, A101, A102, A103, A104, A105, A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Reference link(7). All arguments as reference links. 7 of 7 arguments used.');
		// Case #13: Reference link(6), Number. Reference links with explicit basis. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(A100, A101, A102, A103, A104, A105, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(A100, A101, A102, A103, A104, A105, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Reference link(6), Number. Reference links with explicit basis. 7 of 7 arguments used.');
		// Case #14: Area(7). All arguments as single-cell areas. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(A100:A100, A101:A101, A102:A102, A103:A103, A104:A104, A105:A105, A106:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(A100:A100, A101:A101, A102:A102, A103:A103, A104:A104, A105:A105, A106:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Area(7). All arguments as single-cell areas. 7 of 7 arguments used.');
		// Case #15: Array(7). All arguments as single-element arrays. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC({150000}, {38961}, {39782}, {15000}, {1}, {0.2}, {0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC({150000}, {38961}, {39782}, {15000}, {1}, {0.2}, {0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Array(7). All arguments as single-element arrays. 7 of 7 arguments used.');
		// Case #16: Name(7). All arguments as named ranges. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(TestName, TestName, TestName1, TestName2, TestName4, TestName3, TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(TestName, TestName, TestName1, TestName2, TestName4, TestName3, TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 5951.85, 'Test: Positive case: Name(7). All arguments as named ranges. 7 of 7 arguments used.');
		// Case #17: Name3D(7). All arguments as 3D named ranges. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(TestName3D, TestName3D, TestName3D1, TestName3D2, TestName3D4, TestName3D3, TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(TestName3D, TestName3D, TestName3D1, TestName3D2, TestName3D4, TestName3D3, TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 5951.85, 'Test: Positive case: Name3D(7). All arguments as 3D named ranges. 7 of 7 arguments used.');
		// Case #18: Ref3D(7). All arguments as 3D references. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(Sheet2!A1, Sheet2!A2, Sheet2!A3, Sheet2!A4, Sheet2!A5, Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(Sheet2!A1, Sheet2!A2, Sheet2!A3, Sheet2!A4, Sheet2!A5, Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Ref3D(7). All arguments as 3D references. 6 of 7 arguments used.');
		// Case #19: Area3D(7). All arguments as 3D single-cell areas. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(Sheet2!A1:A1, Sheet2!A2:A2, Sheet2!A3:A3, Sheet2!A4:A4, Sheet2!A5:A5, Sheet2!A6:A6, Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(Sheet2!A1:A1, Sheet2!A2:A2, Sheet2!A3:A3, Sheet2!A4:A4, Sheet2!A5:A5, Sheet2!A6:A6, Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Area3D(7). All arguments as 3D single-cell areas. 7 of 7 arguments used.');
		// Case #20: Table(7). All arguments as table references. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(Table1[Column1], Table1[Column2], Table1[Column3], Table1[Column4], Table1[Column5], Table1[Column6], Table1[Column7])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(Table1[Column1], Table1[Column2], Table1[Column3], Table1[Column4], Table1[Column5], Table1[Column6], Table1[Column7]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Table(7). All arguments as table references. 7 of 7 arguments used.');
		// Case #21: Number(7). All numeric arguments as decimal values. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000.25, 38961.5, 39782.75, 15000.5, 1.25, 0.225, 4.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000.25, 38961.5, 39782.75, 15000.5, 1.25, 0.225, 4.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 33750.05625, 'Test: Positive case: Number(7). All numeric arguments as decimal values. 7 of 7 arguments used.');
		// Case #22: Formula. AMORLINC nested inside SUM formula. 6 of 7 arguments used for AMORLINC.
		oParser = new parserFormula('SUM(AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2),1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2),1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31000, 'Test: Positive case: Formula. AMORLINC nested inside SUM formula. 6 of 7 arguments used for AMORLINC.');
		// Case #23: Number, Formula(2), Number(3), Empty. Empty basis parameter. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3), Empty. Empty basis parameter. 7 of 7 arguments used.');
		// Case #24: Number, Formula, Time, Number(3). Date with time component. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1)+TIME(12,0,0), DATE(2008,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1)+TIME(12,0,0), DATE(2008,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula, Time, Number(3). Date with time component. 6 of 7 arguments used.');
		// Case #25: Number, Formula(2), Number(3). Second period depreciation with one-year period. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2009,8,1), 15000, 2, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2009,8,1), 15000, 2, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3). Second period depreciation with one-year period. 6 of 7 arguments used.');
		// Case #26: Number, Formula(2), Number(3). Period exceeds typical asset life. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2009,8,1), 15000, 5, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2009,8,1), 15000, 5, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Formula(2), Number(3). Period exceeds typical asset life. 6 of 7 arguments used.');
		// Case #27: Number(6). Dates as serial numbers. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(2400, 38961, 39782, 300, 1, 0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(2400, 38961, 39782, 300, 1, 0.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 482, 'Test: Positive case: Number(6). Dates as serial numbers. 6 of 7 arguments used.');
		// Case #28: Number, Formula(2), Number(3). Zero salvage value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2009,8,1), 0, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2009,8,1), 0, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3). Zero salvage value. 6 of 7 arguments used.');
		// Case #29: Number, Formula(2), Number(3). 100% depreciation rate. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,9,1), 15000, 1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,9,1), 15000, 1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 122500, 'Test: Positive case: Number, Formula(2), Number(3). 100% depreciation rate. 6 of 7 arguments used.');
		// Case #30: Number, Formula(2), Number(3). Last period calculation. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2000,1,1), DATE(2001,1,1), 15000, 10, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2000,1,1), DATE(2001,1,1), 15000, 10, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Formula(2), Number(3). Last period calculation. 6 of 7 arguments used.');
		// Case #31: Number, Formula(2), Number(3). Small values test. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(100, DATE(2008,1,1), DATE(2008,12,31), 10, 1, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(100, DATE(2008,1,1), DATE(2008,12,31), 10, 1, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number, Formula(2), Number(3). Small values test. 6 of 7 arguments used.');
		// Case #32: Number, Formula(2), Number(3). Period = 10 with five-year interval between dates. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2013,8,1), 15000, 10, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2013,8,1), 15000, 10, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Formula(2), Number(3). Period = 10 with five-year interval between dates. 6 of 7 arguments used.');
		// Case #33: Number, Formula(2), Number(3). Fractional period (half period). 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,9,1), 15000, 0.5, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,9,1), 15000, 0.5, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3). Fractional period (half period). 6 of 7 arguments used.');
		// Case #34: Number, Formula(2), Number, Formula, Number. Salvage value as percentage of asset cost. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2000,1,1), DATE(2000,12,31), 150000*0.1, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2000,1,1), DATE(2000,12,31), 150000*0.1, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number, Formula, Number. Salvage value as percentage of asset cost. 6 of 7 arguments used.');
		// Case #35: Name(6), Number. Named ranges with specified basis = 3. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(TestName, TestName, TestName1, TestName2, TestName4, TestName3, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(TestName, TestName, TestName1, TestName2, TestName4, TestName3, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 5951.85, 'Test: Positive case: Name(6), Number. Named ranges with specified basis = 3. 7 of 7 arguments used.');
		// Case #36: Number, Formula(2), Number(3). Semi-annual period with double depreciation rate. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2009,2,1), 15000, 1, 0.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2009,2,1), 15000, 1, 0.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 60000, 'Test: Positive case: Number, Formula(2), Number(3). Semi-annual period with double depreciation rate. 6 of 7 arguments used.');
		// Case #37: Number, Formula(2), Number(3). Large cost values with five-year period. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(1000000, DATE(2010,1,1), DATE(2015,1,1), 100000, 1, 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(1000000, DATE(2010,1,1), DATE(2015,1,1), 100000, 1, 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100000, 'Test: Positive case: Number, Formula(2), Number(3). Large cost values with five-year period. 6 of 7 arguments used.');
		// Case #38: Number, Area(2), Number(3). Dates as single-cell areas. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, A101:A101, A102:A102, 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, A101:A101, A102:A102, 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Area(2), Number(3). Dates as single-cell areas. 6 of 7 arguments used.');
		// Case #39: Area, Number(2), Area(3). Mixed types: areas and numbers. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(A100:A100, 38961, 39782, A103:A103, A104:A104, A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(A100:A100, 38961, 39782, A103:A103, A104:A104, A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Area, Number(2), Area(3). Mixed types: areas and numbers. 6 of 7 arguments used.');
		// Case #40: Number, Formula(2), Number(3). Current year in dates. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2023,1,1), DATE(2023,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2023,1,1), DATE(2023,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Number, Formula(2), Number(3). Current year in dates. 6 of 7 arguments used.');
		// Case #41: Formula. AMORLINC inside conditional IF formula. 6 of 7 arguments used for AMORLINC.
		oParser = new parserFormula('IF(TRUE, AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(TRUE, AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Positive case: Formula. AMORLINC inside conditional IF formula. 6 of 7 arguments used for AMORLINC.');
		// Case #42: Number, Formula(2), Number(2), Number, Number. Zero period value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 0, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 0, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0) - 0, 12500, 'Test: Positive case: Number, Formula(2), Number(2), Number, Number. Zero period value. 6 of 7 arguments used.');

		// Negative cases:

		// Case #1: Number(3), Empty, Date, Number(2). Missing required date_purchased parameter. 6 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#28
		/*oParser = new parserFormula('AMORLINC(150000, , DATE(2008,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, , DATE(2008,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Empty, Date, Number(2). Missing required date_purchased parameter. 6 of 7 arguments used.');
		*/// Case #2: Number, Formula, Empty, Number(3). Missing required first_period parameter. 6 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#29
		/*oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), , 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), , 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Formula, Empty, Number(3). Missing required first_period parameter. 6 of 7 arguments used.');
		*/// Case #3: Empty, Number(2), Date, Number(3). Missing required cost parameter. 6 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#29
		/*oParser = new parserFormula('AMORLINC(, 38961, 39782, 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(, 38961, 39782, 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(2), Date, Number(3). Missing required cost parameter. 6 of 7 arguments used.');
		*/// Case #4: Number, Formula(2), Empty, Number(2). Missing required salvage parameter. 6 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#28
		/*oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), , 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), , 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Formula(2), Empty, Number(2). Missing required salvage parameter. 6 of 7 arguments used.');
		*/// Case #5: Number, Formula(2), Number, Empty, Number. Missing required period parameter. 6 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#28
		/*oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, , 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, , 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Formula(2), Number, Empty, Number. Missing required period parameter. 6 of 7 arguments used.');
		*/// Case #6: Number, Formula(2), Number(2), Empty. Missing required rate parameter. 6 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#29
		/*oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Formula(2), Number(2), Empty. Missing required rate parameter. 6 of 7 arguments used.');
		*/// Case #7: Number, Formula(2), Number(3). Negative cost value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(-150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(-150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(3). Negative cost value. 6 of 7 arguments used.');
		// Case #8: Number, Formula(2), Number(3). Negative salvage value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), -15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), -15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(3). Negative salvage value. 6 of 7 arguments used.');
		// Case #9: Number, Formula(2), Number(3). Negative period value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, -1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, -1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(3). Negative period value. 6 of 7 arguments used.');
		// Case #10: Number, Formula(2), Number(3). Negative rate value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, -0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, -0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(3). Negative rate value. 6 of 7 arguments used.');
		// Case #11: Number, Formula(2), Number(3), Number. Negative basis value. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(3), Number. Negative basis value. 7 of 7 arguments used.');
		// Case #12: Number, Formula(2), Number(3), Number. Basis value out of range (0-4). 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(3), Number. Basis value out of range (0-4). 7 of 7 arguments used.');
		// Case #13: Number, Formula(2), Number(3). First period earlier than purchase date. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,12,31), DATE(2008,8,1), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,12,31), DATE(2008,8,1), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(3). First period earlier than purchase date. 6 of 7 arguments used.');
		// Case #14: Number, Formula(2), Number, Number, Number(2). Salvage value greater than cost. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 150001, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 150001, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number, Number, Number(2). Salvage value greater than cost. 6 of 7 arguments used.');
		// Case #15: Number, Formula(2), Number(2), Number, Number. Zero rate value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(2), Number, Number. Zero rate value. 6 of 7 arguments used.');
		// Case #16: String, Formula(2), Number(3). Non-numeric string for cost. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC("text", DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC("text", DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Formula(2), Number(3). Non-numeric string for cost. 6 of 7 arguments used.');
		// Case #17: Number, String, Formula, Number(3). Non-date string for purchase date. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, "text", DATE(2008,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, "text", DATE(2008,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Formula, Number(3). Non-date string for purchase date. 6 of 7 arguments used.');
		// Case #18: Number, Formula, String, Number(3). Non-date string for first period. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), "text", 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), "text", 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula, String, Number(3). Non-date string for first period. 6 of 7 arguments used.');
		// Case #19: Number, Formula(2), String, Number(2). Non-numeric string for salvage value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), "text", 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), "text", 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula(2), String, Number(2). Non-numeric string for salvage value. 6 of 7 arguments used.');
		// Case #20: Number, Formula(2), Number, String, Number. Non-numeric string for period. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, "text", 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, "text", 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula(2), Number, String, Number. Non-numeric string for period. 6 of 7 arguments used.');
		// Case #21: Number, Formula(2), Number(2), Number, String. Non-numeric string for rate. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula(2), Number(2), Number, String. Non-numeric string for rate. 6 of 7 arguments used.');
		// Case #22: Number, Formula(2), Number(3), String. Non-numeric string for basis. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Formula(2), Number(3), String. Non-numeric string for basis. 7 of 7 arguments used.');
		// Case #23: Error, Number(2), Date, Number(3). Error value for cost. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(NA(), 38961, 39782, 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(NA(), 38961, 39782, 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(2), Date, Number(3). Error value for cost. 6 of 7 arguments used.');
		// Case #24: Number, Error, Number, Date, Number(3). Error value for purchase date. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, NA(), 39782, 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, NA(), 39782, 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number, Date, Number(3). Error value for purchase date. 6 of 7 arguments used.');
		// Case #25: Number(2), Error, Number(3). Error value for first period. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, NA(), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, NA(), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Number(3). Error value for first period. 6 of 7 arguments used.');
		// Case #26: Number(3), Error, Number(2). Error value for salvage value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, 39782, NA(), 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, 39782, NA(), 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error, Number(2). Error value for salvage value. 6 of 7 arguments used.');
		// Case #27: Number(4), Error, Number. Error value for period. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, 39782, 15000, NA(), 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, 39782, 15000, NA(), 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(4), Error, Number. Error value for period. 6 of 7 arguments used.');
		// Case #28: Number(5), Error. Error value for rate. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, 39782, 15000, 1, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, 39782, 15000, 1, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(5), Error. Error value for rate. 6 of 7 arguments used.');
		// Case #29: Number(6), Error. Error value for basis. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, 39782, 15000, 1, 0.2, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, 39782, 15000, 1, 0.2, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(6), Error. Error value for basis. 7 of 7 arguments used.');
		// Case #30: Area, Number(5). Multi-cell area for cost. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(A100:A101, 38961, 39782, 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(A100:A101, 38961, 39782, 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(5). Multi-cell area for cost. 6 of 7 arguments used.');
		// Case #31: Number, Area, Number(4). Multi-cell area for purchase date. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, A101:A102, 39782, 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, A101:A102, 39782, 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(4). Multi-cell area for purchase date. 6 of 7 arguments used.');
		// Case #32: Number(2), Area, Number(3). Multi-cell area for first period. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, A103:A104, 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, A103:A104, 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number(3). Multi-cell area for first period. 6 of 7 arguments used.');
		// Case #33: Number(3), Area, Number(2). Multi-cell area for salvage value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, 39782, A104:A105, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, 39782, A104:A105, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area, Number(2). Multi-cell area for salvage value. 6 of 7 arguments used.');
		// Case #34: Number(4), Area, Number. Multi-cell area for period. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, 39782, 15000,A103:A104 , 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, 39782, 15000,A103:A104 , 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Area, Number. Multi-cell area for period. 6 of 7 arguments used.');
		// Case #35: Number(5), Area. Multi-cell area for rate. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, 39782, 15000, 1, A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, 39782, 15000, 1, A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5), Area. Multi-cell area for rate. 6 of 7 arguments used.');
		// Case #36: Number(6), Area. Multi-cell area for basis. 7 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, 38961, 39782, 15000, 1, 0.2, A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, 38961, 39782, 15000, 1, 0.2, A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(6), Area. Multi-cell area for basis. 7 of 7 arguments used.');
		// Case #37: Number, Formula(2), Number(3). Zero asset cost. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(0, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(0, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula(2), Number(3). Zero asset cost. 6 of 7 arguments used.');
		// Case #38: Name, Number(5). Named range with multiple cells for cost. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(TestNameArea, 38961, 39782, 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(TestNameArea, 38961, 39782, 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number(5). Named range with multiple cells for cost. 6 of 7 arguments used.');
		// Case #39: Number, Name, Number(4). Named range with multiple cells for purchase date. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, TestNameArea, 39782, 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, TestNameArea, 39782, 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name, Number(4). Named range with multiple cells for purchase date. 6 of 7 arguments used.');
		// Case #40: Table(7). Table with 2 rows. 7 of 7 arguments used.
		getTableType(599, 0, 601, 6);
		oParser = new parserFormula('AMORLINC(Table1[Column1], Table1[Column2], Table1[Column3], Table1[Column4], Table1[Column5], Table1[Column6], Table1[Column7])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(Table1[Column1], Table1[Column2], Table1[Coumn3], Table1[Column4], Table1[Column5], Table1[Column6], Table1[Column7]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table(7). Table with 2 rows. 7 of 7 arguments used.');

		// Bounded cases:

		// Case #1: Number(6). Minimum positive values for numeric arguments. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(1E-307, 38961, 39782, 1E-307, 1, 0.0000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(1E-307, 38961, 39782, 1E-307, 1, 0.0000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(6). Minimum positive values for numeric arguments. 6 of 7 arguments used.');
		// Case #2: Number(3), Number(3). Maximum cost value, maximum period value, maximum rate. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(1E+307, 38961, 39782, 0, 1E+306, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(1E+307, 38961, 39782, 0, 1E+306, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3), Number(3). Maximum cost value, maximum period value, maximum rate. 6 of 7 arguments used.');
		// Case #3: Number(6). Minimum date values, minimum salvage value, minimum rate. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(1000, 1, 2, 0, 1, 0.0000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(1000, 1, 2, 0, 1, 0.0000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0000000000000001e-7, 'Test: Bounded case: Number(6). Minimum date values, minimum salvage value, minimum rate. 6 of 7 arguments used.');
		// Case #4: Number, Formula(2), Number(3). Minimum and maximum date values in Excel. 6 of 7 arguments used.
		// Different result with MS TODO: Need to fix: Blocked by https://nct.onlyoffice.com/Products/Files/DocEditor.aspx?fileid=366936 Bugs Row#30
		/*oParser = new parserFormula('AMORLINC(150000, DATE(1900,1,1), DATE(9999,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(1900,1,1), DATE(9999,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Formula(2), Number(3). Minimum and maximum date values in Excel. 6 of 7 arguments used.');
		*/// Case #5: Number, Formula(2), Number(3). Salvage value equals cost (boundary case). 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 150000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 150000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Formula(2), Number(3). Salvage value equals cost (boundary case). 6 of 7 arguments used.');
		// Case #6: Number(3), Number(3). Maximum values for cost, salvage value, and period. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(9.99999999999999E+307, 38961, 39782, 9.99999999999999E+307, 2147483647, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(9.99999999999999E+307, 38961, 39782, 9.99999999999999E+307, 2147483647, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3), Number(3). Maximum values for cost, salvage value, and period. 6 of 7 arguments used.');
		// Case #7: Number, Formula(2), Number(3). Purchase date equals first period date. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,8,1), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,8,1), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Bounded case: Number, Formula(2), Number(3). Purchase date equals first period date. 6 of 7 arguments used.');
		// Case #8: Number, Formula(2), Number(3). Maximum valid rate value (100%). 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 72500, 'Test: Bounded case: Number, Formula(2), Number(3). Maximum valid rate value (100%). 6 of 7 arguments used.');
		// Case #9: Number, Formula(2), Number(3). Very large period value. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 100000, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(2008,8,1), DATE(2008,12,31), 15000, 100000, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Formula(2), Number(3). Very large period value. 6 of 7 arguments used.');
		// Case #10: Number, Formula(2), Number(3). Maximum possible dates with minimum interval. 6 of 7 arguments used.
		oParser = new parserFormula('AMORLINC(150000, DATE(9999,12,30), DATE(9999,12,31), 15000, 1, 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AMORLINC(150000, DATE(9999,12,30), DATE(9999,12,31), 15000, 1, 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30000, 'Test: Bounded case: Number, Formula(2), Number(3). Maximum possible dates with minimum interval. 6 of 7 arguments used.');

		testArrayFormula2(assert, "AMORLINC", 6, 7, true);
	});

	QUnit.test("Test: \"COUPDAYBS\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("40568");
		ws.getRange2("A101").setValue("40862");
		ws.getRange2("A102").setValue("45792");
		ws.getRange2("A103").setValue("45793");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("1");
		ws.getRange2("A107").setValue("2");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("40568"); // Column1
		ws.getRange2("B601").setValue("40862"); // Column2
		ws.getRange2("C601").setValue("2"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("40568");
		ws2.getRange2("A2").setValue("40862");
		ws2.getRange2("A3").setValue("45792");
		ws2.getRange2("A4").setValue("45793");
		ws2.getRange2("A5").setValue("1");
		ws2.getRange2("A6").setValue("2");
		ws2.getRange2("A7").setValue("1");
		ws2.getRange2("A8").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("40568"); // TestName
		ws.getRange2("A202").setValue("40862"); // TestName1
		ws.getRange2("A203").setValue("2"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("40568") // TestName3D
		ws2.getRange2("A12").setValue("40862") // TestName3D1
		ws2.getRange2("A13").setValue("2") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3

		// Positive cases:

		// Case #1: Formula(2), Number(2). Return 71. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPDAYBS(DATE(2007,1,25),DATE(2008,11,15),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(DATE(2007,1,25),DATE(2008,11,15),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Formula(2), Number(2). Return 71. 4 of 4 arguments were  used.');
		// Case #2: Formula(2), Number. Return 70. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPDAYBS(DATE(2007,1,25),DATE(2008,11,15),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(DATE(2007,1,25),DATE(2008,11,15),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Positive case: Formula(2), Number. Return 70. 3 of 4 arguments were  used.');
		// Case #3: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Positive case: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.');
		// Case #4: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Positive case: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #5: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,4,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,4,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.');
		// Case #6: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(DATE(2006,3,1),DATE(2006,12,1),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(DATE(2006,3,1),DATE(2006,12,1),1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 90, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.');
		// Case #7: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(DATE(2006,3,1),DATE(2006,11,1),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(DATE(2006,3,1),DATE(2006,11,1),2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.');
		// Case #8: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("03/01/2006","09/01/2006",1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("03/01/2006","09/01/2006",1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.');
		// Case #9: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("03/01/2006","12/01/2006",2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("03/01/2006","12/01/2006",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 90, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #10: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,"40862",1,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,"40862",1,"0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Positive case: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.');
		// Case #11: String(4). All arguments as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("40568","40862","2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("40568","40862","2","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: String(4). All arguments as numeric strings. 4 of 4 arguments used.');
		// Case #12: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,INT(1.9),ROUND(2.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,INT(1.9),ROUND(2.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.');
		// Case #13: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 74, 'Test: Positive case: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.');
		// Case #14: Reference link(4). All arguments as reference links. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(A100,A101,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(A100,A101,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Reference link(4). All arguments as reference links. 4 of 4 arguments used.');
		// Case #15: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(A100:A100,A101:A101,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(A100:A100,A101:A101,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.');
		// Case #16: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS({40568},{40862},{1},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS({40568},{40862},{1},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #17: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS({40568,45792},{40862,45793},{1,2},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS({40568,45792},{40862,45793},{1,2},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Positive case: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.');
		// Case #18: Name(4). All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Name(4). All arguments as named ranges. 4 of 4 arguments used.');
		// Case #19: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(TestName3D,TestName3D1,TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #20: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.');
		// Case #21: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.');
		// Case #22: Table(4). All arguments from table references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Table(4). All arguments from table references. 4 of 4 arguments used.');
		// Case #23: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568.9,40862.1,1.8,2.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568.9,40862.1,1.8,2.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.');
		// Case #24: Formula. COUPDAYBS used inside another formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(COUPDAYBS(40568,40862,2,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COUPDAYBS(40568,40862,2,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 81, 'Test: Positive case: Formula. COUPDAYBS used inside another formula. 4 of 4 arguments used.');
		// Case #25: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.');
		// Case #26: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Positive case: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.');
		// Case #27: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(DATE(2025,5,20),TIME(12,0,0)+45900,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(DATE(2025,5,20),TIME(12,0,0)+45900,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 81, 'Test: Positive case: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.');
		// Case #28: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Positive case: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.');
		// Case #29: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("05/05/2006","06/06/2007",4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("05/05/2006","06/06/2007",4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 60, 'Test: Positive case: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.');
		// Case #30: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,{1},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,{1},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 71, 'Test: Positive case: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.');

		// Negative cases:

		// Case #1: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.');
		// Case #2: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.');
		// Case #3: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40862,40568,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40862,40568,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.');
		// Case #4: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40568,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40568,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.');
		// Case #5: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #6: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #7: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #8: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,-1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,-1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.');
		// Case #9: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #10: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #11: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("abc","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("abc","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.');
		// Case #12: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("03/01/2006","xyz",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("03/01/2006","xyz",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.');
		// Case #13: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("03/01/2006","05/01/2007","abc","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("03/01/2006","05/01/2007","abc","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.');
		// Case #14: String(4). Basis is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("03/01/2006","05/01/2007","1","xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("03/01/2006","05/01/2007","1","xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is non-numeric text string. 4 of 4 arguments used.');
		// Case #15: String(4). Settlement is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("","05/01/2007","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("","05/01/2007","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Settlement is empty string. 4 of 4 arguments used.');
		// Case #16: String(4). Maturity is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("03/01/2006","","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("03/01/2006","","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Maturity is empty string. 4 of 4 arguments used.');
		// Case #17: String(4). Frequency is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("03/01/2006","05/01/2007","","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("03/01/2006","05/01/2007","","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is empty string. 4 of 4 arguments used.');
		// Case #18: String(4). Basis is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("03/01/2006","05/01/2007","1","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("03/01/2006","05/01/2007","1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is empty string. 4 of 4 arguments used.');
		// Case #19: Error, Number(3). Settlement is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(NA(),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(NA(),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(3). Settlement is error value. 4 of 4 arguments used.');
		// Case #20: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,NA(),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,NA(),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.');
		// Case #21: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,NA(),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,NA(),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.');
		// Case #22: Number(3), Error. Basis is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error. Basis is error value. 4 of 4 arguments used.');
		// Case #23: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("13/01/2006","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("13/01/2006","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.');
		// Case #24: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS("01/03/2006","01/32/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS("01/03/2006","01/32/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.');
		// Case #25: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS({40862,40000},{40568,38900},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS({40862,40000},{40568,38900},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.');
		// Case #26: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(A102:A103,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(A102:A103,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.');
		// Case #27: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.');
		// Case #28: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,A104:A105,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,A104:A105,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.');
		// Case #29: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,A104:A105,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,A104:A105,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.');
		// Case #30: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,1,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,1,A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.');
		// Case #31: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,{0,3},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,{0,3},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.');
		// Case #32: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,1,{-1,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,1,{-1,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.');
		// Case #33: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(MATCH("xyz",{"a","b"},0),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(MATCH("xyz",{"a","b"},0),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.');
		// Case #34: Empty(4). All arguments empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(4). All arguments empty. 4 of 4 arguments used.');
		// Case #35: Number(4). Settlement is negative number. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(-1,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(-1,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement is negative number. 4 of 4 arguments used.');
		// Case #36: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,TRUE,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.');
		// Case #37: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.');
		// Case #38: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(TRUE,40862,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(TRUE,40862,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.');
		// Case #39: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,FALSE,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,FALSE,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.');

		// Bounded cases:

		// Case #1: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(DATE(1900,1,1),DATE(1900,1,2),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(DATE(1900,1,1),DATE(1900,1,2),1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #2: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(DATE(9999,12,30),DATE(9999,12,31),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(DATE(9999,12,30),DATE(9999,12,31),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Bounded case: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #3: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Bounded case: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.');
		// Case #4: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,40862,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,40862,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 70, 'Test: Bounded case: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.');
		// Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(DATE(1900,1,1),DATE(9999,12,31),4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(DATE(1900,1,1),DATE(9999,12,31),4,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.');
		// Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(A:A,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(A:A,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.');
		// Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYBS(40568,100:100,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYBS(40568,100:100,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Maturity     as entire column reference. 4 of 4 arguments used.');

        // TODO
        // Need to fix: different results from MS, error types diff
        // Case #1: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
        // Case #2: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
        // Case #27: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
        // Case #34: Empty(4). All arguments empty. 4 of 4 arguments used.
        // Case #36: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
        // Case #37: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
        // Case #38: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
        // Case #39: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
        // Case #1: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.
        // Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
        // Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
        // Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.

		testArrayFormula2(assert, "COUPDAYBS", 3, 4, true);
	});

	QUnit.test("Test: \"COUPDAYS\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("40568");
		ws.getRange2("A101").setValue("40862");
		ws.getRange2("A102").setValue("45792");
		ws.getRange2("A103").setValue("45793");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("1");
		ws.getRange2("A107").setValue("2");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("40568"); // Column1
		ws.getRange2("B601").setValue("40862"); // Column2
		ws.getRange2("C601").setValue("2"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("40568");
		ws2.getRange2("A2").setValue("40862");
		ws2.getRange2("A3").setValue("45792");
		ws2.getRange2("A4").setValue("45793");
		ws2.getRange2("A5").setValue("1");
		ws2.getRange2("A6").setValue("2");
		ws2.getRange2("A7").setValue("1");
		ws2.getRange2("A8").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("40568"); // TestName
		ws.getRange2("A202").setValue("40862"); // TestName1
		ws.getRange2("A203").setValue("2"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("40568") // TestName3D
		ws2.getRange2("A12").setValue("40862") // TestName3D1
		ws2.getRange2("A13").setValue("2") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3

		// Positive cases:

		// Case #1: Formula(2), Number(2). Return 181. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPDAYS(DATE(2007,1,25),DATE(2008,11,15),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(DATE(2007,1,25),DATE(2008,11,15),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 181, 'Test: Positive case: Formula(2), Number(2). Return 181. 4 of 4 arguments were  used.');
		// Case #2: Formula(2), Number. Return 180. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPDAYS(DATE(2007,1,25),DATE(2008,11,15),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(DATE(2007,1,25),DATE(2008,11,15),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Positive case: Formula(2), Number. Return 180. 3 of 4 arguments were  used.');
		// Case #3: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.');
		// Case #4: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Positive case: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #5: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,4,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,4,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 92, 'Test: Positive case: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.');
		// Case #6: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(DATE(2006,3,1),DATE(2006,12,1),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(DATE(2006,3,1),DATE(2006,12,1),1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.');
		// Case #7: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(DATE(2006,3,1),DATE(2006,11,1),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(DATE(2006,3,1),DATE(2006,11,1),2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '182.5', 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.');
		// Case #8: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("03/01/2006","09/01/2006",1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("03/01/2006","09/01/2006",1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.');
		// Case #9: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("03/01/2006","12/01/2006",2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("03/01/2006","12/01/2006",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #10: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,"40862",1,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,"40862",1,"0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.');
		// Case #11: String(4). All arguments as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("40568","40862","2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("40568","40862","2","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 181, 'Test: Positive case: String(4). All arguments as numeric strings. 4 of 4 arguments used.');
		// Case #12: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,INT(1.9),ROUND(2.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,INT(1.9),ROUND(2.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 365, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.');
		// Case #13: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '182.5', 'Test: Positive case: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.');
		// Case #14: Reference link(4). All arguments as reference links. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(A100,A101,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(A100,A101,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Reference link(4). All arguments as reference links. 4 of 4 arguments used.');
		// Case #15: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(A100:A100,A101:A101,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(A100:A100,A101:A101,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.');
		// Case #16: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS({40568},{40862},{1},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS({40568},{40862},{1},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #17: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS({40568,45792},{40862,45793},{1,2},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS({40568,45792},{40862,45793},{1,2},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.');
		// Case #18: Name(4). All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 181, 'Test: Positive case: Name(4). All arguments as named ranges. 4 of 4 arguments used.');
		// Case #19: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(TestName3D,TestName3D1,TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 181, 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #20: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 365, 'Test: Positive case: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.');
		// Case #21: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 365, 'Test: Positive case: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.');
		// Case #22: Table(4). All arguments from table references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 181, 'Test: Positive case: Table(4). All arguments from table references. 4 of 4 arguments used.');
		// Case #23: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568.9,40862.1,1.8,2.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568.9,40862.1,1.8,2.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.');
		// Case #24: Formula. COUPDAYS used inside another formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(COUPDAYS(40568,40862,2,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COUPDAYS(40568,40862,2,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 191, 'Test: Positive case: Formula. COUPDAYS used inside another formula. 4 of 4 arguments used.');
		// Case #25: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 181, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.');
		// Case #26: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.');
		// Case #27: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(DATE(2025,5,20),TIME(12,0,0)+45900,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(DATE(2025,5,20),TIME(12,0,0)+45900,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 184, 'Test: Positive case: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.');
		// Case #28: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.');
		// Case #29: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("05/05/2006","06/06/2007",4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("05/05/2006","06/06/2007",4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 90, 'Test: Positive case: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.');
		// Case #30: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,{1},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,{1},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Positive case: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.');

		// Negative cases:

		// Case #1: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.');
		// Case #2: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.');
		// Case #3: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40862,40568,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40862,40568,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.');
		// Case #4: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40568,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40568,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.');
		// Case #5: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #6: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #7: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #8: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,-1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,-1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.');
		// Case #9: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #10: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #11: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("abc","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("abc","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.');
		// Case #12: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("03/01/2006","xyz",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("03/01/2006","xyz",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.');
		// Case #13: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("03/01/2006","05/01/2007","abc","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("03/01/2006","05/01/2007","abc","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.');
		// Case #14: String(4). Basis is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("03/01/2006","05/01/2007","1","xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("03/01/2006","05/01/2007","1","xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is non-numeric text string. 4 of 4 arguments used.');
		// Case #15: String(4). Settlement is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("","05/01/2007","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("","05/01/2007","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Settlement is empty string. 4 of 4 arguments used.');
		// Case #16: String(4). Maturity is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("03/01/2006","","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("03/01/2006","","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Maturity is empty string. 4 of 4 arguments used.');
		// Case #17: String(4). Frequency is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("03/01/2006","05/01/2007","","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("03/01/2006","05/01/2007","","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is empty string. 4 of 4 arguments used.');
		// Case #18: String(4). Basis is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("03/01/2006","05/01/2007","1","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("03/01/2006","05/01/2007","1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is empty string. 4 of 4 arguments used.');
		// Case #19: Error, Number(3). Settlement is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(NA(),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(NA(),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(3). Settlement is error value. 4 of 4 arguments used.');
		// Case #20: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,NA(),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,NA(),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.');
		// Case #21: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,NA(),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,NA(),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.');
		// Case #22: Number(3), Error. Basis is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error. Basis is error value. 4 of 4 arguments used.');
		// Case #23: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("13/01/2006","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("13/01/2006","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.');
		// Case #24: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS("01/03/2006","01/32/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS("01/03/2006","01/32/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.');
		// Case #25: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS({40862,40000},{40568,38900},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS({40862,40000},{40568,38900},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.');
		// Case #26: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(A102:A103,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(A102:A103,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.');
		// Case #27: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.');
		// Case #28: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,A104:A105,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,A104:A105,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.');
		// Case #29: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,A104:A105,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,A104:A105,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.');
		// Case #30: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,1,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,1,A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.');
		// Case #31: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,{0,3},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,{0,3},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.');
		// Case #32: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,1,{-1,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,1,{-1,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.');
		// Case #33: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(MATCH("xyz",{"a","b"},0),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(MATCH("xyz",{"a","b"},0),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.');
		// Case #34: Empty(4). All arguments empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(4). All arguments empty. 4 of 4 arguments used.');
		// Case #35: Number(4). Settlement is negative number. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(-1,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(-1,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement is negative number. 4 of 4 arguments used.');
		// Case #36: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,TRUE,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.');
		// Case #37: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.');
		// Case #38: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(TRUE,40862,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(TRUE,40862,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.');
		// Case #39: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,FALSE,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,FALSE,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.');

		// Bounded cases:

		// Case #1: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(DATE(1900,1,1),DATE(1900,1,2),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(DATE(1900,1,1),DATE(1900,1,2),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Bounded case: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #2: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(DATE(9999,12,30),DATE(9999,12,31),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(DATE(9999,12,30),DATE(9999,12,31),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Bounded case: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #3: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 360, 'Test: Bounded case: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.');
		// Case #4: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,40862,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,40862,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 90, 'Test: Bounded case: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.');
		// Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(DATE(1900,1,1),DATE(9999,12,31),4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(DATE(1900,1,1),DATE(9999,12,31),4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 90, 'Test: Bounded case: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.');
		// Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(A:A,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(A:A,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.');
		// Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYS(40568,100:100,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYS(40568,100:100,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.');

        // Need to fix: result diff from MS, empty handle, error types diff
        // Case #1: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
        // Case #2: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
        // Case #27: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
        // Case #34: Empty(4). All arguments empty. 4 of 4 arguments used.
        // Case #36: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
        // Case #37: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
        // Case #38: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
        // Case #39: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
        // Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
        // Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.

		testArrayFormula2(assert, "COUPDAYS", 3, 4, true);
	});

	QUnit.test("Test: \"COUPDAYSNC\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("40568");
		ws.getRange2("A101").setValue("40862");
		ws.getRange2("A102").setValue("45792");
		ws.getRange2("A103").setValue("45793");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("1");
		ws.getRange2("A107").setValue("2");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("40568"); // Column1
		ws.getRange2("B601").setValue("40862"); // Column2
		ws.getRange2("C601").setValue("2"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("40568");
		ws2.getRange2("A2").setValue("40862");
		ws2.getRange2("A3").setValue("45792");
		ws2.getRange2("A4").setValue("45793");
		ws2.getRange2("A5").setValue("1");
		ws2.getRange2("A6").setValue("2");
		ws2.getRange2("A7").setValue("1");
		ws2.getRange2("A8").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("40568"); // TestName
		ws.getRange2("A202").setValue("40862"); // TestName1
		ws.getRange2("A203").setValue("2"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("40568") // TestName3D
		ws2.getRange2("A12").setValue("40862") // TestName3D1
		ws2.getRange2("A13").setValue("2") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3

		// Positive cases:

		// Case #1: Formula(2), Number(2). Return 110. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPDAYSNC(DATE(2007,1,25),DATE(2008,11,15),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(DATE(2007,1,25),DATE(2008,11,15),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110, 'Test: Positive case: Formula(2), Number(2). Return 110. 4 of 4 arguments were  used.');
		// Case #2: Formula(2), Number. Return 110 without basis. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPDAYSNC(DATE(2007,1,25),DATE(2008,11,15),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(DATE(2007,1,25),DATE(2008,11,15),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110, 'Test: Positive case: Formula(2), Number. Return 110 without basis. 3 of 4 arguments were  used.');
		// Case #3: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 290, 'Test: Positive case: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.');
		// Case #4: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110, 'Test: Positive case: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #5: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,4,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,4,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21, 'Test: Positive case: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.');
		// Case #6: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(DATE(2006,3,1),DATE(2006,12,1),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(DATE(2006,3,1),DATE(2006,12,1),1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 275, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.');
		// Case #7: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(DATE(2006,3,1),DATE(2006,11,1),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(DATE(2006,3,1),DATE(2006,11,1),2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 61, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.');
		// Case #8: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("03/01/2006","09/01/2006",1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("03/01/2006","09/01/2006",1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.');
		// Case #9: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("03/01/2006","12/01/2006",2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("03/01/2006","12/01/2006",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 90, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #10: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,"40862",1,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,"40862",1,"0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 290, 'Test: Positive case: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.');
		// Case #11: String(4). All arguments as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("40568","40862","2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("40568","40862","2","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110, 'Test: Positive case: String(4). All arguments as numeric strings. 4 of 4 arguments used.');
		// Case #12: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,INT(1.9),ROUND(2.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,INT(1.9),ROUND(2.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 294, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.');
		// Case #13: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 107, 'Test: Positive case: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.');
		// Case #14: Reference link(4). All arguments as reference links. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(A100,A101,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(A100,A101,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 294, 'Test: Positive case: Reference link(4). All arguments as reference links. 4 of 4 arguments used.');
		// Case #15: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(A100:A100,A101:A101,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(A100:A100,A101:A101,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 294, 'Test: Positive case: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.');
		// Case #16: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC({40568},{40862},{1},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC({40568},{40862},{1},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 290, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #17: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC({40568,45792},{40862,45793},{1,2},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC({40568,45792},{40862,45793},{1,2},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 290, 'Test: Positive case: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.');
		// Case #18: Name(4). All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110, 'Test: Positive case: Name(4). All arguments as named ranges. 4 of 4 arguments used.');
		// Case #19: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(TestName3D,TestName3D1,TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110, 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #20: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 294, 'Test: Positive case: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.');
		// Case #21: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 294, 'Test: Positive case: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.');
		// Case #22: Table(4). All arguments from table references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110, 'Test: Positive case: Table(4). All arguments from table references. 4 of 4 arguments used.');
		// Case #23: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568.9,40862.1,1.8,2.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568.9,40862.1,1.8,2.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 294, 'Test: Positive case: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.');
		// Case #24: Formula. COUPDAYSNC used inside another formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(COUPDAYSNC(40568,40862,2,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COUPDAYSNC(40568,40862,2,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120, 'Test: Positive case: Formula. COUPDAYSNC used inside another formula. 4 of 4 arguments used.');
		// Case #25: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.');
		// Case #26: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 290, 'Test: Positive case: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.');
		// Case #27: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(DATE(2025,5,20),TIME(12,0,0)+45900,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(DATE(2025,5,20),TIME(12,0,0)+45900,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 103, 'Test: Positive case: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.');
		// Case #28: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 290, 'Test: Positive case: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.');
		// Case #29: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("05/05/2006","06/06/2007",4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("05/05/2006","06/06/2007",4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 32, 'Test: Positive case: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.');
		// Case #30: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,{1},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,{1},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 294, 'Test: Positive case: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.');

		// Negative cases:

		// Case #1: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.');
		// Case #2: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.');
		// Case #3: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40862,40568,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40862,40568,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.');
		// Case #4: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40568,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40568,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.');
		// Case #5: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #6: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #7: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #8: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,-1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,-1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.');
		// Case #9: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #10: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #11: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("abc","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("abc","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.');
		// Case #12: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("03/01/2006","xyz",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("03/01/2006","xyz",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.');
		// Case #13: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("03/01/2006","05/01/2007","abc","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("03/01/2006","05/01/2007","abc","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.');
		// Case #14: String(4). Basis is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("03/01/2006","05/01/2007","1","xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("03/01/2006","05/01/2007","1","xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is non-numeric text string. 4 of 4 arguments used.');
		// Case #15: String(4). Settlement is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("","05/01/2007","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("","05/01/2007","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Settlement is empty string. 4 of 4 arguments used.');
		// Case #16: String(4). Maturity is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("03/01/2006","","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("03/01/2006","","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Maturity is empty string. 4 of 4 arguments used.');
		// Case #17: String(4). Frequency is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("03/01/2006","05/01/2007","","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("03/01/2006","05/01/2007","","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is empty string. 4 of 4 arguments used.');
		// Case #18: String(4). Basis is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("03/01/2006","05/01/2007","1","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("03/01/2006","05/01/2007","1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is empty string. 4 of 4 arguments used.');
		// Case #19: Error, Number(3). Settlement is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(NA(),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(NA(),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(3). Settlement is error value. 4 of 4 arguments used.');
		// Case #20: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,NA(),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,NA(),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.');
		// Case #21: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,NA(),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,NA(),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.');
		// Case #22: Number(3), Error. Basis is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error. Basis is error value. 4 of 4 arguments used.');
		// Case #23: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("13/01/2006","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("13/01/2006","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.');
		// Case #24: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC("01/03/2006","01/32/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC("01/03/2006","01/32/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.');
		// Case #25: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC({40862,40000},{40568,38900},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC({40862,40000},{40568,38900},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.');
		// Case #26: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(A102:A103,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(A102:A103,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.');
		// Case #27: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.');
		// Case #28: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,A104:A105,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,A104:A105,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.');
		// Case #29: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,A104:A105,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,A104:A105,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.');
		// Case #30: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,1,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,1,A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.');
		// Case #31: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,{0,3},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,{0,3},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.');
		// Case #32: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,1,{-1,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,1,{-1,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.');
		// Case #33: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(MATCH("xyz",{"a","b"},0),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(MATCH("xyz",{"a","b"},0),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.');
		// Case #34: Empty(4). All arguments empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(4). All arguments empty. 4 of 4 arguments used.');
		// Case #35: Number(4). Settlement is negative number. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(-1,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(-1,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement is negative number. 4 of 4 arguments used.');
		// Case #36: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,TRUE,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.');
		// Case #37: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.');
		// Case #38: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(TRUE,40862,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(TRUE,40862,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.');
		// Case #39: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,FALSE,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,FALSE,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.');

		// Bounded cases:

		// Case #1: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(DATE(1900,1,1),DATE(1900,1,2),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(DATE(1900,1,1),DATE(1900,1,2),1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #2: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(DATE(9999,12,30),DATE(9999,12,31),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(DATE(9999,12,30),DATE(9999,12,31),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #3: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 290, 'Test: Bounded case: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.');
		// Case #4: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,40862,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,40862,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Bounded case: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.');
		// Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(DATE(1900,1,1),DATE(9999,12,31),4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(DATE(1900,1,1),DATE(9999,12,31),4,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 89, 'Test: Bounded case: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.');
		// Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(A:A,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(A:A,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.');
		// Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPDAYSNC(40568,100:100,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPDAYSNC(40568,100:100,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.');

        // Need to fix:  ms result diff, error types diff, empty handle
        // Case #1: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
        // Case #2: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
        // Case #27: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
        // Case #34: Empty(4). All arguments empty. 4 of 4 arguments used.
        // Case #36: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
        // Case #37: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
        // Case #38: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
        // Case #39: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
        // Case #1: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.
        // Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
        // Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
        // Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.

		testArrayFormula2(assert, "COUPDAYSNC", 3, 4, true);
	});

	QUnit.test("Test: \"COUPNCD\"", function (assert) {
		let array;
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("40568");
		ws.getRange2("A101").setValue("40862");
		ws.getRange2("A102").setValue("45792");
		ws.getRange2("A103").setValue("45793");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("1");
		ws.getRange2("A107").setValue("2");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("40568"); // Column1
		ws.getRange2("B601").setValue("40862"); // Column2
		ws.getRange2("C601").setValue("2"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("40568");
		ws2.getRange2("A2").setValue("40862");
		ws2.getRange2("A3").setValue("45792");
		ws2.getRange2("A4").setValue("45793");
		ws2.getRange2("A5").setValue("1");
		ws2.getRange2("A6").setValue("2");
		ws2.getRange2("A7").setValue("1");
		ws2.getRange2("A8").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("40568"); // TestName
		ws.getRange2("A202").setValue("40862"); // TestName1
		ws.getRange2("A203").setValue("2"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("40568") // TestName3D
		ws2.getRange2("A12").setValue("40862") // TestName3D1
		ws2.getRange2("A13").setValue("2") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3

		// Positive cases:

		// Case #1: Formula(2), Number(2). Return 39217. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(DATE(2007,1,25),DATE(2008,11,15),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(2007,1,25),DATE(2008,11,15),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 39217, 'Test: Positive case: Formula(2), Number(2). Return 39217. 4 of 4 arguments were  used.');
		// Case #2: Formula(2), Number. Return 41153. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(DATE(2012,8,31),DATE(2013,3,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(2012,8,31),DATE(2013,3,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 41153, 'Test: Positive case: Formula(2), Number. Return 41153. 3 of 4 arguments were  used.');
		// Case #3: Formula(2), Number. Return 41334. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(DATE(2012,9,1),DATE(2013,3,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(2012,9,1),DATE(2013,3,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 41334, 'Test: Positive case: Formula(2), Number. Return 41334. 3 of 4 arguments were  used.');
		// Case #4: Number, Formula, Number. Return 61. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(59,DATE(2013,3,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(59,DATE(2013,3,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 61, 'Test: Positive case: Number, Formula, Number. Return 61. 3 of 4 arguments were  used.');
		// Case #5: Number, Formula, Number. Return 61. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(60,DATE(2013,3,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(60,DATE(2013,3,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 61, 'Test: Positive case: Number, Formula, Number. Return 61. 3 of 4 arguments were  used.');
		// Case #6: Number, Formula, Number. Return 245. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(61,DATE(2013,3,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(61,DATE(2013,3,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 245, 'Test: Positive case: Number, Formula, Number. Return 245. 3 of 4 arguments were  used.');
		// Case #7: String(3). Return 2. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD("1","2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("1","2","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String(3). Return 2. 3 of 4 arguments were  used.');
		// Case #8: Number(3). Return 91. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(0,9222,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(0,9222,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 91, 'Test: Positive case: Number(3). Return 91. 3 of 4 arguments were  used.');
		// Case #9: Number(3). Return 1. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(0,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(0,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3). Return 1. 3 of 4 arguments were  used.');
		// Case #10: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.');
		// Case #11: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40678, 'Test: Positive case: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #12: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,4,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,4,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40589, 'Test: Positive case: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.');
		// Case #13: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(DATE(2006,3,1),DATE(2006,12,1),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(2006,3,1),DATE(2006,12,1),1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 39052, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.');
		// Case #14: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(DATE(2006,3,1),DATE(2006,11,1),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(2006,3,1),DATE(2006,11,1),2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38838, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.');
		// Case #15: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("03/01/2006","09/01/2006",1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("03/01/2006","09/01/2006",1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38961, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.');
		// Case #16: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("03/01/2006","12/01/2006",2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("03/01/2006","12/01/2006",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38869, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #17: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,"40862",1,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,"40862",1,"0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.');
		// Case #18: String(4). All arguments as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("40568","40862","2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("40568","40862","2","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40678, 'Test: Positive case: String(4). All arguments as numeric strings. 4 of 4 arguments used.');
		// Case #19: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,INT(1.9),ROUND(2.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,INT(1.9),ROUND(2.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.');
		// Case #20: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38898, 'Test: Positive case: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.');
		// Case #21: Reference link(4). All arguments as reference links. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(A100,A101,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(A100,A101,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Reference link(4). All arguments as reference links. 4 of 4 arguments used.');
		// Case #22: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(A100:A100,A101:A101,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(A100:A100,A101:A101,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.');
		// Case #23: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD({40568},{40862},{1},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD({40568},{40862},{1},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #24: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD({40568,45792},{40862,45793},{1,2},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD({40568,45792},{40862,45793},{1,2},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.');
		// Case #25: Name(4). All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40678, 'Test: Positive case: Name(4). All arguments as named ranges. 4 of 4 arguments used.');
		// Case #26: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(TestName3D,TestName3D1,TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40678, 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #27: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.');
		// Case #28: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.');
		// Case #29: Table(4). All arguments from table references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40678, 'Test: Positive case: Table(4). All arguments from table references. 4 of 4 arguments used.');
		// Case #30: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568.9,40862.1,1.8,2.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568.9,40862.1,1.8,2.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.');
		// Case #31: Formula. COUPNCD used inside another formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(COUPNCD(40568,40862,2,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COUPNCD(40568,40862,2,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40688, 'Test: Positive case: Formula. COUPNCD used inside another formula. 4 of 4 arguments used.');
		// Case #32: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40678, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.');
		// Case #33: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.');
		// Case #34: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(DATE(2025,5,20),TIME(12,0,0)+45900,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(2025,5,20),TIME(12,0,0)+45900,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45900, 'Test: Positive case: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.');
		// Case #35: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Positive case: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.');
		// Case #36: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("05/05/2006","06/06/2007",4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("05/05/2006","06/06/2007",4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38874, 'Test: Positive case: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.');
		// Case #37: Number(2), Array. Frequency is multiple array with all correct and bounded incorrect values. 3 of 4 arguments were used.
		oParser = new parserFormula('COUPNCD(1060,9222,{0,1,2,3,4})', "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("T9:X15").bbox);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(1060,9222,{0,1,2,3,4}) is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), "#NUM!", 'Test: Positive case: Number(2), Array. Frequency is multiple array with all correct and bounded incorrect values. 3 of 4 arguments were used. Result of COUPNCD(1060,9222,{0,1,2,3,4})[0,0]');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 1186, 'Test: Positive case: Number(2), Array. Frequency is multiple array with all correct and bounded incorrect values. 3 of 4 arguments were used. Result of COUPNCD(1060,9222,{0,1,2,3,4})[0,1]');
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 1186, 'Test: Positive case: Number(2), Array. Frequency is multiple array with all correct and bounded incorrect values. 3 of 4 arguments were used. Result of COUPNCD(1060,9222,{0,1,2,3,4})[0,2]');
		assert.strictEqual(array.getElementRowCol(0, 3).getValue(), "#NUM!", 'Test: Positive case: Number(2), Array. Frequency is multiple array with all correct and bounded incorrect values. 3 of 4 arguments were used. Result of COUPNCD(1060,9222,{0,1,2,3,4})[0,3]');
		assert.strictEqual(array.getElementRowCol(0, 4).getValue(), 1096, 'Test: Positive case: Number(2), Array. Frequency is multiple array with all correct and bounded incorrect values. 3 of 4 arguments were used. Result of COUPNCD(1060,9222,{0,1,2,3,4})[0,4]');

		// Negative cases:

		// Case #1: Error,Number(2). Return #N/A. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(#N/A,3743,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(#N/A,3743,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(2). Return #N/A. 3 of 4 arguments were  used.');
		// Case #2: Error(2), Number. Return #N/A. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(#N/A,#DIV/0!,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(#N/A,#DIV/0!,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2), Number. Return #N/A. 3 of 4 arguments were  used.');
		// Case #3: Number, Error(2). Return #DIV/0!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(200,#DIV/0!,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(200,#DIV/0!,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Error(2). Return #DIV/0!. 3 of 4 arguments were  used.');
		// Case #4: Number(2), Error. Return #N/A. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(200,37437,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(200,37437,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error. Return #N/A. 3 of 4 arguments were  used.');
		// Case #5: String, Number(2). Return #VALUE!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD("1s",2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("1s",2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(2). Return #VALUE!. 3 of 4 arguments were  used.');
		// Case #6: String(3). Return #VALUE!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD("1","2s","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("1","2s","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). Return #VALUE!. 3 of 4 arguments were  used.');
		// Case #7: String(3). Return #VALUE!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD("1","2","1s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("1","2","1s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). Return #VALUE!. 3 of 4 arguments were  used.');
		// Case #8: Number(3). Return #NUM!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(61,61,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(61,61,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!. 3 of 4 arguments were  used.');
		// Case #9: Number(3). Return #NUM!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(61,61,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(61,61,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!. 3 of 4 arguments were  used.');
		// Case #10: Number(3). Return #NUM!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(61,61,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(61,61,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!. 3 of 4 arguments were  used.');
		// Case #11: Number(3). Return #NUM!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(61,61,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(61,61,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!. 3 of 4 arguments were  used.');
		// Case #12: Empty, Number(2). Return #N/A. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(,9222,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(,9222,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(2). Return #N/A. 3 of 4 arguments were  used.');
		// Case #13: Number, Empty, Number. Return #N/A. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(0,,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(0,,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number. Return #N/A. 3 of 4 arguments were  used.');
		// Case #14: Number(2), Empty. Return #N/A. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPNCD(1060,9222,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(1060,9222,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty. Return #N/A. 3 of 4 arguments were  used.');
		// Case #15: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.');
		// Case #16: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.');
		// Case #17: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40862,40568,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40862,40568,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.');
		// Case #18: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40568,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40568,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.');
		// Case #19: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #20: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #21: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #22: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,-1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,-1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.');
		// Case #23: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #24: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #25: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("abc","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("abc","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.');
		// Case #26: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("03/01/2006","xyz",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("03/01/2006","xyz",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.');
		// Case #27: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("03/01/2006","05/01/2007","abc","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("03/01/2006","05/01/2007","abc","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.');
		// Case #28: String(4). Basis is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("03/01/2006","05/01/2007","1","xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("03/01/2006","05/01/2007","1","xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is non-numeric text string. 4 of 4 arguments used.');
		// Case #29: String(4). Settlement is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("","05/01/2007","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("","05/01/2007","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Settlement is empty string. 4 of 4 arguments used.');
		// Case #30: String(4). Maturity is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("03/01/2006","","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("03/01/2006","","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Maturity is empty string. 4 of 4 arguments used.');
		// Case #31: String(4). Frequency is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("03/01/2006","05/01/2007","","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("03/01/2006","05/01/2007","","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is empty string. 4 of 4 arguments used.');
		// Case #32: String(4). Basis is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("03/01/2006","05/01/2007","1","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("03/01/2006","05/01/2007","1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is empty string. 4 of 4 arguments used.');
		// Case #33: Error, Number(3). Settlement is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(NA(),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(NA(),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(3). Settlement is error value. 4 of 4 arguments used.');
		// Case #34: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,NA(),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,NA(),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.');
		// Case #35: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,NA(),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,NA(),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.');
		// Case #36: Number(3), Error. Basis is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error. Basis is error value. 4 of 4 arguments used.');
		// Case #37: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("13/01/2006","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("13/01/2006","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.');
		// Case #38: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD("01/03/2006","01/32/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD("01/03/2006","01/32/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.');
		// Case #39: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD({40862,40000},{40568,38900},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD({40862,40000},{40568,38900},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.');
		// Case #40: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(A102:A103,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(A102:A103,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.');
		// Case #41: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.');
		// Case #42: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,A104:A105,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,A104:A105,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.');
		// Case #43: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,A104:A105,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,A104:A105,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.');
		// Case #44: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,1,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,1,A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.');
		// Case #45: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,{0,3},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,{0,3},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.');
		// Case #46: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,1,{-1,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,1,{-1,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.');
		// Case #47: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(MATCH("xyz",{"a","b"},0),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(MATCH("xyz",{"a","b"},0),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.');
		// Case #48: Empty(4). All arguments empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(,,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(4). All arguments empty. 4 of 4 arguments used.');
		// Case #49: Number(4). Settlement is negative number. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(-1,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(-1,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement is negative number. 4 of 4 arguments used.');
		// Case #50: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,TRUE,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.');
		// Case #51: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.');
		// Case #52: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(TRUE,40862,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(TRUE,40862,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.');
		// Case #53: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,FALSE,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,FALSE,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.');

		// Bounded cases:

		// Case #1: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(DATE(1900,1,1),DATE(1900,1,2),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(1900,1,1),DATE(1900,1,2),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #2: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(DATE(9999,12,30),DATE(9999,12,31),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(9999,12,30),DATE(9999,12,31),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2958465, 'Test: Bounded case: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #3: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40862, 'Test: Bounded case: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.');
		// Case #4: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,40862,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,40862,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40589, 'Test: Bounded case: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.');
		// Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(DATE(1900,1,1),DATE(9999,12,31),4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(DATE(1900,1,1),DATE(9999,12,31),4,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 91, 'Test: Bounded case: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.');
		// Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(A:A,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(A:A,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.');
		// Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNCD(40568,100:100,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNCD(40568,100:100,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.');

        // Need to fix: error types diff, results diff from MS
        // Case #50: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
        // Case #51: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
        // Case #52: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
        // Case #53: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
        // Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
        // Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
        // Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.

		testArrayFormula2(assert, "COUPNCD", 3, 4, true);
	});

	QUnit.test("Test: \"COUPNUM\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("40568");
		ws.getRange2("A101").setValue("40862");
		ws.getRange2("A102").setValue("45792");
		ws.getRange2("A103").setValue("45793");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("1");
		ws.getRange2("A107").setValue("2");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("40568"); // Column1
		ws.getRange2("B601").setValue("40862"); // Column2
		ws.getRange2("C601").setValue("2"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("40568");
		ws2.getRange2("A2").setValue("40862");
		ws2.getRange2("A3").setValue("45792");
		ws2.getRange2("A4").setValue("45793");
		ws2.getRange2("A5").setValue("1");
		ws2.getRange2("A6").setValue("2");
		ws2.getRange2("A7").setValue("1");
		ws2.getRange2("A8").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("40568"); // TestName
		ws.getRange2("A202").setValue("40862"); // TestName1
		ws.getRange2("A203").setValue("2"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("40568") // TestName3D
		ws2.getRange2("A12").setValue("40862") // TestName3D1
		ws2.getRange2("A13").setValue("2") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3

		// Positive cases:

		// Case #1: Formula(2), Number(2). Return 4. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPNUM(DATE(2007,1,25),DATE(2008,11,15),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(DATE(2007,1,25),DATE(2008,11,15),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula(2), Number(2). Return 4. 4 of 4 arguments were  used.');
		// Case #2: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.');
		// Case #3: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #4: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,4,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,4,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.');
		// Case #5: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(DATE(2006,3,1),DATE(2006,12,1),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(DATE(2006,3,1),DATE(2006,12,1),1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.');
		// Case #6: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(DATE(2006,3,1),DATE(2006,11,1),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(DATE(2006,3,1),DATE(2006,11,1),2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.');
		// Case #7: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("03/01/2006","09/01/2006",1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("03/01/2006","09/01/2006",1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.');
		// Case #8: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("03/01/2006","12/01/2006",2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("03/01/2006","12/01/2006",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #9: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,"40862",1,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,"40862",1,"0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.');
		// Case #10: String(4). All arguments as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("40568","40862","2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("40568","40862","2","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String(4). All arguments as numeric strings. 4 of 4 arguments used.');
		// Case #11: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,INT(1.9),ROUND(2.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,INT(1.9),ROUND(2.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.');
		// Case #12: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.');
		// Case #13: Reference link(4). All arguments as reference links. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(A100,A101,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(A100,A101,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link(4). All arguments as reference links. 4 of 4 arguments used.');
		// Case #14: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(A100:A100,A101:A101,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(A100:A100,A101:A101,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.');
		// Case #15: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM({40568},{40862},{1},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM({40568},{40862},{1},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #16: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM({40568,45792},{40862,45793},{1,2},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM({40568,45792},{40862,45793},{1,2},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.');
		// Case #17: Name(4). All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Name(4). All arguments as named ranges. 4 of 4 arguments used.');
		// Case #18: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(TestName3D,TestName3D1,TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #19: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.');
		// Case #20: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.');
		// Case #21: Table(4). All arguments from table references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Table(4). All arguments from table references. 4 of 4 arguments used.');
		// Case #22: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568.9,40862.1,1.8,2.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568.9,40862.1,1.8,2.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.');
		// Case #23: Formula. COUPNUM used inside another formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(COUPNUM(40568,40862,2,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COUPNUM(40568,40862,2,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Formula. COUPNUM used inside another formula. 4 of 4 arguments used.');
		// Case #24: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.');
		// Case #25: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.');
		// Case #26: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(DATE(2025,5,20),TIME(12,0,0)+45900,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(DATE(2025,5,20),TIME(12,0,0)+45900,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.');
		// Case #27: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.');
		// Case #28: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("05/05/2006","06/06/2007",4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("05/05/2006","06/06/2007",4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.');
		// Case #29: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,{1},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,{1},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.');

		// Negative cases:

		// Case #1: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.');
		// Case #2: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.');
		// Case #3: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40862,40568,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40862,40568,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.');
		// Case #4: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40568,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40568,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.');
		// Case #5: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #6: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #7: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #8: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,-1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,-1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.');
		// Case #9: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #10: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #11: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("abc","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("abc","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.');
		// Case #12: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("03/01/2006","xyz",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("03/01/2006","xyz",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.');
		// Case #13: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("03/01/2006","05/01/2007","abc","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("03/01/2006","05/01/2007","abc","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.');
		// Case #14: String(4). Basis is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("03/01/2006","05/01/2007","1","xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("03/01/2006","05/01/2007","1","xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is non-numeric text string. 4 of 4 arguments used.');
		// Case #15: String(4). Settlement is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("","05/01/2007","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("","05/01/2007","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Settlement is empty string. 4 of 4 arguments used.');
		// Case #16: String(4). Maturity is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("03/01/2006","","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("03/01/2006","","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Maturity is empty string. 4 of 4 arguments used.');
		// Case #17: String(4). Frequency is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("03/01/2006","05/01/2007","","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("03/01/2006","05/01/2007","","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is empty string. 4 of 4 arguments used.');
		// Case #18: String(4). Basis is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("03/01/2006","05/01/2007","1","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("03/01/2006","05/01/2007","1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is empty string. 4 of 4 arguments used.');
		// Case #19: Error, Number(3). Settlement is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(NA(),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(NA(),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(3). Settlement is error value. 4 of 4 arguments used.');
		// Case #20: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,NA(),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,NA(),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.');
		// Case #21: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,NA(),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,NA(),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.');
		// Case #22: Number(3), Error. Basis is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error. Basis is error value. 4 of 4 arguments used.');
		// Case #23: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("13/01/2006","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("13/01/2006","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.');
		// Case #24: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM("01/03/2006","01/32/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM("01/03/2006","01/32/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.');
		// Case #25: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM({40862,40000},{40568,38900},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM({40862,40000},{40568,38900},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.');
		// Case #26: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(A102:A103,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(A102:A103,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.');
		// Case #27: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.');
		// Case #28: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,A104:A105,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,A104:A105,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.');
		// Case #29: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,A104:A105,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,A104:A105,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.');
		// Case #30: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,1,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,1,A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.');
		// Case #31: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,{0,3},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,{0,3},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.');
		// Case #32: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,1,{-1,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,1,{-1,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.');
		// Case #33: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(MATCH("xyz",{"a","b"},0),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(MATCH("xyz",{"a","b"},0),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.');
		// Case #34: Empty(4). All arguments empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(4). All arguments empty. 4 of 4 arguments used.');
		// Case #35: Number(4). Settlement is negative number. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(-1,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(-1,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement is negative number. 4 of 4 arguments used.');
		// Case #36: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,TRUE,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.');
		// Case #37: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.');
		// Case #38: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(TRUE,40862,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(TRUE,40862,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.');
		// Case #39: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,FALSE,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,FALSE,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(DATE(1900,1,1),DATE(1900,1,2),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(DATE(1900,1,1),DATE(1900,1,2),1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #2: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(DATE(9999,12,30),DATE(9999,12,31),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(DATE(9999,12,30),DATE(9999,12,31),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #3: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.');
		// Case #4: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,40862,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,40862,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Bounded case: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.');
		// Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(DATE(1900,1,1),DATE(9999,12,31),4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(DATE(1900,1,1),DATE(9999,12,31),4,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.');
		// Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(A:A,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(A:A,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.');
		// Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPNUM(40568,100:100,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPNUM(40568,100:100,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.');

        // Need to fix: empty handle, error types diff, results diff from MS
        // Case #27: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
        // Case #34: Empty(4). All arguments empty. 4 of 4 arguments used.
        // Case #36: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
        // Case #37: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
        // Case #38: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
        // Case #39: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
        // Case #1: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.
        // Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
        // Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
        // Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.

		testArrayFormula2(assert, "COUPNUM", 3, 4, true);
	});

	QUnit.test("Test: \"COUPPCD\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("40568");
		ws.getRange2("A101").setValue("40862");
		ws.getRange2("A102").setValue("45792");
		ws.getRange2("A103").setValue("45793");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("1");
		ws.getRange2("A107").setValue("2");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 3);
		ws.getRange2("A601").setValue("40568"); // Column1
		ws.getRange2("B601").setValue("40862"); // Column2
		ws.getRange2("C601").setValue("2"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("40568");
		ws2.getRange2("A2").setValue("40862");
		ws2.getRange2("A3").setValue("45792");
		ws2.getRange2("A4").setValue("45793");
		ws2.getRange2("A5").setValue("1");
		ws2.getRange2("A6").setValue("2");
		ws2.getRange2("A7").setValue("1");
		ws2.getRange2("A8").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("40568"); // TestName
		ws.getRange2("A202").setValue("40862"); // TestName1
		ws.getRange2("A203").setValue("2"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("40568") // TestName3D
		ws2.getRange2("A12").setValue("40862") // TestName3D1
		ws2.getRange2("A13").setValue("2") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3

		// Positive cases:

		// Case #1: Formula(2), Number(2). Return 39036. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(DATE(2007,1,25),DATE(2008,11,15),2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(2007,1,25),DATE(2008,11,15),2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 39036, 'Test: Positive case: Formula(2), Number(2). Return 39036. 4 of 4 arguments were  used.');
		// Case #2: Array, Number(2). Return 0. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD({1},39691,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD({1},39691,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array, Number(2). Return 0. 3 of 4 arguments were  used.');
		// Case #3: Number(3). Return 0. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(60,44261,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(60,44261,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(3). Return 0. 3 of 4 arguments were  used.');
		// Case #4: Number(3). Return 0. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(91,37530,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(91,37530,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(3). Return 0. 3 of 4 arguments were  used.');
		// Case #5: Number(3). Return 91. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(91,37529,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(91,37529,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 91, 'Test: Positive case: Number(3). Return 91. 3 of 4 arguments were  used.');
		// Case #6: Number(3). Return 1. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(59,37438,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(59,37438,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(3). Return 1. 3 of 4 arguments were  used.');
		// Case #7: Number(3). Return 0. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(59,37437,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(59,37437,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(3). Return 0. 3 of 4 arguments were  used.');
		// Case #8: Number(3). Return 91. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(182,3743,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(182,3743,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 91, 'Test: Positive case: Number(3). Return 91. 3 of 4 arguments were  used.');
		// Case #9: Number(3). Return 0. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(181,37437,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(181,37437,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(3). Return 0. 3 of 4 arguments were  used.');
		// Case #10: Formula(2), Number. Return 40969. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(DATE(2012,8,31),DATE(2013,3,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(2012,8,31),DATE(2013,3,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40969, 'Test: Positive case: Formula(2), Number. Return 40969. 3 of 4 arguments were  used.');
		// Case #11: Formula(2), Number. Return 41153. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(DATE(2012,9,1),DATE(2013,3,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(2012,9,1),DATE(2013,3,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 41153, 'Test: Positive case: Formula(2), Number. Return 41153. 3 of 4 arguments were  used.');
		// Case #12: String, Number(2). Return 182. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD("200",37437,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("200",37437,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 182, 'Test: Positive case: String, Number(2). Return 182. 3 of 4 arguments were  used.');
		// Case #13: Number(4). Return 182. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(200,37437,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(200,37437,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 182, 'Test: Positive case: Number(4). Return 182. 4 of 4 arguments were  used.');
		// Case #14: Number(4). Return 182. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(200,37437,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(200,37437,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 182, 'Test: Positive case: Number(4). Return 182. 4 of 4 arguments were  used.');
		// Case #15: Number(4). Return 182. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(200,37437,2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(200,37437,2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 182, 'Test: Positive case: Number(4). Return 182. 4 of 4 arguments were  used.');
		// Case #16: Number(4). Return 182. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(200,37437,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(200,37437,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 182, 'Test: Positive case: Number(4). Return 182. 4 of 4 arguments were  used.');
		// Case #17: Number(4). Return 182. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(200,37437,2,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(200,37437,2,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 182, 'Test: Positive case: Number(4). Return 182. 4 of 4 arguments were  used.');
		// Case #18: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number(3), Empty. Settlement and maturity as numbers, frequency 1, basis omitted. 3 of 4 arguments used.');
		// Case #19: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number(4). All arguments as numbers, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #20: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,4,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,4,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number(4). All arguments as numbers, frequency 4, basis 1. 4 of 4 arguments used.');
		// Case #21: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(DATE(2006,3,1),DATE(2006,12,1),1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(2006,3,1),DATE(2006,12,1),1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38687, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 1, basis 2. 4 of 4 arguments used.');
		// Case #22: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(DATE(2006,3,1),DATE(2006,11,1),2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(2006,3,1),DATE(2006,11,1),2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38657, 'Test: Positive case: Formula(2), Number(2). Settlement and maturity via DATE formula, frequency 2, basis 3. 4 of 4 arguments used.');
		// Case #23: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("03/01/2006","09/01/2006",1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("03/01/2006","09/01/2006",1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38596, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 1, basis 4. 4 of 4 arguments used.');
		// Case #24: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("03/01/2006","12/01/2006",2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("03/01/2006","12/01/2006",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38687, 'Test: Positive case: String(2), Number(2). Settlement and maturity as date strings, frequency 2, basis 0. 4 of 4 arguments used.');
		// Case #25: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,"40862",1,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,"40862",1,"0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number, String, Number, String. Maturity and basis as numeric strings. 4 of 4 arguments used.');
		// Case #26: String(4). All arguments as numeric strings. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("40568","40862","2","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("40568","40862","2","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: String(4). All arguments as numeric strings. 4 of 4 arguments used.');
		// Case #27: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,INT(1.9),ROUND(2.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,INT(1.9),ROUND(2.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from formulas returning numbers. 4 of 4 arguments used.');
		// Case #28: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(2006,3,15),DATE(2006,6,30),IF(TRUE,2,1),ABS(-3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38717, 'Test: Positive case: Formula(4). All arguments via nested formulas. 4 of 4 arguments used.');
		// Case #29: Reference link(4). All arguments as reference links. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(A100,A101,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(A100,A101,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Reference link(4). All arguments as reference links. 4 of 4 arguments used.');
		// Case #30: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(A100:A100,A101:A101,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(A100:A100,A101:A101,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Area(4). All arguments as single-cell areas. 4 of 4 arguments used.');
		// Case #31: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD({40568},{40862},{1},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD({40568},{40862},{1},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #32: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD({40568,45792},{40862,45793},{1,2},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD({40568,45792},{40862,45793},{1,2},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Array(4). All arguments as multi-element arrays. 4 of 4 arguments used.');
		// Case #33: Name(4). All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Name(4). All arguments as named ranges. 4 of 4 arguments used.');
		// Case #34: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(TestName3D,TestName3D1,TestName3D2,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #35: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(Sheet2!A1,Sheet2!A2,Sheet2!A5,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.');
		// Case #36: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A5:A5,Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Area3D(4). All arguments as 3D single-cell areas. 4 of 4 arguments used.');
		// Case #37: Table(4). All arguments from table references. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Table(4). All arguments from table references. 4 of 4 arguments used.');
		// Case #38: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568.9,40862.1,1.8,2.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568.9,40862.1,1.8,2.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number(4). All arguments as float numbers, truncated to integers. 4 of 4 arguments used.');
		// Case #39: Formula. COUPPCD used inside another formula. 4 of 4 arguments used.
		oParser = new parserFormula('SUM(COUPPCD(40568,40862,2,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(COUPPCD(40568,40862,2,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40507, 'Test: Positive case: Formula. COUPPCD used inside another formula. 4 of 4 arguments used.');
		// Case #40: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,MATCH(2,{1,2,3},0),MIN(1,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number(2), Formula(2). Frequency and basis from nested formulas. 4 of 4 arguments used.');
		// Case #41: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number(3), Empty. Settlement, maturity and frequency, basis empty. 4 of 4 arguments used.');
		// Case #42: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(DATE(2025,5,20),TIME(12,0,0)+45900,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(2025,5,20),TIME(12,0,0)+45900,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45716, 'Test: Positive case: Formula(2), Number(2). Settlement via DATE, maturity via TIME formula. 4 of 4 arguments used.');
		// Case #43: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,DATE(2025,1,2)-DATE(2025,1,1),TIME(15,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number(2), Formula(2). Frequency and basis via DATE and TIME formulas. 4 of 4 arguments used.');
		// Case #44: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("05/05/2006","06/06/2007",4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("05/05/2006","06/06/2007",4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 38782, 'Test: Positive case: String(2), Number(2). Short date format strings, frequency 4, basis 2. 4 of 4 arguments used.');
		// Case #45: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,{1},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,{1},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Positive case: Number(2), Array(2). Frequency and basis as single-element arrays. 4 of 4 arguments used.');

		// Negative cases:

		// Case #1: Error,Number(2). Return #N/A. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(#N/A,3743,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(#N/A,3743,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(2). Return #N/A. 3 of 4 arguments were  used.');
		// Case #2: Error(2), Number. Return #N/A. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(#N/A,#DIV/0!,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(#N/A,#DIV/0!,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2), Number. Return #N/A. 3 of 4 arguments were  used.');
		// Case #3: Number, Error(2). Return #DIV/0!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(200,#DIV/0!,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(200,#DIV/0!,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Error(2). Return #DIV/0!. 3 of 4 arguments were  used.');
		// Case #4: Number(2), Error. Return #N/A. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(200,37437,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(200,37437,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error. Return #N/A. 3 of 4 arguments were  used.');
		// Case #5: String, Number(2). Return #VALUE!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD("200s",37437,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("200s",37437,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(2). Return #VALUE!. 3 of 4 arguments were  used.');
		// Case #6: String(2), Number. Return #VALUE!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD("200","37437s",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("200","37437s",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number. Return #VALUE!. 3 of 4 arguments were  used.');
		// Case #7: String(3). Return #VALUE!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD("200","37437","2s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("200","37437","2s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). Return #VALUE!. 3 of 4 arguments were  used.');
		// Case #8: Number(3). Return #NUM!. 3 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(200,37437,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(200,37437,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). Return #NUM!. 3 of 4 arguments were  used.');
		// Case #9: Number(4). Return #NUM!. 4 of 4 arguments were  used.
		oParser = new parserFormula('COUPPCD(200,37437,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(200,37437,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Return #NUM!. 4 of 4 arguments were  used.');
		// Case #10: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.');
		// Case #11: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.');
		// Case #12: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40862,40568,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40862,40568,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement >= maturity (invalid). 4 of 4 arguments used.');
		// Case #13: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40568,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40568,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement equals maturity (invalid). 4 of 4 arguments used.');
		// Case #14: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 0 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #15: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 3 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #16: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is 5 (invalid, must be 1, 2, or 4). 4 of 4 arguments used.');
		// Case #17: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,-1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,-1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Frequency is negative (invalid). 4 of 4 arguments used.');
		// Case #18: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is -1 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #19: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Basis is 5 (invalid, must be 0-4). 4 of 4 arguments used.');
		// Case #20: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("abc","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("abc","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is non-numeric text string. 4 of 4 arguments used.');
		// Case #21: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("03/01/2006","xyz",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("03/01/2006","xyz",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is non-numeric text string. 4 of 4 arguments used.');
		// Case #22: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("03/01/2006","05/01/2007","abc","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("03/01/2006","05/01/2007","abc","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is non-numeric text string. 4 of 4 arguments used.');
		// Case #23: String(4). Basis is non-numeric text string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("03/01/2006","05/01/2007","1","xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("03/01/2006","05/01/2007","1","xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is non-numeric text string. 4 of 4 arguments used.');
		// Case #24: String(4). Settlement is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("","05/01/2007","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("","05/01/2007","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Settlement is empty string. 4 of 4 arguments used.');
		// Case #25: String(4). Maturity is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("03/01/2006","","1","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("03/01/2006","","1","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Maturity is empty string. 4 of 4 arguments used.');
		// Case #26: String(4). Frequency is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("03/01/2006","05/01/2007","","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("03/01/2006","05/01/2007","","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Frequency is empty string. 4 of 4 arguments used.');
		// Case #27: String(4). Basis is empty string. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("03/01/2006","05/01/2007","1","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("03/01/2006","05/01/2007","1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Basis is empty string. 4 of 4 arguments used.');
		// Case #28: Error, Number(3). Settlement is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(NA(),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(NA(),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(3). Settlement is error value. 4 of 4 arguments used.');
		// Case #29: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,NA(),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,NA(),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(2). Maturity is error value. 4 of 4 arguments used.');
		// Case #30: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,NA(),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,NA(),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error, Number. Frequency is error value. 4 of 4 arguments used.');
		// Case #31: Number(3), Error. Basis is error value. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Error. Basis is error value. 4 of 4 arguments used.');
		// Case #32: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("13/01/2006","05/01/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("13/01/2006","05/01/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Settlement is invalid date (month 13). 4 of 4 arguments used.');
		// Case #33: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD("01/03/2006","01/32/2007",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD("01/03/2006","01/32/2007",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(2). Maturity is invalid date (day 32). 4 of 4 arguments used.');
		// Case #34: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD({40862,40000},{40568,38900},1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD({40862,40000},{40568,38900},1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, Number(3). Array with settlement >= maturity. 4 of 4 arguments used.');
		// Case #35: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(A102:A103,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(A102:A103,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(3). Settlement as area with 2 cells. 4 of 4 arguments used.');
		// Case #36: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.');
		// Case #37: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,A104:A105,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,A104:A105,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(2). Maturity as area with 2 cells. 4 of 4 arguments used.');
		// Case #38: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,A104:A105,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,A104:A105,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number. Frequency as area with 2 cells. 4 of 4 arguments used.');
		// Case #39: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,1,A106:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,1,A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area. Basis as area with 2 cells. 4 of 4 arguments used.');
		// Case #40: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,{0,3},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,{0,3},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Array, Number. Frequency as array with invalid values. 4 of 4 arguments used.');
		// Case #41: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,1,{-1,5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,1,{-1,5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Array. Basis as array with invalid values. 4 of 4 arguments used.');
		// Case #42: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(MATCH("xyz",{"a","b"},0),40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(MATCH("xyz",{"a","b"},0),40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula(2), Number(2). Settlement formula returns error. 4 of 4 arguments used.');
		// Case #43: Empty(4). All arguments empty. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(,,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(4). All arguments empty. 4 of 4 arguments used.');
		// Case #44: Number(4). Settlement is negative number. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(-1,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(-1,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Settlement is negative number. 4 of 4 arguments used.');
		// Case #45: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,TRUE,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.');
		// Case #46: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,1,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.');
		// Case #47: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(TRUE,40862,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(TRUE,40862,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.');
		// Case #48: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,FALSE,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,FALSE,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.');

		// Bounded cases:

		// Case #1: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(DATE(1900,1,1),DATE(1900,1,2),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(1900,1,1),DATE(1900,1,2),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Formula(2), Number(2). Minimum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #2: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(DATE(9999,12,30),DATE(9999,12,31),1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(9999,12,30),DATE(9999,12,31),1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2958100, 'Test: Bounded case: Formula(2), Number(2). Maximum valid settlement and maturity dates. 4 of 4 arguments used.');
		// Case #3: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Bounded case: Number(4). Minimum valid frequency (1) and basis (0). 4 of 4 arguments used.');
		// Case #4: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,40862,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,40862,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40497, 'Test: Bounded case: Number(4). Maximum valid frequency (4) and basis (4). 4 of 4 arguments used.');
		// Case #5: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(DATE(1900,1,1),DATE(9999,12,31),4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(DATE(1900,1,1),DATE(9999,12,31),4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Formula(2), Number(2). Minimum settlement, maximum maturity, max frequency and basis. 4 of 4 arguments used.');
		// Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(A:A,40862,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(A:A,40862,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.');
		// Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.
		oParser = new parserFormula('COUPPCD(40568,100:100,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COUPPCD(40568,100:100,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.');

        // oParser = new parserFormula("COUPPCD(59,39691,2)", "A2", ws);
		// assert.ok(oParser.parse(), "COUPPCD(59,39691,2)");
		// assert.strictEqual(oParser.calculate().getValue(), 59, "Result of COUPPCD(59,39691,2)");		// problem with date 29/1/1900(59)

		// TODO Need to fix
        // Case #10: Number, Empty(3). Settlement only, maturity empty. 4 of 4 arguments used.
        // Case #11: Empty, Number(3). Settlement empty, other arguments present. 4 of 4 arguments used.
        // Case #36: Number(2), Empty(2). Settlement and maturity only, frequency and basis empty. 4 of 4 arguments used.
        // Case #43: Empty(4). All arguments empty. 4 of 4 arguments used.
        // Case #45: Number(2), Boolean, Number. Frequency as boolean (TRUE). 4 of 4 arguments used.
        // Case #46: Number(3), Boolean. Basis as boolean (TRUE). 4 of 4 arguments used.
        // Case #47: Boolean, Number(3). Settlement as boolean (TRUE). 4 of 4 arguments used.
        // Case #48: Number, Boolean, Number(2). Maturity as boolean (FALSE). 4 of 4 arguments used.
        // Case #6: Reference link, Number(3). Settlement as entire column reference. 4 of 4 arguments used.
        // Case #7: Reference link, Number(3). Maturity as entire column reference. 4 of 4 arguments used.

		testArrayFormula2(assert, "COUPPCD", 3, 4, true);
	});

	QUnit.test("Test: \"CUMIPMT\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.0075");
		ws.getRange2("A101").setValue("360");
		ws.getRange2("A102").setValue("12500");
		ws.getRange2("A103").setValue("13");
		ws.getRange2("A104").setValue("24");
		ws.getRange2("A105").setValue("0");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("0.0075"); // Column1
		ws.getRange2("B601").setValue("360"); // Column2
		ws.getRange2("C601").setValue("12500"); // Column3
		ws.getRange2("D601").setValue("13"); // Column4
		ws.getRange2("E601").setValue("24"); // Column5
		ws.getRange2("F601").setValue("0"); // Column6
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.0075");
		ws2.getRange2("A2").setValue("360");
		ws2.getRange2("A3").setValue("12500");
		ws2.getRange2("A4").setValue("13");
		ws2.getRange2("A5").setValue("24");
		ws2.getRange2("A6").setValue("0");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.0075"); // TestName
		ws.getRange2("A202").setValue("360"); // TestName1
		ws.getRange2("A203").setValue("12500"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		ws.getRange2("A205").setValue("0"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.0075") // TestName3D
		ws2.getRange2("A12").setValue("360") // TestName3D1
		ws2.getRange2("A13").setValue("12500") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3
		ws2.getRange2("A15").setValue("0") // TestName3D4

		// Positive cases:

		// Case #1: Formula(2), Number(4). Return -937.5
		oParser = new parserFormula('CUMIPMT(0.09/12,30*12,125000,1,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,30*12,125000,1,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -937.5, 'Test: Positive case: Formula(2), Number(4). Return -937.5');
		// Case #2: Formula(2), Number(4). Return -11135.23213
		oParser = new parserFormula('CUMIPMT(0.09/12,30*12,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,30*12,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -11135.232130750845, 'Test: Positive case: Formula(2), Number(4). Return -11135.23213');
		// Case #3: Number(6). All arguments are integers. Monthly interest rate, 30-year loan, first payment.
		oParser = new parserFormula('CUMIPMT(0.09/12,30*12,125000,1,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,30*12,125000,1,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -937.5, 'Test: Positive case: Number(6). All arguments are integers. Monthly interest rate, 30-year loan, first payment.');
		// Case #4: Number(6). Rate, Nper, Pv, Start_period, end_period are float numbers.
		oParser = new parserFormula('CUMIPMT(0.0875,4.5,10000.50,1.2,4.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.0875,4.5,10000.50,1.2,4.5,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-1563.643054', 'Test: Positive case: Number(6). Rate, Nper, Pv, Start_period, end_period are float numbers.');
		// Case #5: String(6). All arguments as numeric strings. String to number conversion.
		oParser = new parserFormula('CUMIPMT("0.08","24","15000","1","12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT("0.08","24","15000","1","12","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '-12832.45302', 'Test: Positive case: String(6). All arguments as numeric strings. String to number conversion.');
		// Case #6: Reference link(6). All arguments as reference links.
		oParser = new parserFormula('CUMIPMT(A100,A101,A102,A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(A100,A101,A102,A103,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-1113.523213', 'Test: Positive case: Reference link(6). All arguments as reference links.');
		// Case #7: Area(6). All arguments as single-cell areas.
		oParser = new parserFormula('CUMIPMT(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-1113.523213', 'Test: Positive case: Area(6). All arguments as single-cell areas.');
		// Case #8: Array(6). All arguments as single-element arrays.
		oParser = new parserFormula('CUMIPMT({0.05},{12},{25000},{1},{6},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT({0.05},{12},{25000},{1},{6},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-6240.487469', 'Test: Positive case: Array(6). All arguments as single-element arrays.');
		// Case #9: Name(6). All arguments as Name type.
		oParser = new parserFormula('CUMIPMT(TestName,TestName1,TestName2,TestName3,TestName3,TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(TestName,TestName1,TestName2,TestName3,TestName3,TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -93.75, 'Test: Positive case: Name(6). All arguments as Name type.');
		// Case #10: Name3D(6). All arguments as Name3D type.
		oParser = new parserFormula('CUMIPMT(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D3,TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D3,TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -93.75, 'Test: Positive case: Name3D(6). All arguments as Name3D type.');
		// Case #11: Ref3D(6). All arguments as Ref3D type.
		oParser = new parserFormula('CUMIPMT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-1113.523213', 'Test: Positive case: Ref3D(6). All arguments as Ref3D type.');
		// Case #12: Area3D(6). All arguments as Area3D single cells.
		oParser = new parserFormula('CUMIPMT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-1113.523213', 'Test: Positive case: Area3D(6). All arguments as Area3D single cells.');
		// Case #13: Table(6). All arguments from Table, each from different column.
		oParser = new parserFormula('CUMIPMT(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -11250, 'Test: Positive case: Table(6). All arguments from Table, each from different column.');
		// Case #14: Formula(6). All arguments filled via formulas.
		oParser = new parserFormula('CUMIPMT(10%/12,DATE(2029,1,1)-DATE(2025,1,1),ABS(-50000),ROUND(1.5,0),FLOOR(12.9,1),IF(TRUE,0,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(10%/12,DATE(2029,1,1)-DATE(2025,1,1),ABS(-50000),ROUND(1.5,0),FLOOR(12.9,1),IF(TRUE,0,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-4583.332055', 'Test: Positive case: Formula(6). All arguments filled via formulas.');
		// Case #15: Array(6). Multi-element arrays for all arguments.
		oParser = new parserFormula('CUMIPMT({0.06;0.08},{24;36},{20000;30000},{1;2},{12;18},{0;1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT({0.06;0.08},{24;36},{20000;30000},{1;2},{12;18},{0;1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -12483.288058191474, 'Test: Positive case: Array(6). Multi-element arrays for all arguments.');
		// Case #16: Formula. CUMIPMT as nested formula inside SUM parent formula.
		oParser = new parserFormula('SUM(CUMIPMT(0.09/12,30*12,125000,13,24,0),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CUMIPMT(0.09/12,30*12,125000,13,24,0),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -11035.232130750845, 'Test: Positive case: Formula. CUMIPMT as nested formula inside SUM parent formula.');
		// Case #17: Formula(2), Number(4). Formula for nper. Date converted to number.
		oParser = new parserFormula('CUMIPMT(0.08/12,DATE(2025,6,30),50000,5,10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.08/12,DATE(2025,6,30),50000,5,10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '-2000', 'Test: Positive case: Formula(2), Number(4). Formula for nper. Date converted to number.');
		// Case #18: Number(2), Formula, Number(3). Formula for pv. Time converted to number.
		oParser = new parserFormula('CUMIPMT(0.08/12,24,TIME(15,30,45),1,12,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.08/12,24,TIME(15,30,45),1,12,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.040494458', 'Test: Positive case: Number(2), Formula, Number(3). Formula for pv. Time converted to number.');
		// Case #19: Number(3), Formula, Number(2). Formula for start_period.
		oParser = new parserFormula('CUMIPMT(0.08/12,24,10000,SQRT(4),12,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.08/12,24,10000,SQRT(4),12,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-559.8390485', 'Test: Positive case: Number(3), Formula, Number(2). Formula for start_period.');
		// Case #20: Number(4), Formula, Number. Formula for end_period.
		oParser = new parserFormula('CUMIPMT(0.08/12,24,10000,1,ABS(-12),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.08/12,24,10000,1,ABS(-12),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-626.5057152', 'Test: Positive case: Number(4), Formula, Number. Formula for end_period.');
		// Case #21: Number(5), Formula. Formula for type.
		oParser = new parserFormula('CUMIPMT(0.08/12,24,10000,1,12,IF(FALSE,1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.08/12,24,10000,1,12,IF(FALSE,1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-626.5057152', 'Test: Positive case: Number(5), Formula. Formula for type.');
		// Case #22: String(2), Number(4). Short date format strings converted to numbers.
		oParser = new parserFormula('CUMIPMT("5/5","6/5",50000,1,3,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT("5/5","5/6",50000,1,3,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -824933.1379, 'Test: Positive case: String(2), Number(4). Short date format strings converted to numbers.');
		// Case #23: Number(6). Full loan period calculation where end_period equals nper.
		oParser = new parserFormula('CUMIPMT(0.15/12,5*12,75000,1,60,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.15/12,5*12,75000,1,60,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -32054.68538861428, 'Test: Positive case: Number(6). Full loan period calculation where end_period equals nper.');
		// Case #24: Number(6). Mid-range period calculation with type=1.
		oParser = new parserFormula('CUMIPMT(0.12/12,10*12,50000,25,75,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.12/12,10*12,50000,25,75,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -18158.880323907266, 'Test: Positive case: Number(6). Mid-range period calculation with type=1.');

		// Negative cases:

		// Case #1: String, Number(5). Rate as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT("text",30*12,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT("text",30*12,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(5). Rate as non-numeric string. Returns #VALUE! error.');
		// Case #2: Number, String, Number(4). Nper as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,"text",125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,"text",125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(4). Nper as non-numeric string. Returns #VALUE! error.');
		// Case #3: Number(2), String, Number(3). Pv as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,"text",13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,"text",13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Number(3). Pv as non-numeric string. Returns #VALUE! error.');
		// Case #4: Number(3), String, Number(2). Start_period as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,"text",24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,"text",24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String, Number(2). Start_period as non-numeric string. Returns #VALUE! error.');
		// Case #5: Number(4), String, Number. End_period as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,"text",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,"text",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), String, Number. End_period as non-numeric string. Returns #VALUE! error.');
		// Case #6: Number(5), String. Type as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,24,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,24,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5), String. Type as non-numeric string. Returns #VALUE! error.');
		// Case #7: String(6). Rate as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT("","24","15000","1","12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT("","24","15000","1","12","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Rate as empty string. Returns #VALUE! error.');
		// Case #8: String, Empty, String(4). Nper as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT("0.08",,"15000","1","12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT("0.08",,"15000","1","12","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String, Empty, String(4). Nper as empty string. Returns #VALUE! error.');
		// Case #9: String(2), Empty, String(3). Pv as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT("0.08","24",,"1","12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT("0.08","24",,"1","12","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String(2), Empty, String(3). Pv as empty string. Returns #VALUE! error.');
		// Case #10: String(3), Empty, String(2). Start_period as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT("0.08","24","15000",,"12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT("0.08","24","15000",,"12","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String(3), Empty, String(2). Start_period as empty string. Returns #VALUE! error.');
		// Case #11: String(4), Empty, String. End_period as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT("0.08","24","15000","1",,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT("0.08","24","15000","1",,"0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String(4), Empty, String. End_period as empty string. Returns #VALUE! error.');
		// Case #12: Number(6). Negative rate. Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(-0.01,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(-0.01,360,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative rate. Returns #NUM! error.');
		// Case #13: Number(6). Rate equals 0. Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0,360,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Rate equals 0. Returns #NUM! error.');
		// Case #14: Number(6). Negative nper. Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,-1,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,-1,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative nper. Returns #NUM! error.');
		// Case #15: Number(6). Nper equals 0. Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,0,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,0,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Nper equals 0. Returns #NUM! error.');
		// Case #16: Number(6). Negative pv. Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,-125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,-125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative pv. Returns #NUM! error.');
		// Case #17: Number(6). Pv equals 0. Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,0,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,0,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Pv equals 0. Returns #NUM! error.');
		// Case #18: Number(6). Start_period less than 1 (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,0,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,0,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Start_period less than 1 (equals 0). Returns #NUM! error.');
		// Case #19: Number(6). Start_period less than 1 (negative). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,-5,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,-5,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Start_period less than 1 (negative). Returns #NUM! error.');
		// Case #20: Number(6). End_period less than 1 (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). End_period less than 1 (equals 0). Returns #NUM! error.');
		// Case #21: Number(6). End_period less than 1 (negative). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,-10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,-10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). End_period less than 1 (negative). Returns #NUM! error.');
		// Case #22: Number(6). Start_period greater than end_period. Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,25,13,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,25,13,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Start_period greater than end_period. Returns #NUM! error.');
		// Case #23: Number(6). Type not 0 or 1 (equals 2). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,24,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,24,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Type not 0 or 1 (equals 2). Returns #NUM! error.');
		// Case #24: Number(6). Type not 0 or 1 (equals -1). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,24,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,24,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Type not 0 or 1 (equals -1). Returns #NUM! error.');
		// Case #25: Number(6). Type not 0 or 1 (equals 5). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,24,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,24,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Type not 0 or 1 (equals 5). Returns #NUM! error.');
		// Case #26: Empty, Number(5). Empty rate. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMIPMT(,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(,360,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(5). Empty rate. Returns #NUM! error (treated as 0).');
		// Case #27: Number, Empty, Number(4). Empty nper. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMIPMT(0.09/12,,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number(4). Empty nper. Returns #NUM! error (treated as 0).');
		// Case #28: Number(2), Empty, Number(3). Empty pv. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMIPMT(0.09/12,360,,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty, Number(3). Empty pv. Returns #NUM! error (treated as 0).');
		// Case #29: Number(3), Empty, Number(2). Empty start_period. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Empty, Number(2). Empty start_period. Returns #NUM! error (treated as 0).');
		// Case #30: Number(4), Empty, Number. Empty end_period. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(4), Empty, Number. Empty end_period. Returns #NUM! error (treated as 0).');
		// Case #31: Error, Number(5). Rate as error value. Returns #DIV/0! error.
		oParser = new parserFormula('CUMIPMT(#DIV/0!,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(#DIV/0!,360,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error, Number(5). Rate as error value. Returns #DIV/0! error.');
		// Case #32: Number, Error, Number(4). Nper as error value. Returns #REF! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,#REF!,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,#REF!,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Number, Error, Number(4). Nper as error value. Returns #REF! error.');
		// Case #33: Number(2), Error, Number(3). Pv as error value. Returns #NAME? error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,#NAME?,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,#NAME?,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Number(2), Error, Number(3). Pv as error value. Returns #NAME? error.');
		// Case #34: Number(3), Error, Number(2). Start_period as error value. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,#VALUE!,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,#VALUE!,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Error, Number(2). Start_period as error value. Returns #VALUE! error.');
		// Case #35: Number(4), Error, Number. End_period as error value. Returns #NULL! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,#NULL!,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,#NULL!,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number(4), Error, Number. End_period as error value. Returns #NULL! error.');
		// Case #36: Number(5), Error. Type as error value. Returns #N/A error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,24,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,24,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(5), Error. Type as error value. Returns #N/A error.');
		// Case #37: Boolean, Number(5). Rate as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(FALSE,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(FALSE,360,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(5). Rate as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #38: Number, Boolean, Number(4). Nper as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,FALSE,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,FALSE,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(4). Nper as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #39: Number(2), Boolean, Number(3). Pv as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,FALSE,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,FALSE,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number(3). Pv as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #40: Number(3), Boolean, Number(2). Start_period as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,FALSE,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,FALSE,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean, Number(2). Start_period as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #41: Number(4), Boolean, Number. End_period as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,FALSE,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,FALSE,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Boolean, Number. End_period as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #42: Number(5), Boolean. Type as boolean TRUE (equals 1).
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,24,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,24,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5), Boolean. Type as boolean TRUE (equals 1).');
		// Case #43: Area, Number(5). Rate as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(A100:A101,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(A100:A101,360,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(5). Rate as multi-cell area. Returns #VALUE! error.');
		// Case #44: Number, Area, Number(4). Nper as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,A100:A101,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,A100:A101,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(4). Nper as multi-cell area. Returns #VALUE! error.');
		// Case #45: Number(2), Area, Number(3). Pv as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,A100:A101,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,A100:A101,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number(3). Pv as multi-cell area. Returns #VALUE! error.');
		// Case #46: Number(3), Area, Number(2). Start_period as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,A100:A101,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,A100:A101,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area, Number(2). Start_period as multi-cell area. Returns #VALUE! error.');
		// Case #47: Number(4), Area, Number. End_period as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Area, Number. End_period as multi-cell area. Returns #VALUE! error.');
		// Case #48: Number(5), Area. Type as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,24,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,24,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5), Area. Type as multi-cell area. Returns #VALUE! error.');
		// Case #49: Area3D, Number(5). Rate as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(Sheet2!A1:A2,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(Sheet2!A1:A2,360,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number(5). Rate as Area3D. Returns #VALUE! error.');
		// Case #50: Number, Area3D, Number(4). Nper as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,Sheet2!A1:A2,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,Sheet2!A1:A2,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D, Number(4). Nper as Area3D. Returns #VALUE! error.');
		// Case #51: Number(2), Area3D, Number(3). Pv as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,Sheet2!A1:A2,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,Sheet2!A1:A2,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area3D, Number(3). Pv as Area3D. Returns #VALUE! error.');
		// Case #52: Number(3), Area3D, Number(2). Start_period as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,Sheet2!A1:A2,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,Sheet2!A1:A2,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area3D, Number(2). Start_period as Area3D. Returns #VALUE! error.');
		// Case #53: Number(4), Area3D, Number. End_period as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,Sheet2!A1:A2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,Sheet2!A1:A2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Area3D, Number. End_period as Area3D. Returns #VALUE! error.');
		// Case #54: Number(5), Area3D. Type as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,24,Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,24,Sheet2!A1:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5), Area3D. Type as Area3D. Returns #VALUE! error.');
		// Case #55: Number(6). Type  is float number.
		oParser = new parserFormula('CUMIPMT(0.0875,4.5,10000.50,1.2,4.5,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.0875,4.5,10000.50,1.2,4.5,0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Type  is float number.');
		// Case #56: Number(5), Empty. Type is empty.
		oParser = new parserFormula('CUMIPMT(0.09/12,360,125000,13,24,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,360,125000,13,24,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(5), Empty. Type is empty.');

		// Bounded cases:

		// Case #1: Number(6). Minimum rate value. Very small positive number.
		oParser = new parserFormula('CUMIPMT(1E-10,2,1,1,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(1E-10,2,1,1,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.5000000001000002e-10, 'Test: Bounded case: Number(6). Minimum rate value. Very small positive number.');
		// Case #2: Number(6). Minimum accepted values for rate, nper and pv.
		oParser = new parserFormula('CUMIPMT(0.0001,1,0.01,1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.0001,1,0.01,1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(6). Minimum accepted values for rate, nper and pv.');
		/*// Case #3: Number(6). Maximum values. Very large nper, pv and end_period.  TODO: Stop working with max values
		oParser = new parserFormula('CUMIPMT(1000,1E+10,1E+15,1,1E+10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(1000,1E+10,1E+15,1,1E+10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+28, 'Test: Bounded case: Number(6). Maximum values. Very large nper, pv and end_period.');
		// Case #4: Number(6). Maximum accepted values close to Excel limits.
		oParser = new parserFormula('CUMIPMT(999999,999999999,9.99999999999999E+298,1,999999999,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(999999,999999999,9.99999999999999E+298,1,999999999,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+308, 'Test: Bounded case: Number(6). Maximum accepted values close to Excel limits.');*/
		// Case #5: Number(6). Full period calculation where end_period equals nper.
		oParser = new parserFormula('CUMIPMT(0.09/12,30*12,125000,1,360,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.09/12,30*12,125000,1,360,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -237080.1776251524, 'Test: Bounded case: Number(6). Full period calculation where end_period equals nper.');
		// Case #6: Number(6). Large pv value (1 billion).
		oParser = new parserFormula('CUMIPMT(0.5,2,1000000000,1,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.5,2,1000000000,1,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -500000000, 'Test: Bounded case: Number(6). Large pv value (1 billion).');
		// Case #7: Area, Number(5). Rate as entire column reference. Tests boundary with full column.
		oParser = new parserFormula('CUMIPMT(A:A,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(A:A,360,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area, Number(5). Rate as entire column reference. Tests boundary with full column.');
		// Case #8: Number, Area, Number(4). Nper as entire row reference. Tests boundary with full column.
		oParser = new parserFormula('CUMIPMT(0.5,100:100,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.5,100:100,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number, Area, Number(4). Nper as entire row reference. Tests boundary with full column.');
		// Case #9: Number(2), Area, Number(3). Pv as entire column reference. Tests boundary with full column.
		oParser = new parserFormula('CUMIPMT(0.5,360,A:A,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.5,360,A:A,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number(2), Area, Number(3). Pv as entire column reference. Tests boundary with full column.');
		// Case #10: Number(3), Area, Number(2). Start_period as entire row reference. Tests boundary with full column.
		oParser = new parserFormula('CUMIPMT(0.5,360,125000,100:100,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.5,360,125000,100:100,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number(3), Area, Number(2). Start_period as entire row reference. Tests boundary with full column.');
		// Case #11: Number(4), Area, Number. End_period as entire column reference. Tests boundary with full column.
		oParser = new parserFormula('CUMIPMT(0.5,360,125000,13,A:A,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.5,360,125000,13,A:A,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number(4), Area, Number. End_period as entire column reference. Tests boundary with full column.');
		// Case #12: Number(5), Area. Type as entire row reference. Tests boundary with full column.
		oParser = new parserFormula('CUMIPMT(0.5,360,125000,13,24,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMIPMT(0.5,360,125000,13,24,100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number(5), Area. Type as entire row reference. Tests boundary with full column.');

        // TODO many problems in the results in this formula
        // Need to fix: results diff from MS, error type diff

		testArrayFormula2(assert, "CUMIPMT", 6, 6, true);
	});

	QUnit.test("Test: \"CUMPRINC\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.0075");
		ws.getRange2("A101").setValue("360");
		ws.getRange2("A102").setValue("12500");
		ws.getRange2("A103").setValue("13");
		ws.getRange2("A104").setValue("24");
		ws.getRange2("A105").setValue("0");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("0.0075"); // Column1
		ws.getRange2("B601").setValue("360"); // Column2
		ws.getRange2("C601").setValue("12500"); // Column3
		ws.getRange2("D601").setValue("13"); // Column4
		ws.getRange2("E601").setValue("24"); // Column5
		ws.getRange2("F601").setValue("0"); // Column6
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.0075");
		ws2.getRange2("A2").setValue("360");
		ws2.getRange2("A3").setValue("12500");
		ws2.getRange2("A4").setValue("13");
		ws2.getRange2("A5").setValue("24");
		ws2.getRange2("A6").setValue("0");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("0.0075"); // TestName
		ws.getRange2("A202").setValue("360"); // TestName1
		ws.getRange2("A203").setValue("12500"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		ws.getRange2("A205").setValue("0"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0.0075") // TestName3D
		ws2.getRange2("A12").setValue("360") // TestName3D1
		ws2.getRange2("A13").setValue("12500") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3
		ws2.getRange2("A15").setValue("0") // TestName3D4

		// Positive cases:

		// Case #1: Formula(2), Number(4). Return -68.2787118
		oParser = new parserFormula('CUMPRINC(0.09/12,30*12,125000,1,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,30*12,125000,1,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -68.27827118097684, 'Test: Positive case: Formula(2), Number(4). Return -68.2787118');
		// Case #2: Formula(2), Number(4). Return -934.1071234
		oParser = new parserFormula('CUMPRINC(0.09/12,30*12,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,30*12,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -934.1071234208781, 'Test: Positive case: Formula(2), Number(4). Return -934.1071234');
		// Case #3: Number(6). All arguments are integers. Monthly interest rate, 30-year loan, first payment.
		oParser = new parserFormula('CUMPRINC(0.09/12,30*12,125000,1,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,30*12,125000,1,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '-68.27827118', 'Test: Positive case: Number(6). All arguments are integers. Monthly interest rate, 30-year loan, first payment.');
		// Case #4: Number(6). Rate, Nper, Pv, Start_period, end_period are float numbers.
		oParser = new parserFormula('CUMPRINC(0.0875,4.5,10000.50,1.2,4.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.0875,4.5,10000.50,1.2,4.5,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-6785.906061', 'Test: Positive case: Number(6). Rate, Nper, Pv, Start_period, end_period are float numbers.');
		// Case #5: String(6). All arguments as numeric strings. String to number conversion.
		oParser = new parserFormula('CUMPRINC("0.08","24","15000","1","12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC("0.08","24","15000","1","12","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-4263.580072', 'Test: Positive case: String(6). All arguments as numeric strings. String to number conversion.');
		// Case #6: Reference link(6). All arguments as reference links.
		oParser = new parserFormula('CUMPRINC(A100,A101,A102,A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(A100,A101,A102,A103,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '-93.41071234', 'Test: Positive case: Reference link(6). All arguments as reference links.');
		// Case #7: Area(6). All arguments as single-cell areas.
		oParser = new parserFormula('CUMPRINC(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '-93.41071234', 'Test: Positive case: Area(6). All arguments as single-cell areas.');
		// Case #8: Array(6). All arguments as single-element arrays.
		oParser = new parserFormula('CUMPRINC({0.05},{12},{25000},{1},{6},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC({0.05},{12},{25000},{1},{6},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '-10683.32403', 'Test: Positive case: Array(6). All arguments as single-element arrays.');
		// Case #9: Name(6). All arguments as Name type.
		oParser = new parserFormula('CUMPRINC(TestName,TestName1,TestName2,TestName3,TestName3,TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(TestName,TestName1,TestName2,TestName3,TestName3,TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-6.827827118', 'Test: Positive case: Name(6). All arguments as Name type.');
		// Case #10: Name3D(6). All arguments as Name3D type.
		oParser = new parserFormula('CUMPRINC(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D3,TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D3,TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-6.827827118', 'Test: Positive case: Name3D(6). All arguments as Name3D type.');
		// Case #11: Ref3D(6). All arguments as Ref3D type.
		oParser = new parserFormula('CUMPRINC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '-93.41071234', 'Test: Positive case: Ref3D(6). All arguments as Ref3D type.');
		// Case #12: Area3D(6). All arguments as Area3D single cells.
		oParser = new parserFormula('CUMPRINC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '-93.41071234', 'Test: Positive case: Area3D(6). All arguments as Area3D single cells.');
		// Case #13: Table(6). All arguments from Table, each from different column.
		oParser = new parserFormula('CUMPRINC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2.02863e-7, 'Test: Positive case: Table(6). All arguments from Table, each from different column.');
		// Case #14: Formula(6). All arguments filled via formulas.
		oParser = new parserFormula('CUMPRINC(10%/12,DATE(2029,1,1)-DATE(2025,1,1),ABS(-50000),ROUND(1.5,0),FLOOR(12.9,1),IF(TRUE,0,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(10%/12,DATE(2029,1,1)-DATE(2025,1,1),ABS(-50000),ROUND(1.5,0),FLOOR(12.9,1),IF(TRUE,0,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.026141622', 'Test: Positive case: Formula(6). All arguments filled via formulas.');
		// Case #15: Array(6). Multi-element arrays for all arguments.
		oParser = new parserFormula('CUMPRINC({0.06;0.08},{24;36},{20000;30000},{1;2},{12;18},{0;1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC({0.06;0.08},{24;36},{20000;30000},{1;2},{12;18},{0;1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-6639.673138', 'Test: Positive case: Array(6). Multi-element arrays for all arguments.');
		// Case #16: Formula. CUMPRINC as nested formula inside SUM parent formula.
		oParser = new parserFormula('SUM(CUMPRINC(0.09/12,30*12,125000,13,24,0),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CUMPRINC(0.09/12,30*12,125000,13,24,0),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-834.1071234', 'Test: Positive case: Formula. CUMPRINC as nested formula inside SUM parent formula.');
		// Case #17: Formula(2), Number(4). Formula for nper. Date converted to number.
		oParser = new parserFormula('CUMPRINC(0.08/12,DATE(2025,6,30),50000,5,10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.08/12,DATE(2025,6,30),50000,5,10,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.1108e-129, 'Test: Positive case: Formula(2), Number(4). Formula for nper. Date converted to number.');
		// Case #18: Number(2), Formula, Number(3). Formula for pv. Time converted to number.
		oParser = new parserFormula('CUMPRINC(0.08/12,24,TIME(15,30,45),1,12,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.08/12,24,TIME(15,30,45),1,12,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-0.310299721', 'Test: Positive case: Number(2), Formula, Number(3). Formula for pv. Time converted to number.');
		// Case #19: Number(3), Formula, Number(2). Formula for start_period.
		oParser = new parserFormula('CUMPRINC(0.08/12,24,10000,SQRT(4),12,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.08/12,24,10000,SQRT(4),12,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '-4415.163012', 'Test: Positive case: Number(3), Formula, Number(2). Formula for start_period.');
		// Case #20: Number(4), Formula, Number. Formula for end_period.
		oParser = new parserFormula('CUMPRINC(0.08/12,24,10000,1,ABS(-12),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.08/12,24,10000,1,ABS(-12),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '-4800.76926', 'Test: Positive case: Number(4), Formula, Number. Formula for end_period.');
		// Case #21: Number(5), Formula. Formula for type.
		oParser = new parserFormula('CUMPRINC(0.08/12,24,10000,1,12,IF(FALSE,1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.08/12,24,10000,1,12,IF(FALSE,1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '-4800.76926', 'Test: Positive case: Number(5), Formula. Formula for type.');
		// Case #22: String(2), Number(4). Short date format strings converted to numbers.
		oParser = new parserFormula('CUMPRINC("5/5","5/6",50000,1,3,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC("5/5","5/6",50000,1,3,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(8), '-71.15267291', 'Test: Positive case: String(2), Number(4). Short date format strings converted to numbers.');
		// Case #23: Number(6). Full loan period calculation where end_period equals nper.
		oParser = new parserFormula('CUMPRINC(0.15/12,5*12,75000,1,60,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.15/12,5*12,75000,1,60,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '-75000', 'Test: Positive case: Number(6). Full loan period calculation where end_period equals nper.');
		// Case #24: Number(6). Mid-range period calculation with type=1.
		oParser = new parserFormula('CUMPRINC(0.12/12,10*12,50000,25,75,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.12/12,10*12,50000,25,75,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '-18063.98289', 'Test: Positive case: Number(6). Mid-range period calculation with type=1.');

		// Negative cases:

		// Case #1: Formula(2), Number(4). Return #NUM!
		oParser = new parserFormula('CUMPRINC(0.09/12,30*12,-125000,1,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,30*12,-125000,1,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(4). Return #NUM!');
		// Case #2: String, Number(5). Rate as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC("text",30*12,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC("text",30*12,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(5). Rate as non-numeric string. Returns #VALUE! error.');
		// Case #3: Number, String, Number(4). Nper as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,"text",125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,"text",125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(4). Nper as non-numeric string. Returns #VALUE! error.');
		// Case #4: Number(2), String, Number(3). Pv as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,"text",13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,"text",13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Number(3). Pv as non-numeric string. Returns #VALUE! error.');
		// Case #5: Number(3), String, Number(2). Start_period as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,"text",24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,"text",24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String, Number(2). Start_period as non-numeric string. Returns #VALUE! error.');
		// Case #6: Number(4), String, Number. End_period as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,"text",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,"text",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), String, Number. End_period as non-numeric string. Returns #VALUE! error.');
		// Case #7: Number(5), String. Type as non-numeric string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,24,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,24,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5), String. Type as non-numeric string. Returns #VALUE! error.');
		// Case #8: String(6). Rate as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC("","24","15000","1","12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC("","24","15000","1","12","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Rate as empty string. Returns #VALUE! error.');
		// Case #9: String, Empty, String(4). Nper as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC("0.08",,"15000","1","12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC("0.08",,"15000","1","12","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String, Empty, String(4). Nper as empty string. Returns #VALUE! error.');
		// Case #10: String(2), Empty, String(3). Pv as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC("0.08","24",,"1","12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC("0.08","24",,"1","12","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String(2), Empty, String(3). Pv as empty string. Returns #VALUE! error.');
		// Case #11: String(3), Empty, String(2). Start_period as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC("0.08","24","15000",,"12","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC("0.08","24","15000",,"12","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String(3), Empty, String(2). Start_period as empty string. Returns #VALUE! error.');
		// Case #12: String(4), Empty, String. End_period as empty string. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC("0.08","24","15000","1",,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC("0.08","24","15000","1",,"0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: String(4), Empty, String. End_period as empty string. Returns #VALUE! error.');
		// Case #13: Number(6). Negative rate. Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(-0.01,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(-0.01,360,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative rate. Returns #NUM! error.');
		// Case #14: Number(6). Rate equals 0. Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0,360,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Rate equals 0. Returns #NUM! error.');
		// Case #15: Number(6). Negative nper. Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,-1,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,-1,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative nper. Returns #NUM! error.');
		// Case #16: Number(6). Nper equals 0. Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,0,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,0,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Nper equals 0. Returns #NUM! error.');
		// Case #17: Number(6). Negative pv. Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,-125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,-125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative pv. Returns #NUM! error.');
		// Case #18: Number(6). Pv equals 0. Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,0,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,0,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Pv equals 0. Returns #NUM! error.');
		// Case #19: Number(6). Start_period less than 1 (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,0,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,0,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Start_period less than 1 (equals 0). Returns #NUM! error.');
		// Case #20: Number(6). Start_period less than 1 (negative). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,-5,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,-5,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Start_period less than 1 (negative). Returns #NUM! error.');
		// Case #21: Number(6). End_period less than 1 (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). End_period less than 1 (equals 0). Returns #NUM! error.');
		// Case #22: Number(6). End_period less than 1 (negative). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,-10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,-10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). End_period less than 1 (negative). Returns #NUM! error.');
		// Case #23: Number(6). Start_period greater than end_period. Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,25,13,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,25,13,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Start_period greater than end_period. Returns #NUM! error.');
		// Case #24: Number(6). Type not 0 or 1 (equals 2). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,24,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,24,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Type not 0 or 1 (equals 2). Returns #NUM! error.');
		// Case #25: Number(6). Type not 0 or 1 (equals -1). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,24,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,24,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Type not 0 or 1 (equals -1). Returns #NUM! error.');
		// Case #26: Number(6). Type not 0 or 1 (equals 5). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,24,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,24,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Type not 0 or 1 (equals 5). Returns #NUM! error.');
		// Case #27: Empty, Number(5). Empty rate. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMPRINC(,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(,360,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(5). Empty rate. Returns #NUM! error (treated as 0).');
		// Case #28: Number, Empty, Number(4). Empty nper. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMPRINC(0.09/12,,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number(4). Empty nper. Returns #NUM! error (treated as 0).');
		// Case #29: Number(2), Empty, Number(3). Empty pv. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMPRINC(0.09/12,360,,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty, Number(3). Empty pv. Returns #NUM! error (treated as 0).');
		// Case #30: Number(3), Empty, Number(2). Empty start_period. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Empty, Number(2). Empty start_period. Returns #NUM! error (treated as 0).');
		// Case #31: Number(4), Empty, Number. Empty end_period. Returns #NUM! error (treated as 0).
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(4), Empty, Number. Empty end_period. Returns #NUM! error (treated as 0).');
		// Case #32: Error, Number(5). Rate as error value. Returns #DIV/0! error.
		oParser = new parserFormula('CUMPRINC(#DIV/0!,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(#DIV/0!,360,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error, Number(5). Rate as error value. Returns #DIV/0! error.');
		// Case #33: Number, Error, Number(4). Nper as error value. Returns #REF! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,#REF!,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,#REF!,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Number, Error, Number(4). Nper as error value. Returns #REF! error.');
		// Case #34: Number(2), Error, Number(3). Pv as error value. Returns #NAME? error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,#NAME?,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,#NAME?,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Negative case: Number(2), Error, Number(3). Pv as error value. Returns #NAME? error.');
		// Case #35: Number(3), Error, Number(2). Start_period as error value. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,#VALUE!,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,#VALUE!,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Error, Number(2). Start_period as error value. Returns #VALUE! error.');
		// Case #36: Number(4), Error, Number. End_period as error value. Returns #NULL! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,#NULL!,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,#NULL!,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number(4), Error, Number. End_period as error value. Returns #NULL! error.');
		// Case #37: Number(5), Error. Type as error value. Returns #N/A error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,24,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,24,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(5), Error. Type as error value. Returns #N/A error.');
		// Case #38: Boolean, Number(5). Rate as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(FALSE,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(FALSE,360,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(5). Rate as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #39: Number, Boolean, Number(4). Nper as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,FALSE,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,FALSE,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(4). Nper as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #40: Number(2), Boolean, Number(3). Pv as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,FALSE,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,FALSE,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean, Number(3). Pv as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #41: Number(3), Boolean, Number(2). Start_period as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,FALSE,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,FALSE,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean, Number(2). Start_period as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #42: Number(4), Boolean, Number. End_period as boolean FALSE (equals 0). Returns #NUM! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,FALSE,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,FALSE,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Boolean, Number. End_period as boolean FALSE (equals 0). Returns #NUM! error.');
		// Case #43: Number(5), Boolean. Type as boolean TRUE (equals 1). This is valid, not error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,24,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,24,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5), Boolean. Type as boolean TRUE (equals 1). This is valid, not error.');
		// Case #44: Area, Number(5). Rate as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(A100:A101,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(A100:A101,360,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(5). Rate as multi-cell area. Returns #VALUE! error.');
		// Case #45: Number, Area, Number(4). Nper as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,A100:A101,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,A100:A101,125000,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(4). Nper as multi-cell area. Returns #VALUE! error.');
		// Case #46: Number(2), Area, Number(3). Pv as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,A100:A101,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,A100:A101,13,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area, Number(3). Pv as multi-cell area. Returns #VALUE! error.');
		// Case #47: Number(3), Area, Number(2). Start_period as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,A100:A101,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,A100:A101,24,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area, Number(2). Start_period as multi-cell area. Returns #VALUE! error.');
		// Case #48: Number(4), Area, Number. End_period as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Area, Number. End_period as multi-cell area. Returns #VALUE! error.');
		// Case #49: Number(5), Area. Type as multi-cell area. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,24,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,24,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5), Area. Type as multi-cell area. Returns #VALUE! error.');
		// Case #50: Area3D, Number(5). Rate as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(Sheet2!A1:A2,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(Sheet2!A1:A2,360,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number(5). Rate as Area3D. Returns #VALUE! error.');
		// Case #51: Number, Area3D, Number(4). Nper as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,Sheet2!A1:A2,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,Sheet2!A1:A2,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D, Number(4). Nper as Area3D. Returns #VALUE! error.');
		// Case #52: Number(2), Area3D, Number(3). Pv as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,Sheet2!A1:A2,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,Sheet2!A1:A2,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Area3D, Number(3). Pv as Area3D. Returns #VALUE! error.');
		// Case #53: Number(3), Area3D, Number(2). Start_period as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,Sheet2!A1:A2,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,Sheet2!A1:A2,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Area3D, Number(2). Start_period as Area3D. Returns #VALUE! error.');
		// Case #54: Number(4), Area3D, Number. End_period as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,Sheet2!A1:A2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,Sheet2!A1:A2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Area3D, Number. End_period as Area3D. Returns #VALUE! error.');
		// Case #55: Number(5), Area3D. Type as Area3D. Returns #VALUE! error.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,24,Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,24,Sheet2!A1:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5), Area3D. Type as Area3D. Returns #VALUE! error.');
		// Case #56: Number(6). Type is float number.
		oParser = new parserFormula('CUMPRINC(0.0875,4.5,10000.50,1.2,4.5,0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.0875,4.5,10000.50,1.2,4.5,0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Type is float number.');
		// Case #57: Number(5), Empty. Type is empty.
		oParser = new parserFormula('CUMPRINC(0.09/12,360,125000,13,24,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,360,125000,13,24,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(5), Empty. Type is empty.');

		// Bounded cases:

		// Case #1: Number(6). Minimum rate value. Very small positive number.
		oParser = new parserFormula('CUMPRINC(1E-10,2,1,1,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(1E-10,2,1,1,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '-1', 'Test: Bounded case: Number(6). Minimum rate value. Very small positive number.');
		// Case #2: Number(6). Minimum accepted values for rate, nper and pv.
		oParser = new parserFormula('CUMPRINC(0.0001,1,0.01,1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.0001,1,0.01,1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '-0.01', 'Test: Bounded case: Number(6). Minimum accepted values for rate, nper and pv.');
		/*// Case #3: Number(6). Maximum values. Very large nper, pv and end_period. TODO: Stop working with max values
		oParser = new parserFormula('CUMPRINC(1000,1E+10,1E+15,1,1E+10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(1000,1E+10,1E+15,1,1E+10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1000000000000000, 'Test: Bounded case: Number(6). Maximum values. Very large nper, pv and end_period.');
		// Case #4: Number(6). Maximum accepted values close to Excel limits.
		oParser = new parserFormula('CUMPRINC(999999,999999999,9.99999999999999E+298,1,999999999,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(999999,999999999,9.99999999999999E+298,1,999999999,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+299, 'Test: Bounded case: Number(6). Maximum accepted values close to Excel limits.');*/
		// Case #5: Number(6). Full period calculation where end_period equals nper.
		oParser = new parserFormula('CUMPRINC(0.09/12,30*12,125000,1,360,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.09/12,30*12,125000,1,360,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '-125000', 'Test: Bounded case: Number(6). Full period calculation where end_period equals nper.');
		// Case #6: Number(6). Large pv value (1 billion).
		oParser = new parserFormula('CUMPRINC(0.5,2,1000000000,1,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.5,2,1000000000,1,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -400000000, 'Test: Bounded case: Number(6). Large pv value (1 billion).');
		// Case #7: Area, Number(5). Rate as entire column reference. Tests boundary with full column.
		oParser = new parserFormula('CUMPRINC(A:A,360,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(A:A,360,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area, Number(5). Rate as entire column reference. Tests boundary with full column.');
		// Case #8: Number, Area, Number(4). Nper as entire row reference. Tests boundary with full column.
		oParser = new parserFormula('CUMPRINC(0.5,100:100,125000,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.5,100:100,125000,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number, Area, Number(4). Nper as entire row reference. Tests boundary with full column.');
		// Case #9: Number(2), Area, Number(3). Pv as entire column reference. Tests boundary with full column.
		oParser = new parserFormula('CUMPRINC(0.5,360,A:A,13,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.5,360,A:A,13,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number(2), Area, Number(3). Pv as entire column reference. Tests boundary with full column.');
		// Case #10: Number(3), Area, Number(2). Start_period as entire row reference. Tests boundary with full column.
		oParser = new parserFormula('CUMPRINC(0.5,360,125000,100:100,24,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.5,360,125000,100:100,24,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number(3), Area, Number(2). Start_period as entire row reference. Tests boundary with full column.');
		// Case #11: Number(4), Area, Number. End_period as entire column reference. Tests boundary with full column.
		oParser = new parserFormula('CUMPRINC(0.5,360,125000,13,A:A,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.5,360,125000,13,A:A,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number(4), Area, Number. End_period as entire column reference. Tests boundary with full column.');
		// Case #12: Number(5), Area. Type as entire row reference. Tests boundary with full column.
		oParser = new parserFormula('CUMPRINC(0.5,360,125000,13,24,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CUMPRINC(0.5,360,125000,13,24,100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Number(5), Area. Type as entire row reference. Tests boundary with full column.');

        // TODO many problems in this formulas
        // Need to fix: results diff from MS, error types diff

		testArrayFormula2(assert, "CUMPRINC", 6, 6, true);
	});

	QUnit.test("Test: \"DB\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1000000");
		ws.getRange2("A101").setValue("100000");
		ws.getRange2("A102").setValue("6");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A104").setValue("7");
		ws.getRange2("A105").setValue("test");
		ws.getRange2("A106").setValue("#NULL");
		ws.getRange2("A107").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 4);
		ws.getRange2("A601").setValue("1000000"); // Column1
		ws.getRange2("B601").setValue("100000"); // Column2
		ws.getRange2("C601").setValue("6"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		ws.getRange2("E601").setValue("7"); // Column5
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1000000");
		ws2.getRange2("A2").setValue("100000");
		ws2.getRange2("A3").setValue("6");
		ws2.getRange2("A4").setValue("1");
		ws2.getRange2("A5").setValue("7");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1000000"); // TestName
		ws.getRange2("A202").setValue("100000"); // TestName1
		ws.getRange2("A203").setValue("6"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		ws.getRange2("A205").setValue("7"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1000000") // TestName3D
		ws2.getRange2("A12").setValue("100000") // TestName3D1
		ws2.getRange2("A13").setValue("6") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3
		ws2.getRange2("A15").setValue("7") // TestName3D4

		// Positive cases:

		// Case #1: Number(5). Return 186083,3333
		oParser = new parserFormula('DB(1000000,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 186083.33333333334, 'Test: Positive case: Number(5). Return 186083,3333');
		// Case #2: Number(5). Return 259639.4167
		oParser = new parserFormula('DB(1000000,100000,6,2,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,2,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 259639.41666666666, 'Test: Positive case: Number(5). Return 259639.4167');
		// Case #3: Number(5). Return 176814.4428
		oParser = new parserFormula('DB(1000000,100000,6,3,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,3,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 176814.44275000002, 'Test: Positive case: Number(5). Return 176814.4428');
		// Case #4: Number(5). Return 120410.6355
		oParser = new parserFormula('DB(1000000,100000,6,4,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,4,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 120410.63551274998, 'Test: Positive case: Number(5). Return 120410.6355');
		// Case #5: Number(5). Return 81999.64278
		oParser = new parserFormula('DB(1000000,100000,6,5,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,5,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 81999.64278418274, 'Test: Positive case: Number(5). Return 81999.64278');
		// Case #6: Number(5). Return 55841.75674
		oParser = new parserFormula('DB(1000000,100000,6,6,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,6,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 55841.75673602846, 'Test: Positive case: Number(5). Return 55841.75674');
		// Case #7: Number(5). Return 15845.09847
		oParser = new parserFormula('DB(1000000,100000,6,7,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,7,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15845.098473848071, 'Test: Positive case: Number(5). Return 15845.09847');
		// Case #8: Reference link(5). Depreciation in first year with 7 months calculated. 5 of 5 arguments used.
		oParser = new parserFormula('DB(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Reference link(5). Depreciation in first year with 7 months calculated. 5 of 5 arguments used.');
		// Case #9: Number(5). All arguments as numbers, first year with 7 months. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Number(5). All arguments as numbers, first year with 7 months. 5 of 5 arguments used.');
		// Case #10: Number(5). All arguments as numbers, second year. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,2,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,2,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '259639.4167', 'Test: Positive case: Number(5). All arguments as numbers, second year. 5 of 5 arguments used.');
		// Case #11: Number(4). Month argument omitted, defaults to 12. 4 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 319000, 'Test: Positive case: Number(4). Month argument omitted, defaults to 12. 4 of 5 arguments used.');
		// Case #12: Number(5). Depreciation in sixth year. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,6,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,6,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '55841.75674', 'Test: Positive case: Number(5). Depreciation in sixth year. 5 of 5 arguments used.');
		// Case #13: Number(5). Last period with only 5 months calculated. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,7,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,7,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '23632.18485', 'Test: Positive case: Number(5). Last period with only 5 months calculated. 5 of 5 arguments used.');
		// Case #14: String(5). All arguments as numeric strings. 5 of 5 arguments used.
		oParser = new parserFormula('DB("1000000","100000","6","1","7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB("1000000","100000","6","1","7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: String(5). All arguments as numeric strings. 5 of 5 arguments used.');
		// Case #15: Formula(4), Number. Arguments with formulas, DATE converts to number. 5 of 5 arguments used.
		oParser = new parserFormula('DB(DATE(2025,1,1),DATE(2025,1,2),SQRT(36),ROUND(1.7,0),7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(DATE(2025,1,1),DATE(2025,1,2),SQRT(36),ROUND(1.7,0),7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula(4), Number. Arguments with formulas, DATE converts to number. 5 of 5 arguments used.');
		// Case #16: Empty, Number(4). Cost is empty, defaults to 0. 5 of 5 arguments used.
		oParser = new parserFormula('DB(,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(,100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number(4). Cost is empty, defaults to 0. 5 of 5 arguments used.');
		// Case #17: Number, Empty, Number(3). Salvage is empty, defaults to 0. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '583333.3333', 'Test: Positive case: Number, Empty, Number(3). Salvage is empty, defaults to 0. 5 of 5 arguments used.');
		// Case #18: Number(5). All arguments as float numbers. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000.5,100000.75,6.9,1.3,7.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000.5,100000.75,6.9,1.3,7.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '165666.7495', 'Test: Positive case: Number(5). All arguments as float numbers. 5 of 5 arguments used.');
		// Case #19: Number(5). Salvage as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000.99,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000.99,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Number(5). Salvage as float number. 5 of 5 arguments used.');
		// Case #20: Number(5). Life as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6.75,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6.75,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '168583.3333', 'Test: Positive case: Number(5). Life as float number. 5 of 5 arguments used.');
		// Case #21: Number(5). Period as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1.99,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1.99,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Number(5). Period as float number. 5 of 5 arguments used.');
		// Case #22: Number(5). Month as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,7.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,7.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Number(5). Month as float number. 5 of 5 arguments used.');
		// Case #23: Number(5). Cost as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DB(999999.99,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(999999.99,100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3315', 'Test: Positive case: Number(5). Cost as float number. 5 of 5 arguments used.');
		// Case #24: Boolean, Number(4). Cost as boolean TRUE converts to 1. 5 of 5 arguments used.
		oParser = new parserFormula('DB(TRUE,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(TRUE,100000,6,1,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9), '-3.390916667', 'Test: Positive case: Boolean, Number(4). Cost as boolean TRUE converts to 1. 5 of 5 arguments used.');
		// Case #25: Number, Boolean, Number(3). Salvage as boolean FALSE converts to 0. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,FALSE,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,FALSE,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '583333.3333', 'Test: Positive case: Number, Boolean, Number(3). Salvage as boolean FALSE converts to 0. 5 of 5 arguments used.');
		// Case #26: Number(2), Boolean, Number(2). Life as boolean TRUE converts to 1. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,TRUE,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,TRUE,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 525000, 'Test: Positive case: Number(2), Boolean, Number(2). Life as boolean TRUE converts to 1. 5 of 5 arguments used.');
		// Case #27: Number(3), Boolean, Number. Period as boolean TRUE converts to 1. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,TRUE,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,TRUE,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Number(3), Boolean, Number. Period as boolean TRUE converts to 1. 5 of 5 arguments used.');
		// Case #28: Number(4), Boolean. Month as boolean TRUE converts to 1. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '26583.33333', 'Test: Positive case: Number(4), Boolean. Month as boolean TRUE converts to 1. 5 of 5 arguments used.');
		// Case #29: Formula. DB nested inside SUM formula. 5 of 5 arguments used.
		oParser = new parserFormula('SUM(DB(1000000,100000,6,1,7),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DB(1000000,100000,6,1,7),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186183.3333', 'Test: Positive case: Formula. DB nested inside SUM formula. 5 of 5 arguments used.');
		// Case #30: Number(5). Salvage value is zero. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,0,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,0,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '583333.3333', 'Test: Positive case: Number(5). Salvage value is zero. 5 of 5 arguments used.');
		// Case #31: Number(5). First period with only 1 month. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '26583.33333', 'Test: Positive case: Number(5). First period with only 1 month. 5 of 5 arguments used.');
		// Case #32: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('DB({1000000},{100000},{6},{1},{7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB({1000000},{100000},{6},{1},{7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.');
		// Case #33: Array(5). All arguments as multi-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('DB({1000000,500000},{100000,50000},{6,5},{1,2},{7,12})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB({1000000,500000},{100000,50000},{6,5},{1,2},{7,12}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Array(5). All arguments as multi-element arrays. 5 of 5 arguments used.');
		// Case #34: Area(5). All arguments as single-cell areas. 5 of 5 arguments used.
		oParser = new parserFormula('DB(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Area(5). All arguments as single-cell areas. 5 of 5 arguments used.');
		// Case #35: Name(5). All arguments as defined names. 5 of 5 arguments used.
		oParser = new parserFormula('DB(TestName,TestName1,TestName2,TestName3,TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(TestName,TestName1,TestName2,TestName3,TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Name(5). All arguments as defined names. 5 of 5 arguments used.');
		// Case #36: Name3D(5). All arguments as 3D defined names. 5 of 5 arguments used.
		oParser = new parserFormula('DB(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Name3D(5). All arguments as 3D defined names. 5 of 5 arguments used.');
		// Case #37: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.
		oParser = new parserFormula('DB(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.');
		// Case #38: Area3D(5). All arguments as 3D single-cell areas. 5 of 5 arguments used.
		oParser = new parserFormula('DB(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Area3D(5). All arguments as 3D single-cell areas. 5 of 5 arguments used.');
		// Case #39: Table(5). All arguments from table columns. 5 of 5 arguments used.
		oParser = new parserFormula('DB(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '186083.3333', 'Test: Positive case: Table(5). All arguments from table columns. 5 of 5 arguments used.');
		// Case #40: Number(5). Period exceeds life 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,7,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,7,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '15845.09847', 'Test: Positive case: Number(5). Period exceeds life 5 of 5 arguments used.');
		// Case #41: Number(5). Salvage exceeds cost. 5 of 5 arguments used.
		oParser = new parserFormula('DB(100000,1000000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(100000,1000000,6,1,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -27300, 'Test: Positive case: Number(5). Salvage exceeds cost. 5 of 5 arguments used.');
		// Case #42: Boolean, Number(4). Cost as boolean FALSE (0), salvage > cost. 5 of 5 arguments used.
		oParser = new parserFormula('DB(FALSE,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(FALSE,100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean, Number(4). Cost as boolean FALSE (0), salvage > cost. 5 of 5 arguments used.');

		// Negative cases:

		// Case #1: Number(5). Cost is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(-1000000,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(-1000000,100000,6,1,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Cost is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #2: Number(5). Salvage is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,-100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,-100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Salvage is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #3: Number(5). Life is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,-6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,-6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Life is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #4: Number(5). Period is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,-1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,-1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Period is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #5: Number(5). Month is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,-7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,-7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Month is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #6: Number(5). Month exceeds 12, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,13)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,13) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Month exceeds 12, returns #NUM! error. 5 of 5 arguments used.');
		// Case #7: Number(5). Month is zero, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Month is zero, returns #NUM! error. 5 of 5 arguments used.');
		// Case #8: Number(5). Life is zero, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,0,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,0,1,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Life is zero, returns #NUM! error. 5 of 5 arguments used.');
		// Case #9: Number(5). Period is zero, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,0,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,0,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Period is zero, returns #NUM! error. 5 of 5 arguments used.');
		// Case #10: String, Number(4). Cost as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB("text",100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB("text",100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(4). Cost as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #11: Number, String, Number(3). Salvage as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,"text",6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,"text",6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(3). Salvage as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #12: Number(2), String, Number(2). Life as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,"text",1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,"text",1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Number(2). Life as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #13: Number(3), String, Number. Period as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,"text",7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,"text",7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String, Number. Period as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #14: Number(4), String. Month as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), String. Month as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #15: String(5). Cost as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB("","100000","6","1","7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB("","100000","6","1","7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Cost as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #16: String(5). Salvage as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB("1000000","","6","1","7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB("1000000","","6","1","7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Salvage as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #17: String(5). Life as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB("1000000","100000","","1","7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB("1000000","100000","","1","7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Life as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #18: String(5). Period as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB("1000000","100000","6","","7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB("1000000","100000","6","","7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Period as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #19: String(5). Month as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB("1000000","100000","6","1","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB("1000000","100000","6","1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Month as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #20: Number(2), Boolean, Number(2). Life as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,FALSE,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,FALSE,1,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Boolean, Number(2). Life as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.');
		// Case #21: Number(3), Boolean, Number. Period as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,FALSE,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,FALSE,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean, Number. Period as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.');
		// Case #22: Number(4), Boolean. Month as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4), Boolean. Month as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.');
		// Case #23: Error, Number(4). Cost is #N/A error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(#N/A,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(#N/A,100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(4). Cost is #N/A error, propagates error. 5 of 5 arguments used.');
		// Case #24: Number, Error, Number(3). Salvage is #N/A error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,#N/A,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,#N/A,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(3). Salvage is #N/A error, propagates error. 5 of 5 arguments used.');
		// Case #25: Number(2), Error, Number(2). Life is #DIV/0! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,#DIV/0!,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,#DIV/0!,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2), Error, Number(2). Life is #DIV/0! error, propagates error. 5 of 5 arguments used.');
		// Case #26: Number(3), Error, Number. Period is #NUM! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,#NUM!,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,#NUM!,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Error, Number. Period is #NUM! error, propagates error. 5 of 5 arguments used.');
		// Case #27: Number(4), Error. Month is #VALUE! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Error. Month is #VALUE! error, propagates error. 5 of 5 arguments used.');
		// Case #28: Reference link, Number(4). Cost references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(A105,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(A105,100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number(4). Cost references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #29: Number, Reference link, Number(3). Salvage references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,A105,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,A105,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link, Number(3). Salvage references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #30: Number(2), Reference link, Number(2). Life references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,A105,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,A105,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Reference link, Number(2). Life references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #31: Number(3), Reference link, Number. Period references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,A105,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,A105,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Reference link, Number. Period references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #32: Number(4), Reference link. Month references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Reference link. Month references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #33: Reference link, Number(4). Cost references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(A106,100000,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(A106,100000,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number(4). Cost references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #34: Number, Reference link, Number(3). Salvage references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,A106,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,A106,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link, Number(3). Salvage references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #35: Number(2), Reference link, Number(2). Life references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,A106,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,A106,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Reference link, Number(2). Life references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #36: Number(3), Reference link, Number. Period references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,A106,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,A106,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Reference link, Number. Period references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #37: Number(4), Reference link. Month references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Reference link. Month references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #38: Number(2), Empty, Number(2). Life is empty, defaults to 0. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,,1,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Empty, Number(2). Life is empty, defaults to 0. 5 of 5 arguments used.');
		// Case #39: Number(3), Empty, Number. Period is empty, defaults to 0. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,,7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Empty, Number. Period is empty, defaults to 0. 5 of 5 arguments used.');
		// Case #40: Number(4), Empty. Month is empty, defaults to 12. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,6,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,6,1,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4), Empty. Month is empty, defaults to 12. 5 of 5 arguments used.');

		// Bounded cases:

		// Case #1: Number(5). Maximum accepted values for cost and life. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1E+307,1,1000000,1,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1E+307,1,1000000,1,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0000000000000001e+304, 'Test: Bounded case: Number(5). Maximum accepted values for cost and life. 5 of 5 arguments used.');
		// Case #2: Number(5). Minimum accepted positive values. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1,0,1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1,0,1,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08333333333333333, 'Test: Bounded case: Number(5). Minimum accepted positive values. 5 of 5 arguments used.');
		// Case #3: Number(5). Period equals life boundary case. 5 of 5 arguments used.
		oParser = new parserFormula('DB(1000000,100000,100,100,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(1000000,100000,100,100,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2297.6805301344984, 'Test: Bounded case: Number(5). Period equals life boundary case. 5 of 5 arguments used.');
		// Case #4: Area(5). Whole column and row as arguments. 5 of 5 arguments used.
		oParser = new parserFormula('DB(A:A,100:100,6,1,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DB(A:A,100:100,6,1,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Area(5). Whole column and row as arguments. 5 of 5 arguments used.');

        // Need to fix: results diff from MS


		testArrayFormula2(assert, "DB", 4, 5);

	});

	QUnit.test("Test: \"DDB\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1000000");
		ws.getRange2("A101").setValue("100000");
		ws.getRange2("A102").setValue("6");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A104").setValue("2");
		ws.getRange2("A105").setValue("test");
		ws.getRange2("A106").setValue("#NULL");
		ws.getRange2("A107").setValue("");

		//TODO format $
		ws.getRange2("B102").setValue("2400");
		ws.getRange2("B103").setValue("300");
		ws.getRange2("B104").setValue("10");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 4);
		ws.getRange2("A601").setValue("1000000"); // Column1
		ws.getRange2("B601").setValue("100000"); // Column2
		ws.getRange2("C601").setValue("6"); // Column3
		ws.getRange2("D601").setValue("1"); // Column4
		ws.getRange2("E601").setValue("2"); // Column5
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1000000");
		ws2.getRange2("A2").setValue("100000");
		ws2.getRange2("A3").setValue("6");
		ws2.getRange2("A4").setValue("1");
		ws2.getRange2("A5").setValue("2");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1000000"); // TestName
		ws.getRange2("A202").setValue("100000"); // TestName1
		ws.getRange2("A203").setValue("6"); // TestName2
		ws.getRange2("A204").setValue("1"); // TestName3
		ws.getRange2("A205").setValue("2"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1000000") // TestName3D
		ws2.getRange2("A12").setValue("100000") // TestName3D1
		ws2.getRange2("A13").setValue("6") // TestName3D2
		ws2.getRange2("A14").setValue("1") // TestName3D3
		ws2.getRange2("A15").setValue("2") // TestName3D4


		// Positive cases:

		// Case #1: Number(2), Formula, Number. Return  1.31. 4 of 5 arguments were used.
		oParser = new parserFormula('DDB(2400,300,10*365,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(2400,300,10*365,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.315068493', 'Test: Positive case: Number(2), Formula, Number. Return  1.31. 4 of 5 arguments were used.');
		// Case #2: Number(2), Formula, Number. Return 40. 5 of 5 arguments were used.
		oParser = new parserFormula('DDB(2400,300,10*12,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(2400,300,10*12,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Number(2), Formula, Number. Return 40. 5 of 5 arguments were used.');
		// Case #3: Number(5). Return 480. 5 of 5 arguments were used.
		oParser = new parserFormula('DDB(2400,300,10,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(2400,300,10,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 480, 'Test: Positive case: Number(5). Return 480. 5 of 5 arguments were used.');
		// Case #4: Number(5). Return 306. 5 of 5 arguments were used.
		oParser = new parserFormula('DDB(2400,300,10,2,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(2400,300,10,2,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '306', 'Test: Positive case: Number(5). Return 306. 5 of 5 arguments were used.');
		// Case #5: Number(4). Return 22.122. 4 of 5 arguments were used.
		oParser = new parserFormula('DDB(2400,300,10,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(2400,300,10,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '22.1225472', 'Test: Positive case: Number(4). Return 22.122. 4 of 5 arguments were used.');
		// Case #6: Reference link(4), Number. Return  1.31. 5 of 5 arguments were used.
		oParser = new parserFormula('DDB(B102,B103,B104*365,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(B102,B103,B104*365,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.315068493', 'Test: Positive case: Reference link(4), Number. Return  1.31. 5 of 5 arguments were used.');
		// Case #7: Reference link(3), Number(2). Return 40. 5 of 5 arguments were used.
		oParser = new parserFormula('DDB(B102,B103,B104*12,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(B102,B103,B104*12,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Reference link(3), Number(2). Return 40. 5 of 5 arguments were used.');
		// Case #8: Reference link(3), Number(2). Return 480. 5 of 5 arguments were used.
		oParser = new parserFormula('DDB(B102,B103,B104,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(B102,B103,B104,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 480, 'Test: Positive case: Reference link(3), Number(2). Return 480. 5 of 5 arguments were used.');
		// Case #9: Reference link(3), Number(2). Return 306. 5 of 5 arguments were used.
		oParser = new parserFormula('DDB(B102,B103,B104,2,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(B102,B103,B104,2,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '306', 'Test: Positive case: Reference link(3), Number(2). Return 306. 5 of 5 arguments were used.');
		// Case #10: Reference link(3), Number. Return 22.122. 4 of 5 arguments were used.
		oParser = new parserFormula('DDB(B102,B103,B104,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(B102,B103,B104,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '22.1225472', 'Test: Positive case: Reference link(3), Number. Return 22.122. 4 of 5 arguments were used.');
		// Case #11: Number(5). Return depreciation for first period using double-declining balance. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Number(5). Return depreciation for first period using double-declining balance. 5 of 5 arguments used.');
		// Case #12: Number(5). Return depreciation for second period. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '222222.2222', 'Test: Positive case: Number(5). Return depreciation for second period. 5 of 5 arguments used.');
		// Case #13: Number(5). Return depreciation for third period. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,3,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,3,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '148148.1481', 'Test: Positive case: Number(5). Return depreciation for third period. 5 of 5 arguments used.');
		// Case #14: Number(5). Return depreciation for fourth period. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '98765.4321', 'Test: Positive case: Number(5). Return depreciation for fourth period. 5 of 5 arguments used.');
		// Case #15: Number(5). Return depreciation for fifth period. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '65843.6214', 'Test: Positive case: Number(5). Return depreciation for fifth period. 5 of 5 arguments used.');
		// Case #16: Number(5). Return depreciation for sixth period. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,6,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,6,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '31687.2428', 'Test: Positive case: Number(5). Return depreciation for sixth period. 5 of 5 arguments used.');
		// Case #17: Number(5). Factor changed to 3 for accelerated depreciation. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 500000, 'Test: Positive case: Number(5). Factor changed to 3 for accelerated depreciation. 5 of 5 arguments used.');
		// Case #18: Reference link(5). All arguments as reference links. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Reference link(5). All arguments as reference links. 5 of 5 arguments used.');
		// Case #19: Number(4). Factor argument omitted, defaults to 2. 4 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Number(4). Factor argument omitted, defaults to 2. 4 of 5 arguments used.');
		// Case #20: String(5). All arguments as numeric strings. 5 of 5 arguments used.
		oParser = new parserFormula('DDB("1000000","100000","6","1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB("1000000","100000","6","1","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: String(5). All arguments as numeric strings. 5 of 5 arguments used.');
		// Case #21: Formula(5). Arguments with formulas, DATE converts to number. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(DATE(2025,1,1),DATE(1950,1,1),SQRT(36),ROUND(1.7,0),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(DATE(2025,1,1),DATE(1950,1,1),SQRT(36),ROUND(1.7,0),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '10146.22222', 'Test: Positive case: Formula(5). Arguments with formulas, DATE converts to number. 5 of 5 arguments used.');
		// Case #22: Empty, Number(4). Cost is empty, defaults to 0. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(,100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(,100000,6,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number(4). Cost is empty, defaults to 0. 5 of 5 arguments used.');
		// Case #23: Number, Empty, Number(3). Salvage is empty, defaults to 0. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,,6,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Number, Empty, Number(3). Salvage is empty, defaults to 0. 5 of 5 arguments used.');
		// Case #24: Number(5). All arguments as float numbers. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000.5,100000.75,6.9,1.3,2.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000.5,100000.75,6.9,1.3,2.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '347127.9532', 'Test: Positive case: Number(5). All arguments as float numbers. 5 of 5 arguments used.');
		// Case #25: Number(5). Salvage as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000.99,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000.99,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Number(5). Salvage as float number. 5 of 5 arguments used.');
		// Case #26: Number(5). Life as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6.75,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6.75,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '296296.2963', 'Test: Positive case: Number(5). Life as float number. 5 of 5 arguments used.');
		// Case #27: Number(5). Period as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1.99,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1.99,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '223125.085', 'Test: Positive case: Number(5). Period as float number. 5 of 5 arguments used.');
		// Case #28: Number(5). Factor as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '416666.6667', 'Test: Positive case: Number(5). Factor as float number. 5 of 5 arguments used.');
		// Case #29: Number(5). Cost as float number. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(999999.99,100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(999999.99,100000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '333333.33', 'Test: Positive case: Number(5). Cost as float number. 5 of 5 arguments used.');
		// Case #30: Boolean, Number(4). Cost as boolean TRUE converts to 1. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(TRUE,100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(TRUE,100000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean, Number(4). Cost as boolean TRUE converts to 1. 5 of 5 arguments used.');
		// Case #31: Number, Boolean, Number(3). Salvage as boolean FALSE converts to 0. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,FALSE,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,FALSE,6,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Number, Boolean, Number(3). Salvage as boolean FALSE converts to 0. 5 of 5 arguments used.');
		// Case #32: Number(2), Boolean, Number(2). Life as boolean TRUE converts to 1. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,TRUE,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,TRUE,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 900000, 'Test: Positive case: Number(2), Boolean, Number(2). Life as boolean TRUE converts to 1. 5 of 5 arguments used.');
		// Case #33: Number(3), Boolean, Number. Period as boolean TRUE converts to 1. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,TRUE,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,TRUE,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Number(3), Boolean, Number. Period as boolean TRUE converts to 1. 5 of 5 arguments used.');
		// Case #34: Number(4), Boolean. Factor as boolean TRUE converts to 1. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '166666.6667', 'Test: Positive case: Number(4), Boolean. Factor as boolean TRUE converts to 1. 5 of 5 arguments used.');
		// Case #35: Formula. DDB nested inside SUM formula. 5 of 5 arguments used.
		oParser = new parserFormula('SUM(DDB(1000000,100000,6,1,2),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DDB(1000000,100000,6,1,2),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333433.3333', 'Test: Positive case: Formula. DDB nested inside SUM formula. 5 of 5 arguments used.');
		// Case #36: Number(5). Salvage value is zero. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,0,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,0,6,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Number(5). Salvage value is zero. 5 of 5 arguments used.');
		// Case #37: Number(5). Factor is 1, linear depreciation. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '166666.6667', 'Test: Positive case: Number(5). Factor is 1, linear depreciation. 5 of 5 arguments used.');
		// Case #38: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('DDB({1000000},{100000},{6},{1},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB({1000000},{100000},{6},{1},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.');
		// Case #39: Array(5). All arguments as multi-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('DDB({1000000,500000},{100000,50000},{6,5},{1,2},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB({1000000,500000},{100000,50000},{6,5},{1,2},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Array(5). All arguments as multi-element arrays. 5 of 5 arguments used.');
		// Case #40: Area(5). All arguments as single-cell areas. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Area(5). All arguments as single-cell areas. 5 of 5 arguments used.');
		// Case #41: Name(5). All arguments as defined names. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(TestName,TestName1,TestName2,TestName3,TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(TestName,TestName1,TestName2,TestName3,TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Name(5). All arguments as defined names. 5 of 5 arguments used.');
		// Case #42: Name3D(5). All arguments as 3D defined names. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '333333.3333', 'Test: Positive case: Name3D(5). All arguments as 3D defined names. 5 of 5 arguments used.');
		// Case #43: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 333333.33333333326, 'Test: Positive case: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.');
		// Case #44: Area3D(5). All arguments as 3D single-cell areas. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 333333.33333333326, 'Test: Positive case: Area3D(5). All arguments as 3D single-cell areas. 5 of 5 arguments used.');
		// Case #45: Table(5). All arguments from table columns. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 333333.33333333326, 'Test: Positive case: Table(5). All arguments from table columns. 5 of 5 arguments used.');
		// Case #46: Number(5). Period equals life boundary case. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,6,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,6,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '31687.2428', 'Test: Positive case: Number(5). Period equals life boundary case. 5 of 5 arguments used.');
		// Case #47: Number(5). Factor is large number for very accelerated depreciation. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 333333.33333333326, 'Test: Positive case: Number(5). Factor is large number for very accelerated depreciation. 5 of 5 arguments used.');
		// Case #48: Number(5). Salvage exceeds cost, returns 0. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(100000,1000000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(100000,1000000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(5). Salvage exceeds cost, returns 0. 5 of 5 arguments used.');
		// Case #49: Boolean, Number(4). Cost as boolean FALSE (0), salvage > cost, returns 0. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(FALSE,100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(FALSE,100000,6,1,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean, Number(4). Cost as boolean FALSE (0), salvage > cost, returns 0. 5 of 5 arguments used.');

		// Negative cases:

		// Case #1: Reference link(2), Number(2). Return #NUM!. 4 of 5 arguments were used.
		oParser = new parserFormula('DDB(B102,B103,0,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(B102,B103,0,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link(2), Number(2). Return #NUM!. 4 of 5 arguments were used.');
		// Case #2: Number(5). Cost is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(-1000000,100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(-1000000,100000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Cost is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #3: Number(5). Salvage is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,-100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,-100000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Salvage is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #4: Number(5). Life is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,-6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,-6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Life is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #5: Number(5). Period is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,-1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,-1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Period is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #6: Number(5). Factor is negative, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Factor is negative, returns #NUM! error. 5 of 5 arguments used.');
		// Case #7: Number(5). Factor is zero, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Factor is zero, returns #NUM! error. 5 of 5 arguments used.');
		// Case #8: Number(5). Life is zero, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,0,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,0,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Life is zero, returns #NUM! error. 5 of 5 arguments used.');
		// Case #9: Number(5). Period is zero, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,0,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,0,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Period is zero, returns #NUM! error. 5 of 5 arguments used.');
		// Case #10: Number(5). Period exceeds life, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,7,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,7,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Period exceeds life, returns #NUM! error. 5 of 5 arguments used.');
		// Case #11: String, Number(4). Cost as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB("text",100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB("text",100000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(4). Cost as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #12: Number, String, Number(3). Salvage as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,"text",6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,"text",6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(3). Salvage as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #13: Number(2), String, Number(2). Life as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,"text",1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,"text",1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Number(2). Life as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #14: Number(3), String, Number. Period as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,"text",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,"text",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String, Number. Period as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #15: Number(4), String. Factor as text string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), String. Factor as text string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #16: String(5). Cost as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB("","100000","6","1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB("","100000","6","1","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Cost as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #17: String(5). Salvage as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB("1000000","","6","1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB("1000000","","6","1","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Salvage as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #18: String(5). Life as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB("1000000","100000","","1","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB("1000000","100000","","1","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Life as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #19: String(5). Period as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB("1000000","100000","6","","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB("1000000","100000","6","","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Period as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #20: String(5). Factor as empty string, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB("1000000","100000","6","1","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB("1000000","100000","6","1","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Factor as empty string, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #21: Number(2), Boolean, Number(2). Life as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,FALSE,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,FALSE,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Boolean, Number(2). Life as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.');
		// Case #22: Number(3), Boolean, Number. Period as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,FALSE,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,FALSE,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Boolean, Number. Period as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.');
		// Case #23: Number(4), Boolean. Factor as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4), Boolean. Factor as boolean FALSE (0), returns #NUM! error. 5 of 5 arguments used.');
		// Case #24: Error, Number(4). Cost is #N/A error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(#N/A,100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(#N/A,100000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(4). Cost is #N/A error, propagates error. 5 of 5 arguments used.');
		// Case #25: Number, Error, Number(3). Salvage is #N/A error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,#N/A,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,#N/A,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(3). Salvage is #N/A error, propagates error. 5 of 5 arguments used.');
		// Case #26: Number(2), Error, Number(2). Life is #DIV/0! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,#DIV/0!,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,#DIV/0!,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2), Error, Number(2). Life is #DIV/0! error, propagates error. 5 of 5 arguments used.');
		// Case #27: Number(3), Error, Number. Period is #NUM! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,#NUM!,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,#NUM!,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Error, Number. Period is #NUM! error, propagates error. 5 of 5 arguments used.');
		// Case #28: Number(4), Error. Factor is #VALUE! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Error. Factor is #VALUE! error, propagates error. 5 of 5 arguments used.');
		// Case #29: Reference link, Number(4). Cost references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(A105,100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(A105,100000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number(4). Cost references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #30: Number, Reference link, Number(3). Salvage references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,A105,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,A105,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link, Number(3). Salvage references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #31: Number(2), Reference link, Number(2). Life references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,A105,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,A105,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Reference link, Number(2). Life references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #32: Number(3), Reference link, Number. Period references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,A105,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,A105,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Reference link, Number. Period references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #33: Number(4), Reference link. Factor references cell with text, returns #VALUE! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Reference link. Factor references cell with text, returns #VALUE! error. 5 of 5 arguments used.');
		// Case #34: Reference link, Number(4). Cost references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(A106,100000,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(A106,100000,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number(4). Cost references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #35: Number, Reference link, Number(3). Salvage references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,A106,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,A106,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link, Number(3). Salvage references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #36: Number(2), Reference link, Number(2). Life references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,A106,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,A106,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Reference link, Number(2). Life references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #37: Number(3), Reference link, Number. Period references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,A106,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,A106,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Reference link, Number. Period references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #38: Number(4), Reference link. Factor references cell with #NULL! error, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,1,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,1,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Reference link. Factor references cell with #NULL! error, propagates error. 5 of 5 arguments used.');
		// Case #39: Number(2), Empty, Number(2). Life is empty, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Empty, Number(2). Life is empty, returns #NUM! error. 5 of 5 arguments used.');
		// Case #40: Number(3), Empty, Number. Period is empty, returns #NUM! error. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,6,,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,6,,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Empty, Number. Period is empty, returns #NUM! error. 5 of 5 arguments used.');
		// Case #41: Number(4), Empty. Factor is empty, defaults to 2. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(100000,1000,6,1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(100000,1000,6,1,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4), Empty. Factor is empty, defaults to 2. 5 of 5 arguments used.');

		// Bounded cases:

		// Case #1: Number(5). Maximum accepted values for cost and life. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1E+307,1,1000000,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1E+307,1,1000000,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.999999999991046e+301, 'Test: Bounded case: Number(5). Maximum accepted values for cost and life. 5 of 5 arguments used.');
		// Case #2: Number(5). Minimum accepted positive values. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1,0,1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1,0,1,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(5). Minimum accepted positive values. 5 of 5 arguments used.');
		// Case #3: Number(5). Period equals life boundary case. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(1000000,100000,100,100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(1000000,100000,100,100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2706.5215488725225, 'Test: Bounded case: Number(5). Period equals life boundary case. 5 of 5 arguments used.');
		// Case #4: Area(5). Whole column and row as arguments. 5 of 5 arguments used.
		oParser = new parserFormula('DDB(A:A,100:100,6,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DDB(A:A,100:100,6,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Area(5). Whole column and row as arguments. 5 of 5 arguments used.');

        // Need to fix: empty handle, error types handle, results diff from MS

		testArrayFormula2(assert, "DDB", 4, 5);
	});

	QUnit.test("Test: \"DISC\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("43107");
		ws.getRange2("A101").setValue("54058");
		ws.getRange2("A102").setValue("97.975");
		ws.getRange2("A103").setValue("100");
		ws.getRange2("A104").setValue("1");
		ws.getRange2("A105").setValue("Text");
		ws.getRange2("A106").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 4);
		ws.getRange2("A601").setValue("43107"); // Column1
		ws.getRange2("B601").setValue("54058"); // Column2
		ws.getRange2("C601").setValue("97.975"); // Column3
		ws.getRange2("D601").setValue("100"); // Column4
		ws.getRange2("E601").setValue("1"); // Column5
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("43107");
		ws2.getRange2("A2").setValue("54058");
		ws2.getRange2("A3").setValue("97.975");
		ws2.getRange2("A4").setValue("100");
		ws2.getRange2("A5").setValue("1");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("43107"); // TestName
		ws.getRange2("A202").setValue("54058"); // TestName1
		ws.getRange2("A203").setValue("97.975"); // TestName2
		ws.getRange2("A204").setValue("100"); // TestName3
		ws.getRange2("A205").setValue("1"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("43107") // TestName3D
		ws2.getRange2("A12").setValue("54058") // TestName3D1
		ws2.getRange2("A13").setValue("97.975") // TestName3D2
		ws2.getRange2("A14").setValue("100") // TestName3D3
		ws2.getRange2("A15").setValue("1") // TestName3D4

		// Positive cases:

		// Case #1: Formula(2), Number(3). Return 0.052420213
		oParser = new parserFormula('DISC(DATE(2007,1,25),DATE(2007,6,15),97.975,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(DATE(2007,1,25),DATE(2007,6,15),97.975,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.052420213', 'Test: Positive case: Formula(2), Number(3). Return 0.052420213');
		// Case #2: Formula(2), Number(3). Settlement and maturity as DATE formula, all 5 arguments used.
		oParser = new parserFormula('DISC(DATE(2018,7,1),DATE(2048,1,1),97.975,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(DATE(2018,7,1),DATE(2048,1,1),97.975,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000686384', 'Test: Positive case: Formula(2), Number(3). Settlement and maturity as DATE formula, all 5 arguments used.');
		// Case #3: Number(5). All arguments as serial numbers, basis 0 (US 30/360).
		oParser = new parserFormula('DISC(43282,53918,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000695412', 'Test: Positive case: Number(5). All arguments as serial numbers, basis 0 (US 30/360).');
		// Case #4: Number(5). Basis 2 (Actual/360).
		oParser = new parserFormula('DISC(43282,53918,95.5,100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,95.5,100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.001523129', 'Test: Positive case: Number(5). Basis 2 (Actual/360).');
		// Case #5: String(2), Number(3). Settlement and maturity as date strings, basis 3 (Actual/365).
		oParser = new parserFormula('DISC("07/01/2018","01/01/2048",98.5,100,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC("07/01/2018","01/01/2048",98.5,100,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000508073', 'Test: Positive case: String(2), Number(3). Settlement and maturity as date strings, basis 3 (Actual/365).');
		// Case #6: Number(4), Empty. Basis omitted (default to 0), 5 of 5 arguments used.
		oParser = new parserFormula('DISC(43282,53918,97.975,100,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,100,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000695412', 'Test: Positive case: Number(4), Empty. Basis omitted (default to 0), 5 of 5 arguments used.');
		// Case #7: Reference link(5). All arguments as reference links.
		oParser = new parserFormula('DISC(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000675416', 'Test: Positive case: Reference link(5). All arguments as reference links.');
		// Case #8: String(4), Number. Pr and redemption as numeric strings, basis 4 (European 30/360).
		oParser = new parserFormula('DISC("07/01/2018","01/01/2048","97.975","100",4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC("07/01/2018","01/01/2048","97.975","100",4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000686441', 'Test: Positive case: String(4), Number. Pr and redemption as numeric strings, basis 4 (European 30/360).');
		// Case #9: Number(5). Float numbers truncated to integers for settlement, maturity, basis.
		oParser = new parserFormula('DISC(43282.7,53918.9,97.975,100,1.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282.7,53918.9,97.975,100,1.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000695372', 'Test: Positive case: Number(5). Float numbers truncated to integers for settlement, maturity, basis.');
		// Case #10: Formula(4), Number. Nested formulas for pr and redemption.
		oParser = new parserFormula('DISC(DATE(2020,1,1),DATE(2025,1,1),ROUND(97.9751,2),INT(100.5),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(DATE(2020,1,1),DATE(2025,1,1),ROUND(97.9751,2),INT(100.5),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '0.00404', 'Test: Positive case: Formula(4), Number. Nested formulas for pr and redemption.');
		// Case #11: Number, Formula, Number(3). Maturity as DATE formula, settlement as number.
		oParser = new parserFormula('DISC(43282,DATE(2048,1,1),97.975,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,DATE(2048,1,1),97.975,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000686384', 'Test: Positive case: Number, Formula, Number(3). Maturity as DATE formula, settlement as number.');
		// Case #12: Formula(2), Number(3). Settlement with nested IF formula.
		oParser = new parserFormula('DISC(IF(TRUE,DATE(2018,7,1),DATE(2017,1,1)),DATE(2048,1,1),97.975,100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(IF(TRUE,DATE(2018,7,1),DATE(2017,1,1)),DATE(2048,1,1),97.975,100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000676503', 'Test: Positive case: Formula(2), Number(3). Settlement with nested IF formula.');
		// Case #13: Name(5). All arguments as defined names.
		oParser = new parserFormula('DISC(TestName,TestName1,TestName2,TestName3,TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(TestName,TestName1,TestName2,TestName3,TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000675416', 'Test: Positive case: Name(5). All arguments as defined names.');
		// Case #14: Name3D(5). All arguments as 3D defined names.
		oParser = new parserFormula('DISC(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000675416', 'Test: Positive case: Name3D(5). All arguments as 3D defined names.');
		// Case #15: Ref3D(5). All arguments as 3D references.
		oParser = new parserFormula('DISC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000675416', 'Test: Positive case: Ref3D(5). All arguments as 3D references.');
		// Case #16: Table(5). All arguments as table references.
		oParser = new parserFormula('DISC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000675416', 'Test: Positive case: Table(5). All arguments as table references.');
		// Case #17: Formula(2), Number(3). Settlement and maturity with TIME formula added.
		oParser = new parserFormula('DISC(DATE(2020,1,1)+TIME(12,0,0),DATE(2025,1,1)+TIME(18,30,45),97.975,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(DATE(2020,1,1)+TIME(12,0,0),DATE(2025,1,1)+TIME(18,30,45),97.975,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.004049261', 'Test: Positive case: Formula(2), Number(3). Settlement and maturity with TIME formula added.');
		// Case #18: Number(5). Very low price (pr = 0.01).
		oParser = new parserFormula('DISC(43282,53918,0.01,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,0.01,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '0.03433788', 'Test: Positive case: Number(5). Very low price (pr = 0.01).');
		// Case #19: Number(5). Price very close to redemption.
		oParser = new parserFormula('DISC(43282,53918,99.999,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,99.999,100,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(8), '3.43394e-7', 'Test: Positive case: Number(5). Price very close to redemption.');
		// Case #20: Number(5). Redemption value 150 instead of standard 100.
		oParser = new parserFormula('DISC(43282,53918,50,150,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,50,150,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.022564874', 'Test: Positive case: Number(5). Redemption value 150 instead of standard 100.');
		// Case #21: Formula. DISC as part of SUM formula.
		oParser = new parserFormula('SUM(DISC(DATE(2018,7,1),DATE(2048,1,1),97.975,100,1),0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DISC(DATE(2018,7,1),DATE(2048,1,1),97.975,100,1),0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.050686384', 'Test: Positive case: Formula. DISC as part of SUM formula.');
		// Case #22: Array(5). All arguments as single-element arrays.
		oParser = new parserFormula('DISC({43282},{53918},{97.975},{100},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC({43282},{53918},{97.975},{100},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000695372', 'Test: Positive case: Array(5). All arguments as single-element arrays.');
		// Case #23: Array(5). All arguments as multi-element arrays.
		oParser = new parserFormula('DISC({43282,44000},{53918,54000},{97.975,98},{100,100},{1,2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC({43282,44000},{53918,54000},{97.975,98},{100,100},{1,2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000695372', 'Test: Positive case: Array(5). All arguments as multi-element arrays.');
		// Case #24: Number(5). Settlement and maturity differ by 1 day.
		oParser = new parserFormula('DISC(43282,43283,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,43283,97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '7.29', 'Test: Positive case: Number(5). Settlement and maturity differ by 1 day.');
		// Case #25: Formula(2), Number(3). Settlement with ABS, maturity with INT formulas.
		oParser = new parserFormula('DISC(ABS(-43282),INT(53918.9),97.975,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(ABS(-43282),INT(53918.9),97.975,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.000695372', 'Test: Positive case: Formula(2), Number(3). Settlement with ABS, maturity with INT formulas.');

		// Negative cases:

		// Case #1: Formula(2), Number(3). Settlement >= maturity returns #NUM! error.
		oParser = new parserFormula('DISC(DATE(2048,1,1),DATE(2018,7,1),97.975,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(DATE(2048,1,1),DATE(2018,7,1),97.975,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Settlement >= maturity returns #NUM! error.');
		// Case #2: Number(5). Settlement = maturity returns #NUM! error.
		oParser = new parserFormula('DISC(43282,43282,97.975,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,43282,97.975,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Settlement = maturity returns #NUM! error.');
		// Case #3: Number(5). Negative pr returns #NUM! error.
		oParser = new parserFormula('DISC(43282,53918,-5,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,-5,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Negative pr returns #NUM! error.');
		// Case #4: Number(5). Pr = 0 returns #NUM! error.
		oParser = new parserFormula('DISC(43282,53918,0,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,0,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Pr = 0 returns #NUM! error.');
		// Case #5: Number(5). Negative redemption returns #NUM! error.
		oParser = new parserFormula('DISC(43282,53918,97.975,-10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,-10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Negative redemption returns #NUM! error.');
		// Case #6: Number(5). Redemption = 0 returns #NUM! error.
		oParser = new parserFormula('DISC(43282,53918,97.975,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Redemption = 0 returns #NUM! error.');
		// Case #7: Number(5). Basis = -1 (invalid) returns #NUM! error.
		oParser = new parserFormula('DISC(43282,53918,97.975,100,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,100,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Basis = -1 (invalid) returns #NUM! error.');
		// Case #8: Number(5). Basis = 5 (invalid) returns #NUM! error.
		oParser = new parserFormula('DISC(43282,53918,97.975,100,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,100,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Basis = 5 (invalid) returns #NUM! error.');
		// Case #9: String, Number(4). Settlement as text string returns #VALUE! error.
		oParser = new parserFormula('DISC("text",53918,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC("text",53918,97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(4). Settlement as text string returns #VALUE! error.');
		// Case #10: Number, String, Number(3). Maturity as text string returns #VALUE! error.
		oParser = new parserFormula('DISC(43282,"text",97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,"text",97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(3). Maturity as text string returns #VALUE! error.');
		// Case #11: Number(2), String, Number(2). Pr as text string returns #VALUE! error.
		oParser = new parserFormula('DISC(43282,53918,"text",100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,"text",100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Number(2). Pr as text string returns #VALUE! error.');
		// Case #12: Number(3), String, Number. Redemption as text string returns #VALUE! error.
		oParser = new parserFormula('DISC(43282,53918,97.975,"text",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,"text",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String, Number. Redemption as text string returns #VALUE! error.');
		// Case #13: Error, Number(4). Settlement as error returns #N/A.
		oParser = new parserFormula('DISC(#N/A,53918,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(#N/A,53918,97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(4). Settlement as error returns #N/A.');
		// Case #14: Number, Error, Number(3). Maturity as error returns #N/A.
		oParser = new parserFormula('DISC(43282,#N/A,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,#N/A,97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(3). Maturity as error returns #N/A.');
		// Case #15: Number(2), Error, Number(2). Pr as error returns #VALUE!.
		oParser = new parserFormula('DISC(43282,53918,#VALUE!,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,#VALUE!,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Error, Number(2). Pr as error returns #VALUE!.');
		// Case #16: Number(3), Error, Number. Redemption as error returns #NUM!.
		oParser = new parserFormula('DISC(43282,53918,97.975,#NUM!,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,#NUM!,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Error, Number. Redemption as error returns #NUM!.');
		// Case #17: Number(4), Error. Basis as error returns #DIV/0!.
		oParser = new parserFormula('DISC(43282,53918,97.975,100,#DIV/0!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,100,#DIV/0!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(4), Error. Basis as error returns #DIV/0!.');
		// Case #18: Reference link, Number(4). Settlement reference to text returns #VALUE!.
		oParser = new parserFormula('DISC(A105,53918,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(A105,53918,97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number(4). Settlement reference to text returns #VALUE!.');
		// Case #19: Number, Reference link, Number(3). Maturity reference to text returns #VALUE!.
		oParser = new parserFormula('DISC(43282,A105,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,A105,97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link, Number(3). Maturity reference to text returns #VALUE!.');
		// Case #20: Reference link, Number(4). Settlement reference to error returns #NULL!.
		oParser = new parserFormula('DISC(A106,53918,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(A106,53918,97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number(4). Settlement reference to error returns #NULL!.');
		// Case #21: Number, Reference link, Number(3). Maturity reference to error returns #NULL!.
		oParser = new parserFormula('DISC(43282,A106,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,A106,97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number, Reference link, Number(3). Maturity reference to error returns #NULL!.');
		// Case #22: String(2), Number(3). Invalid date string for settlement returns #VALUE!.
		oParser = new parserFormula('DISC("13/01/2025","01/01/2030",97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC("13/01/2025","01/01/2030",97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(3). Invalid date string for settlement returns #VALUE!.');
		// Case #23: String(2), Number(3). Invalid date string for maturity returns #VALUE!.
		oParser = new parserFormula('DISC("01/01/2020","13/01/2025",97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC("01/01/2020","13/01/2025",97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(3). Invalid date string for maturity returns #VALUE!.');
		// Case #24: Empty, Number(4). Empty settlement converted to 0.
		oParser = new parserFormula('DISC(,53918,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(,53918,97.975,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(4). Empty settlement converted to 0.');
		// Case #25: Number, Empty, Number(3). Empty maturity converted to 0, returns #NUM! (settlement >= maturity).
		oParser = new parserFormula('DISC(43282,,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,,97.975,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number(3). Empty maturity converted to 0, returns #NUM! (settlement >= maturity).');
		// Case #26: Number(2), Empty, Number(2). Empty pr converted to 0, returns #NUM! error.
		oParser = new parserFormula('DISC(43282,53918,,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty, Number(2). Empty pr converted to 0, returns #NUM! error.');
		// Case #27: Number(3), Empty, Number. Empty redemption converted to 0, returns #NUM! error.
		oParser = new parserFormula('DISC(43282,53918,97.975,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Empty, Number. Empty redemption converted to 0, returns #NUM! error.');
		// Case #28: String(5). All empty strings return #VALUE! error.
		oParser = new parserFormula('DISC("","","","","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC("","","","","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). All empty strings return #VALUE! error.');
		// Case #29: String(2), Number(3). Empty string for settlement returns #VALUE!.
		oParser = new parserFormula('DISC("","01/01/2048",97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC("","01/01/2048",97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(3). Empty string for settlement returns #VALUE!.');
		// Case #30: String(2), Number(3). Empty string for maturity returns #VALUE!.
		oParser = new parserFormula('DISC("07/01/2018","",97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC("07/01/2018","",97.975,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(3). Empty string for maturity returns #VALUE!.');
		// Case #31: Number(2), String, Number(2). Empty string for pr returns #VALUE!.
		oParser = new parserFormula('DISC(43282,53918,"",100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,"",100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Number(2). Empty string for pr returns #VALUE!.');
		// Case #32: Number(3), String, Number. Empty string for redemption returns #VALUE!.
		oParser = new parserFormula('DISC(43282,53918,97.975,"",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,"",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String, Number. Empty string for redemption returns #VALUE!.');
		// Case #33: Number(4), String. Empty string for basis returns #VALUE!.
		oParser = new parserFormula('DISC(43282,53918,97.975,100,"")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,100,"") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), String. Empty string for basis returns #VALUE!.');
		// Case #34: Boolean, Number(4). Boolean FALSE converted to 0 for settlement.
		oParser = new parserFormula('DISC(FALSE,53918,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(FALSE,53918,97.975,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(4). Boolean FALSE converted to 0 for settlement.');
		// Case #35: Number, Boolean, Number(3). Boolean TRUE converted to 1 for maturity, settlement > maturity.
		oParser = new parserFormula('DISC(43282,TRUE,97.975,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,TRUE,97.975,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(3). Boolean TRUE converted to 1 for maturity, settlement > maturity.');
		// Case #36: Number(3), Boolean(2). Boolean TRUE (redemption=1), FALSE (basis=0).
		oParser = new parserFormula('DISC(43282,53918,97.975,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,97.975,TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Boolean(2). Boolean TRUE (redemption=1), FALSE (basis=0).');
		// Case #37: Area3D(5). All arguments as 3D areas.
		oParser = new parserFormula('DISC(Sheet2!A1:A2,Sheet2!A2:A3,Sheet2!A3:A4,Sheet2!A4:A5,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(Sheet2!A1:A2,Sheet2!A2:A3,Sheet2!A3:A4,Sheet2!A4:A5,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(5). All arguments as 3D areas.');

		// Bounded cases:

		// Case #1: Formula(2), Number(3). Minimum date 1900-01-01 for settlement.
		oParser = new parserFormula('DISC(DATE(1900,1,1),DATE(1900,1,2),50,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(DATE(1900,1,1),DATE(1900,1,2),50,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Bounded case: Formula(2), Number(3). Minimum date 1900-01-01 for settlement.');
		// Case #2: Formula(2), Number(3). Maximum date 9999-12-31 for maturity.
		oParser = new parserFormula('DISC(DATE(9998,12,31),DATE(9999,12,31),50,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(DATE(9998,12,31),DATE(9999,12,31),50,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Bounded case: Formula(2), Number(3). Maximum date 9999-12-31 for maturity.');
		// Case #3: Number(5). Minimum serial numbers 1 and 2.
		oParser = new parserFormula('DISC(1,2,50,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(1,2,50,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 180, 'Test: Bounded case: Number(5). Minimum serial numbers 1 and 2.');
		// Case #4: Number(5). Maximum serial number for maturity (9999-12-31).
		oParser = new parserFormula('DISC(1,2958465,50,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(1,2958465,50,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.00006172837389287589, 'Test: Bounded case: Number(5). Maximum serial number for maturity (9999-12-31).');
		// Case #5: Number(5). Very small pr value.
		oParser = new parserFormula('DISC(43282,53918,1E-10,100,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,1E-10,100,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03434131450917104, 'Test: Bounded case: Number(5). Very small pr value.');
		// Case #6: Number(5). Very large redemption value.
		oParser = new parserFormula('DISC(43282,53918,0.001,1E+10,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(43282,53918,0.001,1E+10,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03431741256110977, 'Test: Bounded case: Number(5). Very large redemption value.');
		// Case #7: Area(5). Whole columns as arguments (intersection values used).
		oParser = new parserFormula('DISC(A:A,B:B,C:C,D:D,E:E)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(A:A,B:B,C:C,D:D,E:E) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area(5). Whole columns as arguments (intersection values used).');
		// Case #8: Area(5). Whole rows as arguments (intersection values used).
		oParser = new parserFormula('DISC(100:100,101:101,102:102,103:103,104:104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DISC(100:100,101:101,102:102,103:103,104:104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area(5). Whole rows as arguments (intersection values used).');

        // Need to fix: empty handle, error type diff, results diff from MS
        // Case #19: Number(5). Price very close to redemption.
        // Case #24: Empty, Number(4). Empty settlement converted to 0.
        // Case #25: Number, Empty, Number(3). Empty maturity converted to 0, returns #NUM! (settlement >= maturity).
        // Case #26: Number(2), Empty, Number(2). Empty pr converted to 0, returns #NUM! error.
        // Case #27: Number(3), Empty, Number. Empty redemption converted to 0, returns #NUM! error.
        // Case #34: Boolean, Number(4). Boolean FALSE converted to 0 for settlement.
        // Case #35: Number, Boolean, Number(3). Boolean TRUE converted to 1 for maturity, settlement > maturity.
        // Case #36: Number(3), Boolean(2). Boolean TRUE (redemption=1), FALSE (basis=0).
        // Case #7: Area(5). Whole columns as arguments (intersection values used).
        // Case #8: Area(5). Whole rows as arguments (intersection values used).

		testArrayFormula2(assert, "DISC", 4, 5, true);
	});

	QUnit.test("Test: \"DOLLARDE\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1.02");
		ws.getRange2("A101").setValue("16");
		ws.getRange2("A102").setValue("1.02");
		ws.getRange2("A103").setValue("1.1");
		ws.getRange2("A104").setValue("16");
		ws.getRange2("A105").setValue("32");
		ws.getRange2("A106").setValue("text");
		ws.getRange2("A107").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.02"); // Column1
		ws.getRange2("B601").setValue("16"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1.02");
		ws2.getRange2("A2").setValue("16");
		ws2.getRange2("A3").setValue("1.02");
		ws2.getRange2("A4").setValue("1.1");
		ws2.getRange2("A5").setValue("16");
		ws2.getRange2("A6").setValue("32");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1.02"); // TestName
		ws.getRange2("A202").setValue("16"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1.02") // TestName3D
		ws2.getRange2("A12").setValue("16") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Return 1.125
		oParser = new parserFormula('DOLLARDE(1.02,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: Number(2). Return 1.125');
		// Case #2: Number(2). Return 1.3125
		oParser = new parserFormula('DOLLARDE(1.1,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.1,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '1.3125', 'Test: Positive case: Number(2). Return 1.3125');
		// Case #3: Number(2). Converts 1.5, read as 1 and 5/8, to decimal number. Return 1.625
		oParser = new parserFormula('DOLLARDE(1.5,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.5,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.625', 'Test: Positive case: Number(2). Converts 1.5, read as 1 and 5/8, to decimal number. Return 1.625');
		// Case #4: Number(2). Converts 2.3, read as 2 and 3/4, to decimal number. Return 2.75
		oParser = new parserFormula('DOLLARDE(2.3,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(2.3,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '2.75', 'Test: Positive case: Number(2). Converts 2.3, read as 2 and 3/4, to decimal number. Return 2.75');
		// Case #5: Number(2). Converts 0.5, read as 0 and 5/32, to decimal number. Return 1.5625
		oParser = new parserFormula('DOLLARDE(0.5,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(0.5,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '1.5625', 'Test: Positive case: Number(2). Converts 0.5, read as 0 and 5/32, to decimal number. Return 1.5625');
		// Case #6: Number(2). Converts integer 10 with no fractional part. Return 10
		oParser = new parserFormula('DOLLARDE(10,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(10,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(2). Converts integer 10 with no fractional part. Return 10');
		// Case #7: Number(2). Zero value with fraction 32. Return 0
		oParser = new parserFormula('DOLLARDE(0,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(0,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero value with fraction 32. Return 0');
		// Case #8: Number(2). Negative fractional_dollar, read as -1 and 2/16. Return -1.125
		oParser = new parserFormula('DOLLARDE(-1.02,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(-1.02,16) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(3), '-1.125', 'Test: Positive case: Number(2). Negative fractional_dollar, read as -1 and 2/16. Return -1.125');
		// Case #9: Number(2). Negative fractional_dollar, read as -5 and 5/8. Return -5.625
		oParser = new parserFormula('DOLLARDE(-5.5,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(-5.5,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(3), '-5.625', 'Test: Positive case: Number(2). Negative fractional_dollar, read as -5 and 5/8. Return -5.625');
		// Case #10: Number(2). Numerator 50 is greater than denominator 32. Return 2.5625 (1 + 50/32)
		oParser = new parserFormula('DOLLARDE(1.50,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.50,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '2.5625', 'Test: Positive case: Number(2). Numerator 50 is greater than denominator 32. Return 2.5625 (1 + 50/32)');
		// Case #11: Number(2). Numerator 99 is greater than denominator 32. Return 4.09375 (1 + 99/32)
		oParser = new parserFormula('DOLLARDE(1.99,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.99,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '4.09375', 'Test: Positive case: Number(2). Numerator 99 is greater than denominator 32. Return 4.09375 (1 + 99/32)');
		// Case #12: Number(2). Numerator 100 is greater than denominator 32. Return 4.125 (1 + 100/32)
		oParser = new parserFormula('DOLLARDE(1.100,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.100,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '1.3125', 'Test: Positive case: Number(2). Numerator 100 is greater than denominator 32. Return 4.125 (1 + 100/32)');
		// Case #13: String, Number. Numeric string converted to number. Return 1.125
		oParser = new parserFormula('DOLLARDE("1.02",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE("1.02",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: String, Number. Numeric string converted to number. Return 1.125');
		// Case #14: Number, String. Fraction as numeric string converted to number. Return 1.125
		oParser = new parserFormula('DOLLARDE(1.02,"16")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,"16") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: Number, String. Fraction as numeric string converted to number. Return 1.125');
		// Case #15: String(2). Both arguments as numeric strings. Return 1.125
		oParser = new parserFormula('DOLLARDE("1.02","16")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE("1.02","16") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: String(2). Both arguments as numeric strings. Return 1.125');
		// Case #16: Number(2). Float fraction 16.9 truncated to 16. Return 1.125
		oParser = new parserFormula('DOLLARDE(1.02,16.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,16.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: Number(2). Float fraction 16.9 truncated to 16. Return 1.125');
		// Case #17: Number(2). Float fraction 32.1 truncated to 32. Return 1.3125
		oParser = new parserFormula('DOLLARDE(1.1,32.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.1,32.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '1.3125', 'Test: Positive case: Number(2). Float fraction 32.1 truncated to 32. Return 1.3125');
		// Case #18: Formula, Number. Nested ROUND formula in first argument. Return 2.875 (1.57 → 1 + 57/16)
		oParser = new parserFormula('DOLLARDE(ROUND(1.567,2),16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(ROUND(1.567,2),16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '4.5625', 'Test: Positive case: Formula, Number. Nested ROUND formula in first argument. Return 2.875 (1.57 → 1 + 57/16)');
		// Case #19: Number, Formula. Nested ROUND formula in fraction argument. Return 1.117647 (1 + 2/17)
		oParser = new parserFormula('DOLLARDE(1.02,ROUND(16.8,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,ROUND(16.8,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.117647059', 'Test: Positive case: Number, Formula. Nested ROUND formula in fraction argument. Return 1.117647 (1 + 2/17)');
		// Case #20: Formula(2). Both arguments using nested formulas. Return 1.125
		oParser = new parserFormula('DOLLARDE(ABS(-1.02),INT(16.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(ABS(-1.02),INT(16.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: Formula(2). Both arguments using nested formulas. Return 1.125');
		// Case #21: Formula. DOLLARDE as part of ROUND formula. Return 1.3125
		oParser = new parserFormula('ROUND(DOLLARDE(1.1,32),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ROUND(DOLLARDE(1.1,32),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '1.3125', 'Test: Positive case: Formula. DOLLARDE as part of ROUND formula. Return 1.3125');
		// Case #22: Formula. DOLLARDE as part of SUM formula. Return 2.4375
		oParser = new parserFormula('SUM(DOLLARDE(1.02,16),DOLLARDE(1.1,32))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DOLLARDE(1.02,16),DOLLARDE(1.1,32)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '2.4375', 'Test: Positive case: Formula. DOLLARDE as part of SUM formula. Return 2.4375');
		// Case #23: Formula. DOLLARDE in IF condition. Return "Greater"
		oParser = new parserFormula('IF(DOLLARDE(1.02,16)>1,"Greater","Less")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(DOLLARDE(1.02,16)>1,"Greater","Less") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'Greater', 'Test: Positive case: Formula. DOLLARDE in IF condition. Return "Greater"');
		// Case #24: Reference link(2). Both arguments as reference links to 1.02 and 16. Return 1.125
		oParser = new parserFormula('DOLLARDE(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: Reference link(2). Both arguments as reference links to 1.02 and 16. Return 1.125');
		// Case #25: Name(2). Both arguments as defined names to 2.3 and 4. Return 2.75
		oParser = new parserFormula('DOLLARDE(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: Name(2). Both arguments as defined names to 2.3 and 4. Return 2.75');
		// Case #26: Name3D(2). Both arguments as 3D defined names to 0.5 and 32. Return 0.15625
		oParser = new parserFormula('DOLLARDE(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: Name3D(2). Both arguments as 3D defined names to 0.5 and 32. Return 0.15625');
		// Case #27: Ref3D(2). Both arguments as 3D references to 1.5 and 8. Return 1.625
		oParser = new parserFormula('DOLLARDE(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: Ref3D(2). Both arguments as 3D references to 1.5 and 8. Return 1.625');
		// Case #28: Table(2). Both arguments as table references to 1.02 and 16. Return 1.125
		oParser = new parserFormula('DOLLARDE(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.125', 'Test: Positive case: Table(2). Both arguments as table references to 1.02 and 16. Return 1.125');
		// Case #29: Number(2). Standard financial fraction with base 32. Return 1.96875
		oParser = new parserFormula('DOLLARDE(1.31,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.31,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '1.96875', 'Test: Positive case: Number(2). Standard financial fraction with base 32. Return 1.96875');
		// Case #30: Number(2). Standard financial fraction with base 64. Return 1.984375
		oParser = new parserFormula('DOLLARDE(1.63,64)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.63,64) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6), '1.984375', 'Test: Positive case: Number(2). Standard financial fraction with base 64. Return 1.984375');
		// Case #31: Number(2). Standard financial fraction with base 128. Return 1.9921875
		oParser = new parserFormula('DOLLARDE(1.127,128)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.127,128) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '1.9921875', 'Test: Positive case: Number(2). Standard financial fraction with base 128. Return 1.9921875');
		// Case #32: Number(2). Fraction base 100 for decimal representation. Return 1.75
		oParser = new parserFormula('DOLLARDE(1.75,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.75,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.75', 'Test: Positive case: Number(2). Fraction base 100 for decimal representation. Return 1.75');
		// Case #33: Number(2). Fraction base 10 for decimal tenths. Return 1.9
		oParser = new parserFormula('DOLLARDE(1.9,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.9,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.9', 'Test: Positive case: Number(2). Fraction base 10 for decimal tenths. Return 1.9');
		// Case #34: Number(2). Large fraction base 500. Return 1.5
		oParser = new parserFormula('DOLLARDE(1.250,500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.250,500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.5', 'Test: Positive case: Number(2). Large fraction base 500. Return 1.5');

		// Negative cases:

		// Case #1: String, Number. Non-numeric string returns #VALUE! error
		oParser = new parserFormula('DOLLARDE("text",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE("text",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string returns #VALUE! error');
		// Case #2: Number, String. Non-numeric string in fraction returns #VALUE! error
		oParser = new parserFormula('DOLLARDE(1.02,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string in fraction returns #VALUE! error');
		// Case #3: String(2). Both arguments as non-numeric strings return #VALUE! error
		oParser = new parserFormula('DOLLARDE("text","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE("text","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Both arguments as non-numeric strings return #VALUE! error');
		// Case #4: Error, Number. First argument as error returns #N/A
		oParser = new parserFormula('DOLLARDE(#N/A,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(#N/A,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. First argument as error returns #N/A');
		// Case #5: Number, Error. Fraction argument as error returns #N/A
		oParser = new parserFormula('DOLLARDE(1.02,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Fraction argument as error returns #N/A');
		// Case #6: Error(2). Both arguments as errors, first error returned #VALUE!
		oParser = new parserFormula('DOLLARDE(#VALUE!,#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(#VALUE!,#NUM!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error(2). Both arguments as errors, first error returned #VALUE!');
		// Case #7: Reference link, Number. Reference to cell with text returns #VALUE!
		oParser = new parserFormula('DOLLARDE(A106,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(A106,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to cell with text returns #VALUE!');
		// Case #8: Number, Reference link. Fraction reference to cell with text returns #VALUE!
		oParser = new parserFormula('DOLLARDE(1.02,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Fraction reference to cell with text returns #VALUE!');
		// Case #9: Reference link, Number. Reference to cell with error returns #NULL!
		oParser = new parserFormula('DOLLARDE(A107,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(A107,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number. Reference to cell with error returns #NULL!');
		// Case #10: Number, Reference link. Fraction reference to cell with error returns #NULL!
		oParser = new parserFormula('DOLLARDE(1.02,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number, Reference link. Fraction reference to cell with error returns #NULL!');
		// Case #11: Number(2). Negative fraction returns #NUM! error
		oParser = new parserFormula('DOLLARDE(1.02,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative fraction returns #NUM! error');
		// Case #12: Number(2). Negative fraction -1 returns #NUM! error
		oParser = new parserFormula('DOLLARDE(1.02,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative fraction -1 returns #NUM! error');
		// Case #13: Number(2). Fraction equals 0 returns #DIV/0! error
		oParser = new parserFormula('DOLLARDE(1.02,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Fraction equals 0 returns #DIV/0! error');
		// Case #14: Number(2). Fraction 0.5 truncates to 0, returns #DIV/0! error
		oParser = new parserFormula('DOLLARDE(1.02,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Fraction 0.5 truncates to 0, returns #DIV/0! error');
		// Case #15: Number(2). Fraction 0.9 truncates to 0, returns #DIV/0! error
		oParser = new parserFormula('DOLLARDE(1.02,0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,0.9) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Fraction 0.9 truncates to 0, returns #DIV/0! error');
		// Case #16: String, Number. Invalid numeric string format returns #VALUE! error
		oParser = new parserFormula('DOLLARDE("1.02.5",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE("1.02.5",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Invalid numeric string format returns #VALUE! error');
		// Case #17: Boolean, Boolean. FALSE and TRUE convert to 0 and 1. Return 0
		oParser = new parserFormula('DOLLARDE(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(FALSE,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Boolean. FALSE and TRUE convert to 0 and 1. Return 0');
		// Case #18: Boolean, Boolean. TRUE and FALSE convert to 1 and 0, fraction 0 causes #DIV/0!
		oParser = new parserFormula('DOLLARDE(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Boolean. TRUE and FALSE convert to 1 and 0, fraction 0 causes #DIV/0!');
		// Case #19: Empty, Number. Empty fractional_dollar converted to 0. Return 0
		oParser = new parserFormula('DOLLARDE(,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(,32) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. Empty fractional_dollar converted to 0. Return 0');
		// Case #20: Number, Boolean. Boolean TRUE converted to 1. Return 3 (1 + 2/1)
		oParser = new parserFormula('DOLLARDE(1.02,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Boolean TRUE converted to 1. Return 3 (1 + 2/1)');
		// Case #21: Number, Boolean. Boolean FALSE converted to 0, causes #DIV/0! error
		oParser = new parserFormula('DOLLARDE(1.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.5,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Boolean FALSE converted to 0, causes #DIV/0! error');
		// Case #22: Boolean, Number. Boolean TRUE converted to 1. Return 1
		oParser = new parserFormula('DOLLARDE(TRUE,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(TRUE,32) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean TRUE converted to 1. Return 1');
		// Case #23: Boolean, Number. Boolean FALSE converted to 0. Return 0
		oParser = new parserFormula('DOLLARDE(FALSE,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(FALSE,32) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE converted to 0. Return 0');
		// Case #24: Area, Number. First argument as area range to 1.1. Return 1.3125
		oParser = new parserFormula('DOLLARDE(A102:A103,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(A102:A103,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. First argument as area range to 1.1. Return 1.3125');
		// Case #25: Number, Area. Second argument as area range to 8. Return 1.625
		oParser = new parserFormula('DOLLARDE(1.5,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.5,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Second argument as area range to 8. Return 1.625');
		// Case #26: Area3D, Number. First argument as 3D area to 1.02. Return 1.125
		oParser = new parserFormula('DOLLARDE(Sheet2!A3:A4,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(Sheet2!A3:A4,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number. First argument as 3D area to 1.02. Return 1.125');
		// Case #27: Number, Area3D. Second argument as 3D area to 32. Return 1.3125
		oParser = new parserFormula('DOLLARDE(1.1,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.1,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D. Second argument as 3D area to 32. Return 1.3125');

		// Bounded cases:

		// Case #1: Number(2). Minimum fraction value 1. Return 3 (1 + 2/1)
		oParser = new parserFormula('DOLLARDE(1.02,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.02, 'Test: Bounded case: Number(2). Minimum fraction value 1. Return 3 (1 + 2/1)');
		// Case #2: Number(2). Maximum fraction value 32767. Return 1.00006103...
		oParser = new parserFormula('DOLLARDE(1.02,32767)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1.02,32767) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0610370189519944, 'Test: Bounded case: Number(2). Maximum fraction value 32767. Return 1.00006103...');
		// Case #3: Number(2). Maximum possible number in Excel. Return 1E+307
		oParser = new parserFormula('DOLLARDE(1E+307,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(1E+307,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Number(2). Maximum possible number in Excel. Return 1E+307');
		// Case #4: Number(2). Minimum possible number in Excel. Return -1E+307
		oParser = new parserFormula('DOLLARDE(-1E+307,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(-1E+307,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+307, 'Test: Bounded case: Number(2). Minimum possible number in Excel. Return -1E+307');
		// Case #5: Number(2). Very large fraction base for precision testing. Return 0.99999
		oParser = new parserFormula('DOLLARDE(0.99999,100000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(0.99999,100000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.99999, 'Test: Bounded case: Number(2). Very large fraction base for precision testing. Return 0.99999');
		// Case #6: Area(2). Whole column and row as arguments. Return value from intersection
		oParser = new parserFormula('DOLLARDE(A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARDE(A:A,100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area(2). Whole column and row as arguments. Return value from intersection');

        // TODO
        // Need to fix: results diff from MS, error type diff
        // Case #8: Number(2). Negative fractional_dollar, read as -1 and 2/16. Return -1.125
        // Case #9: Number(2). Negative fractional_dollar, read as -5 and 5/8. Return -5.625
        // Case #14: Number(2). Fraction 0.5 truncates to 0, returns #DIV/0! error
        // Case #15: Number(2). Fraction 0.9 truncates to 0, returns #DIV/0! error
        // Case #17: Boolean, Boolean. FALSE and TRUE convert to 0 and 1. Return 0
        // Case #18: Boolean, Boolean. TRUE and FALSE convert to 1 and 0, fraction 0 causes #DIV/0!
        // Case #19: Empty, Number. Empty fractional_dollar converted to 0. Return 0
        // Case #20: Number, Boolean. Boolean TRUE converted to 1. Return 3 (1 + 2/1)
        // Case #21: Number, Boolean. Boolean FALSE converted to 0, causes #DIV/0! error
        // Case #22: Boolean, Number. Boolean TRUE converted to 1. Return 1
        // Case #23: Boolean, Number. Boolean FALSE converted to 0. Return 0
        // Case #6: Area(2). Whole column and row as arguments. Return value from intersection

		testArrayFormula2(assert, "DOLLARDE", 2, 2, true);
	});

	QUnit.test("Test: \"DOLLARFR\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1.125");
		ws.getRange2("A101").setValue("16");
		ws.getRange2("A102").setValue("1.125");
		ws.getRange2("A103").setValue("1.3125");
		ws.getRange2("A104").setValue("16");
		ws.getRange2("A105").setValue("32");
		ws.getRange2("A106").setValue("text");
		ws.getRange2("A107").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.125"); // Column1
		ws.getRange2("B601").setValue("16"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1.125");
		ws2.getRange2("A2").setValue("16");
		ws2.getRange2("A3").setValue("1.125");
		ws2.getRange2("A4").setValue("1.3125");
		ws2.getRange2("A5").setValue("16");
		ws2.getRange2("A6").setValue("32");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1.125"); // TestName
		ws.getRange2("A202").setValue("16"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1.125") // TestName3D
		ws2.getRange2("A12").setValue("16") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Return 1.02
		oParser = new parserFormula('DOLLARFR(1.125,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: Number(2). Return 1.02');
		// Case #2: Number(2). Return 1.04
		oParser = new parserFormula('DOLLARFR(1.125,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.04', 'Test: Positive case: Number(2). Return 1.04');
		// Case #3: Number(2). Return 1.1
		oParser = new parserFormula('DOLLARFR(1.3125,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.3125,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.1', 'Test: Positive case: Number(2). Return 1.1');
		// Case #4: Number(2). Converts 1.625 decimal to 1 and 5/8 fractional format. Return 1.5
		oParser = new parserFormula('DOLLARFR(1.625,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.625,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.5', 'Test: Positive case: Number(2). Converts 1.625 decimal to 1 and 5/8 fractional format. Return 1.5');
		// Case #5: Number(2). Converts 2.75 decimal to 2 and 3/4 fractional format. Return 2.3
		oParser = new parserFormula('DOLLARFR(2.75,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(2.75,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '2.3', 'Test: Positive case: Number(2). Converts 2.75 decimal to 2 and 3/4 fractional format. Return 2.3');
		// Case #6: Number(2). Converts 0.15625 decimal to 0 and 5/32 fractional format. Return 0.5
		oParser = new parserFormula('DOLLARFR(0.15625,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(0.15625,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.05', 'Test: Positive case: Number(2). Converts 0.15625 decimal to 0 and 5/32 fractional format. Return 0.5');
		// Case #7: Number(2). Converts integer 10 with no fractional part. Return 10
		oParser = new parserFormula('DOLLARFR(10,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(10,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(2). Converts integer 10 with no fractional part. Return 10');
		// Case #8: Number(2). Zero value with fraction 32. Return 0
		oParser = new parserFormula('DOLLARFR(0,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(0,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Zero value with fraction 32. Return 0');
		// Case #9: Number(2). Negative decimal_dollar converts to -1 and 2/16 fractional. Return -1.02
		oParser = new parserFormula('DOLLARFR(-1.125,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(-1.125,16) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(2), '-1.02', 'Test: Positive case: Number(2). Negative decimal_dollar converts to -1 and 2/16 fractional. Return -1.02');
		// Case #10: Number(2). Negative decimal_dollar converts to -5 and 5/8 fractional. Return -5.5
		oParser = new parserFormula('DOLLARFR(-5.625,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(-5.625,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(1), '-5.5', 'Test: Positive case: Number(2). Negative decimal_dollar converts to -5 and 5/8 fractional. Return -5.5');
		// Case #11: Number(2). Decimal with numerator greater than denominator. Return 1.5 (50/32 where 50 > 32)
		oParser = new parserFormula('DOLLARFR(2.5625,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(2.5625,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '2.18', 'Test: Positive case: Number(2). Decimal with numerator greater than denominator. Return 1.5 (50/32 where 50 > 32)');
		// Case #12: Number(2). Decimal with large numerator. Return 1.99 (99/32 where 99 > 32)
		oParser = new parserFormula('DOLLARFR(4.09375,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(4.09375,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '4.03', 'Test: Positive case: Number(2). Decimal with large numerator. Return 1.99 (99/32 where 99 > 32)');
		// Case #13: Number(2). Decimal converts to fractional format. Return 1.1 (10/32)
		oParser = new parserFormula('DOLLARFR(1.3125,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.3125,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.1', 'Test: Positive case: Number(2). Decimal converts to fractional format. Return 1.1 (10/32)');
		// Case #14: String, Number. Numeric string converted to number. Return 1.02
		oParser = new parserFormula('DOLLARFR("1.125",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR("1.125",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: String, Number. Numeric string converted to number. Return 1.02');
		// Case #15: Number, String. Fraction as numeric string converted to number. Return 1.02
		oParser = new parserFormula('DOLLARFR(1.125,"16")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,"16") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: Number, String. Fraction as numeric string converted to number. Return 1.02');
		// Case #16: String(2). Both arguments as numeric strings. Return 1.02
		oParser = new parserFormula('DOLLARFR("1.125","16")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR("1.125","16") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: String(2). Both arguments as numeric strings. Return 1.02');
		// Case #17: Number(2). Float fraction 16.9 truncated to 16. Return 1.02
		oParser = new parserFormula('DOLLARFR(1.125,16.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,16.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: Number(2). Float fraction 16.9 truncated to 16. Return 1.02');
		// Case #18: Number(2). Float fraction 32.1 truncated to 32. Return 1.1
		oParser = new parserFormula('DOLLARFR(1.3125,32.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.3125,32.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.1', 'Test: Positive case: Number(2). Float fraction 32.1 truncated to 32. Return 1.1');
		// Case #19: Formula, Number. Nested ROUND formula in first argument. Return 1.57 (2.875 → 2 + 14/16)
		oParser = new parserFormula('DOLLARFR(ROUND(2.875,3),16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(ROUND(2.875,3),16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '2.14', 'Test: Positive case: Formula, Number. Nested ROUND formula in first argument. Return 1.57 (2.875 → 2 + 14/16)');
		// Case #20: Number, Formula. Nested ROUND formula in fraction argument. Return 1.02 (1.125 with base 17)
		oParser = new parserFormula('DOLLARFR(1.125,ROUND(16.8,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,ROUND(16.8,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5), '1.02125', 'Test: Positive case: Number, Formula. Nested ROUND formula in fraction argument. Return 1.02 (1.125 with base 17)');
		// Case #21: Formula(2). Both arguments using nested formulas. Return 1.02
		oParser = new parserFormula('DOLLARFR(ABS(-1.125),INT(16.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(ABS(-1.125),INT(16.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: Formula(2). Both arguments using nested formulas. Return 1.02');
		// Case #22: Formula. DOLLARFR as part of ROUND formula. Return 1.1
		oParser = new parserFormula('ROUND(DOLLARFR(1.3125,32),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ROUND(DOLLARFR(1.3125,32),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.1', 'Test: Positive case: Formula. DOLLARFR as part of ROUND formula. Return 1.1');
		// Case #23: Formula. DOLLARFR as part of SUM formula. Return 2.12 (1.02 + 1.1)
		oParser = new parserFormula('SUM(DOLLARFR(1.125,16),DOLLARFR(1.3125,32))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DOLLARFR(1.125,16),DOLLARFR(1.3125,32)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '2.12', 'Test: Positive case: Formula. DOLLARFR as part of SUM formula. Return 2.12 (1.02 + 1.1)');
		// Case #24: Formula. DOLLARFR in IF condition. Return "Greater"
		oParser = new parserFormula('IF(DOLLARFR(1.125,16)>1,"Greater","Less")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(DOLLARFR(1.125,16)>1,"Greater","Less") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'Greater', 'Test: Positive case: Formula. DOLLARFR in IF condition. Return "Greater"');
		// Case #25: Reference link(2). Both arguments as reference links to 1.125 and 16. Return 1.02
		oParser = new parserFormula('DOLLARFR(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: Reference link(2). Both arguments as reference links to 1.125 and 16. Return 1.02');
		// Case #26: Name(2). Both arguments as defined names to 2.75 and 4. Return 2.3
		oParser = new parserFormula('DOLLARFR(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: Name(2). Both arguments as defined names to 2.75 and 4. Return 2.3');
		// Case #27: Name3D(2). Both arguments as 3D defined names to 0.15625 and 32. Return 0.5
		oParser = new parserFormula('DOLLARFR(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: Name3D(2). Both arguments as 3D defined names to 0.15625 and 32. Return 0.5');
		// Case #28: Ref3D(2). Both arguments as 3D references to 1.625 and 8. Return 1.5
		oParser = new parserFormula('DOLLARFR(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: Ref3D(2). Both arguments as 3D references to 1.625 and 8. Return 1.5');
		// Case #29: Table(2). Both arguments as table references to 1.125 and 16. Return 1.02
		oParser = new parserFormula('DOLLARFR(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.02', 'Test: Positive case: Table(2). Both arguments as table references to 1.125 and 16. Return 1.02');
		// Case #30: Number(2). Standard financial fraction with base 32. Return 1.31
		oParser = new parserFormula('DOLLARFR(1.96875,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.96875,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.31', 'Test: Positive case: Number(2). Standard financial fraction with base 32. Return 1.31');
		// Case #31: Number(2). Standard financial fraction with base 64. Return 1.63
		oParser = new parserFormula('DOLLARFR(1.984375,64)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.984375,64) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.63', 'Test: Positive case: Number(2). Standard financial fraction with base 64. Return 1.63');
		// Case #32: Number(2). Standard financial fraction with base 128. Return 1.127
		oParser = new parserFormula('DOLLARFR(1.9921875,128)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.9921875,128) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '1.127', 'Test: Positive case: Number(2). Standard financial fraction with base 128. Return 1.127');
		// Case #33: Number(2). Fraction base 100 for decimal representation. Return 1.75
		oParser = new parserFormula('DOLLARFR(1.75,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.75,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.75', 'Test: Positive case: Number(2). Fraction base 100 for decimal representation. Return 1.75');
		// Case #34: Number(2). Fraction base 10 for decimal tenths. Return 1.9
		oParser = new parserFormula('DOLLARFR(1.9,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.9,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '1.9', 'Test: Positive case: Number(2). Fraction base 10 for decimal tenths. Return 1.9');
		// Case #35: Number(2). Large fraction base 500. Return 1.25 (250/500)
		oParser = new parserFormula('DOLLARFR(1.5,500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.5,500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '1.25', 'Test: Positive case: Number(2). Large fraction base 500. Return 1.25 (250/500)');

		// Negative cases:

		// Case #1: String, Number. Non-numeric string returns #VALUE! error
		oParser = new parserFormula('DOLLARFR("text",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR("text",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string returns #VALUE! error');
		// Case #2: Number, String. Non-numeric string in fraction returns #VALUE! error
		oParser = new parserFormula('DOLLARFR(1.125,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string in fraction returns #VALUE! error');
		// Case #3: String(2). Both arguments as non-numeric strings return #VALUE! error
		oParser = new parserFormula('DOLLARFR("text","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR("text","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Both arguments as non-numeric strings return #VALUE! error');
		// Case #4: Error, Number. First argument as error returns #N/A
		oParser = new parserFormula('DOLLARFR(#N/A,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(#N/A,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. First argument as error returns #N/A');
		// Case #5: Number, Error. Fraction argument as error returns #N/A
		oParser = new parserFormula('DOLLARFR(1.125,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Fraction argument as error returns #N/A');
		// Case #6: Error(2). Both arguments as errors, first error returned #VALUE!
		oParser = new parserFormula('DOLLARFR(#VALUE!,#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(#VALUE!,#NUM!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error(2). Both arguments as errors, first error returned #VALUE!');
		// Case #7: Reference link, Number. Reference to cell with text returns #VALUE!
		oParser = new parserFormula('DOLLARFR(A106,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(A106,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to cell with text returns #VALUE!');
		// Case #8: Number, Reference link. Fraction reference to cell with text returns #VALUE!
		oParser = new parserFormula('DOLLARFR(1.125,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Fraction reference to cell with text returns #VALUE!');
		// Case #9: Reference link, Number. Reference to cell with error returns #NULL!
		oParser = new parserFormula('DOLLARFR(A107,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(A107,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number. Reference to cell with error returns #NULL!');
		// Case #10: Number, Reference link. Fraction reference to cell with error returns #NULL!
		oParser = new parserFormula('DOLLARFR(1.125,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number, Reference link. Fraction reference to cell with error returns #NULL!');
		// Case #11: Number(2). Negative fraction returns #NUM! error
		oParser = new parserFormula('DOLLARFR(1.125,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative fraction returns #NUM! error');
		// Case #12: Number(2). Negative fraction -1 returns #NUM! error
		oParser = new parserFormula('DOLLARFR(1.125,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative fraction -1 returns #NUM! error');
		// Case #13: Number(2). Fraction equals 0 returns #DIV/0! error
		oParser = new parserFormula('DOLLARFR(1.125,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Fraction equals 0 returns #DIV/0! error');
		// Case #14: Number(2). Fraction 0.5 truncates to 0, returns #DIV/0! error
		oParser = new parserFormula('DOLLARFR(1.125,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Fraction 0.5 truncates to 0, returns #DIV/0! error');
		// Case #15: Number(2). Fraction 0.9 truncates to 0, returns #DIV/0! error
		oParser = new parserFormula('DOLLARFR(1.125,0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,0.9) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(2). Fraction 0.9 truncates to 0, returns #DIV/0! error');
		// Case #16: String, Number. Invalid numeric string format returns #VALUE! error
		oParser = new parserFormula('DOLLARFR("1.125.5",16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR("1.125.5",16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Invalid numeric string format returns #VALUE! error');
		// Case #17: Boolean, Boolean. FALSE and TRUE convert to 0 and 1. Return 0
		oParser = new parserFormula('DOLLARFR(FALSE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(FALSE,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Boolean. FALSE and TRUE convert to 0 and 1. Return 0');
		// Case #18: Boolean, Boolean. TRUE and FALSE convert to 1 and 0, fraction 0 causes #DIV/0!
		oParser = new parserFormula('DOLLARFR(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Boolean. TRUE and FALSE convert to 1 and 0, fraction 0 causes #DIV/0!');
		// Case #19: Empty, Number. Empty decimal_dollar converted to 0. Return 0
		oParser = new parserFormula('DOLLARFR(,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(,32) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. Empty decimal_dollar converted to 0. Return 0');
		// Case #20: Number, Boolean. Boolean TRUE converted to 1. Return 1.02 (2/1 simplified)
		oParser = new parserFormula('DOLLARFR(1.125,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.125,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Boolean TRUE converted to 1. Return 1.02 (2/1 simplified)');
		// Case #21: Number, Boolean. Boolean FALSE converted to 0, causes #DIV/0! error
		oParser = new parserFormula('DOLLARFR(1.625,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.625,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Boolean FALSE converted to 0, causes #DIV/0! error');
		// Case #22: Boolean, Number. Boolean TRUE converted to 1. Return 1
		oParser = new parserFormula('DOLLARFR(TRUE,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(TRUE,32) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean TRUE converted to 1. Return 1');
		// Case #23: Boolean, Number. Boolean FALSE converted to 0. Return 0
		oParser = new parserFormula('DOLLARFR(FALSE,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(FALSE,32) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE converted to 0. Return 0');
		// Case #24: Area, Number. First argument as area range to 1.3125. Return 1.1
		oParser = new parserFormula('DOLLARFR(A102:A103,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(A102:A103,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. First argument as area range to 1.3125. Return 1.1');
		// Case #25: Number, Area. Second argument as area range to 8. Return 1.5
		oParser = new parserFormula('DOLLARFR(1.625,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.625,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Second argument as area range to 8. Return 1.5');
		// Case #26: Area3D, Number. First argument as 3D area to 1.125. Return 1.02
		oParser = new parserFormula('DOLLARFR(Sheet2!A3:A4,16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(Sheet2!A3:A4,16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number. First argument as 3D area to 1.125. Return 1.02');
		// Case #27: Number, Area3D. Second argument as 3D area to 32. Return 1.1
		oParser = new parserFormula('DOLLARFR(1.3125,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.3125,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D. Second argument as 3D area to 32. Return 1.1');

		// Bounded cases:

		// Case #1: Number(2). Minimum fraction value 1. Return 1.02 (3 = 1 + 2/1, so result is 1.02)
		oParser = new parserFormula('DOLLARFR(3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Bounded case: Number(2). Minimum fraction value 1. Return 1.02 (3 = 1 + 2/1, so result is 1.02)');
		// Case #2: Number(2). Maximum fraction value 32767. Return 1.02
		oParser = new parserFormula('DOLLARFR(1.00006103,32767)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1.00006103,32767) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0000199977000999, 'Test: Bounded case: Number(2). Maximum fraction value 32767. Return 1.02');
		// Case #3: Number(2). Maximum possible number in Excel. Return 1E+307
		oParser = new parserFormula('DOLLARFR(1E+307,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(1E+307,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Number(2). Maximum possible number in Excel. Return 1E+307');
		// Case #4: Number(2). Minimum possible number in Excel. Return -1E+307
		oParser = new parserFormula('DOLLARFR(-1E+307,32)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(-1E+307,32) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1e+307, 'Test: Bounded case: Number(2). Minimum possible number in Excel. Return -1E+307');
		// Case #5: Number(2). Very large fraction base for precision testing. Return 0.99999
		oParser = new parserFormula('DOLLARFR(0.99999,100000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(0.99999,100000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.99999, 'Test: Bounded case: Number(2). Very large fraction base for precision testing. Return 0.99999');
		// Case #6: Area(2). Whole column and row as arguments. Return value from intersection
		oParser = new parserFormula('DOLLARFR(A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DOLLARFR(A:A,100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area(2). Whole column and row as arguments. Return value from intersection');

        // TODO
        // Need to fix: results diff from MS, error types diff
        // Case #9: Number(2). Negative decimal_dollar converts to -1 and 2/16 fractional. Return -1.02
        // Case #10: Number(2). Negative decimal_dollar converts to -5 and 5/8 fractional. Return -5.5
        // Case #14: Number(2). Fraction 0.5 truncates to 0, returns #DIV/0! error
        // Case #15: Number(2). Fraction 0.9 truncates to 0, returns #DIV/0! error
        // Case #17: Boolean, Boolean. FALSE and TRUE convert to 0 and 1. Return 0
        // Case #18: Boolean, Boolean. TRUE and FALSE convert to 1 and 0, fraction 0 causes #DIV/0!
        // Case #19: Empty, Number. Empty decimal_dollar converted to 0. Return 0
        // Case #20: Number, Boolean. Boolean TRUE converted to 1. Return 1.02 (2/1 simplified)
        // Case #21: Number, Boolean. Boolean FALSE converted to 0, causes #DIV/0! error
        // Case #22: Boolean, Number. Boolean TRUE converted to 1. Return 1
        // Case #23: Boolean, Number. Boolean FALSE converted to 0. Return 0
        // Case #6: Area(2). Whole column and row as arguments. Return value from intersection

		testArrayFormula2(assert, "DOLLARFR", 2, 2, true);
	});

	QUnit.test("Test: \"DURATION\"", function (assert) {

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("43107");
		ws.getRange2("A101").setValue("54058");
		ws.getRange2("A102").setValue("0.08");
		ws.getRange2("A103").setValue("0.09");
		ws.getRange2("A104").setValue("2");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A106").setValue("text");
		ws.getRange2("A107").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("43107"); // Column1
		ws.getRange2("B601").setValue("54058"); // Column2
		ws.getRange2("C601").setValue("0.08"); // Column3
		ws.getRange2("D601").setValue("0.09"); // Column4
		ws.getRange2("E601").setValue("2"); // Column5
		ws.getRange2("F601").setValue("1"); // Column6
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("43107");
		ws2.getRange2("A2").setValue("54058");
		ws2.getRange2("A3").setValue("0.08");
		ws2.getRange2("A4").setValue("0.09");
		ws2.getRange2("A5").setValue("2");
		ws2.getRange2("A6").setValue("1");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("43107"); // TestName
		ws.getRange2("A202").setValue("54058"); // TestName1
		ws.getRange2("A203").setValue("0.08"); // TestName2
		ws.getRange2("A204").setValue("0.09"); // TestName3
		ws.getRange2("A205").setValue("1"); // TestName4
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("43107") // TestName3D
		ws2.getRange2("A12").setValue("54058") // TestName3D1
		ws2.getRange2("A13").setValue("0.08") // TestName3D2
		ws2.getRange2("A14").setValue("0.09") // TestName3D3
		ws2.getRange2("A15").setValue("1") // TestName3D4

		// Positive cases:

		// Case #1: Formula(2), Number(4). Return 5.993774956
		oParser = new parserFormula('DURATION(DATE(2008,1,1),DATE(2016,1,1),0.08,0.09,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(2008,1,1),DATE(2016,1,1),0.08,0.09,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '5.993774956', 'Test: Positive case: Formula(2), Number(4). Return 5.993774956');
		// Case #2: Formula(2), Number(4). Settlement and maturity as DATE formula, all 6 arguments used.
		oParser = new parserFormula('DURATION(DATE(2020,1,1),DATE(2025,1,1),0.08,0.09,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(2020,1,1),DATE(2025,1,1),0.08,0.09,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.198878302', 'Test: Positive case: Formula(2), Number(4). Settlement and maturity as DATE formula, all 6 arguments used.');
		// Case #3: Number(6). All arguments as serial numbers, frequency annual, basis 0.
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.531874772', 'Test: Positive case: Number(6). All arguments as serial numbers, frequency annual, basis 0.');
		// Case #4: Number(6). Frequency quarterly, basis 2 (Actual/360).
		oParser = new parserFormula('DURATION(43831,45657,0.1,0.08,4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.1,0.08,4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.037690219', 'Test: Positive case: Number(6). Frequency quarterly, basis 2 (Actual/360).');
		// Case #5: String(2), Number(4). Settlement and maturity as date strings, basis 3 (Actual/365).
		oParser = new parserFormula('DURATION("01/01/2020","01/01/2025",0.075,0.085,2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION("01/01/2020","01/01/2025",0.075,0.085,2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.242305245', 'Test: Positive case: String(2), Number(4). Settlement and maturity as date strings, basis 3 (Actual/365).');
		// Case #6: Number(5), Empty. Basis omitted, 5 of 6 arguments used.
		oParser = new parserFormula('DURATION(43831,45657,0.08,0.09,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.08,0.09,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.196100524', 'Test: Positive case: Number(5), Empty. Basis omitted, 5 of 6 arguments used.');
		// Case #7: Reference link(6). All arguments as reference links.
		oParser = new parserFormula('DURATION(A100,A101,A102,A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(A100,A101,A102,A103,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '10.93652129', 'Test: Positive case: Reference link(6). All arguments as reference links.');
		// Case #8: String(4), Number(2). Coupon and yld as numeric strings, basis 4 (European 30/360).
		oParser = new parserFormula('DURATION("5/15/2021","5/15/2031","0.065","0.075",1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION("5/15/2021","5/15/2031","0.065","0.075",1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '7.56095042', 'Test: Positive case: String(4), Number(2). Coupon and yld as numeric strings, basis 4 (European 30/360).');
		// Case #9: Number(6). Float numbers truncated to integers for settlement, maturity, frequency, basis.
		oParser = new parserFormula('DURATION(44318.5,47118.7,0.055,0.065,2.9,1.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(44318.5,47118.7,0.055,0.065,2.9,1.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '6.186372448', 'Test: Positive case: Number(6). Float numbers truncated to integers for settlement, maturity, frequency, basis.');
		// Case #10: Formula(4), Number(2). Nested formulas for coupon and yld.
		oParser = new parserFormula('DURATION(DATE(2022,6,30),DATE(2027,6,30),ROUND(0.0751,2),SQRT(0.0064),2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(2022,6,30),DATE(2027,6,30),ROUND(0.0751,2),SQRT(0.0064),2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.217665805', 'Test: Positive case: Formula(4), Number(2). Nested formulas for coupon and yld.');
		// Case #11: Number, Formula, Number(4). Maturity as DATE formula, settlement as number.
		oParser = new parserFormula('DURATION(43831,DATE(2025,1,15),0.07,0.08,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,DATE(2025,1,15),0.07,0.08,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.114257477', 'Test: Positive case: Number, Formula, Number(4). Maturity as DATE formula, settlement as number.');
		// Case #12: Formula(2), Number(4). Settlement with nested IF formula.
		oParser = new parserFormula('DURATION(IF(TRUE,DATE(2020,3,1),DATE(2019,1,1)),DATE(2030,3,1),0.09,0.1,2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(IF(TRUE,DATE(2020,3,1),DATE(2019,1,1)),DATE(2030,3,1),0.09,0.1,2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '6.681622814', 'Test: Positive case: Formula(2), Number(4). Settlement with nested IF formula.');
		// Case #13: Name(6). All arguments as defined names.
		oParser = new parserFormula('DURATION(TestName,TestName1,TestName2,TestName3,TestName4,TestName4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(TestName,TestName1,TestName2,TestName3,TestName4,TestName4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '11.35732958', 'Test: Positive case: Name(6). All arguments as defined names.');
		// Case #14: Name3D(6). All arguments as 3D defined names.
		oParser = new parserFormula('DURATION(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4,TestName3D4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D4,TestName3D4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '11.35732958', 'Test: Positive case: Name3D(6). All arguments as 3D defined names.');
		// Case #15: Ref3D(6). All arguments as 3D references.
		oParser = new parserFormula('DURATION(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '10.93652129', 'Test: Positive case: Ref3D(6). All arguments as 3D references.');
		// Case #16: Table(6). All arguments as table references.
		oParser = new parserFormula('DURATION(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column6]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '10.93652129', 'Test: Positive case: Table(6). All arguments as table references.');
		// Case #17: Formula(2), Number(4). Settlement and maturity with TIME formula added.
		oParser = new parserFormula('DURATION(DATE(2023,1,1)+TIME(12,0,0),DATE(2028,1,1)+TIME(18,30,45),0.055,0.065,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(2023,1,1)+TIME(12,0,0),DATE(2028,1,1)+TIME(18,30,45),0.055,0.065,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.424107736', 'Test: Positive case: Formula(2), Number(4). Settlement and maturity with TIME formula added.');
		// Case #18: Number(6). Minimum typical coupon and yld values (0.1%).
		oParser = new parserFormula('DURATION(43831,45657,0.001,0.002,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.001,0.002,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.987212332', 'Test: Positive case: Number(6). Minimum typical coupon and yld values (0.1%).');
		// Case #19: Number(6). Maximum typical coupon (100%) and high yld (95%).
		oParser = new parserFormula('DURATION(43831,45657,1,0.95,4,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,1,0.95,4,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.278909266', 'Test: Positive case: Number(6). Maximum typical coupon (100%) and high yld (95%).');
		// Case #20: Formula. DURATION as part of SUM formula.
		oParser = new parserFormula('SUM(DURATION(DATE(2020,1,1),DATE(2025,1,1),0.08,0.09,2,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DURATION(DATE(2020,1,1),DATE(2025,1,1),0.08,0.09,2,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '14.1988783', 'Test: Positive case: Formula. DURATION as part of SUM formula.');
		// Case #21: Array(6). All arguments as single-element arrays.
		oParser = new parserFormula('DURATION({43831},{45657},{0.05},{0.06},{1},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION({43831},{45657},{0.05},{0.06},{1},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.531874772', 'Test: Positive case: Array(6). All arguments as single-element arrays.');
		// Case #22: Array(6). All arguments as multi-element arrays.
		oParser = new parserFormula('DURATION({43831,44000},{45657,46000},{0.05,0.06},{0.06,0.07},{1,2},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION({43831,44000},{45657,46000},{0.05,0.06},{0.06,0.07},{1,2},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.531874772001797, 'Test: Positive case: Array(6). All arguments as multi-element arrays.');
		// Case #23: Number(6). Settlement and maturity differ by 1 day.
		oParser = new parserFormula('DURATION(43831,43832,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,43832,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.002777778', 'Test: Positive case: Number(6). Settlement and maturity differ by 1 day.');
		// Case #24: Formula(2), Number(4). Settlement with ABS, maturity with INT formulas.
		oParser = new parserFormula('DURATION(ABS(-43831),INT(45657.9),0.08,0.09,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(ABS(-43831),INT(45657.9),0.08,0.09,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '4.19613105', 'Test: Positive case: Formula(2), Number(4). Settlement with ABS, maturity with INT formulas.');

		// Negative cases:

		// Case #1: Formula(2), Number(4). Return #NUM!
		oParser = new parserFormula('DURATION(DATE(2008,1,1),DATE(2016,1,1),-0.08,0.09,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(2008,1,1),DATE(2016,1,1),-0.08,0.09,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(4). Return #NUM!');
		// Case #2: Formula(2), Number(4). Return #NUM!
		oParser = new parserFormula('DURATION(DATE(2008,1,1),DATE(2016,1,1),-0.08,0.09,5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(2008,1,1),DATE(2016,1,1),-0.08,0.09,5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(4). Return #NUM!');
		// Case #3: Formula(2), Number(4). Settlement >= maturity returns #NUM! error.
		oParser = new parserFormula('DURATION(DATE(2025,1,1),DATE(2020,1,1),0.08,0.09,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(2025,1,1),DATE(2020,1,1),0.08,0.09,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(4). Settlement >= maturity returns #NUM! error.');
		// Case #4: Number(6). Settlement = maturity returns #NUM! error.
		oParser = new parserFormula('DURATION(43831,43831,0.08,0.09,2,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,43831,0.08,0.09,2,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Settlement = maturity returns #NUM! error.');
		// Case #5: Number(6). Negative coupon returns #NUM! error.
		oParser = new parserFormula('DURATION(43831,45657,-0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,-0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative coupon returns #NUM! error.');
		// Case #6: Number(6). Negative yld returns #NUM! error.
		oParser = new parserFormula('DURATION(43831,45657,0.05,-0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,-0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative yld returns #NUM! error.');
		// Case #7: Number(6). Frequency = 3 (invalid) returns #NUM! error.
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,3,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,3,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Frequency = 3 (invalid) returns #NUM! error.');
		// Case #8: Number(6). Frequency = 0 (invalid) returns #NUM! error.
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Frequency = 0 (invalid) returns #NUM! error.');
		// Case #9: Number(6). Frequency = 5 (invalid) returns #NUM! error.
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Frequency = 5 (invalid) returns #NUM! error.');
		// Case #10: Number(6). Basis = -1 (invalid) returns #NUM! error.
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,1,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,1,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Basis = -1 (invalid) returns #NUM! error.');
		// Case #11: Number(6). Basis = 5 (invalid) returns #NUM! error.
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Basis = 5 (invalid) returns #NUM! error.');
		// Case #12: String, Number(5). Settlement as text string returns #VALUE! error.
		oParser = new parserFormula('DURATION("text",45657,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION("text",45657,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(5). Settlement as text string returns #VALUE! error.');
		// Case #13: Number, String, Number(4). Maturity as text string returns #VALUE! error.
		oParser = new parserFormula('DURATION(43831,"text",0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,"text",0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(4). Maturity as text string returns #VALUE! error.');
		// Case #14: Number(2), String, Number(3). Coupon as text string returns #VALUE! error.
		oParser = new parserFormula('DURATION(43831,45657,"text",0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,"text",0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String, Number(3). Coupon as text string returns #VALUE! error.');
		// Case #15: Number(3), String, Number(2). Yld as text string returns #VALUE! error.
		oParser = new parserFormula('DURATION(43831,45657,0.05,"text",1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,"text",1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String, Number(2). Yld as text string returns #VALUE! error.');
		// Case #16: Error, Number(5). Settlement as error returns #N/A.
		oParser = new parserFormula('DURATION(#N/A,45657,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(#N/A,45657,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(5). Settlement as error returns #N/A.');
		// Case #17: Number, Error, Number(4). Maturity as error returns #N/A.
		oParser = new parserFormula('DURATION(43831,#N/A,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,#N/A,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error, Number(4). Maturity as error returns #N/A.');
		// Case #18: Number(2), Error, Number(3). Coupon as error returns #VALUE!.
		oParser = new parserFormula('DURATION(43831,45657,#VALUE!,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,#VALUE!,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Error, Number(3). Coupon as error returns #VALUE!.');
		// Case #19: Number(3), Error, Number(2). Yld as error returns #NUM!.
		oParser = new parserFormula('DURATION(43831,45657,0.05,#NUM!,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,#NUM!,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3), Error, Number(2). Yld as error returns #NUM!.');
		// Case #20: Number(4), Error, Number. Frequency as error returns #DIV/0!.
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,#DIV/0!,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,#DIV/0!,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(4), Error, Number. Frequency as error returns #DIV/0!.');
		// Case #21: Number(5), Error. Basis as error returns #REF!.
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,1,#REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,1,#REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Number(5), Error. Basis as error returns #REF!.');
		// Case #22: Reference link, Number(5). Settlement reference to text returns #VALUE!.
		oParser = new parserFormula('DURATION(A106,45657,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(A106,45657,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number(5). Settlement reference to text returns #VALUE!.');
		// Case #23: Number, Reference link, Number(4). Maturity reference to text returns #VALUE!.
		oParser = new parserFormula('DURATION(43831,A106,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,A106,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link, Number(4). Maturity reference to text returns #VALUE!.');
		// Case #24: Reference link, Number(5). Settlement reference to error returns #NULL!.
		oParser = new parserFormula('DURATION(A107,45657,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(A107,45657,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number(5). Settlement reference to error returns #NULL!.');
		// Case #25: Number, Reference link, Number(4). Maturity reference to error returns #NULL!.
		oParser = new parserFormula('DURATION(43831,A107,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,A107,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number, Reference link, Number(4). Maturity reference to error returns #NULL!.');
		// Case #26: String(2), Number(4). Invalid date string for settlement returns #VALUE!.
		oParser = new parserFormula('DURATION("13/01/2025","01/01/2030",0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION("13/01/2025","01/01/2030",0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(4). Invalid date string for settlement returns #VALUE!.');
		// Case #27: String(2), Number(4). Invalid date string for maturity returns #VALUE!.
		oParser = new parserFormula('DURATION("01/01/2020","13/01/2025",0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION("01/01/2020","13/01/2025",0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2), Number(4). Invalid date string for maturity returns #VALUE!.');
		// Case #28: Empty, Number(5). Empty settlement converted to 0, returns #NUM! (settlement >= maturity).
		oParser = new parserFormula('DURATION(,45657,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(,45657,0.05,0.06,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(5). Empty settlement converted to 0, returns #NUM! (settlement >= maturity).');
		// Case #29: Number, Empty, Number(4). Empty maturity converted to 0, returns #NUM! (settlement >= maturity).
		oParser = new parserFormula('DURATION(43831,,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,,0.05,0.06,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number(4). Empty maturity converted to 0, returns #NUM! (settlement >= maturity).');
		// Case #30: Number(2), Empty, Number(3). Empty coupon converted to 0.
		oParser = new parserFormula('DURATION(43831,45657,,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,,0.06,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty, Number(3). Empty coupon converted to 0.');
		// Case #31: Number(3), Empty, Number(2). Empty yld converted to 0.
		oParser = new parserFormula('DURATION(43831,45657,0.05,,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Empty, Number(2). Empty yld converted to 0.');
		// Case #32: Number(4), Empty, Number. Empty frequency converted to 0, returns #NUM! error.
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(4), Empty, Number. Empty frequency converted to 0, returns #NUM! error.');
		// Case #33: String(6). All empty strings return #VALUE! error.
		oParser = new parserFormula('DURATION("","","";"","","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION("","","";"","","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). All empty strings return #VALUE! error.');
		// Case #34: Area, Number(5). Settlement as area (first cell used).
		oParser = new parserFormula('DURATION(A108:A109,45657,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(A108:A109,45657,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(5). Settlement as area (first cell used).');
		// Case #35: Number, Area, Number(4). Maturity as area (first cell used).
		oParser = new parserFormula('DURATION(43831,A108:A109,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,A108:A109,0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(4). Maturity as area (first cell used).');
		// Case #36: Number(4), Empty(2). Frequency and basis omitted (default to 0).
		oParser = new parserFormula('DURATION(43831,45657,0.06,0.07,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.06,0.07,,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(4), Empty(2). Frequency and basis omitted (default to 0).');
		// Case #37: Boolean, Number(5). Boolean FALSE converted to 0 for settlement.
		oParser = new parserFormula('DURATION(FALSE,45657,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(FALSE,45657,0.05,0.06,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(5). Boolean FALSE converted to 0 for settlement.');
		// Case #38: Number, Boolean, Number(4). Boolean TRUE converted to 1 for maturity, settlement > maturity.
		oParser = new parserFormula('DURATION(43831,TRUE,0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,TRUE,0.05,0.06,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean, Number(4). Boolean TRUE converted to 1 for maturity, settlement > maturity.');
		// Case #39: Number(4), Boolean(2). Boolean TRUE (frequency=1), FALSE (basis=0).
		oParser = new parserFormula('DURATION(43831,45657,0.05,0.06,TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,0.05,0.06,TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4), Boolean(2). Boolean TRUE (frequency=1), FALSE (basis=0).');
		// Case #40: Area3D(6). All arguments as 3D areas.
		oParser = new parserFormula('DURATION(Sheet2!A1:A2,Sheet2!A2:A3,Sheet2!A3:A4,Sheet2!A4:A5,Sheet2!A5:A6,Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(Sheet2!A1:A2,Sheet2!A2:A3,Sheet2!A3:A4,Sheet2!A4:A5,Sheet2!A5:A6,Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(6). All arguments as 3D areas.');

		// Bounded cases:

		// Case #1: Formula(2), Number(4). Minimum date 1900-01-01 for settlement.
		oParser = new parserFormula('DURATION(DATE(1900,1,1),DATE(1901,1,1),0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(1900,1,1),DATE(1901,1,1),0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula(2), Number(4). Minimum date 1900-01-01 for settlement.');
		// Case #2: Formula(2), Number(4). Maximum date 9999-12-31 for maturity.
		oParser = new parserFormula('DURATION(DATE(9998,12,31),DATE(9999,12,31),0.05,0.06,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(9998,12,31),DATE(9999,12,31),0.05,0.06,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Formula(2), Number(4). Maximum date 9999-12-31 for maturity.');
		// Case #3: Number(6). Minimum serial numbers and minimum coupon/yld (0.1%).
		oParser = new parserFormula('DURATION(DATE(1900,1,1),DATE(1901,1,1),0.001,0.001,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(DATE(1900,1,1),DATE(1901,1,1),0.001,0.001,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(6). Minimum serial numbers and minimum coupon/yld (0.1%).');
		// Case #5: Number(6). Very small coupon and yld values.
		oParser = new parserFormula('DURATION(43831,45657,1E-10,1E-10,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,1E-10,1E-10,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.997222221222222, 'Test: Bounded case: Number(6). Very small coupon and yld values.');
		// Case #6: Number(6). Very large coupon and yld values.
		oParser = new parserFormula('DURATION(43831,45657,1E+10,1E+10,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(43831,45657,1E+10,1E+10,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.24722222232222227, 'Test: Bounded case: Number(6). Very large coupon and yld values.');
		// Case #7: Area(6). Whole columns as arguments (intersection values used).
		oParser = new parserFormula('DURATION(A:A,B:B,C:C,D:D,E:E,F:F)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(A:A,B:B,C:C,D:D,E:E,F:F) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area(6). Whole columns as arguments (intersection values used).');
		// Case #8: Area(6). Whole rows as arguments (intersection values used).
		oParser = new parserFormula('DURATION(100:100,101:101,102:102,103:103,104:104,105:105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DURATION(100:100,101:101,102:102,103:103,104:104,105:105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area(6). Whole rows as arguments (intersection values used).');

        // TODO
        // Need to fix: empty handle, error types diff, results diff from MS
        // Case #28: Empty, Number(5). Empty settlement converted to 0, returns #NUM! (settlement >= maturity).
        // Case #29: Number, Empty, Number(4). Empty maturity converted to 0, returns #NUM! (settlement >= maturity).
        // Case #30: Number(2), Empty, Number(3). Empty coupon converted to 0.
        // Case #31: Number(3), Empty, Number(2). Empty yld converted to 0.
        // Case #32: Number(4), Empty, Number. Empty frequency converted to 0, returns #NUM! error.
        // Case #36: Number(4), Empty(2). Frequency and basis omitted (default to 0).
        // Case #37: Boolean, Number(5). Boolean FALSE converted to 0 for settlement.
        // Case #38: Number, Boolean, Number(4). Boolean TRUE converted to 1 for maturity, settlement > maturity.
        // Case #39: Number(4), Boolean(2). Boolean TRUE (frequency=1), FALSE (basis=0).
        // Case #7: Area(6). Whole columns as arguments (intersection values used).
        // Case #8: Area(6). Whole rows as arguments (intersection values used).

		testArrayFormula2(assert, "DURATION", 5, 6, true);
	});

	QUnit.test("Test: \"EFFECT\"", function (assert) {

		function effect(nr, np) {

			if (nr <= 0 || np < 1) {
				return "#NUM!";
			}

			return Math.pow((1 + nr / np), np) - 1;

		}

		oParser = new parserFormula("EFFECT(0.0525,4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), effect(0.0525, 4));

		oParser = new parserFormula("EFFECT(0.0525,-4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), effect(0.0525, -4));

		oParser = new parserFormula("EFFECT(0.0525,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), effect(0.0525, 1));

		oParser = new parserFormula("EFFECT(-1,54)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), effect(-1, 54));

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.5");
		ws.getRange2("A104").setValue("Text");
		// For area
		ws.getRange2("A102").setValue("10");
		ws.getRange2("A103").setValue("100");
		ws.getRange2("A105").setValue("TRUE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("123"); // Num (Column1)
		ws.getRange2("B601").setValue("321"); // Num (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)

		// 3D links. Use A1:Z10
		ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number, Number. Standard case: nominal 10% with 4 periods.
		oParser = new parserFormula('EFFECT(0.1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10381289062499954, 'Test: Positive case: Number, Number. Standard case: nominal 10% with 4 periods.');
		// Case #2: Number, Number. Monthly compounding.
		oParser = new parserFormula('EFFECT(0.12,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.12,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12682503013196977, 'Test: Positive case: Number, Number. Monthly compounding.');
		// Case #3: Number, Number. Semiannual compounding.
		oParser = new parserFormula('EFFECT(0.08,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.08,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '0.0816', 'Test: Positive case: Number, Number. Semiannual compounding.');
		// Case #4: Number, Number. Single compounding period (same as nominal).
		oParser = new parserFormula('EFFECT(0.05,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.05,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.05', 'Test: Positive case: Number, Number. Single compounding period (same as nominal).');
		// Case #5: Formula, Number. Formula for nominal_rate.
		oParser = new parserFormula('EFFECT(RATE(10,0,-1000,1000),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(RATE(10,0,-1000,1000),4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 8.88178e-16, 'Test: Positive case: Formula, Number. Formula for nominal_rate.');
		// Case #6: Number, Formula. Formula used for npery.
		oParser = new parserFormula('EFFECT(0.1,ROUND(12.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,ROUND(12.9,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10474810056483985, 'Test: Positive case: Number, Formula. Formula used for npery.');
		// Case #7: Reference link, Number. Reference link to nominal_rate.
		oParser = new parserFormula('EFFECT(A100,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(A100,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10381289062499954, 'Test: Positive case: Reference link, Number. Reference link to nominal_rate.');
		// Case #8: Number, Reference link. Reference link to npery.
		oParser = new parserFormula('EFFECT(0.08,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.08,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Reference link. Reference link to npery.');
		// Case #9: Area, Number. Area with nominal_rate values.
		oParser = new parserFormula('EFFECT(A100:A101,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(A100:A101,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area, Number. Area with nominal_rate values.');
		// Case #10: Number, Area. Area as npery reference.
		oParser = new parserFormula('EFFECT(0.1,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number, Area. Area as npery reference.');
		// Case #11: Table, Number. Using Table reference for nominal_rate.
		oParser = new parserFormula('EFFECT(Table1[Column1],4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(Table1[Column1],4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1016189.00390625, 'Test: Positive case: Table, Number. Using Table reference for nominal_rate.');
		// Case #12: Number, Table. Using Table reference for npery.
		oParser = new parserFormula('EFFECT(0.08,Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.08,Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08327627039923868, 'Test: Positive case: Number, Table. Using Table reference for npery.');
		// Case #13: Name, Number. Named reference for nominal_rate.
		oParser = new parserFormula('EFFECT(TestName,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(TestName,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Number. Named reference for nominal_rate.');
		// Case #14: Name3D, Number. 3D named reference for nominal_rate.
		oParser = new parserFormula('EFFECT(TestName3D,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(TestName3D,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Number. 3D named reference for nominal_rate.');
		// Case #15: Ref3D, Number. 3D reference link.
		oParser = new parserFormula('EFFECT(Sheet2!A1,12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(Sheet2!A1,12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6130352902246758, 'Test: Positive case: Ref3D, Number. 3D reference link.');
		// Case #16: Area3D, Number. 3D area reference.
		oParser = new parserFormula('EFFECT(Sheet2!A1:A2,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(Sheet2!A1:A2,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.44140625, 'Test: Positive case: Area3D, Number. 3D area reference.');
		// Case #17: Formula, Formula. Formulas in both arguments.
		oParser = new parserFormula('EFFECT(RATE(10,0,-1000,1000),ROUND(12.9,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(RATE(10,0,-1000,1000),ROUND(12.9,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula, Formula. Formulas in both arguments.');
		// Case #18: Number, Array. Array for npery.
		oParser = new parserFormula('EFFECT(0.1,{1,2,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,{1,2,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.1', 'Test: Positive case: Number, Array. Array for npery.');
		// Case #19: Array, Number. Array for nominal_rate.
		oParser = new parserFormula('EFFECT({0.05,0.1,0.15},4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT({0.05,0.1,0.15},4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.05094533691406222, 'Test: Positive case: Array, Number. Array for nominal_rate.');
		// Case #20: Name, Formula. Named reference and formula.
		oParser = new parserFormula('EFFECT(TestName,ROUND(4.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(TestName,ROUND(4.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Formula. Named reference and formula.');

		// Negative cases:
		// Case #1: Number, Number. Nominal_rate ? 0 ? #NUM!.
		oParser = new parserFormula('EFFECT(0,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Nominal_rate ? 0 ? #NUM!.');
		// Case #2: Number, Number. Negative nominal_rate.
		oParser = new parserFormula('EFFECT(-0.1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(-0.1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative nominal_rate.');
		// Case #3: Number, Number. npery < 1 ? #NUM!.
		oParser = new parserFormula('EFFECT(0.1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. npery < 1 ? #NUM!.');
		// Case #4: Number, Number. Negative npery.
		oParser = new parserFormula('EFFECT(0.1,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative npery.');
		// Case #5: String, Number. Non-numeric nominal_rate.
		oParser = new parserFormula('EFFECT("abc",4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT("abc",4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric nominal_rate.');
		// Case #6: Number, String. Non-numeric npery.
		oParser = new parserFormula('EFFECT(0.1,"xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,"xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric npery.');
		// Case #7: Error, Number. Error in nominal_rate.
		oParser = new parserFormula('EFFECT(#VALUE!,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(#VALUE!,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Number. Error in nominal_rate.');
		// Case #8: Number, Error. Error in npery.
		oParser = new parserFormula('EFFECT(0.1,#REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,#REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Number, Error. Error in npery.');
		// Case #9: Reference link, String. Invalid npery via reference.
		oParser = new parserFormula('EFFECT(A100,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(A100,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, String. Invalid npery via reference.');
		// Case #10: String, Reference link. Invalid nominal_rate via reference.
		oParser = new parserFormula('EFFECT("xyz",A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT("xyz",A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Reference link. Invalid nominal_rate via reference.');
		// Case #11: Area, String. Invalid string with area.
		oParser = new parserFormula('EFFECT(A100:A101,"bad")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(A100:A101,"bad") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, String. Invalid string with area.');
		// Case #12: Name, String. Invalid months from name.
		oParser = new parserFormula('EFFECT(TestName,"bad")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(TestName,"bad") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, String. Invalid months from name.');
		// Case #13: Name3D, Error. 3D name with error npery.
		oParser = new parserFormula('EFFECT(TestName3D,#REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(TestName3D,#REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Name3D, Error. 3D name with error npery.');
		// Case #14: Ref3D, String. Invalid npery on 3D ref.
		oParser = new parserFormula('EFFECT(Sheet2!A1,"invalid")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(Sheet2!A1,"invalid") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, String. Invalid npery on 3D ref.');
		// Case #15: Area3D, Error. Area3D with error npery.
		oParser = new parserFormula('EFFECT(Sheet2!A1:A2,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(Sheet2!A1:A2,#N/A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Error. Area3D with error npery.');
		// Case #16: Empty, Number. Empty nominal_rate.
		oParser = new parserFormula('EFFECT(,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. Empty nominal_rate.');
		// Case #17: Number, Empty. Empty npery.
		oParser = new parserFormula('EFFECT(0.1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty. Empty npery.');
		// Case #18: Empty, Empty. Both arguments empty.
		oParser = new parserFormula('EFFECT(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Empty. Both arguments empty.');
		// Case #19: Formula, String. Invalid npery string with formula.
		oParser = new parserFormula('EFFECT(RATE(10,0,-1000,1000),"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(RATE(10,0,-1000,1000),"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula, String. Invalid npery string with formula.');
		// Case #20: Number, Formula. Error from invalid formula.
		oParser = new parserFormula('EFFECT(0.1,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Error from invalid formula.');

		// Bounded cases:
		// Case #1: Number, Number. Minimum positive nominal_rate.
		oParser = new parserFormula('EFFECT(1E-10,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(1E-10,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.000000082740371e-10, 'Test: Bounded case: Number, Number. Minimum positive nominal_rate.');
		// Case #2: Number, Number. Very high nominal_rate processed without error.
		oParser = new parserFormula('EFFECT(5,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(5,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Bounded case: Number, Number. Very high nominal_rate processed without error.');
		// Case #3: Number, Number. Minimum valid npery (1).
		oParser = new parserFormula('EFFECT(0.1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.1', 'Test: Bounded case: Number, Number. Minimum valid npery (1).');
		// Case #4: Number, Number. Extremely high npery.
		oParser = new parserFormula('EFFECT(0.1,10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: EFFECT(0.1,10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10517036549473469, 'Test: Bounded case: Number, Number. Extremely high npery.');

		// Need to fix: ms result diff, error types diff, empty handle
		// Case #5: Formula, Number. Formula for nominal_rate. - res diff(with rate formula)
		// Case #17: Formula, Formula. Formulas in both arguments. - res diff(with rate formula)
		// Case #15: Area3D, Error. Area3D with error npery.
		// Case #16: Empty, Number. Empty nominal_rate.
		// Case #17: Number, Empty. Empty npery.
		// Case #18: Empty, Empty. Both arguments empty.


		testArrayFormula2(assert, "EFFECT", 2, 2, true)
	});

	QUnit.test("Test: \"FV\"", function (assert) {

		function fv(rate, nper, pmt, pv, type) {
			var res;
			if (type === undefined || type === null) {
				type = 0;
			}

			if (pv === undefined || pv === null) {
				pv = 0;
			}

			if (rate != 0) {
				res = -1 * (pv * Math.pow(1 + rate, nper) + pmt * (1 + rate * type) * (Math.pow(1 + rate, nper) - 1) / rate);
			} else {
				res = -1 * (pv + pmt * nper);
			}
			return res;
		}

		oParser = new parserFormula("FV(0.06/12,10,-200,-500,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), fv(0.06 / 12, 10, -200, -500, 1));

		oParser = new parserFormula("FV(0.12/12,12,-1000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), fv(0.12 / 12, 12, -1000));

		oParser = new parserFormula("FV(0.11/12,35,-2000,,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(Math.abs(oParser.calculate().getValue() - fv(0.11 / 12, 35, -2000, null, 1)) < dif);

		oParser = new parserFormula("FV(0.06/12,12,-100,-1000,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(Math.abs(oParser.calculate().getValue() - fv(0.06 / 12, 12, -100, -1000, 1)) < dif);

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Monthly payments at 1% monthly rate, 12 periods, no PV, end of period. Returns future value.
		oParser = new parserFormula('FV(0.01,12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1268.2503013196979, 'Test: Positive case: Number. Monthly payments at 1% monthly rate, 12 periods, no PV, end of period. Returns future value.');
		// Case #2: Number. Annual payments at 12% annual rate, 4 years, no PV, end of period. Returns future value.
		oParser = new parserFormula('FV(0.12,4,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.12,4,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4779.328000000005, 'Test: Positive case: Number. Annual payments at 12% annual rate, 4 years, no PV, end of period. Returns future value.');
		// Case #3: String. String convertible to numbers, monthly rate and periods. Returns future value.
		oParser = new parserFormula('FV("0.01","12","-100","0","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV("0.01","12","-100","0","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1268.2503013196979, 'Test: Positive case: String. String convertible to numbers, monthly rate and periods. Returns future value.');
		// Case #4: Formula. Nested formulas evaluating to valid numbers. Returns future value.
		oParser = new parserFormula('FV(SQRT(0.0001),ROUND(12,0),-ABS(100),0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(SQRT(0.0001),ROUND(12,0),-ABS(100),0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1268.2503013196979, 'Test: Positive case: Formula. Nested formulas evaluating to valid numbers. Returns future value.');
		// Case #5: Reference link. Reference to cells with valid numbers. Returns future value.
		oParser = new parserFormula('FV(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(A100,A101,A102,A103,A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.471206043, 'Test: Positive case: Reference link. Reference to cells with valid numbers. Returns future value.');
		// Case #6: Area. Single-cell range for all arguments. Returns future value.
		oParser = new parserFormula('FV(A105:A105,A106:A106,A107:A107,A108:A108,A109:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(A105:A105,A106:A106,A107:A107,A108:A108,A109:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.081730203519774, 'Test: Positive case: Area. Single-cell range for all arguments. Returns future value.');
		// Case #7: Array. Array with single valid elements. Returns future value.
		oParser = new parserFormula('FV({0.01},{12},{-100},{0},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV({0.01},{12},{-100},{0},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1268.2503013196979, 'Test: Positive case: Array. Array with single valid elements. Returns future value.');
		// Case #8: Name. Named range with valid numbers. Returns future value.
		oParser = new parserFormula('FV(TestName,TestName1,TestName2,TestName3,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(TestName,TestName1,TestName2,TestName3,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid numbers. Returns future value.');
		// Case #9: Name3D. 3D named range with valid numbers. Returns future value.
		oParser = new parserFormula('FV(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid numbers. Returns future value.');
		// Case #10: Ref3D. 3D reference to cells with valid numbers. Returns future value.
		oParser = new parserFormula('FV(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. Returns future value.');
		// Case #11: Area3D. 3D single-cell range. Returns future value.
		oParser = new parserFormula('FV(Sheet2!A6:A6,Sheet2!A7:A7,Sheet2!A8:A8,Sheet2!A9:A9,Sheet2!A10:A10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(Sheet2!A6:A6,Sheet2!A7:A7,Sheet2!A8:A8,Sheet2!A9:A9,Sheet2!A10:A10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range. Returns future value.');
		// Case #12: Table. Table structured reference with valid numbers. Returns future value.
		oParser = new parserFormula('FV(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with valid numbers. Returns future value.');
		// Case #13: Formula. Nested IF for rate. Returns future value.
		oParser = new parserFormula('FV(IF(TRUE,0.01,0.02),12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(IF(TRUE,0.01,0.02),12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1268.2503013196979, 'Test: Positive case: Formula. Nested IF for rate. Returns future value.');
		// Case #14: Number. Positive pmt (inflow), negative pv (outflow), payment at beginning. Returns future value.
		oParser = new parserFormula('FV(0.01,12,100,-1000,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,12,100,-1000,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -154.10777420092495, 'Test: Positive case: Number. Positive pmt (inflow), negative pv (outflow), payment at beginning. Returns future value.');
		// Case #15: Date. Date serial number as rate (divided to valid range). Returns future value.
		oParser = new parserFormula('FV(DATE(2025,1,1)/45688,12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(DATE(2025,1,1)/45688,12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 408157.1901301258, 'Test: Positive case: Date. Date serial number as rate (divided to valid range). Returns future value.');
		// Case #16: Time. Time as rate (small positive number). Returns future value.
		oParser = new parserFormula('FV(TIME(12,0,0),12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(TIME(12,0,0),12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25749.267578125, 'Test: Positive case: Time. Time as rate (small positive number). Returns future value.');
		// Case #17: String. String convertible to numbers, positive pmt, negative pv. Returns future value.
		oParser = new parserFormula('FV("0.01","12","100","-1000","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV("0.01","12","100","-1000","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -154.10777420092495, 'Test: Positive case: String. String convertible to numbers, positive pmt, negative pv. Returns future value.');
		// Case #18: Formula. Nested formulas for nper and pv. Returns future value.
		oParser = new parserFormula('FV(0.01,ROUND(12.5,0),-ABS(100),-ROUND(1000.5,0),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,ROUND(12.5,0),-ABS(100),-ROUND(1000.5,0),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2520.164178046618, 'Test: Positive case: Formula. Nested formulas for nper and pv. Returns future value.');
		// Case #19: Number. Omitted pv defaults to 0, type -1 treated as 0. Returns future value.
		oParser = new parserFormula('FV(0.01,12,-100,,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,12,-100,,-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1280.932804, 'Test: Positive case: Number. Omitted pv defaults to 0, type -1 treated as 0. Returns future value.');
		// Case #20: Number. Omitted type defaults to 0. Returns future value.
		oParser = new parserFormula('FV(0.01,12,-100,-1000,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,12,-100,-1000,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2395.075331451668, 'Test: Positive case: Number. Omitted type defaults to 0. Returns future value.');
		// Case #21: Array. Arrays with multiple valid elements. Returns array of future values.
		oParser = new parserFormula('FV({0.01,0.02},{12,24},{-100,-200},{0,0},{0,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV({0.01,0.02},{12,24},{-100,-200},{0,0},{0,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1268.2503013196979, 'Test: Positive case: Array. Arrays with multiple valid elements. Returns array of future values.');
		// Case #22: Number. Zero rate and pmt, negative pv. Returns future value (-1000).
		oParser = new parserFormula('FV(0,12,0,-1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0,12,0,-1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Positive case: Number. Zero rate and pmt, negative pv. Returns future value (-1000).');

		// Negative cases:
		// Case #1: String. Non-numeric string for rate returns #VALUE!.
		oParser = new parserFormula('FV("abc",12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV("abc",12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for rate returns #VALUE!.');
		// Case #2: Error. Error in rate propagates #N/A. Returns #N/A.
		oParser = new parserFormula('FV(NA(),12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(NA(),12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in rate propagates #N/A. Returns #N/A.');
		// Case #3: Area. Multi-cell range for rate returns #VALUE!.
		oParser = new parserFormula('FV(A100:A101,A102,A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(A100:A101,A102,A103,A104,A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.642128221, 'Test: Negative case: Area. Multi-cell range for rate returns #VALUE!.');
		// Case #4: Empty. Empty rate returns #VALUE!.
		oParser = new parserFormula('FV(,12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(,12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1200, 'Test: Negative case: Empty. Empty rate returns #VALUE!.');
		// Case #5: Boolean. Boolean rate (1) is valid but high. Returns future value.
		oParser = new parserFormula('FV(TRUE,12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(TRUE,12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 409500, 'Test: Negative case: Boolean. Boolean rate (1) is valid but high. Returns future value.');
		// Case #6: Ref3D. 3D ref to text for rate returns #VALUE!.
		oParser = new parserFormula('FV(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to text for rate returns #VALUE!.');
		// Case #7: Name. Named range with multi-cell area for rate returns #VALUE!.
		oParser = new parserFormula('FV(TestNameArea,TestName1,TestName2,TestName3,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(TestNameArea,TestName1,TestName2,TestName3,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with multi-cell area for rate returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! for rate propagates error. Returns #N/A.
		oParser = new parserFormula('FV(SQRT(-1),12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(SQRT(-1),12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! for rate propagates error. Returns #N/A.');
		// Case #10: Number. Negative nper returns #NUM!.
		oParser = new parserFormula('FV(0.01,-12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,-12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1125.5077473484644, 'Test: Negative case: Number. Negative nper returns #NUM!.');
		// Case #11: Number. Empty pmt returns #VALUE!.
		oParser = new parserFormula('FV(0.01,12,,"-1000",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,12,,"-1000",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1126.8250301319697, 'Test: Negative case: Number. Empty pmt returns #VALUE!.');
		// Case #12: String. Non-numeric string for pmt returns #VALUE!.
		oParser = new parserFormula('FV(0.01,12,"abc",0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,12,"abc",0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for pmt returns #VALUE!.');
		// Case #13: Error. Error in pmt propagates #N/A. Returns #N/A.
		oParser = new parserFormula('FV(0.01,12,NA(),0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,12,NA(),0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in pmt propagates #N/A. Returns #N/A.');
		// Case #14: Area3D. Multi-cell 3D range for rate returns #VALUE!.
		oParser = new parserFormula('FV(Sheet2!A6:A7,Sheet2!A8,Sheet2!A9,Sheet2!A10,Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(Sheet2!A6:A7,Sheet2!A8,Sheet2!A9,Sheet2!A10,Sheet2!A1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. Multi-cell 3D range for rate returns #VALUE!.');
		// Case #15: Name3D. 3D named range with multi-cell area for rate returns #VALUE!.
		oParser = new parserFormula('FV(TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with multi-cell area for rate returns #VALUE!.');
		// Case #16: Date. Large date serial number as rate returns #NUM!.
		oParser = new parserFormula('FV(DATE(2025,1,1),12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(DATE(2025,1,1),12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.7980421279622045e+53, 'Test: Negative case: Date. Large date serial number as rate returns #NUM!.');
		// Case #17: Time. Negative time value as rate returns #NUM!.
		oParser = new parserFormula('FV(TIME(12,0,0)-1,12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(TIME(12,0,0)-1,12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 199.951171875, 'Test: Negative case: Time. Negative time value as rate returns #NUM!.');
		// Case #18: Number. Error in pv propagates #N/A. Returns #N/A.
		oParser = new parserFormula('FV(0.01,12,-100,NA(),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,12,-100,NA(),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number. Error in pv propagates #N/A. Returns #N/A.');
		// Case #19: Number. Non-numeric string for type returns #VALUE!.
		oParser = new parserFormula('FV(0.01,12,-100,0,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,12,-100,0,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Non-numeric string for type returns #VALUE!.');
		// Case #20: Array. Array with booleans for rate returns #VALUE!.
		oParser = new parserFormula('FV({TRUE,FALSE},12,-100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV({TRUE,FALSE},12,-100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 409500, 'Test: Negative case: Array. Array with booleans for rate returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum Excel number for rate. Returns large future value or #NUM! if overflow.
		oParser = new parserFormula('FV(1.79769313486232E+308,1,-1,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(1.79769313486232E+308,1,-1,0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum Excel number for rate. Returns large future value or #NUM! if overflow.');
		// Case #2: Number. Minimum Excel number for rate. Returns large future value or #NUM! if overflow.
		oParser = new parserFormula('FV(-1.79769313486232E+308,1,-1,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(-1.79769313486232E+308,1,-1,0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum Excel number for rate. Returns large future value or #NUM! if overflow.');
		// Case #3: Number. Maximum Excel number for nper. Returns #NUM! due to overflow.
		oParser = new parserFormula('FV(0.01,1.79769313486232E+308,-1,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,1.79769313486232E+308,-1,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum Excel number for nper. Returns #NUM! due to overflow.');
		// Case #4: Number. Minimum Excel number for pmt. Returns large future value.
		oParser = new parserFormula('FV(0.01,1,-1.79769313486232E+308,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,1,-1.79769313486232E+308,0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.7977e+307, 'Test: Bounded case: Number. Minimum Excel number for pmt. Returns large future value.');
		// Case #5: Number. Minimum Excel number for pv. Returns large future value.
		oParser = new parserFormula('FV(0.01,1,-1,-1.79769313486232E+308,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FV(0.01,1,-1,-1.79769313486232E+308,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.8157e+307, 'Test: Bounded case: Number. Minimum Excel number for pv. Returns large future value.');

		// Need to fix: area handle, ms result difference in some cases
		// Case #5: Reference link. Reference to cells with valid numbers. Returns future value.
		// Case #19: Number. Omitted pv defaults to 0, type -1 treated as 0. Returns future value. - calc problem
		// Case #3: Area. Multi-cell range for rate returns #VALUE!.
		// Case #14: Area3D. Multi-cell 3D range for rate returns #VALUE!.
		// Case #1: Number. Maximum Excel number for rate. Returns large future value or #NUM! if overflow.
		// Case #2: Number. Minimum Excel number for rate. Returns large future value or #NUM! if overflow.
		// Case #4: Number. Minimum Excel number for pmt. Returns large future value.
		// Case #5: Number. Minimum Excel number for pv. Returns large future value.


		testArrayFormula2(assert, "FV", 3, 5);
	});

	QUnit.test("Test: \"FVSCHEDULE\"", function (assert) {

		function fvschedule(rate, shedList) {

			for (var i = 0; i < shedList.length; i++) {
				rate *= 1 + shedList[i]
			}

			return rate;
		}

		oParser = new parserFormula("FVSCHEDULE(1,{0.09,0.11,0.1})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), fvschedule(1, [0.09, 0.11, 0.1]));

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Valid principal and numeric schedule array. Returns 1000*(1+0.01)*(1+0.02)*(1+0.03).
		oParser = new parserFormula('FVSCHEDULE(1000,{0.01,0.02,0.03})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,{0.01,0.02,0.03}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1061.106, 'Test: Positive case: Number. Valid principal and numeric schedule array. Returns 1000*(1+0.01)*(1+0.02)*(1+0.03).');
		// Case #2: Number. Negative principal (outflow) with schedule including 0. Returns -1000*(1+0.05)*(1+0)*(1+0.02).
		oParser = new parserFormula('FVSCHEDULE(-1000,{0.05,0,0.02})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(-1000,{0.05,0,0.02}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1071, 'Test: Positive case: Number. Negative principal (outflow) with schedule including 0. Returns -1000*(1+0.05)*(1+0)*(1+0.02).');
		// Case #3: String. String convertible to numbers for principal and schedule. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE("1000","0.01")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE("1000","0.01") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1010, 'Test: Positive case: String. String convertible to numbers for principal and schedule. Returns 1000*(1+0.01).');
		// Case #4: Formula. Nested formulas evaluating to valid numbers. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(SQRT(1000000),SQRT(0.0001))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(SQRT(1000000),SQRT(0.0001)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1010, 'Test: Positive case: Formula. Nested formulas evaluating to valid numbers. Returns 1000*(1+0.01).');
		// Case #5: Reference link. Reference to cells with valid numbers. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.12, 'Test: Positive case: Reference link. Reference to cells with valid numbers. Returns 1000*(1+0.01).');
		// Case #6: Area. Single-cell range for both arguments. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.42, 'Test: Positive case: Area. Single-cell range for both arguments. Returns 1000*(1+0.01).');
		// Case #7: Array. Array with single principal and valid schedule. Returns 1000*(1+0.01)*(1+0.02).
		oParser = new parserFormula('FVSCHEDULE({1000},{0.01,0.02})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE({1000},{0.01,0.02}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1030.2, 'Test: Positive case: Array. Array with single principal and valid schedule. Returns 1000*(1+0.01)*(1+0.02).');
		// Case #8: Name. Named range with valid numbers. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.75, 'Test: Positive case: Name. Named range with valid numbers. Returns 1000*(1+0.01).');
		// Case #9: Name3D. 3D named range with valid numbers. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.25, 'Test: Positive case: Name3D. 3D named range with valid numbers. Returns 1000*(1+0.01).');
		// Case #10: Ref3D. 3D reference to cells with valid numbers. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. Returns 1000*(1+0.01).');
		// Case #11: Area3D. 3D single-cell range. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell range. Returns 1000*(1+0.01).');
		// Case #12: Table. Table structured reference with valid numbers. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.0150249999999996, 'Test: Positive case: Table. Table structured reference with valid numbers. Returns 1000*(1+0.01).');
		// Case #13: Formula. Nested IF for principal and schedule. Returns 1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(IF(TRUE,1000,500),IF(TRUE,0.01,0.02))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(IF(TRUE,1000,500),IF(TRUE,0.01,0.02)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1010, 'Test: Positive case: Formula. Nested IF for principal and schedule. Returns 1000*(1+0.01).');
		// Case #14: Number. Blank cell equivalent (0) in schedule. Returns 1000*(1+0.01)*(1+0).
		oParser = new parserFormula('FVSCHEDULE(1000,{0.01,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,{0.01,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1010, 'Test: Positive case: Number. Blank cell equivalent (0) in schedule. Returns 1000*(1+0.01)*(1+0).');
		// Case #15: Date. Date serial number as principal (divided to valid range). Returns ~1000*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(DATE(2025,1,1)/45.688,0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(DATE(2025,1,1)/45.688,0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1009.3368061635439, 'Test: Positive case: Date. Date serial number as principal (divided to valid range). Returns ~1000*(1+0.01).');
		// Case #16: Time. Time as schedule rate (0.5). Returns 1000*(1+0.5).
		oParser = new parserFormula('FVSCHEDULE(1000,TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1500, 'Test: Positive case: Time. Time as schedule rate (0.5). Returns 1000*(1+0.5).');
		// Case #17: String. String convertible to numbers, negative principal. Returns -1000*(1+0.01)*(1+0.02).
		oParser = new parserFormula('FVSCHEDULE("-1000","0.01,0.02")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE("-1000","0.01,0.02") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String. String convertible to numbers, negative principal. Returns -1000*(1+0.01)*(1+0.02).');
		// Case #18: Formula. Nested ROUND formulas. Returns 1000*(1+0.02).
		oParser = new parserFormula('FVSCHEDULE(ROUND(1000.5,0),ROUND(0.015,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(ROUND(1000.5,0),ROUND(0.015,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1021.02, 'Test: Positive case: Formula. Nested ROUND formulas. Returns 1000*(1+0.02).');
		// Case #19: Number. Empty schedule returns principal unchanged (1000).
		oParser = new parserFormula('FVSCHEDULE(1000,{""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,{""}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number. Empty schedule returns principal unchanged (1000).');
		// Case #20: Number. Negative principal with mixed schedule (including 0). Returns -1000*(1+0.01)*(1+0.02)*(1+0).
		oParser = new parserFormula('FVSCHEDULE(-1000,{0.01,0.02,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(-1000,{0.01,0.02,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1030.2, 'Test: Positive case: Number. Negative principal with mixed schedule (including 0). Returns -1000*(1+0.01)*(1+0.02)*(1+0).');
		// Case #21: Array. Arrays with multiple valid elements. Returns array of future values.
		oParser = new parserFormula('FVSCHEDULE({1000,2000},{0.01,0.02})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE({1000,2000},{0.01,0.02}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1030.2, 'Test: Positive case: Array. Arrays with multiple valid elements. Returns array of future values.');
		// Case #22: Number. Zero principal returns 0. Returns 0.
		oParser = new parserFormula('FVSCHEDULE(0,{0.01,0.02})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(0,{0.01,0.02}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero principal returns 0. Returns 0.');

		// Negative cases:
		// Case #1: String. Non-numeric string for principal returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE("abc",{0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE("abc",{0.01}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for principal returns #VALUE!.');
		// Case #2: Error. Error in principal propagates #N/A. Returns #N/A.
		oParser = new parserFormula('FVSCHEDULE(NA(),{0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(NA(),{0.01}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in principal propagates #N/A. Returns #N/A.');
		// Case #3: Area. Multi-cell range for principal returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(A100:A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(A100:A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for principal returns #VALUE!.');
		// Case #4: Empty. Empty principal returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(,{0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(,{0.01}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty. Empty principal returns #VALUE!.');
		// Case #5: Boolean. Boolean principal (1) is valid. Returns 1*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(TRUE,{0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(TRUE,{0.01}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean principal (1) is valid. Returns 1*(1+0.01).');
		// Case #6: Ref3D. 3D ref to text for schedule returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Negative case: Ref3D. 3D ref to text for schedule returns #VALUE!.');
		// Case #7: Name. Named range with multi-cell area for schedule returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(TestName,TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(TestName,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Negative case: Name. Named range with multi-cell area for schedule returns #VALUE!.');
		// Case #8: Table. Table column with text for schedule returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text for schedule returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! for principal propagates error. Returns #N/A.
		oParser = new parserFormula('FVSCHEDULE(SQRT(-1),{0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(SQRT(-1),{0.01}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! for principal propagates error. Returns #N/A.');
		// Case #10: String. Non-numeric string in schedule returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(1000,{"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,{"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string in schedule returns #VALUE!.');
		// Case #11: Error. Error in schedule propagates #N/A. Returns #N/A.
		oParser = new parserFormula('FVSCHEDULE(1000,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error in schedule propagates #N/A. Returns #N/A.');
		// Case #12: Boolean. Boolean in schedule returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(1000,{TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,{TRUE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean in schedule returns #VALUE!.');
		// Case #13: Area3D. Multi-cell 3D range for schedule returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(Sheet2!A3,Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(Sheet2!A3,Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. Multi-cell 3D range for schedule returns #VALUE!.');
		// Case #14: Name3D. 3D named range with multi-cell area for schedule returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(TestName3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(TestName3D,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '-0.18', 'Test: Negative case: Name3D. 3D named range with multi-cell area for schedule returns #VALUE!.');
		// Case #15: Date. Large date serial number as principal returns valid value. Returns 45688*(1+0.01).
		oParser = new parserFormula('FVSCHEDULE(DATE(2025,1,1),{0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(DATE(2025,1,1),{0.01}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 46114.58, 'Test: Negative case: Date. Large date serial number as principal returns valid value. Returns 45688*(1+0.01).');
		// Case #16: Time. Negative time value as schedule rate returns valid value. Returns 1000*(1-0.5).
		oParser = new parserFormula('FVSCHEDULE(1000,TIME(12,0,0)-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,TIME(12,0,0)-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 500, 'Test: Negative case: Time. Negative time value as schedule rate returns valid value. Returns 1000*(1-0.5).');
		// Case #17: Number. Negative rate in schedule is valid. Returns 1000*(1-0.01).
		oParser = new parserFormula('FVSCHEDULE(1000,{-0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,{-0.01}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 990, 'Test: Negative case: Number. Negative rate in schedule is valid. Returns 1000*(1-0.01).');
		// Case #18: String. Non-numeric string for schedule returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(1000,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for schedule returns #VALUE!.');
		// Case #19: Array. Array with boolean for principal returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE({1000,TRUE},{0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE({1000,TRUE},{0.01}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1010, 'Test: Negative case: Array. Array with boolean for principal returns #VALUE!.');
		// Case #20: Formula. Nested IF returning non-numeric string for schedule returns #VALUE!.
		oParser = new parserFormula('FVSCHEDULE(1000,IF(TRUE,"abc",0.01))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,IF(TRUE,"abc",0.01)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. Nested IF returning non-numeric string for schedule returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum Excel number for principal. Returns large future value or #NUM! if overflow.
		oParser = new parserFormula('FVSCHEDULE(1.79769313486232E+307,{0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1.79769313486232E+307,{0.01}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.8156700662109432e+307, 'Test: Bounded case: Number. Maximum Excel number for principal. Returns large future value or #NUM! if overflow.');
		// Case #2: Number. Minimum Excel number for principal. Returns large negative future value or #NUM! if overflow.
		oParser = new parserFormula('FVSCHEDULE(-1.79769313486232E+307,{0.01})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(-1.79769313486232E+307,{0.01}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.8156700662109432e+307, 'Test: Bounded case: Number. Minimum Excel number for principal. Returns large negative future value or #NUM! if overflow.');
		// Case #3: Number. Maximum Excel number in schedule. Returns large future value or #NUM! if overflow.
		oParser = new parserFormula('FVSCHEDULE(1000,{1.79769313486232E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,{1.79769313486232E+307}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum Excel number in schedule. Returns large future value or #NUM! if overflow.');
		// Case #4: Number. Minimum Excel number in schedule. Returns future value or #NUM! if overflow.
		oParser = new parserFormula('FVSCHEDULE(1000,{-1.79769313486232E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: FVSCHEDULE(1000,{-1.79769313486232E+307}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum Excel number in schedule. Returns future value or #NUM! if overflow.');

		// Need to fix: error, area, bool, array types handle in args. Boundary cases diff
		// Case #4: Empty. Empty principal returns #VALUE!.
		// Case #5: Boolean. Boolean principal (1) is valid. Returns 1*(1+0.01).
		// Case #11: Error. Error in schedule propagates #N/A. Returns #N/A.
		// Case #12: Boolean. Boolean in schedule returns #VALUE!.
		// Case #3: Number. Maximum Excel number in schedule. Returns large future value or #NUM! if overflow.
		// Case #4: Number. Minimum Excel number in schedule. Returns future value or #NUM! if overflow.


		//testArrayFormula2(assert, "FVSCHEDULE", 2, 2, true, true);
	});

	QUnit.test("Test: \"INTRATE\"", function (assert) {

		function intrate(settlement, maturity, investment, redemption, basis) {

			if (settlement >= maturity || investment <= 0 || redemption <= 0 || basis < 0 || basis > 4) {
				return "#NUM!"
			}

			return ((redemption / investment) - 1) / AscCommonExcel.yearFrac(settlement, maturity, basis)

		}

		oParser = new parserFormula("INTRATE(DATE(2008,2,15),DATE(2008,5,15),1000000,1014420,2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), intrate(new cDate(2008, 1, 15), new cDate(2008, 4, 15), 1000000, 1014420, 2));

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("38777");
		ws.getRange2("A101").setValue("38838");
		ws.getRange2("A104").setValue("0");
		// For area
		ws.getRange2("A102").setValue("1000");
		ws.getRange2("A103").setValue("1100");
		ws.getRange2("A105").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("38777"); // Num (Column1)
		ws.getRange2("B601").setValue("38838"); // Num (Column2)
		ws.getRange2("C601").setValue("1000"); // Num (Column3)
		ws.getRange2("D601").setValue("1100"); // Num (Column4)
		ws.getRange2("E601").setValue("0"); // Num (Column5)
		ws.getRange2("F601").setValue("Text"); // Text (Column6)

		// 3D links. Use A1:Z10
		ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Formula(2), Number(3). Dates via DATE formula, valid basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Formula(2), Number(3). Dates via DATE formula, valid basis 0. 5 of 5 arguments used.');
		// Case #2: Formula(2), Number(3). Dates via DATE formula, valid basis 1. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5983606557377055, 'Test: Positive case: Formula(2), Number(3). Dates via DATE formula, valid basis 1. 5 of 5 arguments used.');
		// Case #3: Formula(2), Number(3). Dates via DATE formula, valid basis 2. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.59016393442623, 'Test: Positive case: Formula(2), Number(3). Dates via DATE formula, valid basis 2. 5 of 5 arguments used.');
		// Case #4: Formula(2), Number(3). Dates via DATE formula, valid basis 3. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5983606557377055, 'Test: Positive case: Formula(2), Number(3). Dates via DATE formula, valid basis 3. 5 of 5 arguments used.');
		// Case #5: Formula(2), Number(3). Dates via DATE formula, valid basis 4. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Formula(2), Number(3). Dates via DATE formula, valid basis 4. 5 of 5 arguments used.');
		// Case #6: Formula(2), Number(2), Empty. Basis omitted, defaults to 0. 4 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Formula(2), Number(2), Empty. Basis omitted, defaults to 0. 4 of 5 arguments used.');
		// Case #7: String(2), Number(3). Dates as strings, valid basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE("03/01/2006","05/01/2006",1000,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE("03/01/2006","05/01/2006",1000,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: String(2), Number(3). Dates as strings, valid basis 0. 5 of 5 arguments used.');
		// Case #8: Formula(3), Number(2). Investment via SUM formula, valid basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),SUM(500,500),1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),SUM(500,500),1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Formula(3), Number(2). Investment via SUM formula, valid basis 0. 5 of 5 arguments used.');
		// Case #9: Formula(3), Number(2). Redemption via ABS formula, valid basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,ABS(1100),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,ABS(1100),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Formula(3), Number(2). Redemption via ABS formula, valid basis 0. 5 of 5 arguments used.');
		// Case #10: Formula(4), Number. Investment and redemption via ROUND formula, valid basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),ROUND(1000,0),ROUND(1100,0),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),ROUND(1000,0),ROUND(1100,0),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Formula(4), Number. Investment and redemption via ROUND formula, valid basis 0. 5 of 5 arguments used.');
		// Case #11: Reference link(5). All arguments as reference links, valid basis. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Reference link(5). All arguments as reference links, valid basis. 5 of 5 arguments used.');
		// Case #12: Area(5). All arguments as single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Area(5). All arguments as single-cell ranges. 5 of 5 arguments used.');
		// Case #13: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE({38777},{38838},{1000},{1100},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE({38777},{38838},{1000},{1100},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.');
		// Case #14: Name(5). All arguments as named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(TestName,TestName1,TestName2,TestName2,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(TestName,TestName1,TestName2,TestName2,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(5). All arguments as named ranges. 5 of 5 arguments used.');
		// Case #15: Name3D(5). All arguments as 3D named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(TestName3D,TestName3D1,TestName3D2,TestName3D3,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(5). All arguments as 3D named ranges. 5 of 5 arguments used.');
		// Case #16: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.');
		// Case #17: Area3D(5). All arguments as 3D single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(5). All arguments as 3D single-cell ranges. 5 of 5 arguments used.');
		// Case #18: Table. All arguments as table references. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Table. All arguments as table references. 5 of 5 arguments used.');
		// Case #19: Formula(2), String(2), Number. Investment and redemption as numeric strings, valid basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),"1000","1100",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),"1000","1100",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.6', 'Test: Positive case: Formula(2), String(2), Number. Investment and redemption as numeric strings, valid basis 0. 5 of 5 arguments used.');
		// Case #20: Formula(5). All arguments filled with formulas. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2025,5,20),DATE(2025,6,30),ROUND(1000,0),ABS(1100),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2025,5,20),DATE(2025,6,30),ROUND(1000,0),ABS(1100),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.9', 'Test: Positive case: Formula(5). All arguments filled with formulas. 5 of 5 arguments used.');

		// Negative cases:
		// Case #1: Formula(2), Boolean, Number(2). Investment as boolean, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),TRUE,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),TRUE,1100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula(2), Boolean, Number(2). Investment as boolean, returns #VALUE!. 5 of 5 arguments used.');
		// Case #2: Formula(2), Number, Boolean. Redemption as boolean, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,TRUE,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,TRUE,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula(2), Number, Boolean. Redemption as boolean, returns #VALUE!. 5 of 5 arguments used.');
		// Case #3: Formula(2), Number(3). Settlement >= maturity, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,5,1),DATE(2006,3,1),1000,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,5,1),DATE(2006,3,1),1000,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Settlement >= maturity, returns #NUM!. 5 of 5 arguments used.');
		// Case #4: Formula(2), Number(3). Settlement = maturity, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,3,1),1000,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,3,1),1000,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Settlement = maturity, returns #NUM!. 5 of 5 arguments used.');
		// Case #5: Formula(2), Number(3). Negative investment, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),-1000,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),-1000,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Negative investment, returns #NUM!. 5 of 5 arguments used.');
		// Case #6: Formula(2), Number(3). Zero investment, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),0,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),0,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Zero investment, returns #NUM!. 5 of 5 arguments used.');
		// Case #7: Formula(2), Number(3). Negative redemption, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,-1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,-1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Negative redemption, returns #NUM!. 5 of 5 arguments used.');
		// Case #8: Formula(2), Number(3). Zero redemption, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Zero redemption, returns #NUM!. 5 of 5 arguments used.');
		// Case #9: Empty, Formula, Number(3). Settlement is empty, returns #VALUE!. 4 of 5 arguments used.
		oParser = new parserFormula('INTRATE(,DATE(2006,5,1),1000,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(,DATE(2006,5,1),1000,1100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Formula, Number(3). Settlement is empty, returns #VALUE!. 4 of 5 arguments used.');
		// Case #10: Formula, Empty, Number(3). Maturity is empty, returns #VALUE!. 4 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),,1000,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),,1000,1100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula, Empty, Number(3). Maturity is empty, returns #VALUE!. 4 of 5 arguments used.');
		// Case #11: Formula(2), Empty, Number(2). Investment is empty, returns #VALUE!. 4 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),,1100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula(2), Empty, Number(2). Investment is empty, returns #VALUE!. 4 of 5 arguments used.');
		// Case #12: Formula(2), Number, Empty. Redemption is empty, returns #VALUE!. 4 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula(2), Number, Empty. Redemption is empty, returns #VALUE!. 4 of 5 arguments used.');
		// Case #13: Formula(2), Number(3). Negative basis, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Negative basis, returns #NUM!. 5 of 5 arguments used.');
		// Case #14: Formula(2), Number(3). Basis out of range (5), returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,1100,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Basis out of range (5), returns #NUM!. 5 of 5 arguments used.');
		// Case #15: String, Formula, Number(3). Settlement as non-date string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE("Str",DATE(2006,5,1),1000,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE("Str",DATE(2006,5,1),1000,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Formula, Number(3). Settlement as non-date string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #16: Formula, String, Number(3). Maturity as non-date string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),"Str",1000,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),"Str",1000,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula, String, Number(3). Maturity as non-date string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #17: Formula(2), Array, Number(2). Investment as array with invalid data, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),{TRUE},1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),{TRUE},1100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula(2), Array, Number(2). Investment as array with invalid data, returns #VALUE!. 5 of 5 arguments used.');
		// Case #18: Formula(2), Number, Array. Redemption as array with invalid data, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,{TRUE},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,{TRUE},0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula(2), Number, Array. Redemption as array with invalid data, returns #VALUE!. 5 of 5 arguments used.');
		// Case #19: Formula(2), Area, Number. Investment as multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),A100:A101,1100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),A100:A101,1100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula(2), Area, Number. Investment as multi-cell range, returns #VALUE!. 5 of 5 arguments used.');
		// Case #20: Formula(2), Number, Area. Redemption as multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,A100:A101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(2006,3,1),DATE(2006,5,1),1000,A100:A101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula(2), Number, Area. Redemption as multi-cell range, returns #VALUE!. 5 of 5 arguments used.');

		// Bounded cases:
		// Case #1: Formula(2), Number(3). Minimum valid investment/redemption (1E-307), minimum valid date (1/1/1900). 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(1900,1,1),DATE(1900,1,2),1E-307,1E-307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(1900,1,1),DATE(1900,1,2),1E-307,1E-307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Formula(2), Number(3). Minimum valid investment/redemption (1E-307), minimum valid date (1/1/1900). 5 of 5 arguments used.');
		// Case #2: Formula(2), Number(3). Maximum valid investment/redemption, maximum valid dates (12/30/9999 to 12/31/9999). 5 of 5 arguments used.
		oParser = new parserFormula('INTRATE(DATE(9999,12,30),DATE(9999,12,31),9.99999999999999E+307,9.99999999999999E+307,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: INTRATE(DATE(9999,12,30),DATE(9999,12,31),9.99999999999999E+307,9.99999999999999E+307,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula(2), Number(3). Maximum valid investment/redemption, maximum valid dates (12/30/9999 to 12/31/9999). 5 of 5 arguments used.');

		// Need to fix: error types differences, ms result diff
		// Case #1: Formula(2), Boolean, Number(2). Investment as boolean, returns #VALUE!. 5 of 5 arguments used. - result diff
		// Case #2: Formula(2), Number, Boolean. Redemption as boolean, returns #VALUE!. 5 of 5 arguments used. - result diff
		// Case #9: Empty, Formula, Number(3). Settlement is empty, returns #VALUE!. 4 of 5 arguments used.
		// Case #10: Formula, Empty, Number(3). Maturity is empty, returns #VALUE!. 4 of 5 arguments used.
		// Case #11: Formula(2), Empty, Number(2). Investment is empty, returns #VALUE!. 4 of 5 arguments used.
		// Case #12: Formula(2), Number, Empty. Redemption is empty, returns #VALUE!. 4 of 5 arguments used.
		// Case #17: Formula(2), Array, Number(2). Investment as array with invalid data, returns #VALUE!. 5 of 5 arguments used. - result diff
		// Case #18: Formula(2), Number, Array. Redemption as array with invalid data, returns #VALUE!. 5 of 5 arguments used. - result diff

		testArrayFormula2(assert, "INTRATE", 4, 5, true);
	});

	QUnit.test("Test: \"IPMT\"", function (assert) {

		function ipmt(rate, per, nper, pv, fv, type) {

			if (fv == undefined) {
				fv = 0;
			}
			if (type == undefined) {
				type = 0;
			}

			var res = AscCommonExcel.getPMT(rate, nper, pv, fv, type);
			res = AscCommonExcel.getIPMT(rate, per, pv, type, res);

			return res;

		}

		oParser = new parserFormula("IPMT(0.1/12,1*3,3,8000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), ipmt(0.1 / 12, 1 * 3, 3, 8000));

		oParser = new parserFormula("IPMT(0.1,3,3,8000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), ipmt(0.1, 3, 3, 8000));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.12");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A104").setValue("0");
		// For area
		ws.getRange2("A102").setValue("4");
		ws.getRange2("A103").setValue("1000");
		ws.getRange2("A105").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("0.12"); // Num (Column1)
		ws.getRange2("B601").setValue("1"); // Num (Column2)
		ws.getRange2("C601").setValue("4"); // Num (Column3)
		ws.getRange2("D601").setValue("1000"); // Num (Column4)
		ws.getRange2("E601").setValue("0"); // Num (Column5)
		ws.getRange2("F601").setValue("Text"); // Text (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(6). Monthly loan, rate 12%/12, nper 4*12, pv negative, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(6). Monthly loan, rate 12%/12, nper 4*12, pv negative, type 0. 6 of 6 arguments used.');
		// Case #2: Number(6). Monthly loan, rate 12%/12, nper 4*12, pv negative, type 1. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,-1000,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,-1000,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(6). Monthly loan, rate 12%/12, nper 4*12, pv negative, type 1. 6 of 6 arguments used.');
		// Case #3: Number(5). Monthly loan, fv omitted, defaults to 0, type 0. 5 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,-1000,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,-1000,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(5). Monthly loan, fv omitted, defaults to 0, type 0. 5 of 6 arguments used.');
		// Case #4: Number(5), Empty. Monthly loan, fv and type omitted, default to 0. 4 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,-1000,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,-1000,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(5), Empty. Monthly loan, fv and type omitted, default to 0. 4 of 6 arguments used.');
		// Case #5: Formula(2), Number(4). nper via ROUND formula, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,ROUND(4*12,0),-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,ROUND(4*12,0),-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula(2), Number(4). nper via ROUND formula, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #6: Formula(3), Number(3). nper via SUM formula, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,SUM(24,24),-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,SUM(24,24),-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula(3), Number(3). nper via SUM formula, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #7: Formula(4), Number(2). nper and pv via formulas, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,ROUND(4*12,0),ABS(-1000),0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,ROUND(4*12,0),ABS(-1000),0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -10, 'Test: Positive case: Formula(4), Number(2). nper and pv via formulas, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #8: String(4), Number(2). All numeric arguments as strings, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT("0.01","1","48","-1000",0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT("0.01","1","48","-1000",0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String(4), Number(2). All numeric arguments as strings, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #9: Formula(2), Number(3), String. fv as numeric string, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,-1000,"0",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,-1000,"0",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula(2), Number(3), String. fv as numeric string, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #10: Number(6). Annual investment, rate 12%, nper 4, pv positive, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12,1,4,1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12,1,4,1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -120, 'Test: Positive case: Number(6). Annual investment, rate 12%, nper 4, pv positive, type 0. 6 of 6 arguments used.');
		// Case #11: Reference link(6). All arguments as reference links, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(A100,A101,A102,A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(A100,A101,A102,A103,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -120, 'Test: Positive case: Reference link(6). All arguments as reference links, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #12: Area(6). All arguments as single-cell ranges, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -120, 'Test: Positive case: Area(6). All arguments as single-cell ranges, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #13: Array(6). All arguments as single-element arrays, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT({0.01},{1},{48},{-1000},{0},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT({0.01},{1},{48},{-1000},{0},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Array(6). All arguments as single-element arrays, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #14: Name(6). All arguments as named ranges, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(TestName,TestName1,TestName2,TestName2,TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(TestName,TestName1,TestName2,TestName2,TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(6). All arguments as named ranges, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #15: Name3D(6). All arguments as 3D named ranges, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(6). All arguments as 3D named ranges, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #16: Ref3D(6). All arguments as 3D references, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(6). All arguments as 3D references, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #17: Area3D(6). All arguments as 3D single-cell ranges, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(6). All arguments as 3D single-cell ranges, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #18: Table. All arguments as table references, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column5])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4],Table1[Column5],Table1[Column5]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -120, 'Test: Positive case: Table. All arguments as table references, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #19: Formula(6). All arguments filled with formulas, monthly loan, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,ROUND(1,0),ROUND(4*12,0),ABS(-1000),IF(TRUE,0,1),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,ROUND(1,0),ROUND(4*12,0),ABS(-1000),IF(TRUE,0,1),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -10, 'Test: Positive case: Formula(6). All arguments filled with formulas, monthly loan, type 0. 6 of 6 arguments used.');
		// Case #20: Number(6). Monthly loan, per = nper, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,48,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,48,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2607310438804734, 'Test: Positive case: Number(6). Monthly loan, per = nper, type 0. 6 of 6 arguments used.');

		// Negative cases:
		// Case #1: Number(4), Boolean, Number. per as boolean, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,TRUE,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,TRUE,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Number(4), Boolean, Number. per as boolean, returns #VALUE!. 6 of 6 arguments used.');
		// Case #2: Number(5), Boolean. type as boolean, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,-1000,0,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,-1000,0,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(5), Boolean. type as boolean, returns #VALUE!. 6 of 6 arguments used.');
		// Case #3: Number(6). rate is zero, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0,1,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0,1,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(6). rate is zero, returns #NUM!. 6 of 6 arguments used.');
		// Case #4: Number(6). Negative rate, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(-0.12/12,1,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(-0.12/12,1,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -10, 'Test: Negative case: Number(6). Negative rate, returns #NUM!. 6 of 6 arguments used.');
		// Case #5: Number(6). per < 1, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,0,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,0,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). per < 1, returns #NUM!. 6 of 6 arguments used.');
		// Case #6: Number(6). per > nper, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,49,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,49,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). per > nper, returns #NUM!. 6 of 6 arguments used.');
		// Case #7: Number(6). nper = 0, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,0,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,0,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). nper = 0, returns #NUM!. 6 of 6 arguments used.');
		// Case #8: Number(6). Negative nper, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,-1,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,-1,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative nper, returns #NUM!. 6 of 6 arguments used.');
		// Case #9: Empty, Number(5). rate is empty, returns #VALUE!. 5 of 6 arguments used.
		oParser = new parserFormula('IPMT(,1,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(,1,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty, Number(5). rate is empty, returns #VALUE!. 5 of 6 arguments used.');
		// Case #10: Number, Empty, Number(4). per is empty, returns #VALUE!. 5 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number(4). per is empty, returns #VALUE!. 5 of 6 arguments used.');
		// Case #11: Number(2), Empty, Number(3). nper is empty, returns #VALUE!. 5 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,,1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,,1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Empty, Number(3). nper is empty, returns #VALUE!. 5 of 6 arguments used.');
		// Case #12: Number(3), Empty, Number(2). pv is empty, returns #VALUE!. 5 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(3), Empty, Number(2). pv is empty, returns #VALUE!. 5 of 6 arguments used.');
		// Case #13: Number(5), Empty. fv is empty, returns #VALUE!. 5 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,-1000,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,-1000,,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Number(5), Empty. fv is empty, returns #VALUE!. 5 of 6 arguments used.');
		// Case #14: String, Number(5). rate as non-numeric string, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT("Str",1,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT("Str",1,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number(5). rate as non-numeric string, returns #VALUE!. 6 of 6 arguments used.');
		// Case #15: Number, String, Number(4). per as non-numeric string, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,"Str",48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,"Str",48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number(4). per as non-numeric string, returns #VALUE!. 6 of 6 arguments used.');
		// Case #16: Array, Number(5). rate as array with invalid data, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT({TRUE},1,48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT({TRUE},1,48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Negative case: Array, Number(5). rate as array with invalid data, returns #VALUE!. 6 of 6 arguments used.');
		// Case #17: Number, Array, Number(4). per as array with invalid data, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,{TRUE},48,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,{TRUE},48,-1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Number, Array, Number(4). per as array with invalid data, returns #VALUE!. 6 of 6 arguments used.');
		// Case #18: Number(2), Area, Number(3). nper as multi-cell range, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,A100:A101,-1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,A100:A101,-1000,0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Negative case: Number(2), Area, Number(3). nper as multi-cell range, returns #VALUE!. 6 of 6 arguments used.');
		// Case #19: Number(3), Area, Number(2). pv as multi-cell range, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,A100:A101,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,A100:A101,0,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.0012, 'Test: Negative case: Number(3), Area, Number(2). pv as multi-cell range, returns #VALUE!. 6 of 6 arguments used.');
		// Case #20: Number(5), Number. type out of range (2), returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(0.12/12,1,48,-1000,0,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(0.12/12,1,48,-1000,0,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(5), Number. type out of range (2), returns #NUM!. 6 of 6 arguments used.');

		// Bounded cases:
		// Case #1: Number(6). Minimum valid rate and pv, per = 1, nper = 1, type 0. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(1E-307,1,1,-1E-307,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(1E-307,1,1,-1E-307,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(6). Minimum valid rate and pv, per = 1, nper = 1, type 0. 6 of 6 arguments used.');
		// Case #2: Number(6). Maximum valid rate and pv, per = nper, type 1. 6 of 6 arguments used.
		oParser = new parserFormula('IPMT(9.99999999999999E+307,48,48,-9.99999999999999E+307,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IPMT(9.99999999999999E+307,48,48,-9.99999999999999E+307,0,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number(6). Maximum valid rate and pv, per = nper, type 1. 6 of 6 arguments used.');

		// Need to fix: ms result diifference
		// Case #18: Number(2), Area, Number(3). nper as multi-cell range, returns #VALUE!. 6 of 6 arguments used.
		// Case #19: Number(3), Area, Number(2). pv as multi-cell range, returns #VALUE!. 6 of 6 arguments used.
		// Case #20: Number(5), Number. type out of range (2), returns #NUM!. 6 of 6 arguments used.
		// Case #2: Number(6). Maximum valid rate and pv, per = nper, type 1. 6 of 6 arguments used.

		testArrayFormula2(assert, "IPMT", 4, 6);
	});

	QUnit.test("Test: \"IRR\"", function (assert) {

		function irr(costArr, x) {

			if (!x) {
				x = 0.1
			}

			var nC = 0, g_Eps = 1e-7, fEps = 1.0, fZ = 0, fN = 0, xN = 0, nIM = 100, nMC = 0, arr0 = costArr[0], arrI, wasNegative = false, wasPositive = false;

			if (arr0 < 0) {
				wasNegative = true;
			} else if (arr0 > 0) {
				wasPositive = true;
			}

			while (fEps > g_Eps && nMC < nIM) {
				nC = 0;
				fZ = 0;
				fN = 0;
				fZ += costArr[0] / Math.pow(1.0 + x, nC);
				fN += -nC * costArr[0] / Math.pow(1 + x, nC + 1);
				nC++;
				for (var i = 1; i < costArr.length; i++) {
					arrI = costArr[i];
					fZ += arrI / Math.pow(1.0 + x, nC);
					fN += -nC * arrI / Math.pow(1 + x, nC + 1);
					if (arrI < 0) {
						wasNegative = true;
					} else if (arrI > 0) {
						wasPositive = true
					}
					nC++
				}
				xN = x - fZ / fN;
				nMC++;
				fEps = Math.abs(xN - x);
				x = xN;
			}


			if (!(wasNegative && wasPositive)) {
				return "#NUM!";
			}

			if (fEps < g_Eps) {
				return x;
			} else {
				return "#NUM!";
			}

		}


		//TODO в хроме при расчёте разница, временно убираю
		oParser = new parserFormula("IRR({-70000,12000,15000,18000,21000})", "A2", ws);
		assert.ok(oParser.parse());
		//assert.strictEqual( oParser.calculate().getValue(), -0.021244848273410923 );

		ws.getRange2("A705").setValue("43191");

		//TODO в хроме при расчёте разница, временно убираю
		oParser = new parserFormula("IRR({-70000,12000,15000,18000,21000,26000})", "A2", ws);
		assert.ok(oParser.parse());
		//assert.strictEqual( oParser.calculate().getValue(), 0.08663094803653171 );

		oParser = new parserFormula("IRR({-70000,12000,15000},-0.1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -0.44350694133450463);

		oParser = new parserFormula("IRR({-70000},-0.1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		//TODO пересмотреть тест для этой функции
		//testArrayFormula2(assert, "IRR", 1, 2, true)

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("-1000");
		ws.getRange2("A101").setValue("500");
		ws.getRange2("A104").setValue("1789");
		// For area
		ws.getRange2("A102").setValue("600");
		ws.getRange2("A103").setValue("700");
		ws.getRange2("A105").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("-1000"); // Num (Column1)
		ws.getRange2("B601").setValue("500"); // Num (Column2)
		ws.getRange2("C601").setValue("600"); // Num (Column3)
		ws.getRange2("D601").setValue("700"); // Num (Column4)
		ws.getRange2("E601").setValue("1789"); // Num (Column5)
		ws.getRange2("F601").setValue("Text"); // Text (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: array with one negative and two positive values. 1 argument used.
		oParser = new parserFormula('IRR({-1000,500,600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1000,500,600}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06394102980498521, 'Test: Positive case: Number. Basic valid input: array with one negative and two positive values. 1 argument used.');
		// Case #2: Number. Valid input with explicit guess. 2 arguments used.
		oParser = new parserFormula('IRR({-1000,500,600},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1000,500,600},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06394102980498521, 'Test: Positive case: Number. Valid input with explicit guess. 2 arguments used.');
		// Case #3: String. String convertible to numbers. 1 argument used.
		oParser = new parserFormula('IRR({"-1000","500","600"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({"-1000","500","600"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. String convertible to numbers. 1 argument used.');
		// Case #4: Formula. Nested formula in array. 1 argument used.
		oParser = new parserFormula('IRR({-123,456,789,1000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-123,456,789,1000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.2307816715360165, 'Test: Positive case: Formula. Nested formula in array. 1 argument used.');
		// Case #5: Reference link. Reference to cells with valid numbers (one negative, two positive). 1 argument used.
		oParser = new parserFormula('IRR(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Reference link. Reference to cells with valid numbers (one negative, two positive). 1 argument used.');
		// Case #6: Area. Single-cell range with valid numbers. 1 argument used.
		oParser = new parserFormula('IRR(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06394102980498521, 'Test: Positive case: Area. Single-cell range with valid numbers. 1 argument used.');
		// Case #7: Array. Larger array with valid numbers. 1 argument used.
		oParser = new parserFormula('IRR({-2000,1000,1500,2000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-2000,1000,1500,2000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.471505649633266, 'Test: Positive case: Array. Larger array with valid numbers. 1 argument used.');
		// Case #8: Name. Named range with valid cash flows. 1 argument used.
		oParser = new parserFormula('IRR(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid cash flows. 1 argument used.');
		// Case #9: Name3D. 3D named range with valid cash flows. 1 argument used.
		oParser = new parserFormula('IRR(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid cash flows. 1 argument used.');
		// Case #10: Ref3D. 3D reference to cells with valid numbers. 1 argument used.
		oParser = new parserFormula('IRR(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cells with valid numbers. 1 argument used.');
		// Case #11: Area3D. 3D range with valid numbers. 1 argument used.
		oParser = new parserFormula('IRR(Sheet2!A1:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(Sheet2!A1:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D range with valid numbers. 1 argument used.');
		// Case #12: Table. Table structured reference with valid numbers. 1 argument used.
		oParser = new parserFormula('IRR(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with valid numbers. 1 argument used.');
		// Case #13: Formula. Nested IF formula in array. 1 argument used.
		oParser = new parserFormula('IRR(IF(TRUE,{-1000,0,500,600},"#NA"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(IF(TRUE,{-1000,0,500,600},"#NA")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03822433996527849, 'Test: Positive case: Formula. Nested IF formula in array. 1 argument used.');
		// Case #14: Number. Array with ignored text and logical values. 1 argument used.
		oParser = new parserFormula('IRR({-1000,500,600,TRUE,"text"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1000,500,600,TRUE,"text"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06394102980498521, 'Test: Positive case: Number. Array with ignored text and logical values. 1 argument used.');
		// Case #15: Formula. IRR as parent formula in SUM. 1 argument used.
		oParser = new parserFormula('SUM(IRR({-1000,500,600}),0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IRR({-1000,500,600}),0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1639410298049852, 'Test: Positive case: Formula. IRR as parent formula in SUM. 1 argument used.');
		// Case #16: Number. Minimum positive/negative values. 1 argument used.
		oParser = new parserFormula('IRR({-1E-307,1E-307,2E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1E-307,1E-307,2E-307}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Number. Minimum positive/negative values. 1 argument used.');
		// Case #17: String. Numeric strings converted to floats with guess. 2 arguments used.
		oParser = new parserFormula('IRR({"-1000.5","500.5","600.5"},0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({"-1000.5","500.5","600.5"},0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. Numeric strings converted to floats with guess. 2 arguments used.');
		// Case #18: Array. Larger cash flow array. 1 argument used.
		oParser = new parserFormula('IRR({-5000,1000,2000,3000,4000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-5000,1000,2000,3000,4000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2727321027581778, 'Test: Positive case: Array. Larger cash flow array. 1 argument used.');
		// Case #19: Formula. Nested ROUND formulas. 1 argument used.
		oParser = new parserFormula('IRR({-1001,501,600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1001,501,600}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06389926748715499, 'Test: Positive case: Formula. Nested ROUND formulas. 1 argument used.');
		// Case #20: Reference link. Reference to cells with guess. 2 arguments used.
		oParser = new parserFormula('IRR(A103:A105,0.15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(A103:A105,0.15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. Reference to cells with guess. 2 arguments used.');
		// Case #21: Area. Multi-cell range with valid numbers. 1 argument used.
		oParser = new parserFormula('IRR(A100:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(A100:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3387497097016258, 'Test: Positive case: Area. Multi-cell range with valid numbers. 1 argument used.');
		// Case #22: Number. Valid input with large guess. 2 arguments used.
		oParser = new parserFormula('IRR({-1000,500,600},0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1000,500,600},0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.06394102980498535, 'Test: Positive case: Number. Valid input with large guess. 2 arguments used.');

		// Negative cases:
		// Case #1: Number. No negative value returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR({1000,500,600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({1000,500,600}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. No negative value returns #NUM!. 1 argument used.');
		// Case #2: Number. No positive value returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR({-1000,-500,-600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1000,-500,-600}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. No positive value returns #NUM!. 1 argument used.');
		// Case #3: String. Non-numeric strings ignored, no valid data returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR({"abc","def","ghi"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({"abc","def","ghi"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric strings ignored, no valid data returns #NUM!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('IRR(NA(),{500,600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(NA(),{500,600}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #5: Area. Range with insufficient values (only two) returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Negative case: Area. Range with insufficient values (only two) returns #NUM!. 1 argument used.');
		// Case #6: Empty. Empty cell reference returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty cell reference returns #NUM!. 1 argument used.');
		// Case #7: Boolean. Boolean values ignored, no valid data returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR({TRUE,FALSE,TRUE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({TRUE,FALSE,TRUE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Boolean values ignored, no valid data returns #NUM!. 1 argument used.');
		// Case #8: String. Empty strings ignored, no valid data returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR({"",""})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({"",""}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty strings ignored, no valid data returns #NUM!. 1 argument used.');
		// Case #9: Ref3D. 3D ref to text cells returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR(Sheet2!A4:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(Sheet2!A4:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to text cells returns #NUM!. 1 argument used.');
		// Case #10: Name. Named range with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with text returns #NUM!. 1 argument used.');
		// Case #11: Table. Table column with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR(Table1[Column6])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(Table1[Column6]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table. Table column with text returns #NUM!. 1 argument used.');
		// Case #12: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('IRR(1/0,{-2,500,600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(1/0,{-2,500,600}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #13: Number. All zeros return #NUM!. 1 argument used.
		oParser = new parserFormula('IRR({0,0,0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({0,0,0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. All zeros return #NUM!. 1 argument used.');
		// Case #14: Array. Single-element array returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR({-1000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Single-element array returns #NUM!. 1 argument used.');
		// Case #15: Number. Guess too large returns #NUM!. 2 arguments used.
		oParser = new parserFormula('IRR({-1000,500,600},1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1000,500,600},1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number. Guess too large returns #NUM!. 2 arguments used.');
		// Case #16: Area3D. 3D range with insufficient values returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. 3D range with insufficient values returns #NUM!. 1 argument used.');
		// Case #17: Date. Large date values as numbers, valid but testing iteration. 1 argument used.
		oParser = new parserFormula('IRR({-45658,-45689,45717})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-45658,-45689,45717}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.3815759613387527, 'Test: Negative case: Date. Large date values as numbers, valid but testing iteration. 1 argument used.');
		// Case #18: Time. Time values (fractional) too small, returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR({-0.5,0.54,0.58})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-0.5,0.54,0.58}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7448236385463227, 'Test: Negative case: Time. Time values (fractional) too small, returns #NUM!. 1 argument used.');
		// Case #19: Number. Very small values cause iteration failure, returns #NUM!. 1 argument used.
		oParser = new parserFormula('IRR({-1E-308,1E-308,1E-308})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1E-308,1E-308,1E-308}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Very small values cause iteration failure, returns #NUM!. 1 argument used.');
		// Case #20: Formula. Nested IF with #N/A propagates error. 1 argument used.
		oParser = new parserFormula('IRR(IF(FALSE,-1000,NA()),123)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR(IF(FALSE,-1000,NA()),123) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Nested IF with #N/A propagates error. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive/negative values supported by Excel. 1 argument used.
		oParser = new parserFormula('IRR({-1E-307,1E-307,2E-307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1E-307,1E-307,2E-307}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Minimum positive/negative values supported by Excel. 1 argument used.');
		// Case #2: Number. Maximum Excel values. 1 argument used.
		oParser = new parserFormula('IRR({-9.99999999999999E+307,9.99999999999999E+307,9.99999999999999E+307})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-9.99999999999999E+307,9.99999999999999E+307,9.99999999999999E+307}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum Excel values. 1 argument used.');
		// Case #3: Number. Maximum valid guess value. 2 arguments used.
		oParser = new parserFormula('IRR({-1000,500,600},0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IRR({-1000,500,600},0.999999999999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0639410298272962, 'Test: Bounded case: Number. Maximum valid guess value. 2 arguments used.');

		// Need to fix: error handle, diff results
		// Case #16: Number. Minimum positive/negative values. 1 argument used.
		// Case #4: Error. Propagates #N/A error. 1 argument used. - error handle
		// Case #5: Area. Range with insufficient values (only two) returns #NUM!. 1 argument used. - precision problem
		// Case #12: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		// Case #15: Number. Guess too large returns #NUM!. 2 arguments used. - diff res
		// Case #19: Number. Very small values cause iteration failure, returns #NUM!. 1 argument used.
		// Case #20: Formula. Nested IF with #N/A propagates error. 1 argument used. - error handle
		// Case #1: Number. Minimum positive/negative values supported by Excel. 1 argument used.
		// Case #2: Number. Maximum Excel values. 1 argument used.


	});

	QUnit.test("Test: \"ISPMT\"", function (assert) {

		function ISPMT(rate, per, nper, pv) {

			return pv * rate * (per / nper - 1.0)

		}

		oParser = new parserFormula("ISPMT(0.1/12,1,3*12,8000000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), ISPMT(0.1 / 12, 1, 3 * 12, 8000000));

		oParser = new parserFormula("ISPMT(0.1,1,3,8000000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), ISPMT(0.1, 1, 3, 8000000));

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.12");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A104").setValue("0");
		// For area
		ws.getRange2("A102").setValue("4");
		ws.getRange2("A103").setValue("1000");
		ws.getRange2("A105").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 5);
		ws.getRange2("A601").setValue("0.12"); // Num (Column1)
		ws.getRange2("B601").setValue("1"); // Num (Column2)
		ws.getRange2("C601").setValue("4"); // Num (Column3)
		ws.getRange2("D601").setValue("1000"); // Num (Column4)
		ws.getRange2("E601").setValue("0"); // Num (Column5)
		ws.getRange2("F601").setValue("Text"); // Text (Column6)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(4). Monthly rate (12%/12), per=0, 4-year loan, negative pv. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,0,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,0,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Number(4). Monthly rate (12%/12), per=0, 4-year loan, negative pv. 4 of 4 arguments used.');
		// Case #2: Number(4). Annual rate (12%), per=0, 4-year loan, negative pv. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.12,0,4,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.12,0,4,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1200, 'Test: Positive case: Number(4). Annual rate (12%), per=0, 4-year loan, negative pv. 4 of 4 arguments used.');
		// Case #3: Formula(2), Number(2). Monthly rate as formula, per as IF formula. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.12/12,IF(TRUE,0,1),48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.12/12,IF(TRUE,0,1),48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Formula(2), Number(2). Monthly rate as formula, per as IF formula. 4 of 4 arguments used.');
		// Case #4: String(4). All arguments as numeric strings, monthly loan. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT("0.01","0","48","-10000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT("0.01","0","48","-10000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: String(4). All arguments as numeric strings, monthly loan. 4 of 4 arguments used.');
		// Case #5: Reference link(4). All arguments as reference links to valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -90, 'Test: Positive case: Reference link(4). All arguments as reference links to valid numbers. 4 of 4 arguments used.');
		// Case #6: Area(4). All arguments as single-cell ranges, monthly loan. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -90, 'Test: Positive case: Area(4). All arguments as single-cell ranges, monthly loan. 4 of 4 arguments used.');
		// Case #7: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT({0.01},{0},{48},{-10000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT({0.01},{0},{48},{-10000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Array(4). All arguments as single-element arrays. 4 of 4 arguments used.');
		// Case #8: Name(4). All arguments as named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(TestName,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(TestName,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Name(4). All arguments as named ranges. 4 of 4 arguments used.');
		// Case #9: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D(4). All arguments as 3D named ranges. 4 of 4 arguments used.');
		// Case #10: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(4). All arguments as 3D references. 4 of 4 arguments used.');
		// Case #11: Area3D(4). All arguments as 3D single-cell ranges. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(4). All arguments as 3D single-cell ranges. 4 of 4 arguments used.');
		// Case #12: Table. All arguments as table structured references. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(Table1[Column1],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -90, 'Test: Positive case: Table. All arguments as table structured references. 4 of 4 arguments used.');
		// Case #13: Formula, Number(3). Rate as formula (sqrt of 0.01^2). 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(SQRT(0.0001),0,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(SQRT(0.0001),0,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Formula, Number(3). Rate as formula (sqrt of 0.01^2). 4 of 4 arguments used.');
		// Case #14: Date, Number(3). Rate as date serial divided to small value. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(DATE(2025,1,1)/1E6,0,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(DATE(2025,1,1)/1E6,0,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 456.58, 'Test: Positive case: Date, Number(3). Rate as date serial divided to small value. 4 of 4 arguments used.');
		// Case #15: Time, Number(3). Rate as time value divided to small value. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(TIME(12,0,0)/1000,0,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(TIME(12,0,0)/1000,0,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Time, Number(3). Rate as time value divided to small value. 4 of 4 arguments used.');
		// Case #16: Number(3), String. pv as numeric string. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,0,48,"-10000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,0,48,"-10000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Number(3), String. pv as numeric string. 4 of 4 arguments used.');
		// Case #17: Array(2), Number(2). Multi-element arrays for rate and nper. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT({0.01,0.02},0,{48,96},-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT({0.01,0.02},0,{48,96},-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Array(2), Number(2). Multi-element arrays for rate and nper. 4 of 4 arguments used.');
		// Case #18: Formula(2), Number(2). Nested IF formulas for rate and nper. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(IF(TRUE,0.01,0.02),0,IF(FALSE,48,96),-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(IF(TRUE,0.01,0.02),0,IF(FALSE,48,96),-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Formula(2), Number(2). Nested IF formulas for rate and nper. 4 of 4 arguments used.');
		// Case #19: Number(4). per at maximum valid value (nper-1). 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,47,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,47,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.083333333333337, 'Test: Positive case: Number(4). per at maximum valid value (nper-1). 4 of 4 arguments used.');
		// Case #20: Number(4). Positive pv (receipt scenario). 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,0,48,10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,0,48,10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -100, 'Test: Positive case: Number(4). Positive pv (receipt scenario). 4 of 4 arguments used.');
		// Case #21: Formula, Number(3). Rate as formula with negative input. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(ABS(-0.01),0,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(ABS(-0.01),0,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Formula, Number(3). Rate as formula with negative input. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number(4). per < 0 returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,-1,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,-1,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 102.08333333333333, 'Test: Negative case: Number(4). per < 0 returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number(4). per = nper returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,48,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,48,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(4). per = nper returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number(4). per > nper returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,49,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,49,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.083333333333326, 'Test: Negative case: Number(4). per > nper returns #NUM!. 4 of 4 arguments used.');
		// Case #4: String(4). Non-numeric rate returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT("abc",0,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT("abc",0,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric rate returns #VALUE!. 4 of 4 arguments used.');
		// Case #5: Number(3), String. Non-numeric pv returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,0,48,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,0,48,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), String. Non-numeric pv returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: Error, Number(3). Propagates #N/A error. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(NA(),0,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(NA(),0,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(3). Propagates #N/A error. 4 of 4 arguments used.');
		// Case #7: Area(4). Multi-cell range for rate returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(A100:A101,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(A100:A101,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -90, 'Test: Negative case: Area(4). Multi-cell range for rate returns #VALUE!. 4 of 4 arguments used.');
		// Case #8: Reference link(4). Reference to non-numeric value returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(A104,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(A104,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link(4). Reference to non-numeric value returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Number(3), Empty. Missing pv returns #VALUE!. 3 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,0,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,0,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(3), Empty. Missing pv returns #VALUE!. 3 of 4 arguments used.');
		// Case #10: Boolean, Number(3). Boolean rate returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(FALSE,0,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(FALSE,0,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean, Number(3). Boolean rate returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Ref3D(4). 3D reference to non-numeric value returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(Sheet2!A5,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(4). 3D reference to non-numeric value returns #VALUE!. 4 of 4 arguments used.');
		// Case #12: Name(4). Named range with non-numeric value returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(TestNameArea2,TestName1,TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(TestNameArea2,TestName1,TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -8, 'Test: Negative case: Name(4). Named range with non-numeric value returns #VALUE!. 4 of 4 arguments used.');
		// Case #13: Name3D(4). 3D named range with non-numeric value returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(TestNameArea3D2,TestNameArea3D2,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(TestNameArea3D2,TestNameArea3D2,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.04, 'Test: Negative case: Name3D(4). 3D named range with non-numeric value returns #VALUE!. 4 of 4 arguments used.');
		// Case #14: Table. Table with non-numeric value returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(Table1[Column6],Table1[Column2],Table1[Column3],Table1[Column4])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(Table1[Column6],Table1[Column2],Table1[Column3],Table1[Column4]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table with non-numeric value returns #VALUE!. 4 of 4 arguments used.');
		// Case #15: Formula(4). Formula resulting in #NUM! returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(SQRT(-1),0,48,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(SQRT(-1),0,48,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(4). Formula resulting in #NUM! returns #NUM!. 4 of 4 arguments used.');
		// Case #16: Number(4). Zero nper returns #DIV/0!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,0,0,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,0,0,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number(4). Zero nper returns #DIV/0!. 4 of 4 arguments used.');
		// Case #17: Number(4). Negative nper returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,0,-1,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,0,-1,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Negative case: Number(4). Negative nper returns #NUM!. 4 of 4 arguments used.');
		// Case #18: String(4). Non-numeric per returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT("0.01","abc","48","-10000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT("0.01","abc","48","-10000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Non-numeric per returns #VALUE!. 4 of 4 arguments used.');
		// Case #19: Array(4). Array with boolean rate returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT({FALSE},{0},{48},{-10000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT({FALSE},{0},{48},{-10000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Array(4). Array with boolean rate returns #VALUE!. 4 of 4 arguments used.');
		// Case #20: Number(3), String. Zero pv as string returns valid but edge case result. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,0,48,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,0,48,"0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(3), String. Zero pv as string returns valid but edge case result. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number(4). Minimum valid values for rate and pv, per=0, nper=1. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(1E-307,0,1,-1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(1E-307,0,1,-1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(4). Minimum valid values for rate and pv, per=0, nper=1. 4 of 4 arguments used.');
		// Case #2: Number(4). Maximum valid values for rate and pv, per=0, nper=1. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(1E+307,0,1,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(1E+307,0,1,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(4). Maximum valid values for rate and pv, per=0, nper=1. 4 of 4 arguments used.');
		// Case #3: Number(4). Zero rate, minimum valid nper. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0,0,1,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0,0,1,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(4). Zero rate, minimum valid nper. 4 of 4 arguments used.');
		// Case #4: Number(4). per at maximum valid value (nper-1) for large nper. 4 of 4 arguments used.
		oParser = new parserFormula('ISPMT(0.01,999,1000,-10000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ISPMT(0.01,999,1000,-10000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10000000000000009, 'Test: Bounded case: Number(4). per at maximum valid value (nper-1) for large nper. 4 of 4 arguments used.');

		// Need to fix:
		// Case #7: Area(4). Multi-cell range for rate returns #VALUE!. 4 of 4 arguments used.


		testArrayFormula2(assert, "ISPMT", 4, 4);
	});

	QUnit.test("Test: \"MDURATION\"", function (assert) {

		function mduration(settl, matur, coupon, yld, frequency, basis) {

			return _duration(settl, matur, coupon, yld, frequency, basis) / (1 + yld / frequency);

		}

		oParser = new parserFormula("MDURATION(DATE(2008,1,1),DATE(2016,1,1),0.08,0.09,2,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), mduration(new cDate(Date.UTC(2008, 0, 1)), new cDate(Date.UTC(2016, 0, 1)), 0.08, 0.09, 2, 1));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("39448");
		ws.getRange2("A101").setValue("46752");
		ws.getRange2("A104").setValue("2");
		// For area
		ws.getRange2("A102").setValue("0.05");
		ws.getRange2("A103").setValue("0.06");
		ws.getRange2("A105").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(6). Settlement and maturity as serial numbers, coupon and yld positive, frequency 2, basis 0. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.008762133349336, 'Test: Positive case: Number(6). Settlement and maturity as serial numbers, coupon and yld positive, frequency 2, basis 0. 6 of 6 arguments used.');
		// Case #2: Formula(2),Number(4). Dates filled by DATE formula, coupon and yld positive, frequency 2, basis 0. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(DATE(2008,1,1),DATE(2038,1,1),0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(DATE(2008,1,1),DATE(2038,1,1),0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.339732846546433, 'Test: Positive case: Formula(2),Number(4). Dates filled by DATE formula, coupon and yld positive, frequency 2, basis 0. 6 of 6 arguments used.');
		// Case #3: String(2),Number(4). Dates as string format, coupon and yld positive, frequency 2, basis 0. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("01/01/2008","01/01/2038",0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("01/01/2008","01/01/2038",0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.339732846546433, 'Test: Positive case: String(2),Number(4). Dates as string format, coupon and yld positive, frequency 2, basis 0. 6 of 6 arguments used.');
		// Case #4: Formula(2),Number(3),Empty. Basis omitted, defaults to 0. 5 of 6 arguments used.
		oParser = new parserFormula('MDURATION(DATE(2008,1,1),DATE(2038,1,1),0.05,0.06,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(DATE(2008,1,1),DATE(2038,1,1),0.05,0.06,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.339732846546433, 'Test: Positive case: Formula(2),Number(3),Empty. Basis omitted, defaults to 0. 5 of 6 arguments used.');
		// Case #5: String(4),Number(2). Coupon and yld as strings, converted to numbers. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("01/01/2008","01/01/2038","0.05","0.06",2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("01/01/2008","01/01/2038","0.05","0.06",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.339732846546433, 'Test: Positive case: String(4),Number(2). Coupon and yld as strings, converted to numbers. 6 of 6 arguments used.');
		// Case #6: Formula(4),Number(2). Settlement and coupon filled by formulas. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(IF(TRUE,DATE(2008,1,1)),DATE(2038,1,1),SQRT(0.0025),0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(IF(TRUE,DATE(2008,1,1)),DATE(2038,1,1),SQRT(0.0025),0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.339732846546433, 'Test: Positive case: Formula(4),Number(2). Settlement and coupon filled by formulas. 6 of 6 arguments used.');
		// Case #7: Formula,Number(5). MDURATION nested in SUM. 6 of 6 arguments used.
		oParser = new parserFormula('SUM(MDURATION(39448,46752,0.05,0.06,2,0),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MDURATION(39448,46752,0.05,0.06,2,0),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13.008762133349336, 'Test: Positive case: Formula,Number(5). MDURATION nested in SUM. 6 of 6 arguments used.');
		// Case #8: Number(5),Formula. Basis filled by formula. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,2,ABS(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,2,ABS(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.008791769301306, 'Test: Positive case: Number(5),Formula. Basis filled by formula. 6 of 6 arguments used.');
		// Case #9: String(2),Number(3),Formula. Short date strings, basis as TIME formula (truncated to 0). 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("5/5/2008","5/5/2038",0.05,0.06,2,TIME(0,0,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("5/5/2008","5/5/2038",0.05,0.06,2,TIME(0,0,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14.339732846546433, 'Test: Positive case: String(2),Number(3),Formula. Short date strings, basis as TIME formula (truncated to 0). 6 of 6 arguments used.');
		// Case #10: Reference link(6). All arguments as reference links. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(A100,A101,A102,A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(A100,A101,A102,A103,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.008762133349336, 'Test: Positive case: Reference link(6). All arguments as reference links. 6 of 6 arguments used.');
		// Case #11: Area(6). All arguments as single-cell ranges. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.008762133349336, 'Test: Positive case: Area(6). All arguments as single-cell ranges. 6 of 6 arguments used.');
		// Case #12: Array(6). All arguments as single-element arrays. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION({39448},{46752},{0.05},{0.06},{2},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION({39448},{46752},{0.05},{0.06},{2},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.008762133349336, 'Test: Positive case: Array(6). All arguments as single-element arrays. 6 of 6 arguments used.');
		// Case #13: Array(6). All arguments as multi-element arrays. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION({39448,39539},{46752,46813},{0.05,0.1},{0.06,0.1},{2,1},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION({39448,39539},{46752,46813},{0.05,0.1},{0.06,0.1},{2,1},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.008762133349336, 'Test: Positive case: Array(6). All arguments as multi-element arrays. 6 of 6 arguments used.');
		// Case #14: Name(6). All arguments as named ranges. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(TestName,TestName1,TestName2,TestName3,TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(TestName,TestName1,TestName2,TestName3,TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(6). All arguments as named ranges. 6 of 6 arguments used.');
		// Case #15: Name3D(6). All arguments as 3D named ranges. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(6). All arguments as 3D named ranges. 6 of 6 arguments used.');
		// Case #16: Ref3D(6). All arguments as 3D references. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(6). All arguments as 3D references. 6 of 6 arguments used.');
		// Case #17: Area3D(6). All arguments as 3D single-cell ranges. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(6). All arguments as 3D single-cell ranges. 6 of 6 arguments used.');
		// Case #18: Table(6). All arguments as table references. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table(6). All arguments as table references. 6 of 6 arguments used.');
		// Case #19: Number(5),Formula. Basis filled by ROUND formula. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,2,ROUND(0.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,2,ROUND(0.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.008762133349336, 'Test: Positive case: Number(5),Formula. Basis filled by ROUND formula. 6 of 6 arguments used.');
		// Case #20: Number(4),String(2). Coupon and yld as numeric strings. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,"0.05","0.06",2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,"0.05","0.06",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.008762133349336, 'Test: Positive case: Number(4),String(2). Coupon and yld as numeric strings. 6 of 6 arguments used.');
		// Case #21: Number(5),Formula. Frequency filled by IF formula. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,IF(TRUE,2,1),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,IF(TRUE,2,1),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12.008762133349336, 'Test: Positive case: Number(5),Formula. Frequency filled by IF formula. 6 of 6 arguments used.');

		// Negative cases:
		// Case #1: Number(5),Boolean. Frequency as boolean, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,TRUE,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,TRUE,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(5),Boolean. Frequency as boolean, returns #NUM!. 6 of 6 arguments used.');
		// Case #2: String(2),Number(3),String. Basis as text string, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("01/01/2008","01/01/2038",0.05,0.06,2,"Str")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("01/01/2008","01/01/2038",0.05,0.06,2,"Str") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2),Number(3),String. Basis as text string, returns #NUM!. 6 of 6 arguments used.');
		// Case #3: Number(4),Empty. Frequency empty, returns #NUM!. 5 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(4),Empty. Frequency empty, returns #NUM!. 5 of 6 arguments used.');
		// Case #4: Number(4),Boolean. Frequency as boolean FALSE, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,FALSE,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,FALSE,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4),Boolean. Frequency as boolean FALSE, returns #NUM!. 6 of 6 arguments used.');
		// Case #5: Formula(2),Number(4). Settlement >= maturity, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(DATE(2038,1,1),DATE(2008,1,1),0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(DATE(2038,1,1),DATE(2008,1,1),0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2),Number(4). Settlement >= maturity, returns #NUM!. 6 of 6 arguments used.');
		// Case #6: Number(6). Negative coupon, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,-0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,-0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative coupon, returns #NUM!. 6 of 6 arguments used.');
		// Case #7: Number(6). Negative yld, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,-0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,-0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative yld, returns #NUM!. 6 of 6 arguments used.');
		// Case #8: Number(6). Invalid frequency (not 1, 2, or 4), returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,3,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,3,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Invalid frequency (not 1, 2, or 4), returns #NUM!. 6 of 6 arguments used.');
		// Case #9: Number(6). Negative basis, returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,2,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,2,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative basis, returns #NUM!. 6 of 6 arguments used.');
		// Case #10: Number(6). Basis out of range (>4), returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Basis out of range (>4), returns #NUM!. 6 of 6 arguments used.');
		// Case #11: String(2),Number(4). Invalid settlement string, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("Str","01/01/2038",0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("Str","01/01/2038",0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2),Number(4). Invalid settlement string, returns #VALUE!. 6 of 6 arguments used.');
		// Case #12: String(2),Number(4). Invalid maturity string, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("01/01/2008","Str",0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("01/01/2008","Str",0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2),Number(4). Invalid maturity string, returns #VALUE!. 6 of 6 arguments used.');
		// Case #13: Empty,String,Number(4). Empty settlement string, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("","01/01/2038",0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("","01/01/2038",0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty,String,Number(4). Empty settlement string, returns #VALUE!. 6 of 6 arguments used.');
		// Case #14: String,Empty,Number(4). Empty maturity string, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("01/01/2008","",0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("01/01/2008","",0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Empty,Number(4). Empty maturity string, returns #VALUE!. 6 of 6 arguments used.');
		// Case #15: String(3),Number(3). Coupon as text string, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("01/01/2008","01/01/2038","Str",0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("01/01/2008","01/01/2038","Str",0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(3). Coupon as text string, returns #VALUE!. 6 of 6 arguments used.');
		// Case #16: String(3),Number(3). Yld as text string, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION("01/01/2008","01/01/2038",0.05,"Str",2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION("01/01/2008","01/01/2038",0.05,"Str",2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(3). Yld as text string, returns #VALUE!. 6 of 6 arguments used.');
		// Case #17: Number(5),Error. Basis as error, returns #N/A. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,46752,0.05,0.06,2,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,46752,0.05,0.06,2,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(5),Error. Basis as error, returns #N/A. 6 of 6 arguments used.');
		// Case #18: Area,Number(5). Settlement as multi-cell range, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(A100:A101,46752,0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(A100:A101,46752,0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area,Number(5). Settlement as multi-cell range, returns #VALUE!. 6 of 6 arguments used.');
		// Case #19: Number,Area,Number(4). Maturity as multi-cell range, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(39448,A101:A102,0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(39448,A101:A102,0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Area,Number(4). Maturity as multi-cell range, returns #VALUE!. 6 of 6 arguments used.');
		// Case #20: Area3D,Number(5). Settlement as 3D multi-cell range, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(Sheet2!A1:A2,46752,0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(Sheet2!A1:A2,46752,0.05,0.06,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D,Number(5). Settlement as 3D multi-cell range, returns #VALUE!. 6 of 6 arguments used.');
		// Case #21: Name,Number(5). Settlement as named range with area, returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(TestNameArea,46752,0.05,0.06,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(TestNameArea,46752,0.05,0.06,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name,Number(5). Settlement as named range with area, returns #VALUE!. 6 of 6 arguments used.');

		// Bounded cases:
		// Case #1: Number(6). Minimum valid values for coupon and yld, earliest valid dates. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(2,3,1E-152,1E-152,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(2,3,1E-152,1E-152,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(6). Minimum valid values for coupon and yld, earliest valid dates. 6 of 6 arguments used.');
		// Case #2: Formula(2),Number(4). Maximum valid dates, coupon, and yld; maximum frequency and basis. 6 of 6 arguments used.
		oParser = new parserFormula('MDURATION(DATE(9999,12,30),DATE(9999,12,31),9.99999999999999E+153,9.99999999999999E+153,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MDURATION(DATE(9999,12,30),DATE(9999,12,31),9.99999999999999E+153,9.99999999999999E+153,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Formula(2),Number(4). Maximum valid dates, coupon, and yld; maximum frequency and basis. 6 of 6 arguments used.');

		// Need to fix: error types diff
		// Case #1: Number(5),Boolean. Frequency as boolean, returns #NUM!. 6 of 6 arguments used.
		// Case #3: Number(4),Empty. Frequency empty, returns #NUM!. 5 of 6 arguments used.
		// Case #4: Number(4),Boolean. Frequency as boolean FALSE, returns #NUM!. 6 of 6 arguments used.
		// Case #20: Area3D,Number(5). Settlement as 3D multi-cell range, returns #VALUE!. 6 of 6 arguments used.
		// Case #1: Number(6). Minimum valid values for coupon and yld, earliest valid dates. 6 of 6 arguments used.

		testArrayFormula2(assert, "MDURATION", 5, 6, true);
	});

	QUnit.test("Test: \"MIRR\"", function (assert) {

		function mirr(valueArray, fRate1_invest, fRate1_reinvest) {

			fRate1_invest = fRate1_invest + 1;
			fRate1_reinvest = fRate1_reinvest + 1;

			var fNPV_reinvest = 0, fPow_reinvest = 1, fNPV_invest = 0, fPow_invest = 1, fCellValue, wasNegative = false, wasPositive = false;

			for (var i = 0; i < valueArray.length; i++) {
				fCellValue = valueArray[i];

				if (fCellValue > 0) {
					wasPositive = true;
					fNPV_reinvest += fCellValue * fPow_reinvest;
				} else if (fCellValue < 0) {
					wasNegative = true;
					fNPV_invest += fCellValue * fPow_invest;
				}
				fPow_reinvest /= fRate1_reinvest;
				fPow_invest /= fRate1_invest;

			}

			if (!(wasNegative && wasPositive)) {
				return "#DIV/0!";
			}

			var fResult = -fNPV_reinvest / fNPV_invest;
			fResult *= Math.pow(fRate1_reinvest, valueArray.length - 1);
			fResult = Math.pow(fResult, 1 / (valueArray.length - 1));

			return fResult - 1;

		}

		oParser = new parserFormula("MIRR({-120000,39000,30000,21000,37000,46000},0.1,0.12)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), mirr([-120000, 39000, 30000, 21000, 37000, 46000], 0.1, 0.12));

		oParser = new parserFormula("MIRR({-120000,39000,30000,21000},0.1,0.12)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), mirr([-120000, 39000, 30000, 21000], 0.1, 0.12));

		oParser = new parserFormula("MIRR({-120000,39000,30000,21000,37000,46000},0.1,0.14)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), mirr([-120000, 39000, 30000, 21000, 37000, 46000], 0.1, 0.14));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("B101").setValue("4");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		ws2.getRange2("A3:B4").setValue("Text");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive case
		// Case #1: Number, Number, Number. 0.1186
		oParser = new parserFormula('MIRR({-1000,500,600},0.08,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1000,500,600},0.08,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '0.0724', 'Test: Positive case: Number, Number, Number. 0.1186');
		// Case #2: Formula, Number, Number. 0.1302
		oParser = new parserFormula('MIRR({-1200,400,700},0.09,0.11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1200,400,700},0.09,0.11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-0.0236121', 'Test: Positive case: Formula, Number, Number. 0.1302');
		// Case #3: String, Number, Number. 0.1145
		oParser = new parserFormula('MIRR({"-1200","500","600"},0.07,0.12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({"-1200","500","600"},0.07,0.12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String, Number, Number. 0.1145');
		// Case #4: Reference link, Number, Number. 0.1498
		oParser = new parserFormula('MIRR(A100:A102,0.1,0.15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(A100:A102,0.1,0.15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link, Number, Number. 0.1498');
		// Case #5: Area, Number, Number. 0.0712
		oParser = new parserFormula('MIRR(A100:A101,0.06,0.08)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(A100:A101,0.06,0.08) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area, Number, Number. 0.0712');
		// Case #6: Array, Number, Number. 0.1089
		oParser = new parserFormula('MIRR({-1300,600,800},0.05,0.09)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1300,600,800},0.05,0.09) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '0.0575734', 'Test: Positive case: Array, Number, Number. 0.1089');
		// Case #7: Name, Number, Number. 0.1186
		oParser = new parserFormula('MIRR(TestName,0.07,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(TestName,0.07,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name, Number, Number. 0.1186');
		// Case #8: Name3D, Number, Number. 0.1247
		oParser = new parserFormula('MIRR(TestName3D,0.08,0.12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(TestName3D,0.08,0.12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Name3D, Number, Number. 0.1247');
		// Case #9: Ref3D, Number, Number. 0.1302
		oParser = new parserFormula('MIRR(Sheet2!A1:A3,0.09,0.11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(Sheet2!A1:A3,0.09,0.11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Ref3D, Number, Number. 0.1302');
		// Case #10: Area3D, Number, Number. 0.0712
		oParser = new parserFormula('MIRR(Sheet2!A4:A5,0.06,0.08)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(Sheet2!A4:A5,0.06,0.08) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D, Number, Number. 0.0712');
		// Case #12: Date, Number, Number. 0.0897
		oParser = new parserFormula('MIRR({-12,500,600},0.08,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-12,500,600},0.08,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), "8.7894501", 'Test: Positive case: Date, Number, Number. 0.0897');
		// Case #13: Time, Number, Number. 0.1356
		oParser = new parserFormula('MIRR({-0.1,400,700},0.09,0.11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-0.1,400,700},0.09,0.11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '105.9579357', 'Test: Positive case: Time, Number, Number. 0.1356');
		// Case #14: Formula, Formula, Number. 0.1186
		oParser = new parserFormula('MIRR({-1500,500,600},IF(TRUE,0.08,0.1),0.12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1500,500,600},IF(TRUE,0.08,0.1),0.12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-0.1206063', 'Test: Positive case: Formula, Formula, Number. 0.1186');
		// Case #15: Formula, Number, Formula. 0.1145
		oParser = new parserFormula('MIRR({-1100,400,700},0.07,IF(TRUE,0.12,0.1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1100,400,700},0.07,IF(TRUE,0.12,0.1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '0.0215852', 'Test: Positive case: Formula, Number, Formula. 0.1145');
		// Case #16: Formula, Number, Number. 0.1286
		oParser = new parserFormula('SUM(MIRR({-1000,500,600},0.08,0.1),0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(MIRR({-1000,500,600},0.08,0.1),0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '0.0823805', 'Test: Positive case: Formula, Number, Number. 0.1286');
		// Case #17: Number, String, Number. 0.1302
		oParser = new parserFormula('MIRR({-1200,500,600},"0.09",0.11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1200,500,600},"0.09",0.11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-0.0189292', 'Test: Positive case: Number, String, Number. 0.1302');
		// Case #18: Number, Number, String. 0.1145
		oParser = new parserFormula('MIRR({-1100,400,700},0.07,"0.12")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1100,400,700},0.07,"0.12") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '0.0215852', 'Test: Positive case: Number, Number, String. 0.1145');
		// Case #19: Array, Reference link, Number. 0.1089
		oParser = new parserFormula('MIRR({-1300,600,800},A103,0.09)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1300,600,800},A103,0.09) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '0.0575734', 'Test: Positive case: Array, Reference link, Number. 0.1089');
		// Case #20: Array, Number, Reference link. 0.1247
		oParser = new parserFormula('MIRR({-1400,700,900},0.06,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1400,700,900},0.06,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '0.0690450', 'Test: Positive case: Array, Number, Reference link. 0.1247');
		// Case #21: Reference link, Reference link, Reference link. 0.1302
		oParser = new parserFormula('MIRR(A105:A107,A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(A105:A107,A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Reference link, Reference link, Reference link. 0.1302');

		// Negative cases:
		// Case #1: Number, Number, Number. #NUM!
		oParser = new parserFormula('MIRR({1000,500,600},0.08,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({1000,500,600},0.08,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Number, Number. #NUM!');
		// Case #2: Empty, Number, Number. #NUM!
		oParser = new parserFormula('MIRR(A110:A110,0.07,0.12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(A110:A110,0.07,0.12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty, Number, Number. #NUM!');
		// Case #3: String, Number, Number. #VALUE!
		oParser = new parserFormula('MIRR({"abc",500,600},0.08,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({"abc",500,600},0.08,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: String, Number, Number. #VALUE!');
		// Case #4: Error, Number, Number. #N/A
		oParser = new parserFormula('MIRR({-1,500,600},NA(),0.11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1,500,600},NA(),0.11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number, Number. #N/A');
		// Case #5: Area, Number, Number. #VALUE!
		oParser = new parserFormula('MIRR(A100:A102,0.06,0.08)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(A100:A102,0.06,0.08) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area, Number, Number. #VALUE!');
		// Case #6: Boolean, Number, Number. #NUM!
		oParser = new parserFormula('MIRR({FALSE,500,600},0.07,0.12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({FALSE,500,600},0.07,0.12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Boolean, Number, Number. #NUM!');
		// Case #7: Number, String, Number. #VALUE!
		oParser = new parserFormula('MIRR({-1000,500,600},"abc",0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1000,500,600},"abc",0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String, Number. #VALUE!');
		// Case #8: Number, Number, String. #VALUE!
		oParser = new parserFormula('MIRR({-1100,400,700},0.09,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1100,400,700},0.09,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Number, String. #VALUE!');
		// Case #9: Name, Number, Number. #VALUE!
		oParser = new parserFormula('MIRR(TestNameArea,0.08,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(TestNameArea,0.08,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name, Number, Number. #VALUE!');
		// Case #10: Name3D, Number, Number. #VALUE!
		oParser = new parserFormula('MIRR(TestNameArea3D,0.07,0.12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(TestNameArea3D,0.07,0.12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Name3D, Number, Number. #VALUE!');
		// Case #11: Ref3D, Number, Number. #VALUE!
		oParser = new parserFormula('MIRR(Sheet2!A6:A8,0.06,0.08)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(Sheet2!A6:A8,0.06,0.08) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D, Number, Number. #VALUE!');
		// Case #12: Area3D, Number, Number. #VALUE!
		oParser = new parserFormula('MIRR(Sheet2!A9:A10,0.09,0.11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR(Sheet2!A9:A10,0.09,0.11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Area3D, Number, Number. #VALUE!');
		// Case #14: Formula, Number, Number. #NUM!
		oParser = new parserFormula('MIRR({-1,500,600},0.08,#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1,500,600},0.08,#NUM!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number, Number. #NUM!');
		// Case #15: Number, Number, Number. #NUM!
		oParser = new parserFormula('MIRR({-1000},0.08,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1000},0.08,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Number, Number. #NUM!');
		// Case #16: Number, Number, Number. #DIV/0!
		oParser = new parserFormula('MIRR({0,0,0},0.07,0.12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({0,0,0},0.07,0.12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Number, Number. #DIV/0!');
		// Case #17: Number, Boolean, Number. #VALUE!
		oParser = new parserFormula('MIRR({-1100,400,700},TRUE,0.11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1100,400,700},TRUE,0.11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '0.0198039', 'Test: Negative case: Number, Boolean, Number. #VALUE!');
		// Case #18: Number, Number, Boolean. #VALUE!
		oParser = new parserFormula('MIRR({-1200,500,600},0.09,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1200,500,600},0.09,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '-0.0425729', 'Test: Negative case: Number, Number, Boolean. #VALUE!');
		// Case #19: Empty, Number, Number. #NUM!
		oParser = new parserFormula('MIRR({""},0.08,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({""},0.08,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Empty, Number, Number. #NUM!');
		// Case #20: Array, Empty, Number. #VALUE!
		oParser = new parserFormula('MIRR({-1300,600,800},,0.09)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1300,600,800},,0.09) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '0.0575734', 'Test: Negative case: Array, Empty, Number. #VALUE!');

		// Bounded cases:
		// Case #1: Number, Number, Number. 0
		oParser = new parserFormula('MIRR({-1E308,1E308},1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1E308,1E308},1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number, Number. 0');
		// Case #2: Number, Number, Number. Large
		oParser = new parserFormula('MIRR({-1E307,1E307},1E307,1E307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1E307,1E307},1E307,1E307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number, Number. Large');
		// Case #3: Number, Number, Number. 0
		oParser = new parserFormula('MIRR({-1,1},0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: MIRR({-1,1},0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number, Number. 0');

		// Need to fix: Should be #NUM! but we get 0
		// Case #2: Number, Number, Number. Large

		//testArrayFormula2(assert, "MIRR", 3, 3, null, true);
	});

	QUnit.test("Test: \"NOMINAL\"", function (assert) {

		function nominal(rate, np) {

			if (rate <= 0 || np < 1) {
				return "#NUM!"
			}

			return (Math.pow(rate + 1, 1 / np) - 1) * np;

		}

		oParser = new parserFormula("NOMINAL(0.053543,4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), nominal(0.053543, 4));

		oParser = new parserFormula("NOMINAL(0.053543,-4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), nominal(0.053543, -4));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number, Number. Basic valid input: positive rate, single period. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.05', 'Test: Positive case: Number, Number. Basic valid input: positive rate, single period. 2 of 2 arguments used.');
		// Case #2: Number, Number. Basic valid input: float rate, two periods. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.097617696', 'Test: Positive case: Number, Number. Basic valid input: float rate, two periods. 2 of 2 arguments used.');
		// Case #3: String, Number. String convertible to number for rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL("0.1",4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL("0.1",4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.096454756', 'Test: Positive case: String, Number. String convertible to number for rate. 2 of 2 arguments used.');
		// Case #4: Formula, Number. Nested formula for rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(SQRT(0.01),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(SQRT(0.01),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9),'0.097617696', 'Test: Positive case: Formula, Number. Nested formula for rate. 2 of 2 arguments used.');
		// Case #5: Reference link, Number. Reference link to rate with valid number. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(A100,365)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(A100,365) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '0.4056904', 'Test: Positive case: Reference link, Number. Reference link to rate with valid number. 2 of 2 arguments used.');
		// Case #6: Area, Number. Single-cell area for rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(A101:A101,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(A101:A101,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area, Number. Single-cell area for rate. 2 of 2 arguments used.');
		// Case #7: Array, Number. Array with valid rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL({0.05},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL({0.05},2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.049390153', 'Test: Positive case: Array, Number. Array with valid rate. 2 of 2 arguments used.');
		// Case #8: Name, Number. Named range for rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(TestName,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(TestName,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Number. Named range for rate. 2 of 2 arguments used.');
		// Case #9: Name3D, Number. 3D named range for rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(TestName3D,365)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(TestName3D,365) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Number. 3D named range for rate. 2 of 2 arguments used.');
		// Case #10: Ref3D, Number. 3D reference to rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(Sheet2!A1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(Sheet2!A1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Ref3D, Number. 3D reference to rate. 2 of 2 arguments used.');
		// Case #11: Area3D, Number. 3D single-cell range for rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(Sheet2!A2:A2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(Sheet2!A2:A2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: Area3D, Number. 3D single-cell range for rate. 2 of 2 arguments used.');
		// Case #12: Table, Number. Table reference for rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(Table1[Column1],4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(Table1[Column1],4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '0.75682846', 'Test: Positive case: Table, Number. Table reference for rate. 2 of 2 arguments used.');
		// Case #13: Date, Number. Date as serial number for rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(DATE(2025,1,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(DATE(2025,1,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '425.3593336', 'Test: Positive case: Date, Number. Date as serial number for rate. 2 of 2 arguments used.');
		// Case #14: Time, Number. Time adjusted to valid rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(TIME(0,0,0)+0.05,365)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(TIME(0,0,0)+0.05,365) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.048793425', 'Test: Positive case: Time, Number. Time adjusted to valid rate. 2 of 2 arguments used.');
		// Case #15: Number, Formula. Nested formula for npery. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.1,ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.1,ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.097617696', 'Test: Positive case: Number, Formula. Nested formula for npery. 2 of 2 arguments used.');
		// Case #16: Number, Reference link. Reference link to npery. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Reference link. Reference link to npery. 2 of 2 arguments used.');
		// Case #17: Number, Area. Single-cell area for npery. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.1,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.1,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Area. Single-cell area for npery. 2 of 2 arguments used.');
		// Case #18: Number, Array. Array with valid npery. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,{365})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,{365}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.048793425', 'Test: Positive case: Number, Array. Array with valid npery. 2 of 2 arguments used.');
		// Case #19: Number, Name. Named range for npery. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.1,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.1,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Name. Named range for npery. 2 of 2 arguments used.');
		// Case #20: Number, Name3D. 3D named range for npery. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Name3D. 3D named range for npery. 2 of 2 arguments used.');
		// Case #21: Number, Ref3D. 3D reference to npery. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.1,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.1,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number, Ref3D. 3D reference to npery. 2 of 2 arguments used.');
		// Case #22: Number, Area3D. 3D single-cell range for npery. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Area3D. 3D single-cell range for npery. 2 of 2 arguments used.');

		// Negative cases:
		// Case #1: Number, Number. Negative rate returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(-0.05,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(-0.05,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative rate returns #NUM!. 2 of 2 arguments used.');
		// Case #2: Number, Number. Zero rate returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0,365)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0,365) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Zero rate returns #NUM!. 2 of 2 arguments used.');
		// Case #3: String, Number. Non-numeric string returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL("abc",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL("abc",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string returns #VALUE!. 2 of 2 arguments used.');
		// Case #4: Error, Number. Error propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(NA(),365)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(NA(),365) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error propagates #N/A. 2 of 2 arguments used.');
		// Case #5: Area, Number. Multi-cell range returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(A104:A105,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(A104:A105,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell range returns #VALUE!. 2 of 2 arguments used.');
		// Case #6: Empty, Number. Empty cell for rate returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(A106,365)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(A106,365) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty cell for rate returns #VALUE!. 2 of 2 arguments used.');
		// Case #7: Boolean, Number. Boolean FALSE (0) returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(FALSE,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(FALSE,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE (0) returns #VALUE!. 2 of 2 arguments used.');
		// Case #8: Ref3D, Number. 3D ref to non-numeric value returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(Sheet2!A5,365)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(Sheet2!A5,365) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D, Number. 3D ref to non-numeric value returns #VALUE!. 2 of 2 arguments used.');
		// Case #9: Name, Number. Named range with non-numeric value returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(TestName2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(TestName2,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '4.782329983', 'Test: Negative case: Name, Number. Named range with non-numeric value returns #VALUE!. 2 of 2 arguments used.');
		// Case #11: Formula, Number. Formula resulting in #NUM! propagates error. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in #NUM! propagates error. 2 of 2 arguments used.');
		// Case #12: Number, Number. Zero npery returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Zero npery returns #NUM!. 2 of 2 arguments used.');
		// Case #13: Number, Number. Negative npery returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.1,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.1,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative npery returns #NUM!. 2 of 2 arguments used.');
		// Case #14: Number, String. Non-numeric string for npery returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string for npery returns #VALUE!. 2 of 2 arguments used.');
		// Case #15: Number, Error. Error for npery propagates #N/A. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.1,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error for npery propagates #N/A. 2 of 2 arguments used.');
		// Case #16: Number, Area. Multi-cell range for npery returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Multi-cell range for npery returns #VALUE!. 2 of 2 arguments used.');
		// Case #17: Number, Empty. Empty cell for npery returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.1,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.1,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty. Empty cell for npery returns #VALUE!. 2 of 2 arguments used.');
		// Case #18: Number, Boolean. Boolean FALSE (0) for npery returns #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Boolean FALSE (0) for npery returns #NUM!. 2 of 2 arguments used.');
		// Case #19: Number, Ref3D. 3D ref to non-numeric value returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.1,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.1,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Ref3D. 3D ref to non-numeric value returns #VALUE!. 2 of 2 arguments used.');
		// Case #21: Name, Name. Named range with area returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(TestNameArea,TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(TestNameArea,TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Name. Named range with area returns #VALUE!. 2 of 2 arguments used.');
		// Case #22: Name3D, Name3D. 3D named range with area returns #VALUE!. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(TestNameArea3D2,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(TestNameArea3D2,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D, Name3D. 3D named range with area returns #VALUE!. 2 of 2 arguments used.');

		// Bounded cases:
		// Case #1: Number, Number. Smallest valid rate, single period. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.000000000000001,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.000000000000001,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.11022e-15, 'Test: Bounded case: Number, Number. Smallest valid rate, single period. 2 of 2 arguments used.');
		// Case #2: Number, Number. Max valid Excel number for rate. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(9.99999999999999E+307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(9.99999999999999E+307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Number, Number. Max valid Excel number for rate. 2 of 2 arguments used.');
		// Case #3: Number, Number. Max integer for npery. 2 of 2 arguments used.
		oParser = new parserFormula('NOMINAL(0.05,2147483647)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NOMINAL(0.05,2147483647) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.048789978', 'Test: Bounded case: Number, Number. Max integer for npery. 2 of 2 arguments used.');


		// Need to fix: error types difference, precision problems, ms res diffs
		// Case #11: Area3D, Number. 3D single-cell range for rate. 2 of 2 arguments used.
		// Case #7: Boolean, Number. Boolean FALSE (0) returns #VALUE!. 2 of 2 arguments used.
		// Case #18: Number, Boolean. Boolean FALSE (0) for npery returns #NUM!. 2 of 2 arguments used.
		// Case #1: Number, Number. Smallest valid rate, single period. 2 of 2 arguments used.

		testArrayFormula2(assert, "NOMINAL", 2, 2, true);
	});

	QUnit.test("Test: \"NPER\"", function (assert) {

		function nper(rate, pmt, pv, fv, type) {

			if (rate === undefined || rate === null) {
				rate = 0;
			}

			if (pmt === undefined || pmt === null) {
				pmt = 0;
			}

			if (pv === undefined || pv === null) {
				pv = 0;
			}

			if (type === undefined || type === null) {
				type = 0;
			}

			if (fv === undefined || fv === null) {
				fv = 0;
			}

			let res;
			if (rate != 0) {
				res = (-fv * rate + pmt * (1 + rate * type)) / (rate * pv + pmt * (1 + rate * type))
				res = Math.log(res) / Math.log(1 + rate)
			} else {
				res = -(pv + fv) / pmt;
			}
			return res;
		}

		oParser = new parserFormula("NPER(0.12/12,-100,-1000,10000,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), nper(0.12 / 12, -100, -1000, 10000, 1));

		oParser = new parserFormula("NPER(0.12/12,-100,-1000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), nper(0.12 / 12, -100, -1000));


		// bug 70050
		oParser = new parserFormula("NPER(0,-393977.5252,14351946.04,,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), nper(0,-393977.5252,14351946.04,0,1));

		oParser = new parserFormula("NPER(0,393977.5252,14351946.04,,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), nper(0,393977.5252,14351946.04,0,1));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. All arguments are numbers, valid input. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,-100,0,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,-100,0,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '8.3104', 'Test: Positive case: Number. All arguments are numbers, valid input. 5 of 5 arguments used.');
		// Case #1: Number. All arguments are numbers, fv omitted. 4 of 5 arguments used.
		oParser = new parserFormula('NPER(0.1,-200,0,2000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.1,-200,0,2000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '7.2725', 'Test: Positive case: Number. All arguments are numbers, fv omitted. 4 of 5 arguments used.');
		// Case #2: String. All arguments as strings convertible to numbers. 5 of 5 arguments used.
		oParser = new parserFormula('NPER("0.1","-200","0","2000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER("0.1","-200","0","2000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '7.2725', 'Test: Positive case: String. All arguments as strings convertible to numbers. 5 of 5 arguments used.');
		// Case #3: Formula. Rate as formula, others as numbers. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(SQRT(0.0025),-100,-1,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(SQRT(0.0025),-100,-1,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '8.3001', 'Test: Positive case: Formula. Rate as formula, others as numbers. 5 of 5 arguments used.');
		// Case #4: Formula. Rate as nested IF formula. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(IF(TRUE,0.05,0.01),-100,-1,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(IF(TRUE,0.05,0.01),-100,-1,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '8.3001', 'Test: Positive case: Formula. Rate as nested IF formula. 5 of 5 arguments used.');
		// Case #5: Reference link. Rate as reference link to valid number. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(A100,-100,-1,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(A100,-100,-1,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '4.4067', 'Test: Positive case: Reference link. Rate as reference link to valid number. 5 of 5 arguments used.');
		// Case #6: Area. Rate as single-cell range. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(A101:A101,-100,-1,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(A101:A101,-100,-1,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '3.0096', 'Test: Positive case: Area. Rate as single-cell range. 5 of 5 arguments used.');
		// Case #7: Array. Rate as single-element array. 5 of 5 arguments used.
		oParser = new parserFormula('NPER({0.05},-100,-2,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER({0.05},-100,-2,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '8.2899', 'Test: Positive case: Array. Rate as single-element array. 5 of 5 arguments used.');
		// Case #8: Name. Rate as named range. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(TestName,-100,-10000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(TestName,-100,-10000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '3.6147', 'Test: Positive case: Name. Rate as named range. 5 of 5 arguments used.');
		// Case #9: Name3D. Rate as 3D named range. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(TestName3D,-100,-10000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(TestName3D,-100,-10000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '3.6147', 'Test: Positive case: Name3D. Rate as 3D named range. 5 of 5 arguments used.');
		// Case #10: Ref3D. Rate as 3D reference. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(Sheet2!A1,-100,-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(Sheet2!A1,-100,-10,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '4.2987', 'Test: Positive case: Ref3D. Rate as 3D reference. 5 of 5 arguments used.');
		// Case #11: Area3D. Rate as 3D single-cell range. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(Sheet2!A1:A1,-100,-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(Sheet2!A1:A1,-100,-10,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '4.2987', 'Test: Positive case: Area3D. Rate as 3D single-cell range. 5 of 5 arguments used.');
		// Case #12: Table. Rate as table reference. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(Table1[Column1],-100,-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(Table1[Column1],-100,-10,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '3.3219', 'Test: Positive case: Table. Rate as table reference. 5 of 5 arguments used.');
		// Case #13: Reference link. Pmt as reference link to valid number. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,A101,-10000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,A101,-10000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-47.7563', 'Test: Positive case: Reference link. Pmt as reference link to valid number. 5 of 5 arguments used.');
		// Case #14: Area. Pmt as single-cell range. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,A102:A102,-10000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,A102:A102,-10000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-47.3791', 'Test: Positive case: Area. Pmt as single-cell range. 5 of 5 arguments used.');
		// Case #15: Formula. Pmt as formula. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,ABS(-100),-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,ABS(-100),-10,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-14.1040', 'Test: Positive case: Formula. Pmt as formula. 5 of 5 arguments used.');
		// Case #16: Reference link. Pv as reference link to valid number. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,-100,A103,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,-100,A103,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '8.3104', 'Test: Positive case: Reference link. Pv as reference link to valid number. 5 of 5 arguments used.');
		// Case #17: Formula. Fv as nested IF formula. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,-100,-1000,IF(TRUE,-1000,-500),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,-100,-1000,IF(TRUE,-1000,-500),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-22.5171', 'Test: Positive case: Formula. Fv as nested IF formula. 5 of 5 arguments used.');
		// Case #18: Reference link. Type as reference link to valid number. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,-100,-10,1000,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,-100,-10,1000,A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(4), '7.8851', 'Test: Positive case: Reference link. Type as reference link to valid number. 5 of 5 arguments used.');
		// Case #19: Formula. Type as formula. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,-100,-10,1000,ROUND(0.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,-100,-10,1000,ROUND(0.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '8.2082', 'Test: Positive case: Formula. Type as formula. 5 of 5 arguments used.');
		// Case #20: Array. Fv as single-element array. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,-100,-10,{1000},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,-100,-10,{1000},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '8.2082', 'Test: Positive case: Array. Fv as single-element array. 5 of 5 arguments used.');
		// Case #21: Formula. NPER inside SUM formula. 5 of 5 arguments used.
		oParser = new parserFormula('SUM(NPER(0.05,-100,-1000,1000,0),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(NPER(0.05,-100,-1000,1000,0),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. NPER inside SUM formula. 5 of 5 arguments used.');
		// Case #22: Reference link. All arguments as reference links. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(A100,A101,A102,A103,A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-0.2598', 'Test: Positive case: Reference link. All arguments as reference links. 5 of 5 arguments used.');
		// Case #23: Name. All arguments as named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(TestName1,TestName2,TestName2,TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(TestName1,TestName2,TestName2,TestName,TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-0.6707', 'Test: Positive case: Name. All arguments as named ranges. 5 of 5 arguments used.');
		// Case #24: Name3D. All arguments as 3D named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. All arguments as 3D named ranges. 5 of 5 arguments used.');
		// Case #25: Table. All arguments as table references. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-1.5850', 'Test: Positive case: Table. All arguments as table references. 5 of 5 arguments used.');

		// Negative cases:
		// Case #0: Number. Rate is zero, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0,-100,-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0,-100,-1000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Rate is zero, returns #NUM!. 5 of 5 arguments used.');
		// Case #1: Number. Pmt is zero, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,0,-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,0,-1000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Pmt is zero, returns #NUM!. 5 of 5 arguments used.');
		// Case #2: String. Rate as non-numeric string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER("abc",-100,-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER("abc",-100,-1000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Rate as non-numeric string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #3: Error. Rate as error, propagates #N/A. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(NA(),-100,-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(NA(),-100,-1000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Rate as error, propagates #N/A. 5 of 5 arguments used.');
		// Case #4: Empty. Rate as empty cell, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(A105,-100,-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(A105,-100,-10,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '3.3219', 'Test: Negative case: Empty. Rate as empty cell, returns #VALUE!. 5 of 5 arguments used.');
		// Case #5: Boolean. Rate as boolean, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(TRUE,-100,-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(TRUE,-100,-10,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '3.3219', 'Test: Negative case: Boolean. Rate as boolean, returns #NUM!. 5 of 5 arguments used.');
		// Case #6: Area. Rate as multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(A106:A107,-100,-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(A106:A107,-100,-10,1000,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 9.9, 'Test: Negative case: Area. Rate as multi-cell range, returns #VALUE!. 5 of 5 arguments used.');
		// Case #7: String. Pmt as non-numeric string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,"abc",-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,"abc",-1000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Pmt as non-numeric string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #8: Error. Pmt as error, propagates #N/A. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,NA(),-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,NA(),-1000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Pmt as error, propagates #N/A. 5 of 5 arguments used.');
		// Case #9: Empty. Pmt as empty cell, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,A105,-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,A105,-10,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Pmt as empty cell, returns #NUM!. 5 of 5 arguments used.');
		// Case #10: Boolean. Pmt as boolean, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,FALSE,-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,FALSE,-10,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '94.3873', 'Test: Negative case: Boolean. Pmt as boolean, returns #NUM!. 5 of 5 arguments used.');
		// Case #11: Area. Pmt as multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,A106:A107,-10,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,A106:A107,-10,1000,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(4), '94.3873', 'Test: Negative case: Area. Pmt as multi-cell range, returns #VALUE!. 5 of 5 arguments used.');
		// Case #12: Ref3D. Pmt as 3D ref to text, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,Sheet2!A2,-10000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,Sheet2!A2,-10000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-47.7563', 'Test: Negative case: Ref3D. Pmt as 3D ref to text, returns #VALUE!. 5 of 5 arguments used.');
		// Case #13: Name. Pmt as named range with text, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,TestNameArea2,-10000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,TestNameArea2,-10000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '-47.4914', 'Test: Negative case: Name. Pmt as named range with text, returns #VALUE!. 5 of 5 arguments used.');
		// Case #15: Formula. Pmt as formula resulting in #NUM!, propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,SQRT(-1),-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,SQRT(-1),-1000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Pmt as formula resulting in #NUM!, propagates error. 5 of 5 arguments used.');
		// Case #16: Number. Pv is zero, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,-100,0,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,-100,0,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '8.3104', 'Test: Negative case: Number. Pv is zero, returns #NUM!. 5 of 5 arguments used.');
		// Case #17: Number. Type is invalid (not 0 or 1), returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,-100,-1000,1000,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,-100,-1000,1000,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Type is invalid (not 0 or 1), returns #NUM!. 5 of 5 arguments used.');
		// Case #18: Area3D. Pmt as multi-cell 3D range, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,Sheet2!A1:A2,-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,Sheet2!A1:A2,-1000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D. Pmt as multi-cell 3D range, returns #VALUE!. 5 of 5 arguments used.');
		// Case #19: Name. Pmt as named range with multi-cell area, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.05,TestNameArea,-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.05,TestNameArea,-1000,1000,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Pmt as named range with multi-cell area, returns #VALUE!. 5 of 5 arguments used.');
		// Case #20: Date. Rate as date (large number), returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(DATE(2025,1,1),-100,-1000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(DATE(2025,1,1),-100,-1000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Date. Rate as date (large number), returns #NUM!. 5 of 5 arguments used.');

		// Bounded cases:
		// Case #0: Number. Minimum valid values for rate, pmt, pv, fv. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(1E-307,-1E-307,-1E-307,1E-307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(1E-307,-1E-307,-1E-307,1E-307,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Minimum valid values for rate, pmt, pv, fv. 5 of 5 arguments used.');
		// Case #1: Number. Maximum valid values for pmt, pv, fv; rate < 1. 5 of 5 arguments used.
		oParser = new parserFormula('NPER(0.99,-1E+307,-1E+307,1E+307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPER(0.99,-1E+307,-1E+307,1E+307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid values for pmt, pv, fv; rate < 1. 5 of 5 arguments used.');

		// Need to fix: results diff from MS, error types diff, area/array handle should be added
		// Case #18: Reference link. Type as reference link to valid number. 5 of 5 arguments used.
		// Case #22: Reference link. All arguments as reference links. 5 of 5 arguments used.
		// Case #23: Name. All arguments as named ranges. 5 of 5 arguments used.
		// Case #6: Area. Rate as multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		// Case #11: Area. Pmt as multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		// Case #17: Number. Type is invalid (not 0 or 1), returns #NUM!. 5 of 5 arguments used.
		// Case #19: Name. Pmt as named range with multi-cell area, returns #VALUE!. 5 of 5 arguments used.
		// Case #0: Number. Minimum valid values for rate, pmt, pv, fv. 5 of 5 arguments used.

		testArrayFormula2(assert, "NPER", 3, 5);
	});

	QUnit.test("Test: \"NPV\"", function (assert) {

		//TODO в хроме при расчёте разница, временно убираю
		oParser = new parserFormula("NPV(0.1,-10000,3000,4200,6800)", "A2", ws);
		assert.ok(oParser.parse());
		//assert.strictEqual( oParser.calculate().getValue(), 1188.4434123352216 );

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: positive and negative cash flows. 3 arguments used.
		oParser = new parserFormula('NPV(0.1,100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '49.58677686', 'Test: Positive case: Number. Basic valid input: positive and negative cash flows. 3 arguments used.');
		// Case #1: Number,String. String convertible to number for cash flow. 3 arguments used.
		oParser = new parserFormula('NPV(0.1,"100",-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,"100",-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '49.58677686', 'Test: Positive case: Number,String. String convertible to number for cash flow. 3 arguments used.');
		// Case #2: Formula. Rate as a formula returning valid number. 3 arguments used.
		oParser = new parserFormula('NPV(SQRT(0.01),100,200)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(SQRT(0.01),100,200) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '256.1983471', 'Test: Positive case: Formula. Rate as a formula returning valid number. 3 arguments used.');
		// Case #3: Formula,Number. Nested IF formula for rate. 3 arguments used.
		oParser = new parserFormula('NPV(IF(TRUE,0.1,0.05),100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(IF(TRUE,0.1,0.05),100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '49.58677686', 'Test: Positive case: Formula,Number. Nested IF formula for rate. 3 arguments used.');
		// Case #4: Date,Number. Date as serial number for rate (>=0). 3 arguments used.
		oParser = new parserFormula('NPV(DATE(2025,1,1),100,200)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(DATE(2025,1,1),100,200) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '0.002190245', 'Test: Positive case: Date,Number. Date as serial number for rate (>=0). 3 arguments used.');
		// Case #5: Time,Number. Time as fraction for rate (0.5). 3 arguments used.
		oParser = new parserFormula('NPV(TIME(12,0,0),100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(TIME(12,0,0),100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '44.44444444', 'Test: Positive case: Time,Number. Time as fraction for rate (0.5). 3 arguments used.');
		// Case #6: Reference link,Number. Reference link for rate. 3 arguments used.
		oParser = new parserFormula('NPV(A100,100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(A100,100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '44.44444444', 'Test: Positive case: Reference link,Number. Reference link for rate. 3 arguments used.');
		// Case #7: Number,Reference link. Reference link for cash flows. 3 arguments used.
		oParser = new parserFormula('NPV(0.1,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.776859504', 'Test: Positive case: Number,Reference link. Reference link for cash flows. 3 arguments used.');
		// Case #8: Area. Single-cell range for rate. 2 arguments used.
		oParser = new parserFormula('NPV(A100:A100,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(A100:A100,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '66.66666667', 'Test: Positive case: Area. Single-cell range for rate. 2 arguments used.');
		// Case #9: Number,Area. Two-cell range for cash flows. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,A101:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,A101:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.776859504', 'Test: Positive case: Number,Area. Two-cell range for cash flows. 2 arguments used.');
		// Case #10: Array. Array with single element for rate. 3 arguments used.
		oParser = new parserFormula('NPV({0.1},100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV({0.1},100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '49.58677686', 'Test: Positive case: Array. Array with single element for rate. 3 arguments used.');
		// Case #11: Number,Array. Array with multiple cash flows. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,{100,-50})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,{100,-50}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '49.58677686', 'Test: Positive case: Number,Array. Array with multiple cash flows. 2 arguments used.');
		// Case #12: Name,Number. Named range for rate. 3 arguments used.
		oParser = new parserFormula('NPV(TestName,100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(TestName,100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name,Number. Named range for rate. 3 arguments used.');
		// Case #13: Name3D,Number. 3D named range for rate. 3 arguments used.
		oParser = new parserFormula('NPV(TestName3D,100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(TestName3D,100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D,Number. 3D named range for rate. 3 arguments used.');
		// Case #14: Ref3D,Number. 3D reference for rate. 3 arguments used.
		oParser = new parserFormula('NPV(Sheet2!A1,100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(Sheet2!A1,100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '44.44444444', 'Test: Positive case: Ref3D,Number. 3D reference for rate. 3 arguments used.');
		// Case #15: Number,Ref3D. 3D references for cash flows. 3 arguments used.
		oParser = new parserFormula('NPV(0.1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,Sheet2!A2,Sheet2!A3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue().toFixed(9), '#VALUE!', 'Test: Positive case: Number,Ref3D. 3D references for cash flows. 3 arguments used.');
		// Case #16: Area3D,Number. 3D single-cell range for rate. 2 arguments used.
		oParser = new parserFormula('NPV(Sheet2!A1:A1,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(Sheet2!A1:A1,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '66.66666667', 'Test: Positive case: Area3D,Number. 3D single-cell range for rate. 2 arguments used.');
		// Case #17: Number,Area3D. 3D two-cell range for cash flows. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,Sheet2!A2:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,Sheet2!A2:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9), '1.363636364', 'Test: Positive case: Number,Area3D. 3D two-cell range for cash flows. 2 arguments used.');
		// Case #18: Table. Table structured references. 3 arguments used.
		oParser = new parserFormula('NPV(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		// todo create isolated tests with tables
		// assert.strictEqual(oParser.calculate().getValue(), 0.75, 'Test: Positive case: Table. Table structured references. 3 arguments used.');
		// Case #19: Formula,Number. Simple formula for rate. 4 arguments used.
		oParser = new parserFormula('NPV(0.1*2,100,-50,200)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1*2,100,-50,200) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '164.3518519', 'Test: Positive case: Formula,Number. Simple formula for rate. 4 arguments used.');
		// Case #20: Number,String. Negative cash flow as string. 3 arguments used.
		oParser = new parserFormula('NPV(0.1,"-50",100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,"-50",100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8), '37.19008264', 'Test: Positive case: Number,String. Negative cash flow as string. 3 arguments used.');
		// Case #21: Number,Formula. Nested IF for cash flow. 3 arguments used.
		oParser = new parserFormula('NPV(0.1,IF(TRUE,100,-100),200)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,IF(TRUE,100,-100),200) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7), '256.1983471', 'Test: Positive case: Number,Formula. Nested IF for cash flow. 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Rate = -1 returns #NUM!. 3 arguments used.
		oParser = new parserFormula('NPV(-1,100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(-1,100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Rate = -1 returns #NUM!. 3 arguments used.');
		// Case #2: Number. Negative rate < -1 returns #NUM!. 3 arguments used.
		oParser = new parserFormula('NPV(-2,100,-50)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(-2,100,-50) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -150, 'Test: Negative case: Number. Negative rate < -1 returns #NUM!. 3 arguments used.');
		// Case #3: String. Non-numeric string rate returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV("abc",100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV("abc",100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string rate returns #VALUE!. 2 arguments used.');
		// Case #4: Number,String. Non-numeric string cash flow returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,"abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. Non-numeric string cash flow returns #VALUE!. 2 arguments used.');
		// Case #5: Error. Error input propagates #N/A. 2 arguments used.
		oParser = new parserFormula('NPV(NA(),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(NA(),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error input propagates #N/A. 2 arguments used.');
		// Case #6: Number,Error. Error cash flow propagates #N/A. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Error. Error cash flow propagates #N/A. 2 arguments used.');
		// Case #7: Reference link,Number. Reference to empty cell returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(A103,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(A103,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Negative case: Reference link,Number. Reference to empty cell returns #VALUE!. 2 arguments used.');
		// Case #8: Number,Reference link. Cash flow reference to empty cell returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number,Reference link. Cash flow reference to empty cell returns #VALUE!. 2 arguments used.');
		// Case #9: Boolean. Boolean rate (0) is valid but may be unexpected. 2 arguments used.
		oParser = new parserFormula('NPV(FALSE,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(FALSE,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Negative case: Boolean. Boolean rate (0) is valid but may be unexpected. 2 arguments used.');
		// Case #10: Number,Boolean. Boolean cash flow returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number,Boolean. Boolean cash flow returns #VALUE!. 2 arguments used.');
		// Case #11: Area. Multi-cell range for rate returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(A103:A104,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(A103:A104,100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Negative case: Area. Multi-cell range for rate returns #VALUE!. 2 arguments used.');
		// Case #12: Name. Named range with area for rate returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(TestNameArea2,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(TestNameArea2,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '55.56', 'Test: Negative case: Name. Named range with area for rate returns #VALUE!. 2 arguments used.');
		// Case #13: Name3D. 3D named range with area for rate returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(TestNameArea3D2,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(TestNameArea3D2,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '55.56', 'Test: Negative case: Name3D. 3D named range with area for rate returns #VALUE!. 2 arguments used.');
		// Case #14: Ref3D. 3D reference to text returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(Sheet2!A4,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(Sheet2!A4,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 2 arguments used.');
		// Case #15: Number,Ref3D. 3D reference to text cash flow returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number,Ref3D. 3D reference to text cash flow returns #VALUE!. 2 arguments used.');
		// Case #16: Area3D. 3D multi-cell range for rate returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(Sheet2!A4:A5,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(Sheet2!A4:A5,100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Negative case: Area3D. 3D multi-cell range for rate returns #VALUE!. 2 arguments used.');
		// Case #17: Number,Area3D. 3D multi-cell range for cash flow returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,Sheet2!A4:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number,Area3D. 3D multi-cell range for cash flow returns #VALUE!. 2 arguments used.');
		// Case #19: Formula. Formula resulting in #NUM! for rate propagates error. 2 arguments used.
		oParser = new parserFormula('NPV(SQRT(-1),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(SQRT(-1),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! for rate propagates error. 2 arguments used.');
		// Case #20: Number,Formula. Formula resulting in #NUM! for cash flow propagates error. 2 arguments used.
		oParser = new parserFormula('NPV(0.1,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.1,SQRT(-1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Formula. Formula resulting in #NUM! for cash flow propagates error. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid rate and cash flow. 2 arguments used.
		oParser = new parserFormula('NPV(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum valid rate and cash flow. 2 arguments used.');
		// Case #2: Number. Maximum valid rate and cash flows. 3 arguments used.
		oParser = new parserFormula('NPV(1E+307,1E+307,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(1E+307,1E+307,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid rate and cash flows. 3 arguments used.');
		// Case #3: Number. Rate close to 1 (upper boundary). 2 arguments used.
		oParser = new parserFormula('NPV(0.999999999999999,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: NPV(0.999999999999999,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '50.0', 'Test: Bounded case: Number. Rate close to 1 (upper boundary). 2 arguments used.');

		// Need to fix: array and area handle, error handle, diff results in err cases
		// Case #15: Number,Ref3D. 3D references for cash flows. 3 arguments used.
		// Case #4: Number,String. Non-numeric string cash flow returns #VALUE!. 2 arguments used.
		// Case #6: Number,Error. Error cash flow propagates #N/A. 2 arguments used.
		// Case #11: Area. Multi-cell range for rate returns #VALUE!. 2 arguments used.
		// Case #16: Area3D. 3D multi-cell range for rate returns #VALUE!. 2 arguments used.
		// Case #20: Number,Formula. Formula resulting in #NUM! for cash flow propagates error. 2 arguments used.

	});

	QUnit.test("Test: \"ODDFPRICE\"", function (assert) {

		oParser = new parserFormula("ODDFPRICE(DATE(1999,2,28),DATE(2016,1,1),DATE(1998,2,28),DATE(2015,1,1),7%,0,100,2,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(difBetween(oParser.calculate().getValue(), 217.878453038674));

		oParser = new parserFormula("ODDFPRICE(DATE(2008,11,11),DATE(2021,3,1),DATE(2008,10,15),DATE(2009,3,1),0.0785,0.0625,100,2,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(difBetween(oParser.calculate().getValue(), 113.597717474079));

		oParser = new parserFormula("ODDFPRICE(DATE(1990,6,1),DATE(1995,12,31),DATE(1990,1,1),DATE(1990,12,31),6%,5%,1000,1,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(difBetween(oParser.calculate().getValue(), 790.11323221867));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("45658");
		ws.getRange2("A101").setValue("46569");
		ws.getRange2("A104").setValue("0.03");
		// For area
		ws.getRange2("A102").setValue("45474");
		ws.getRange2("A103").setValue("45839");
		ws.getRange2("A105").setValue("98");
		ws.getRange2("A106").setValue("100");
		ws.getRange2("A107").setValue("2");
		ws.getRange2("A108").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number, Number, Number, Number, Number, Number, Number, Number. All arguments are numbers, valid dates (maturity > first_coupon > settlement > issue). 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.030, 98.0, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.030, 98.0, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.439387435, 'Test: Positive case: Number, Number, Number, Number, Number, Number, Number, Number. All arguments are numbers, valid dates (maturity > first_coupon > settlement > issue). 8 of 9 arguments used.');
		// Case #1: Number, Number, Number, Number, Number, Number, Number, Number, Number. All arguments are numbers, basis=0. 9 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.031, 98.1, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.031, 98.1, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.487430243, 'Test: Positive case: Number, Number, Number, Number, Number, Number, Number, Number, Number. All arguments are numbers, basis=0. 9 of 9 arguments used.');
		// Case #2: Date, Date, Date, Date, Number, Number, Number, Number. Dates via DATE formula, valid order. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.032, 98.2, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.032, 98.2, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.535476997, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number. Dates via DATE formula, valid order. 8 of 9 arguments used.');
		// Case #3: String, String, String, String, String, String, String, Number. Strings convertible to valid dates and numbers. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.033, 98.3, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.033, 98.3, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.583527687, 'Test: Positive case: String, String, String, String, String, String, String, Number. Strings convertible to valid dates and numbers. 8 of 9 arguments used.');
		// Case #4: Formula, Formula, Formula, Formula, Formula, Number, Number, Number. Nested formulas for dates and rate. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.034, 98.4, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.034, 98.4, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.631582299, 'Test: Positive case: Formula, Formula, Formula, Formula, Formula, Number, Number, Number. Nested formulas for dates and rate. 8 of 9 arguments used.');
		// Case #5: Reference link, Reference link, Reference link, Reference link, Reference link, Number, Number, Number. Reference links to valid values (dates and rate). 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.035, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.035, 98.5, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.679640822, 'Test: Positive case: Reference link, Reference link, Reference link, Reference link, Reference link, Number, Number, Number. Reference links to valid values (dates and rate). 8 of 9 arguments used.');
		// Case #6: Area, Area, Area, Area, Area, Number, Number, Number. Single-cell ranges with valid values. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.036, 98.6, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.036, 98.6, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.727703245, 'Test: Positive case: Area, Area, Area, Area, Area, Number, Number, Number. Single-cell ranges with valid values. 8 of 9 arguments used.');
		// Case #7: Array, Array, Array, Array, Array, Number, Number, Number. Arrays with single valid elements. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.037, 98.7, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.037, 98.7, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.775769555, 'Test: Positive case: Array, Array, Array, Array, Array, Number, Number, Number. Arrays with single valid elements. 8 of 9 arguments used.');
		// Case #8: Name, Name, Name, Name, Name, Number, Number, Number. Named ranges with valid values. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.038, 98.8, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.038, 98.8, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.823839741, 'Test: Positive case: Name, Name, Name, Name, Name, Number, Number, Number. Named ranges with valid values. 8 of 9 arguments used.');
		// Case #9: Name3D, Name3D, Name3D, Name3D, Name, Number, Number, Number. 3D named ranges with valid values. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.039, 98.9, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.039, 98.9, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.871913792, 'Test: Positive case: Name3D, Name3D, Name3D, Name3D, Name, Number, Number, Number. 3D named ranges with valid values. 8 of 9 arguments used.');
		// Case #10: Ref3D, Ref3D, Ref3D, Ref3D, Ref3D, Number, Number, Number. 3D references to valid cells. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE("01/01/2025","07/01/2027","07/01/2024","07/01/2025","0.05","98.5","100","2","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE("01/01/2025","07/01/2027","07/01/2024","07/01/2025","0.05","98.5","100","2","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2.399487023, 'Test: Positive case: Ref3D, Ref3D, Ref3D, Ref3D, Ref3D, Number, Number, Number. 3D references to valid cells. 8 of 9 arguments used.');
		// Case #11: Area3D, Area3D, Area3D, Area3D, Area3D, Number, Number, Number. 3D single-cell ranges. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2025,1,1),DATE(2027,7,1),DATE(2024,7,1),DATE(2025,7,1),5%*1,100-1.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2025,1,1),DATE(2027,7,1),DATE(2024,7,1),DATE(2025,7,1),5%*1,100-1.5,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2.399487023, 'Test: Positive case: Area3D, Area3D, Area3D, Area3D, Area3D, Number, Number, Number. 3D single-cell ranges. 8 of 9 arguments used.');
		// Case #12: Table, Table, Table, Table, Table, Number, Number, Number. Table structured references with valid values. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(A100,A101,A102,A103,A104,A105,A106,A107,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(A100,A101,A102,A103,A104,A105,A106,A107,A108) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.439387435, 'Test: Positive case: Table, Table, Table, Table, Table, Number, Number, Number. Table structured references with valid values. 8 of 9 arguments used.');
		// Case #13: Formula, Number, Number, Number, Number, Number, Number, Number. ODDFPRICE inside SUM formula. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8,Sheet2!A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8,Sheet2!A9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula, Number, Number, Number, Number, Number, Number, Number. ODDFPRICE inside SUM formula. 8 of 9 arguments used.');
		// Case #14: Formula, Formula, Formula, Formula, Number, Number, Number, Number. Nested IF formulas for dates. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(TestName,TestName1,TestName2,TestName3,0.05,98.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(TestName,TestName1,TestName2,TestName3,0.05,98.5,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula, Formula, Formula, Formula, Number, Number, Number, Number. Nested IF formulas for dates. 8 of 9 arguments used.');
		// Case #15: Number, Number, Number, Number, Number, Number, Number, Number, Number. Float dates truncated to integers, basis=1. 9 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(TestName3D2,TestName3D2,TestName3D2,TestName3D2,0.05,98.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(TestName3D2,TestName3D2,TestName3D2,TestName3D2,0.05,98.5,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Number, Number, Number, Number, Number, Number, Number, Number. Float dates truncated to integers, basis=1. 9 of 9 arguments used.');
		// Case #16: String, String, String, String, String, String, String, Number, Number. Short date strings, basis=2. 9 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE("01/01/2025","07/01/2027","07/01/2024","07/01/2025",0.05,98.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE("01/01/2025","07/01/2027","07/01/2024","07/01/2025",0.05,98.5,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2.399487023, 'Test: Positive case: String, String, String, String, String, String, String, Number, Number. Short date strings, basis=2. 9 of 9 arguments used.');
		// Case #18: Array, Array, Array, Array, Array, Number, Number, Number, Number. Single-element arrays, basis=3. 9 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(A100:A101,A102:A103,A104:A105,A106:A107,A108,A109,A110,A111,A112)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(A100:A101,A102:A103,A104:A105,A106:A107,A108,A109,A110,A111,A112) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Array, Array, Array, Array, Array, Number, Number, Number, Number. Single-element arrays, basis=3. 9 of 9 arguments used.');
		// Case #19: Number, Number, Number, Number, Number, Number, Number, Number, Number. Valid numbers, frequency=4, basis=4. 9 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(Sheet2!A1:A2,Sheet2!A3:A4,Sheet2!A5:A6,Sheet2!A7:A8,Sheet2!A9,Sheet2!A10,Sheet2!A11,Sheet2!A12,Sheet2!A13)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(Sheet2!A1:A2,Sheet2!A3:A4,Sheet2!A5:A6,Sheet2!A7:A8,Sheet2!A9,Sheet2!A10,Sheet2!A11,Sheet2!A12,Sheet2!A13) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number, Number, Number, Number, Number, Number, Number, Number, Number. Valid numbers, frequency=4, basis=4. 9 of 9 arguments used.');
		// Case #20: Formula, Number, Number, Number, Number, Number, Number, Number. Mixed date formula and numbers. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(TestNameArea,TestNameArea,TestNameArea,TestNameArea,0.05,98.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(TestNameArea,TestNameArea,TestNameArea,TestNameArea,0.05,98.5,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula, Number, Number, Number, Number, Number, Number, Number. Mixed date formula and numbers. 8 of 9 arguments used.');
		// Case #21: Reference link, Number, Number, Number, Number, Number, Number, Number. Reference link for settlement date. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,0.05,98.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,TestNameArea3D2,0.05,98.5,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link, Number, Number, Number, Number, Number, Number, Number. Reference link for settlement date. 8 of 9 arguments used.');

		// Negative cases:
		// Case #1: Number, Number, Number, Number, Number, Number, Number, Number. Settlement >= maturity returns #NUM!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.01, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.01, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Number, Number. Settlement >= maturity returns #NUM!. 8 of 9 arguments used.');
		// Case #2: Number, Number, Number, Number, Number, Number, Number, Number. Issue >= settlement returns #NUM!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.02, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.02, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Number, Number. Issue >= settlement returns #NUM!. 8 of 9 arguments used.');
		// Case #3: Number, Number, Number, Number, Number, Number, Number, Number. First_coupon >= maturity returns #NUM!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.03, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.03, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Number, Number. First_coupon >= maturity returns #NUM!. 8 of 9 arguments used.');
		// Case #4: String, Number, Number, Number, Number, Number, Number, Number. Invalid string for settlement returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.04, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.04, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number, Number, Number, Number, Number, Number, Number. Invalid string for settlement returns #VALUE!. 8 of 9 arguments used.');
		// Case #5: Number, String, Number, Number, Number, Number, Number, Number. Invalid string for maturity returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.05, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.05, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, String, Number, Number, Number, Number, Number, Number. Invalid string for maturity returns #VALUE!. 8 of 9 arguments used.');
		// Case #6: Number, Number, String, Number, Number, Number, Number, Number. Invalid string for issue returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.06, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.06, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, String, Number, Number, Number, Number, Number. Invalid string for issue returns #VALUE!. 8 of 9 arguments used.');
		// Case #7: Number, Number, Number, String, Number, Number, Number, Number. Invalid string for first_coupon returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.07, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.07, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, String, Number, Number, Number, Number. Invalid string for first_coupon returns #VALUE!. 8 of 9 arguments used.');
		// Case #8: Number, Number, Number, Number, Number, Number, Number, Number. Negative rate returns #NUM!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.08, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.08, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Number, Number. Negative rate returns #NUM!. 8 of 9 arguments used.');
		// Case #9: Number, Number, Number, Number, Number, Number, Number, Number. Negative yld returns #NUM!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.09, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.09, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Number, Number. Negative yld returns #NUM!. 8 of 9 arguments used.');
		// Case #10: Number, Number, Number, Number, Number, Number, String, Number. Non-numeric string for redemption returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.10, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.10, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, String, Number. Non-numeric string for redemption returns #VALUE!. 8 of 9 arguments used.');
		// Case #11: Number, Number, Number, Number, Number, Number, Number, Number. Invalid frequency (not 1, 2, or 4) returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.11, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.11, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Number, Number. Invalid frequency (not 1, 2, or 4) returns #VALUE!. 8 of 9 arguments used.');
		// Case #12: Number, Number, Number, Number, Number, Number, Number, Number, Number. Basis < 0 returns #NUM!. 9 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.12, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.12, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Number, Number, Number. Basis < 0 returns #NUM!. 9 of 9 arguments used.');
		// Case #13: Number, Number, Number, Number, Number, Number, Number, Number, Number. Basis > 4 returns #NUM!. 9 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.13, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.13, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Number, Number, Number. Basis > 4 returns #NUM!. 9 of 9 arguments used.');
		// Case #14: Empty, Number, Number, Number, Number, Number, Number, Number. Empty settlement returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.14, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.14, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number, Number, Number, Number, Number, Number, Number. Empty settlement returns #VALUE!. 8 of 9 arguments used.');
		// Case #15: Number, Empty, Number, Number, Number, Number, Number, Number. Empty maturity returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.15, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.15, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number, Number, Number, Number, Number, Number. Empty maturity returns #VALUE!. 8 of 9 arguments used.');
		// Case #16: Number, Number, Empty, Number, Number, Number, Number, Number. Empty issue returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.16, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.16, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Empty, Number, Number, Number, Number, Number. Empty issue returns #VALUE!. 8 of 9 arguments used.');
		// Case #17: Number, Number, Number, Empty, Number, Number, Number, Number. Empty first_coupon returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.17, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.17, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Empty, Number, Number, Number, Number. Empty first_coupon returns #VALUE!. 8 of 9 arguments used.');
		// Case #18: Number, Number, Number, Number, Empty, Number, Number, Number. Empty rate returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.18, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.18, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Empty, Number, Number, Number. Empty rate returns #VALUE!. 8 of 9 arguments used.');
		// Case #19: Number, Number, Number, Number, Number, Empty, Number, Number. Empty yld returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.19, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.19, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Empty, Number, Number. Empty yld returns #VALUE!. 8 of 9 arguments used.');
		// Case #20: Number, Number, Number, Number, Number, Number, Empty, Number. Empty redemption returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.20, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.20, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Empty, Number. Empty redemption returns #VALUE!. 8 of 9 arguments used.');
		// Case #21: Number, Number, Number, Number, Number, Number, Number, Empty. Empty frequency returns #VALUE!. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(1900,1,1), DATE(1901,1,1), DATE(1899,1,1), DATE(1900,7,1), 0.0001, 0.01, 100, 1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(1900,1,1), DATE(1901,1,1), DATE(1899,1,1), DATE(1900,7,1), 0.0001, 0.01, 100, 1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number, Number, Number, Number, Number, Number, Empty. Empty frequency returns #VALUE!. 8 of 9 arguments used.');
		// Case #22: Error, Number, Number, Number, Number, Number, Number, Number. #N/A error propagates. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(DATE(2099,1,1), DATE(2100,12,31), DATE(2098,1,1), DATE(2099,7,1), 1, 10000, 1000000, 4, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(DATE(2099,1,1), DATE(2100,12,31), DATE(2098,1,1), DATE(2099,7,1), 1, 10000, 1000000, 4, 4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Error, Number, Number, Number, Number, Number, Number, Number. #N/A error propagates. 8 of 9 arguments used.');

		// Bounded cases:
		// Case #1: Number, Number, Number, Number, Number, Number, Number, Number. Minimum valid values for rate, yld, redemption; min frequency. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(2,4,1,3,1E-307,1E-307,1E-307,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(2,4,1,3,1E-307,1E-307,1E-307,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number, Number, Number, Number, Number, Number, Number. Minimum valid values for rate, yld, redemption; min frequency. 8 of 9 arguments used.');
		// Case #2: Number, Number, Number, Number, Number, Number, Number, Number, Number. Maximum valid values for dates, rate, yld, redemption; max frequency and basis. 9 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(2958463,2958465,2958462,2958464,1E+307,1E+307,9.99999999999999E+307,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(2958463,2958465,2958462,2958464,1E+307,1E+307,9.99999999999999E+307,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number, Number, Number, Number, Number, Number, Number, Number. Maximum valid values for dates, rate, yld, redemption; max frequency and basis. 9 of 9 arguments used.');
		// Case #3: Number, Number, Number, Number, Number, Number, Number, Number. Minimum valid rate and yld with default basis. 8 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(38777,38838,38776,38778,1E-307,1E-307,1000,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(38777,38838,38776,38778,1E-307,1E-307,1000,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number, Number, Number, Number, Number, Number, Number. Minimum valid rate and yld with default basis. 8 of 9 arguments used.');
		// Case #4: Number, Number, Number, Number, Number, Number, Number, Number, Number. Min settlement and max maturity dates, basis=0. 9 of 9 arguments used.
		oParser = new parserFormula('ODDFPRICE(2,2958465,1,3,0.05,0.06,1000,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFPRICE(2,2958465,1,3,0.05,0.06,1000,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number, Number, Number, Number, Number, Number, Number, Number. Min settlement and max maturity dates, basis=0. 9 of 9 arguments used.');

		// Todo many problems in result precision
		// Need to fix: positive and bounded cases precision problem

		testArrayFormula2(assert, "ODDFPRICE", 8, 9, true);
	});

	QUnit.test("Test: \"ODDFYIELD\"", function (assert) {
		ws.getRange2("A10:Z100").cleanAll();
		oParser = new parserFormula("ODDFYIELD(DATE(1990,6,1),DATE(1995,12,31),DATE(1990,1,1),DATE(1990,12,31),6%,790,100,1,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "ODDFYIELD(DATE(1990,6,1),DATE(1995,12,31),DATE(1990,1,1),DATE(1990,12,31),6%,790,100,1,1)");
		assert.ok(difBetween(oParser.calculate().getValue(), -0.2889178784774840));

		oParser = new parserFormula("ODDFYIELD(DATE(2008,11,11),DATE(2021,3,1),DATE(2008,10,15),DATE(2009,3,1),0.0575,84.5,100,2,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "ODDFYIELD(DATE(2008,11,11),DATE(2021,3,1),DATE(2008,10,15),DATE(2009,3,1),0.0575,84.5,100,2,0)");
		assert.ok(difBetween(oParser.calculate().getValue(), 0.0772455415972989));

		oParser = new parserFormula("ODDFYIELD(DATE(2008,12,11),DATE(2021,4,1),DATE(2008,10,15),DATE(2009,4,1),6%,100,100,4,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "ODDFYIELD(DATE(2008,12,11),DATE(2021,4,1),DATE(2008,10,15),DATE(2009,4,1),6%,100,100,4,1)");
		assert.ok(difBetween(oParser.calculate().getValue(), 0.0599769985558904));

		// for bug 21211
		ws.getRange2("A12").setValue("November 11, 2008");
		ws.getRange2("A13").setValue("March 1, 2021");
		ws.getRange2("A14").setValue("October 15, 2008");
		ws.getRange2("A15").setValue("March 1, 2009");
		ws.getRange2("A16").setValue("5.75%");
		ws.getRange2("A17").setValue("84.50");
		ws.getRange2("A18").setValue("100");
		ws.getRange2("A19").setValue("2");
		ws.getRange2("A20").setValue("0");

		oParser = new parserFormula("ODDFYIELD(A12, A13, A14, A15, A16, A17, A18, A19, A20)", "A2", ws);
		assert.ok(oParser.parse(), 'ODDFYIELD(A12, A13, A14, A15, A16, A17, A18, A19, A20)');
		assert.ok(oParser.calculate().getValue(), 0.08, 'Result of ODDFYIELD(A12, A13, A14, A15, A16, A17, A18, A19, A20)');

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("45658");
		ws.getRange2("A101").setValue("46569");
		ws.getRange2("A104").setValue("0.03");
		// For area
		ws.getRange2("A102").setValue("45474");
		ws.getRange2("A103").setValue("45839");
		ws.getRange2("A105").setValue("98");
		ws.getRange2("A106").setValue("100");
		ws.getRange2("A107").setValue("2");
		ws.getRange2("A108").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.030, 98.0, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.030, 98.0, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.038346533, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #2: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.031, 98.1, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.031, 98.1, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.038924075, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #3: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.032, 98.2, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.032, 98.2, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.039500775, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #4: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.033, 98.3, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.033, 98.3, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.040076636, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #5: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.034, 98.4, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.034, 98.4, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.040651657, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #6: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.035, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.035, 98.5, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.041225841, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #7: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.036, 98.6, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.036, 98.6, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.041799188, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #8: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.037, 98.7, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.037, 98.7, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.042371701, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #9: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.038, 98.8, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.038, 98.8, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.04294338, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #10: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.039, 98.9, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1), DATE(2027,7,1), DATE(2024,7,1), DATE(2025,7,1), 0.039, 98.9, 100, 2, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.043514226, 'Test: Positive case: Date, Date, Date, Date, Number, Number, Number, Number, Number. All numeric arguments valid.');
		// Case #11: String. All arguments as strings converted correctly.
		oParser = new parserFormula('ODDFYIELD("01/01/2025","07/01/2027","07/01/2024","07/01/2025","0.05","98.5","100","2","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD("01/01/2025","07/01/2027","07/01/2024","07/01/2025","0.05","98.5","100","2","0") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.056218425, 'Test: Positive case: String. All arguments as strings converted correctly.');
		// Case #12: Formula. Formulas inside arguments handled correctly.
		oParser = new parserFormula('ODDFYIELD(DATE(2025,1,1),DATE(2027,7,1),DATE(2024,7,1),DATE(2025,7,1),5%*1,100-1.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2025,1,1),DATE(2027,7,1),DATE(2024,7,1),DATE(2025,7,1),5%*1,100-1.5,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.056218425, 'Test: Positive case: Formula. Formulas inside arguments handled correctly.');
		// Case #13: Reference link. Reference link case.
		oParser = new parserFormula('ODDFYIELD(A100,A101,A102,A103,A104,A105,A106,A107,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(A100,A101,A102,A103,A104,A105,A106,A107,A108) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.038346533, 'Test: Positive case: Reference link. Reference link case.');
		// Case #14: Ref3D. 3D reference case.
		oParser = new parserFormula('ODDFYIELD(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8,Sheet2!A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8,Sheet2!A9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D reference case.');
		// Case #15: Name. Named ranges used as arguments.
		oParser = new parserFormula('ODDFYIELD(TestName,TestName1,TestName2,TestName3,0.05,98.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(TestName,TestName1,TestName2,TestName3,0.05,98.5,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges used as arguments.');
		// Case #16: Name3D. 3D named ranges.
		oParser = new parserFormula('ODDFYIELD(TestName3D2,TestName3D2,TestName3D2,TestName3D2,0.05,98.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(TestName3D2,TestName3D2,TestName3D2,TestName3D2,0.05,98.5,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges.');
		// Case #17: Array. Array constants as arguments.
		oParser = new parserFormula('ODDFYIELD("01/01/2025","07/01/2027","07/01/2024","07/01/2025",0.05,98.5,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD("01/01/2025","07/01/2027","07/01/2024","07/01/2025",0.05,98.5,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.056218425, 'Test: Positive case: Array. Array constants as arguments.');
		// Case #19: Area. Areas used for arguments.
		oParser = new parserFormula('ODDFYIELD(A100:A101,A102:A103,A104:A105,A106:A107,A108,A109,A110,A111,A112)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(A100:A101,A102:A103,A104:A105,A106:A107,A108,A109,A110,A111,A112) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area. Areas used for arguments.');
		// Case #20: Area3D. 3D area references.
		oParser = new parserFormula('ODDFYIELD(Sheet2!A1:A2,Sheet2!A3:A4,Sheet2!A5:A6,Sheet2!A7:A8,Sheet2!A9,Sheet2!A10,Sheet2!A11,Sheet2!A12,Sheet2!A13)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(Sheet2!A1:A2,Sheet2!A3:A4,Sheet2!A5:A6,Sheet2!A7:A8,Sheet2!A9,Sheet2!A10,Sheet2!A11,Sheet2!A12,Sheet2!A13) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D area references.');

		// Negative cases:
		// Case #1: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.01, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.01, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #2: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.02, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.02, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #3: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.03, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.03, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #4: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.04, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.04, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #5: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.05, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.05, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #6: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.06, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.06, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #7: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.07, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.07, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #8: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.08, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.08, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #9: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.09, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.09, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #10: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.10, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.10, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #11: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.11, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.11, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #12: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.12, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.12, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #13: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.13, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.13, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #14: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.14, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.14, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #15: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.15, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.15, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #16: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.16, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.16, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #17: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.17, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.17, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #18: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.18, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.18, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #19: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.19, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.19, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');
		// Case #20: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.
		oParser = new parserFormula('ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.20, 98.5, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2027,1,1), DATE(2025,7,1), DATE(2024,7,1), DATE(2025,7,1), -0.20, 98.5, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Invalid inputs cause error.');

		// Bounded cases:
		// Case #1: Date, Date, Date, Date, Number, Number, Number, Number, Number. Minimum possible valid values.
		oParser = new parserFormula('ODDFYIELD(DATE(1900,1,1), DATE(1901,1,1), DATE(1899,1,1), DATE(1900,7,1), 0.0001, 0.01, 100, 1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(1900,1,1), DATE(1901,1,1), DATE(1899,1,1), DATE(1900,7,1), 0.0001, 0.01, 100, 1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Minimum possible valid values.');
		// Case #2: Date, Date, Date, Date, Number, Number, Number, Number, Number. Maximum possible valid values.
		oParser = new parserFormula('ODDFYIELD(DATE(2099,1,1), DATE(2100,12,31), DATE(2098,1,1), DATE(2099,7,1), 1, 10000, 1000000, 4, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDFYIELD(DATE(2099,1,1), DATE(2100,12,31), DATE(2098,1,1), DATE(2099,7,1), 1, 10000, 1000000, 4, 4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Date, Date, Date, Date, Number, Number, Number, Number, Number. Maximum possible valid values.');

		// Need to fix: different results in positive cases and one boundary case


		testArrayFormula2(assert, "ODDFYIELD", 8, 9, true);
	});

	QUnit.test("Test: \"ODDLPRICE\"", function (assert) {

		function oddlprice(settlement, maturity, last_interest, rate, yld, redemption, frequency, basis) {

			var fDCi = _yearFrac(last_interest, maturity, basis) * frequency;
			var fDSCi = _yearFrac(settlement, maturity, basis) * frequency;
			var fAi = _yearFrac(last_interest, settlement, basis) * frequency;

			var res = redemption + fDCi * 100.0 * rate / frequency;
			res /= fDSCi * yld / frequency + 1.0;
			res -= fAi * 100.0 * rate / frequency;

			return res;
		}

		oParser = new parserFormula("ODDLPRICE(DATE(2008,11,11),DATE(2021,3,1),DATE(2008,10,15),0.0785,0.0625,100,2,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(),
			oddlprice(new cDate(Date.UTC(2008, 10, 11)), new cDate(Date.UTC(2021, 2, 1)), new cDate(Date.UTC(2008, 9, 15)), 0.0785, 0.0625, 100, 2, 1));


		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("38777");
		ws.getRange2("A101").setValue("38838");
		ws.getRange2("A104").setValue("0.06");
		// For area
		ws.getRange2("A102").setValue("38746");
		ws.getRange2("A103").setValue("0.05");
		ws.getRange2("A105").setValue("100");
		ws.getRange2("A106").setValue("2");
		ws.getRange2("A107").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(8). Valid numbers, all arguments provided. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.83058305830582, 'Test: Positive case: Number(8). Valid numbers, all arguments provided. 8 of 8 arguments used.');
		// Case #2: Formula(3),Number(5). Dates as formulas, valid numbers. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,1,1),0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,1,1),0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.82673267326733, 'Test: Positive case: Formula(3),Number(5). Dates as formulas, valid numbers. 8 of 8 arguments used.');
		// Case #3: Formula(3),Number(4),Empty. Basis omitted, defaults to 0. 7 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,1,1),0.05,0.06,100,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,1,1),0.05,0.06,100,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.82673267326733, 'Test: Positive case: Formula(3),Number(4),Empty. Basis omitted, defaults to 0. 7 of 8 arguments used.');
		// Case #4: String(3),Number(5). Dates as strings, valid numbers. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE("03/01/2006","05/01/2006","01/01/2006",0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE("03/01/2006","05/01/2006","01/01/2006",0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.82673267326733, 'Test: Positive case: String(3),Number(5). Dates as strings, valid numbers. 8 of 8 arguments used.');
		// Case #5: Formula(4),Number(4). Nested formula for settlement and rate. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),DATE(2006,1,1),SQRT(0.0025),0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),DATE(2006,1,1),SQRT(0.0025),0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.82673267326733, 'Test: Positive case: Formula(4),Number(4). Nested formula for settlement and rate. 8 of 8 arguments used.');
		// Case #6: Reference link(8). All arguments as reference links. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(A100,A101,A102,A103,A104,A105,A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(A100,A101,A102,A103,A104,A105,A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.83058305830582, 'Test: Positive case: Reference link(8). All arguments as reference links. 8 of 8 arguments used.');
		// Case #7: Area(8). Single-cell ranges. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106,A107:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106,A107:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.83058305830582, 'Test: Positive case: Area(8). Single-cell ranges. 8 of 8 arguments used.');
		// Case #8: Array(8). Single-element arrays. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE({38777},{38838},{38746},{0.05},{0.06},{100},{2},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE({38777},{38838},{38746},{0.05},{0.06},{100},{2},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.83058305830582, 'Test: Positive case: Array(8). Single-element arrays. 8 of 8 arguments used.');
		// Case #9: Name(8). Named ranges. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(TestName,TestName1,TestName2,TestName3,TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(TestName,TestName1,TestName2,TestName3,TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(8). Named ranges. 8 of 8 arguments used.');
		// Case #10: Name3D(8). 3D named ranges. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(8). 3D named ranges. 8 of 8 arguments used.');
		// Case #11: Ref3D(8). 3D references. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(8). 3D references. 8 of 8 arguments used.');
		// Case #12: Area3D(8). 3D single-cell ranges. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7,Sheet2!A8:A8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7,Sheet2!A8:A8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(8). 3D single-cell ranges. 8 of 8 arguments used.');
		// Case #13: Table. Table structured references. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured references. 8 of 8 arguments used.');
		// Case #14: Formula(8). All arguments as formulas. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),SQRT(0.0025),SQRT(0.0036),ABS(100),VALUE("2"),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),SQRT(0.0025),SQRT(0.0036),ABS(100),VALUE("2"),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.88511773362768, 'Test: Positive case: Formula(8). All arguments as formulas. 8 of 8 arguments used.');
		// Case #15: Formula,Number(7). ODDLPRICE inside SUM formula. 8 of 8 arguments used.
		oParser = new parserFormula('SUM(ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 109.83058305830582, 'Test: Positive case: Formula,Number(7). ODDLPRICE inside SUM formula. 8 of 8 arguments used.');
		// Case #16: String(6),Number(2). String numbers converted to numbers. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE("05/20/2025","06/30/2025","04/01/2025","0.05","0.06","100","2","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE("05/20/2025","06/30/2025","04/01/2025","0.05","0.06","100","2","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.88511773362768, 'Test: Positive case: String(6),Number(2). String numbers converted to numbers. 8 of 8 arguments used.');
		// Case #17: Array(8). Multi-element arrays. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE({38770,38778},{38838,38839},{38746,38747},{0.05,0.04},{0.06,0.07},{100,101},{2,4},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE({38770,38778},{38838,38839},{38746,38747},{0.05,0.04},{0.06,0.07},{100,101},{2,4},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.80688059537539, 'Test: Positive case: Array(8). Multi-element arrays. 8 of 8 arguments used.');
		// Case #18: Number(8). Float numbers, basis and frequency truncated. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777.5,38838.5,38746.5,0.05,0.06,100.5,2.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777.5,38838.5,38746.5,0.05,0.06,100.5,2.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100.32289547012776, 'Test: Positive case: Number(8). Float numbers, basis and frequency truncated. 8 of 8 arguments used.');
		// Case #19: Reference link,Formula,String,Number(5). Mixed types, string date converted. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(A100,DATE(2025,6,30),"04/01/2025",0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(A100,DATE(2025,6,30),"04/01/2025",0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link,Formula,String,Number(5). Mixed types, string date converted. 8 of 8 arguments used.');
		// Case #20: Date(3),Number(5). Date arguments, frequency = 1, basis = 1. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),0.05,0.06,100,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),0.05,0.06,100,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.8839295899507, 'Test: Positive case: Date(3),Number(5). Date arguments, frequency = 1, basis = 1. 8 of 8 arguments used.');
		// Case #21: Time,Formula,Number(6). Time adjusted to valid date, frequency = 4. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(TIME(12,0,0)+38777,DATE(2006,5,1),DATE(2006,1,1),0.05,0.06,100,4,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(TIME(12,0,0)+38777,DATE(2006,5,1),DATE(2006,1,1),0.05,0.06,100,4,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.82673267326733, 'Test: Positive case: Time,Formula,Number(6). Time adjusted to valid date, frequency = 4. 8 of 8 arguments used.');

		// Negative cases:
		// Case #1: Number(7),Empty. Basis omitted, valid inputs. 7 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.83058305830582, 'Test: Negative case: Number(7),Empty. Basis omitted, valid inputs. 7 of 8 arguments used.');
		// Case #2: Number(8). Settlement >= maturity, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38838,38777,38746,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38838,38777,38746,0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Settlement >= maturity, returns #NUM!. 8 of 8 arguments used.');
		// Case #3: Number(8). Settlement <= last_interest, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38777,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38777,0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Settlement <= last_interest, returns #NUM!. 8 of 8 arguments used.');
		// Case #4: Number(8). Rate < 0, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,-0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,-0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Rate < 0, returns #NUM!. 8 of 8 arguments used.');
		// Case #5: Number(8). Yield < 0, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,0.05,-0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,0.05,-0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Yield < 0, returns #NUM!. 8 of 8 arguments used.');
		// Case #6: Number(8). Basis < 0, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Basis < 0, returns #NUM!. 8 of 8 arguments used.');
		// Case #7: Number(8). Basis > 4, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,0.05,0.06,100,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Basis > 4, returns #NUM!. 8 of 8 arguments used.');
		// Case #8: String(3),Number(5). Invalid settlement date, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE("invalid","05/01/2006","01/01/2006",0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE("invalid","05/01/2006","01/01/2006",0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(5). Invalid settlement date, returns #VALUE!. 8 of 8 arguments used.');
		// Case #9: String(3),Number(5). Invalid maturity date, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE("03/01/2006","invalid","01/01/2006",0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE("03/01/2006","invalid","01/01/2006",0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(5). Invalid maturity date, returns #VALUE!. 8 of 8 arguments used.');
		// Case #10: String(3),Number(5). Invalid last_interest date, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE("03/01/2006","05/01/2006","invalid",0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE("03/01/2006","05/01/2006","invalid",0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(5). Invalid last_interest date, returns #VALUE!. 8 of 8 arguments used.');
		// Case #11: String,Number(7). Empty settlement string, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE("",38838,38746,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE("",38838,38746,0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Number(7). Empty settlement string, returns #VALUE!. 8 of 8 arguments used.');
		// Case #12: Boolean,Number(7). Boolean settlement, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(FALSE,38838,38746,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(FALSE,38838,38746,0.05,0.06,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean,Number(7). Boolean settlement, returns #NUM!. 8 of 8 arguments used.');
		// Case #13: Error,Number(7). Propagates #N/A error. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(NA(),38838,38746,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(NA(),38838,38746,0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(7). Propagates #N/A error. 8 of 8 arguments used.');
		// Case #14: Area,Number(7). Multi-cell range for settlement, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(A100:A101,38838,38746,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(A100:A101,38838,38746,0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area,Number(7). Multi-cell range for settlement, returns #NUM!. 8 of 8 arguments used.');
		// Case #15: Name,Number(7). Named range with text, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(TestNameArea,38838,38746,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(TestNameArea,38838,38746,0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name,Number(7). Named range with text, returns #VALUE!. 8 of 8 arguments used.');
		// Case #16: Ref3D,Number(7). 3D ref to text, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(Sheet2!A9,38838,38746,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(Sheet2!A9,38838,38746,0.05,0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D,Number(7). 3D ref to text, returns #VALUE!. 8 of 8 arguments used.');
		// Case #17: Array,Number(7). Array with boolean, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE({FALSE},38838,38746,0.05,0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE({FALSE},38838,38746,0.05,0.06,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array,Number(7). Array with boolean, returns #NUM!. 8 of 8 arguments used.');
		// Case #18: Number(3),String,Number(4). Non-numeric rate string, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,"abc",0.06,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,"abc",0.06,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3),String,Number(4). Non-numeric rate string, returns #VALUE!. 8 of 8 arguments used.');
		// Case #19: Number(4),String,Number(3). Non-numeric yield string, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,0.05,"abc",100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,0.05,"abc",100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4),String,Number(3). Non-numeric yield string, returns #VALUE!. 8 of 8 arguments used.');
		// Case #20: Table. Table with invalid data, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 	"#VALUE!", 'Test: Negative case: Table. Table with invalid data, returns #VALUE!. 8 of 8 arguments used.');
		// Case #21: Number(8). Invalid frequency (not 1, 2, or 4), returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,0.05,0.06,100,3,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,0.05,0.06,100,3,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Invalid frequency (not 1, 2, or 4), returns #NUM!. 8 of 8 arguments used.');
		// Case #22: Number(8). Negative redemption, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(38777,38838,38746,0.05,0.06,-100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(38777,38838,38746,0.05,0.06,-100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Negative redemption, returns #NUM!. 8 of 8 arguments used.');

		// Bounded cases:
		// Case #1: Number(8). Minimum valid values for rate, yield, and redemption. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(1,2,1,0.0000000001,0.0000000001,0.0000000001,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(1,2,1,0.0000000001,0.0000000001,0.0000000001,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(8). Minimum valid values for rate, yield, and redemption. 8 of 8 arguments used.');
		// Case #2: Formula(3),Number(5). Maximum valid dates, redemption, frequency = 4, basis = 4. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(DATE(9999,12,30),DATE(9999,12,31),DATE(9999,12,29),0.1,0.1,9.99999999999999E+307,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(DATE(9999,12,30),DATE(9999,12,31),DATE(9999,12,29),0.1,0.1,9.99999999999999E+307,4,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula(3),Number(5). Maximum valid dates, redemption, frequency = 4, basis = 4. 8 of 8 arguments used.');
		// Case #3: Number(8). Minimum valid rate and yield near zero. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLPRICE(36526,36527,36525,1E-307,1E-307,100,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLPRICE(36526,36527,36525,1E-307,1E-307,100,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Bounded case: Number(8). Minimum valid rate and yield near zero. 8 of 8 arguments used.');

		// Need to fix:
		// Case #17: Array,Number(7). Array with boolean, returns #NUM!. 8 of 8 arguments used.
		// Case #12: Boolean,Number(7). Boolean settlement, returns #NUM!. 8 of 8 arguments used.
		// Case #2: Formula(3),Number(5). Maximum valid dates, redemption, frequency = 4, basis = 4. 8 of 8 arguments used.


		testArrayFormula2(assert, "ODDLPRICE", 7, 8, true);
	});

	QUnit.test("Test: \"ODDLYIELD\"", function (assert) {

		function oddlyield(settlement, maturity, last_interest, rate, pr, redemption, frequency, basis) {

			var fDCi = _yearFrac(last_interest, maturity, basis) * frequency;
			var fDSCi = _yearFrac(settlement, maturity, basis) * frequency;
			var fAi = _yearFrac(last_interest, settlement, basis) * frequency;

			var res = redemption + fDCi * 100.0 * rate / frequency;
			res /= pr + fAi * 100.0 * rate / frequency;
			res--;
			res *= frequency / fDSCi;

			return res;
		}

		oParser = new parserFormula("ODDLYIELD(DATE(2008,11,11),DATE(2021,3,1),DATE(2008,10,15),0.0575,84.5,100,2,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), oddlyield(new cDate(2008, 10, 11), new cDate(2021, 2, 1), new cDate(2008, 9, 15), 0.0575, 84.5, 100, 2, 0));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("38777");
		ws.getRange2("A101").setValue("38838");
		ws.getRange2("A104").setValue("100");
		// For area
		ws.getRange2("A102").setValue("38746");
		ws.getRange2("A103").setValue("0.05");
		ws.getRange2("A105").setValue("100");
		ws.getRange2("A106").setValue("2");
		ws.getRange2("A107").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(8). Valid numbers, all arguments provided. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04977876106194623, 'Test: Positive case: Number(8). Valid numbers, all arguments provided. 8 of 8 arguments used.');
		// Case #2: Formula(3),Number(5). Dates as formulas, valid numbers. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,1,1),0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,1,1),0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0495867768595053, 'Test: Positive case: Formula(3),Number(5). Dates as formulas, valid numbers. 8 of 8 arguments used.');
		// Case #3: Formula(3),Number(4),Empty. Basis omitted, defaults to 0. 7 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,1,1),0.05,100,100,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,1,1),0.05,100,100,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0495867768595053, 'Test: Positive case: Formula(3),Number(4),Empty. Basis omitted, defaults to 0. 7 of 8 arguments used.');
		// Case #4: String(3),Number(5). Dates as strings, valid numbers. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD("03/01/2006","05/01/2006","01/01/2006",0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD("03/01/2006","05/01/2006","01/01/2006",0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0495867768595053, 'Test: Positive case: String(3),Number(5). Dates as strings, valid numbers. 8 of 8 arguments used.');
		// Case #5: Formula(4),Number(4). Nested formula for settlement and rate. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),DATE(2006,1,1),SQRT(0.0025),100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),DATE(2006,1,1),SQRT(0.0025),100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0495867768595053, 'Test: Positive case: Formula(4),Number(4). Nested formula for settlement and rate. 8 of 8 arguments used.');
		// Case #6: Reference link(8). All arguments as reference links. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(A100,A101,A102,A103,A104,A105,A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(A100,A101,A102,A103,A104,A105,A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04977876106194623, 'Test: Positive case: Reference link(8). All arguments as reference links. 8 of 8 arguments used.');
		// Case #7: Area(8). Single-cell ranges. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106,A107:A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106,A107:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04977876106194623, 'Test: Positive case: Area(8). Single-cell ranges. 8 of 8 arguments used.');
		// Case #8: Array(8). Single-element arrays. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD({38777},{38838},{38746},{0.05},{100},{100},{2},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD({38777},{38838},{38746},{0.05},{100},{100},{2},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04977876106194623, 'Test: Positive case: Array(8). Single-element arrays. 8 of 8 arguments used.');
		// Case #9: Name(8). Named ranges. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(TestName,TestName1,TestName2,TestName3,TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(TestName,TestName1,TestName2,TestName3,TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(8). Named ranges. 8 of 8 arguments used.');
		// Case #10: Name3D(8). 3D named ranges. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(8). 3D named ranges. 8 of 8 arguments used.');
		// Case #11: Ref3D(8). 3D references. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7,Sheet2!A8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(8). 3D references. 8 of 8 arguments used.');
		// Case #12: Area3D(8). 3D single-cell ranges. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7,Sheet2!A8:A8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7,Sheet2!A8:A8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(8). 3D single-cell ranges. 8 of 8 arguments used.');
		// Case #13: Table. Table structured references. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured references. 8 of 8 arguments used.');
		// Case #14: Formula(8). All arguments as formulas. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),SQRT(0.0025),ABS(100),ABS(100),VALUE("2"),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),SQRT(0.0025),ABS(100),ABS(100),VALUE("2"),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04966202234791073, 'Test: Positive case: Formula(8). All arguments as formulas. 8 of 8 arguments used.');
		// Case #15: Formula,Number(7). ODDLYIELD inside SUM formula. 8 of 8 arguments used.
		oParser = new parserFormula('SUM(ODDLYIELD(38777,38838,38746,0.05,100,100,2,0),0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(ODDLYIELD(38777,38838,38746,0.05,100,100,2,0),0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.05977876106194623, 'Test: Positive case: Formula,Number(7). ODDLYIELD inside SUM formula. 8 of 8 arguments used.');
		// Case #16: String(6),Number(2). String numbers converted to numbers. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD("05/20/2025","06/30/2025","04/01/2025","0.05","100","100","2","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD("05/20/2025","06/30/2025","04/01/2025","0.05","100","100","2","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04966202234791073, 'Test: Positive case: String(6),Number(2). String numbers converted to numbers. 8 of 8 arguments used.');
		// Case #17: Array(8). Multi-element arrays. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD({38777,38778},{38838,38839},{38746,38747},{0.05,0.04},{100,101},{100,101},{2,4},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD({38777,38778},{38838,38839},{38746,38747},{0.05,0.04},{100,101},{100,101},{2,4},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04977876106194623, 'Test: Positive case: Array(8). Multi-element arrays. 8 of 8 arguments used.');
		// Case #18: Number(8). Float numbers, basis and frequency truncated. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777.5,38838.5,38746.5,0.05,100.5,100.5,2.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777.5,38838.5,38746.5,0.05,100.5,100.5,2.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.049539011971926956, 'Test: Positive case: Number(8). Float numbers, basis and frequency truncated. 8 of 8 arguments used.');
		// Case #19: Reference link,Formula,String,Number(5). Mixed types, string date converted. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(A100,DATE(2025,6,30),"04/01/2025",0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(A100,DATE(2025,6,30),"04/01/2025",0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link,Formula,String,Number(5). Mixed types, string date converted. 8 of 8 arguments used.');
		// Case #20: Date(3),Number(5). Date arguments, frequency = 1, basis = 1. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),0.05,100,100,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),0.05,100,100,1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04966662130902244, 'Test: Positive case: Date(3),Number(5). Date arguments, frequency = 1, basis = 1. 8 of 8 arguments used.');
		// Case #21: Time,Formula,Number(6). Time adjusted to valid date, frequency = 4. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(TIME(12,0,0)+38777,DATE(2006,5,1),DATE(2006,1,1),0.05,100,100,4,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(TIME(12,0,0)+38777,DATE(2006,5,1),DATE(2006,1,1),0.05,100,100,4,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0495867768595053, 'Test: Positive case: Time,Formula,Number(6). Time adjusted to valid date, frequency = 4. 8 of 8 arguments used.');

		// Negative cases:
		// Case #1: Number(7),Empty. Basis omitted, valid inputs. 7 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,0.05,100,100,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,0.05,100,100,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04977876106194623, 'Test: Negative case: Number(7),Empty. Basis omitted, valid inputs. 7 of 8 arguments used.');
		// Case #2: Number(8). Settlement >= maturity, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38838,38777,38746,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38838,38777,38746,0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Settlement >= maturity, returns #NUM!. 8 of 8 arguments used.');
		// Case #3: Number(8). Settlement <= last_interest, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38777,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38777,0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Settlement <= last_interest, returns #NUM!. 8 of 8 arguments used.');
		// Case #4: Number(8). Rate < 0, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,-0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,-0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Rate < 0, returns #NUM!. 8 of 8 arguments used.');
		// Case #5: Number(8). Price <= 0, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,0.05,0,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,0.05,0,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Price <= 0, returns #NUM!. 8 of 8 arguments used.');
		// Case #6: Number(8). Basis < 0, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,0.05,100,100,2,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,0.05,100,100,2,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Basis < 0, returns #NUM!. 8 of 8 arguments used.');
		// Case #7: Number(8). Basis > 4, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,0.05,100,100,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,0.05,100,100,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Basis > 4, returns #NUM!. 8 of 8 arguments used.');
		// Case #8: String(3),Number(5). Invalid settlement date, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD("invalid","05/01/2006","01/01/2006",0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD("invalid","05/01/2006","01/01/2006",0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(5). Invalid settlement date, returns #VALUE!. 8 of 8 arguments used.');
		// Case #9: String(3),Number(5). Invalid maturity date, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD("03/01/2006","invalid","01/01/2006",0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD("03/01/2006","invalid","01/01/2006",0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(5). Invalid maturity date, returns #VALUE!. 8 of 8 arguments used.');
		// Case #10: String(3),Number(5). Invalid last_interest date, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD("03/01/2006","05/01/2006","invalid",0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD("03/01/2006","05/01/2006","invalid",0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(5). Invalid last_interest date, returns #VALUE!. 8 of 8 arguments used.');
		// Case #11: String,Number(7). Empty settlement string, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD("",38838,38746,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD("",38838,38746,0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Number(7). Empty settlement string, returns #VALUE!. 8 of 8 arguments used.');
		// Case #12: Boolean,Number(7). Boolean settlement, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(FALSE,38838,38746,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(FALSE,38838,38746,0.05,100,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean,Number(7). Boolean settlement, returns #NUM!. 8 of 8 arguments used.');
		// Case #13: Error,Number(7). Propagates #N/A error. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(NA(),38838,38746,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(NA(),38838,38746,0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number(7). Propagates #N/A error. 8 of 8 arguments used.');
		// Case #14: Area,Number(7). Multi-cell range for settlement, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(A100:A101,38838,38746,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(A100:A101,38838,38746,0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area,Number(7). Multi-cell range for settlement, returns #NUM!. 8 of 8 arguments used.');
		// Case #15: Name,Number(7). Named range with text, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(TestNameArea,38838,38746,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(TestNameArea,38838,38746,0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name,Number(7). Named range with text, returns #VALUE!. 8 of 8 arguments used.');
		// Case #16: Ref3D,Number(7). 3D ref to text, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(Sheet2!A9,38838,38746,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(Sheet2!A9,38838,38746,0.05,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D,Number(7). 3D ref to text, returns #VALUE!. 8 of 8 arguments used.');
		// Case #17: Array,Number(7). Array with boolean, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD({FALSE},38838,38746,0.05,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD({FALSE},38838,38746,0.05,100,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array,Number(7). Array with boolean, returns #NUM!. 8 of 8 arguments used.');
		// Case #18: Number(3),String,Number(4). Non-numeric rate string, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,"abc",100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,"abc",100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3),String,Number(4). Non-numeric rate string, returns #VALUE!. 8 of 8 arguments used.');
		// Case #19: Number(4),String,Number(3). Non-numeric price string, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,0.05,"abc",100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,0.05,"abc",100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4),String,Number(3). Non-numeric price string, returns #VALUE!. 8 of 8 arguments used.');
		// Case #20: Table. Table with invalid data, returns #VALUE!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Negative case: Table. Table with invalid data, returns #VALUE!. 8 of 8 arguments used.');
		// Case #21: Number(8). Invalid frequency (not 1, 2, or 4), returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,0.05,100,100,3,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,0.05,100,100,3,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Invalid frequency (not 1, 2, or 4), returns #NUM!. 8 of 8 arguments used.');
		// Case #22: Number(8). Negative redemption, returns #NUM!. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(38777,38838,38746,0.05,100,-100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(38777,38838,38746,0.05,100,-100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(8). Negative redemption, returns #NUM!. 8 of 8 arguments used.');

		// Bounded cases:
		// Case #1: Number(8). Minimum valid values for rate, price, and redemption. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(1,2,1,0.0000000001,0.0000000001,0.0000000001,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(1,2,1,0.0000000001,0.0000000001,0.0000000001,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(8). Minimum valid values for rate, price, and redemption. 8 of 8 arguments used.');
		// Case #2: Formula(3),Number(5). Maximum valid dates, price, redemption, frequency = 4, basis = 4. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(DATE(9999,12,30),DATE(9999,12,31),DATE(9999,12,29),0.1,9.99999999999999E+307,9.99999999999999E+307,4,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(DATE(9999,12,30),DATE(9999,12,31),DATE(9999,12,29),0.1,9.99999999999999E+307,9.99999999999999E+307,4,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula(3),Number(5). Maximum valid dates, price, redemption, frequency = 4, basis = 4. 8 of 8 arguments used.');
		// Case #3: Number(8). Minimum valid rate near zero. 8 of 8 arguments used.
		oParser = new parserFormula('ODDLYIELD(36526,36527,36525,1E-307,100,100,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ODDLYIELD(36526,36527,36525,1E-307,100,100,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(8). Minimum valid rate near zero. 8 of 8 arguments used.');

		// Need to fix: error type diff
		// Case #5: Number(8). Price <= 0, returns #NUM!. 8 of 8 arguments used.
		// Case #12: Boolean,Number(7). Boolean settlement, returns #NUM!. 8 of 8 arguments used.
		// Case #17: Array,Number(7). Array with boolean, returns #NUM!. 8 of 8 arguments used.

		testArrayFormula2(assert, "ODDLYIELD", 7, 8, true);
	});

	QUnit.test("Test: \"PDURATION\"", function (assert) {
		oParser = new parserFormula("PDURATION(2.5%,2000,2200)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 3.86);

		oParser = new parserFormula("PDURATION(0.025/12,1000,1200)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 87.6);

		oParser = new parserFormula("PDURATION(0.025,1000,1200)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 7.38);

		oParser = new parserFormula("PDURATION(-0.025,1000,1200)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("PDURATION(0.025,-1000,1200)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("PDURATION(0.025,1000,-1200)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("PDURATION({0.025},{1000},{1200})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 7.38);

		oParser = new parserFormula("PDURATION(\"TEST\",1000,-1200)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: all arguments are numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(0.1,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(0.1,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), "1", 'Test: Positive case: Number. Basic valid input: all arguments are numbers. 3 of 3 arguments used.');
		// Case #1: Number. Valid input: smaller rate and values. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(0.05,500,600)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(0.05,500,600) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.7368506521275986, 'Test: Positive case: Number. Valid input: smaller rate and values. 3 of 3 arguments used.');
		// Case #2: String. String convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION("0.1","1000","1100")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION("0.1","1000","1100") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), "1", 'Test: Positive case: String. String convertible to numbers. 3 of 3 arguments used.');
		// Case #3: Formula. All arguments are formulas returning valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(SQRT(0.01),ROUND(1000,0),ABS(1100))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(SQRT(0.01),ROUND(1000,0),ABS(1100)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), "1", 'Test: Positive case: Formula. All arguments are formulas returning valid numbers. 3 of 3 arguments used.');
		// Case #4: Reference link. All arguments are reference links to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.709511291351455, 'Test: Positive case: Reference link. All arguments are reference links to valid numbers. 3 of 3 arguments used.');
		// Case #5: Area. All arguments are single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. All arguments are single-cell ranges. 3 of 3 arguments used.');
		// Case #6: Array. All arguments are arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION({0.1},{1000},{1100})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION({0.1},{1000},{1100}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), '1', 'Test: Positive case: Array. All arguments are arrays with single valid elements. 3 of 3 arguments used.');
		// Case #7: Name. All arguments are named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. All arguments are named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #8: Name3D. All arguments are 3D named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. All arguments are 3D named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #9: Ref3D. All arguments are 3D references to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. All arguments are 3D references to valid numbers. 3 of 3 arguments used.');
		// Case #10: Area3D. All arguments are 3D single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. All arguments are 3D single-cell ranges. 3 of 3 arguments used.');
		// Case #11: Table. All arguments are table structured references with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. All arguments are table structured references with valid numbers. 3 of 3 arguments used.');
		// Case #12: Formula. Rate is a nested IF formula returning valid number. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(IF(TRUE,0.1,0.05),1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(IF(TRUE,0.1,0.05),1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), '1', 'Test: Positive case: Formula. Rate is a nested IF formula returning valid number. 3 of 3 arguments used.');
		// Case #13: Date. Rate is a date adjusted to valid number (>0). 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(DATE(2025,1,1)/10^6,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(DATE(2025,1,1)/10^6,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.13478089081381, 'Test: Positive case: Date. Rate is a date adjusted to valid number (>0). 3 of 3 arguments used.');
		// Case #14: Time. Rate is a time adjusted to valid number (>0). 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(TIME(0,0,1)/1000,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(TIME(0,0,1)/1000,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8234799.582748764, 'Test: Positive case: Time. Rate is a time adjusted to valid number (>0). 3 of 3 arguments used.');
		// Case #15: Number,String. Mixed types: Number and String convertible to number. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(0.1,"1000",1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(0.1,"1000",1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), '1', 'Test: Positive case: Number,String. Mixed types: Number and String convertible to number. 3 of 3 arguments used.');
		// Case #16: Formula,String. Rate is formula, pv and fv are strings convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(SQRT(0.01),"1000","1100")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(SQRT(0.01),"1000","1100") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), '1', 'Test: Positive case: Formula,String. Rate is formula, pv and fv are strings convertible to numbers. 3 of 3 arguments used.');
		// Case #17: Array. Arrays with multiple valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION({0.1,0.05},{1000,500},{1100,600})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION({0.1,0.05},{1000,500},{1100,600}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), '1', 'Test: Positive case: Array. Arrays with multiple valid elements. 3 of 3 arguments used.');
		// Case #18: Reference link,Number. Rate is reference link, others are numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(A106,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(A106,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link,Number. Rate is reference link, others are numbers. 3 of 3 arguments used.');
		// Case #19: Area,Number. Rate is single-cell range, others are numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(A107:A107,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(A107:A107,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area,Number. Rate is single-cell range, others are numbers. 3 of 3 arguments used.');
		// Case #20: Ref3D,Number. Rate is 3D reference, others are numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(Sheet2!A7,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(Sheet2!A7,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D,Number. Rate is 3D reference, others are numbers. 3 of 3 arguments used.');
		// Case #21: Name,Number. Rate is named range, others are numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(TestName3,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(TestName3,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name,Number. Rate is named range, others are numbers. 3 of 3 arguments used.');
		// Case #22: Number,Formula. pv is a formula, others are numbers. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(0.1,SQRT(1000000),1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(0.1,SQRT(1000000),1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(0), '1', 'Test: Positive case: Number,Formula. pv is a formula, others are numbers. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Rate is zero, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(0,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(0,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Rate is zero, returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number. Rate is negative, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(-0.1,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(-0.1,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Rate is negative, returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number. pv is zero, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(0.1,0,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(0.1,0,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. pv is zero, returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number. pv is negative, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(0.1,-1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(0.1,-1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. pv is negative, returns #NUM!. 3 of 3 arguments used.');
		// Case #5: Number. fv is zero, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(0.1,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(0.1,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. fv is zero, returns #NUM!. 3 of 3 arguments used.');
		// Case #6: Number. fv is negative, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(0.1,1000,-1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(0.1,1000,-1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. fv is negative, returns #NUM!. 3 of 3 arguments used.');
		// Case #7: String. Rate is non-numeric string, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION("abc",1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION("abc",1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Rate is non-numeric string, returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: String. Rate is string convertible to zero, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION("0",1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION("0",1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Rate is string convertible to zero, returns #NUM!. 3 of 3 arguments used.');
		// Case #9: Error. Rate is error, propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(NA(),1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(NA(),1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Rate is error, propagates #N/A. 3 of 3 arguments used.');
		// Case #10: Empty. Rate is empty cell, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(A108,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(A108,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Rate is empty cell, returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Boolean. Rate is boolean (0), returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(FALSE,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(FALSE,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean. Rate is boolean (0), returns #NUM!. 3 of 3 arguments used.');
		// Case #12: Area. Rate is multi-cell range, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(A109:A110,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(A109:A110,1000,1100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Rate is multi-cell range, returns #NUM!. 3 of 3 arguments used.');
		// Case #13: Array. Rate is array with boolean, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION({FALSE},1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION({FALSE},1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Rate is array with boolean, returns #NUM!. 3 of 3 arguments used.');
		// Case #14: Ref3D. Rate is 3D reference to text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(Sheet2!A8,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(Sheet2!A8,1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. Rate is 3D reference to text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Name. Rate is named range with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(TestNameArea2,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(TestNameArea2,1000,1100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.137503524, 'Test: Negative case: Name. Rate is named range with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Table. Rate is table column with text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(Table1[Column1],1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(Table1[Column1],1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.13750352374993502, 'Test: Negative case: Table. Rate is table column with text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Formula. Rate is formula returning #NUM!, propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(SQRT(-1),1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(SQRT(-1),1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Rate is formula returning #NUM!, propagates error. 3 of 3 arguments used.');
		// Case #18: Area3D. Rate is multi-cell 3D range, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(Sheet2!A9:A10,1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(Sheet2!A9:A10,1000,1100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. Rate is multi-cell 3D range, returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Time. Rate is time value (0.5), valid but small. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(TIME(12,0,0),1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(TIME(12,0,0),1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.23506382645112683, 'Test: Negative case: Time. Rate is time value (0.5), valid but small. 3 of 3 arguments used.');
		// Case #20: Date. Rate is date (large number), returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(DATE(2025,1,1),1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(DATE(2025,1,1),1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.008883453304961982, 'Test: Negative case: Date. Rate is date (large number), returns #NUM!. 3 of 3 arguments used.');
		// Case #21: String. Rate is empty string, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION("",1000,1100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION("",1000,1100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Rate is empty string, returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid values for rate, pv, fv. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(1E-307,1E-307,1E-306)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(1E-307,1E-307,1E-306) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number. Minimum valid values for rate, pv, fv. 3 of 3 arguments used.');
		// Case #2: Number. Maximum valid values for rate, fv; minimum for pv. 3 of 3 arguments used.
		oParser = new parserFormula('PDURATION(1E+307,1E-307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PDURATION(1E+307,1E-307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Number. Maximum valid values for rate, fv; minimum for pv. 3 of 3 arguments used.');

		// Need to fix: area handle, error type diff, bounded case results diff
		// Case #12: Area. Rate is multi-cell range, returns #NUM!. 3 of 3 arguments used.
		// Case #15: Name. Rate is named range with text, returns #VALUE!. 3 of 3 arguments used.
		// Case #18: Area3D. Rate is multi-cell 3D range, returns #NUM!. 3 of 3 arguments used.
		// Case #1: Number. Minimum valid values for rate, pv, fv. 3 of 3 arguments used.
		// Case #2: Number. Maximum valid values for rate, fv; minimum for pv. 3 of 3 arguments used.

		testArrayFormula2(assert, "PDURATION", 3, 3);
	});

	QUnit.test("Test: \"PMT\"", function (assert) {

		function pmt(rate, nper, pv, fv, type) {
			var res;
			if (type === undefined || type === null) {
				type = 0;
			}

			if (fv === undefined || fv === null) {
				fv = 0;
			}

			if (rate != 0) {
				res = -1 * (pv * Math.pow(1 + rate, nper) + fv) / ((1 + rate * type) * (Math.pow(1 + rate, nper) - 1) / rate);
			} else {
				res = -1 * (pv + fv) / nper;
			}
			return res;
		}

		oParser = new parserFormula("PMT(0.08/12,10,10000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(Math.abs(oParser.calculate().getValue() - pmt(0.08 / 12, 10, 10000)) < dif);

		oParser = new parserFormula("PMT(0.08/12,10,10000,0,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(Math.abs(oParser.calculate().getValue() - pmt(0.08 / 12, 10, 10000, 0, 1)) < dif);


		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: all numbers, 3 mandatory arguments used.
		oParser = new parserFormula('PMT(0.05,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 112.82541002081534, 'Test: Positive case: Number. Basic valid input: all numbers, 3 mandatory arguments used.');
		// Case #1: Number. All 5 arguments used, numbers only.
		oParser = new parserFormula('PMT(0.1,24,-2000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.1,24,-2000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 222.5995527013756, 'Test: Positive case: Number. All 5 arguments used, numbers only.');
		// Case #2: Formula. Rate as nested formula, 3 arguments used.
		oParser = new parserFormula('PMT(SQRT(0.01),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(SQRT(0.01),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 146.76331510028726, 'Test: Positive case: Formula. Rate as nested formula, 3 arguments used.');
		// Case #3: String. String convertible to numbers, 3 arguments used.
		oParser = new parserFormula('PMT("0.05","12","-1000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT("0.05","12","-1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 112.82541002081534, 'Test: Positive case: String. String convertible to numbers, 3 arguments used.');
		// Case #4: Reference link. All arguments as cell references, 3 arguments used.
		oParser = new parserFormula('PMT(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5486439270618299, 'Test: Positive case: Reference link. All arguments as cell references, 3 arguments used.');
		// Case #5: Area. All arguments as single-cell ranges, 3 arguments used.
		oParser = new parserFormula('PMT(A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. All arguments as single-cell ranges, 3 arguments used.');
		// Case #6: Array. All arguments as single-element arrays, 3 arguments used.
		oParser = new parserFormula('PMT({0.05},{12},{-1000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT({0.05},{12},{-1000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 112.82541002081534, 'Test: Positive case: Array. All arguments as single-element arrays, 3 arguments used.');
		// Case #7: Name. All arguments as named ranges, 3 arguments used.
		oParser = new parserFormula('PMT(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -12.674621202458752, 'Test: Positive case: Name. All arguments as named ranges, 3 arguments used.');
		// Case #8: Name3D. All arguments as 3D named ranges, 3 arguments used.
		oParser = new parserFormula('PMT(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.8535533905932736, 'Test: Positive case: Name3D. All arguments as 3D named ranges, 3 arguments used.');
		// Case #9: Ref3D. All arguments as 3D references, 3 arguments used.
		oParser = new parserFormula('PMT(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. All arguments as 3D references, 3 arguments used.');
		// Case #10: Area3D. All arguments as 3D single-cell ranges, 3 arguments used.
		oParser = new parserFormula('PMT(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. All arguments as 3D single-cell ranges, 3 arguments used.');
		// Case #11: Table. All arguments as table references, 3 arguments used.
		oParser = new parserFormula('PMT(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Table. All arguments as table references, 3 arguments used.');
		// Case #12: Formula. PMT inside SUM formula, 3 arguments used.
		oParser = new parserFormula('SUM(PMT(0.05,12,-1000),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PMT(0.05,12,-1000),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 122.82541002081534, 'Test: Positive case: Formula. PMT inside SUM formula, 3 arguments used.');
		// Case #13: Number,Formula. Nper as formula, 3 arguments used.
		oParser = new parserFormula('PMT(0.05,ABS(-12),-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,ABS(-12),-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 112.82541002081534, 'Test: Positive case: Number,Formula. Nper as formula, 3 arguments used.');
		// Case #14: String,Number. String for rate and type, numbers for others, 5 arguments used.
		oParser = new parserFormula('PMT("0.05",12,-1000,0,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT("0.05",12,-1000,0,"0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 112.82541002081534, 'Test: Positive case: String,Number. String for rate and type, numbers for others, 5 arguments used.');
		// Case #15: Array. Multi-element arrays, 3 arguments used.
		oParser = new parserFormula('PMT({0.05,0.1},{12,24},{-1000,-2000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT({0.05,0.1},{12,24},{-1000,-2000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 112.82541002081534, 'Test: Positive case: Array. Multi-element arrays, 3 arguments used.');
		// Case #16: Reference link. References with all 5 arguments used.
		oParser = new parserFormula('PMT(A106,A107,A108,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(A106,A107,A108,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. References with all 5 arguments used.');
		// Case #17: Date. Rate as date serial number scaled, 3 arguments used.
		oParser = new parserFormula('PMT(DATE(2025,1,1)/1000000,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(DATE(2025,1,1)/1000000,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 110.07937197281565, 'Test: Positive case: Date. Rate as date serial number scaled, 3 arguments used.');
		// Case #18: Time. Rate as time adjusted to valid number, 3 arguments used.
		oParser = new parserFormula('PMT(TIME(12,0,0)+0.01,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(TIME(12,0,0)+0.01,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 513.6555151488042, 'Test: Positive case: Time. Rate as time adjusted to valid number, 3 arguments used.');
		// Case #19: Formula. Rate as nested IF formula, 3 arguments used.
		oParser = new parserFormula('PMT(IF(TRUE,0.05,0.1),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(IF(TRUE,0.05,0.1),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 112.82541002081534, 'Test: Positive case: Formula. Rate as nested IF formula, 3 arguments used.');
		// Case #20: Number. Monthly rate calculation, 3 arguments used.
		oParser = new parserFormula('PMT(0.05/12,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05/12,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 85.60748178846745, 'Test: Positive case: Number. Monthly rate calculation, 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Negative rate returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PMT(-0.05,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(-0.05,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 58.78080570884224, 'Test: Negative case: Number. Negative rate returns #NUM!. 3 arguments used.');
		// Case #1: Number. Negative nper returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PMT(0.05,-12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,-12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -62.82541002081534, 'Test: Negative case: Number. Negative nper returns #NUM!. 3 arguments used.');
		// Case #2: String. Non-numeric string rate returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PMT("abc",12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT("abc",12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string rate returns #VALUE!. 3 arguments used.');
		// Case #3: Error. Error propagation returns #N/A. 3 arguments used.
		oParser = new parserFormula('PMT(NA(),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(NA(),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error propagation returns #N/A. 3 arguments used.');
		// Case #4: Empty. Empty rate returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PMT(,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 83.33333333333333, 'Test: Negative case: Empty. Empty rate returns #VALUE!. 3 arguments used.');
		// Case #5: Area. Multi-cell range for rate returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PMT(A109:A110,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(A109:A110,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.333333333, 'Test: Negative case: Area. Multi-cell range for rate returns #VALUE!. 3 arguments used.');
		// Case #6: Boolean. Boolean rate returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PMT(TRUE,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(TRUE,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000.2442002442002, 'Test: Negative case: Boolean. Boolean rate returns #VALUE!. 3 arguments used.');
		// Case #7: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PMT(Sheet2!A7,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(Sheet2!A7,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 arguments used.');
		// Case #8: Name. Named range with text returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PMT(TestNameArea,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(TestNameArea,TestName1,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -35.8492424, 'Test: Negative case: Name. Named range with text returns #VALUE!. 3 arguments used.');
		// Case #10: Formula. Formula resulting in #NUM! returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PMT(SQRT(-1),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(SQRT(-1),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! returns #NUM!. 3 arguments used.');
		// Case #11: Number. Zero rate returns #DIV/0!. 3 arguments used.
		oParser = new parserFormula('PMT(0,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '83.33', 'Test: Negative case: Number. Zero rate returns #DIV/0!. 3 arguments used.');
		// Case #12: Number. Zero nper returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PMT(0.05,0,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,0,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero nper returns #NUM!. 3 arguments used.');
		// Case #13: Array. Array with boolean returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PMT({FALSE},{12},{-1000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT({FALSE},{12},{-1000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '83.33', 'Test: Negative case: Array. Array with boolean returns #VALUE!. 3 arguments used.');
		// Case #14: Empty. Empty reference returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PMT(A111,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(A111,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '83.33', 'Test: Negative case: Empty. Empty reference returns #VALUE!. 3 arguments used.');
		// Case #15: Number. Zero pv returns 0, but invalid for most cases. 3 arguments used.
		oParser = new parserFormula('PMT(0.05,12,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,12,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Zero pv returns 0, but invalid for most cases. 3 arguments used.');
		// Case #16: String. Negative rate as string returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PMT("-0.05","12","-1000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT("-0.05","12","-1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 58.78080570884224, 'Test: Negative case: String. Negative rate as string returns #NUM!. 3 arguments used.');
		// Case #17: Time. Time value too small returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PMT(TIME(12,0,0),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(TIME(12,0,0),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 503.88360560923115, 'Test: Negative case: Time. Time value too small returns #NUM!. 3 arguments used.');
		// Case #18: Area3D. 3D multi-cell range returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PMT(Sheet2!A8:A9,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(Sheet2!A8:A9,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 3 arguments used.');
		// Case #19: Number. Invalid type value returns #NUM!. 5 arguments used.
		oParser = new parserFormula('PMT(0.05,12,-1000,0,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,12,-1000,0,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 107.4527714, 'Test: Negative case: Number. Invalid type value returns #NUM!. 5 arguments used.');
		// Case #20: Formula. Nested formula returns #N/A. 3 arguments used.
		oParser = new parserFormula('PMT(0.05,IF(FALSE,12,NA()),-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,IF(FALSE,12,NA()),-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Nested formula returns #N/A. 3 arguments used.');

		// Bounded cases:
		// Case #0: Number. Smallest valid rate. 3 arguments used.
		oParser = new parserFormula('PMT(1E-307,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(1E-307,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Smallest valid rate. 3 arguments used.');
		// Case #1: Number. Largest valid nper. 3 arguments used.
		oParser = new parserFormula('PMT(0.05,1E+307,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,1E+307,-1000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Bounded case: Number. Largest valid nper. 3 arguments used.');
		// Case #2: Number. Largest valid pv (negative). 3 arguments used.
		oParser = new parserFormula('PMT(0.05,12,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,12,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1282541002081533e+306, 'Test: Bounded case: Number. Largest valid pv (negative). 3 arguments used.');
		// Case #3: Number. Largest valid fv. 5 arguments used.
		oParser = new parserFormula('PMT(0.05,12,-1000,1E+307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PMT(0.05,12,-1000,1E+307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6.2825410020815325e+305, 'Test: Bounded case: Number. Largest valid fv. 5 arguments used.');


		// Need to fix:
		// Case #5: Area. Multi-cell range for rate returns #VALUE!. 3 arguments used.
		// Case #8: Name. Named range with text returns #VALUE!. 3 arguments used.
		// Case #19: Number. Invalid type value returns #NUM!. 5 arguments used.
		// Case #1: Number. Largest valid nper. 3 arguments used.


		testArrayFormula2(assert, "PMT", 3, 5);
	});

	QUnit.test("Test: \"PPMT\"", function (assert) {

		function ppmt(rate, per, nper, pv, fv, type) {

			if (fv == undefined) {
				fv = 0;
			}
			if (type == undefined) {
				type = 0;
			}

			var fRmz = _getPMT(rate, nper, pv, fv, type);

			return fRmz - _getIPMT(rate, per, pv, type, fRmz);

		}

		oParser = new parserFormula("PPMT(0.1/12,1,2*12,2000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), ppmt(0.1 / 12, 1, 2 * 12, 2000));

		oParser = new parserFormula("PPMT(0.08,10,10,200000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), ppmt(0.08, 10, 10, 200000));

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: all numbers, 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -46.76331510028723, 'Test: Positive case: Number. Basic valid input: all numbers, 4 of 6 arguments used.');
		// Case #2: Number. All arguments as numbers, including optional fv and type. 6 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.08,2,24,5000,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.08,2,24,5000,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -97.05719119099996, 'Test: Positive case: Number. All arguments as numbers, including optional fv and type. 6 of 6 arguments used.');
		// Case #3: String. String convertible to numbers. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT("0.1","1","12","1000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT("0.1","1","12","1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -46.76331510028723, 'Test: Positive case: String. String convertible to numbers. 4 of 6 arguments used.');
		// Case #4: Formula. Nested formulas for rate and per. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(SQRT(0.01),ABS(-1),12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(SQRT(0.01),ABS(-1),12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -46.76331510028723, 'Test: Positive case: Formula. Nested formulas for rate and per. 4 of 6 arguments used.');
		// Case #5: Reference link. References to cells with valid numbers. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(A100,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. References to cells with valid numbers. 4 of 6 arguments used.');
		// Case #6: Area. Single-cell ranges. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell ranges. 4 of 6 arguments used.');
		// Case #7: Array. Arrays with single elements. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT({0.1},{1},{12},{1000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT({0.1},{1},{12},{1000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -46.76331510028723, 'Test: Positive case: Array. Arrays with single elements. 4 of 6 arguments used.');
		// Case #8: Name. Named ranges. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named ranges. 4 of 6 arguments used.');
		// Case #9: Name3D. 3D named ranges. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(TestName3D,TestName3D1,TestName3D2,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(TestName3D,TestName3D1,TestName3D2,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named ranges. 4 of 6 arguments used.');
		// Case #10: Ref3D. 3D references to cells. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to cells. 4 of 6 arguments used.');
		// Case #11: Area3D. 3D single-cell ranges. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges. 4 of 6 arguments used.');
		// Case #12: Table. Table structured references. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured references. 4 of 6 arguments used.');
		// Case #13: Date. Date as serial number for rate. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(DATE(2025,1,1)/100000,1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(DATE(2025,1,1)/100000,1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -5.061658999266001, 'Test: Positive case: Date. Date as serial number for rate. 4 of 6 arguments used.');
		// Case #14: Time. Time as small rate value. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(TIME(0,0,1)/100,1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(TIME(0,0,1)/100,1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -83.33328026196308, 'Test: Positive case: Time. Time as small rate value. 4 of 6 arguments used.');
		// Case #15: Formula. PPMT inside SUM formula. 4 of 6 arguments used.
		oParser = new parserFormula('SUM(PPMT(0.1,1,12,1000),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PPMT(0.1,1,12,1000),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -36.76331510028723, 'Test: Positive case: Formula. PPMT inside SUM formula. 4 of 6 arguments used.');
		// Case #16: Formula. Nested IF for rate. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(IF(TRUE,0.1,0),1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(IF(TRUE,0.1,0),1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -46.76331510028723, 'Test: Positive case: Formula. Nested IF for rate. 4 of 6 arguments used.');
		// Case #17: String. String rate as fraction. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT("0.1/12",1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT("0.1/12",1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String. String rate as fraction. 4 of 6 arguments used.');
		// Case #18: Number. Valid type argument (1). 6 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,1,12,1000,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,1,12,1000,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -133.42119554571565, 'Test: Positive case: Number. Valid type argument (1). 6 of 6 arguments used.');
		// Case #19: Formula. Nested ROUND for per. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,ROUND(1.4,0),12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,ROUND(1.4,0),12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -46.76331510028723, 'Test: Positive case: Formula. Nested ROUND for per. 4 of 6 arguments used.');
		// Case #20: Reference link. All arguments as references, including fv and type. 6 of 6 arguments used.
		oParser = new parserFormula('PPMT(A100,A101,A102,A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(A100,A101,A102,A103,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. All arguments as references, including fv and type. 6 of 6 arguments used.');
		// Case #21: Array. Arrays with multiple elements. 6 of 6 arguments used.
		oParser = new parserFormula('PPMT({0.1,0.2},{1,2},{12,24},{1000,2000},{0,1000},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT({0.1,0.2},{1,2},{12,24},{1000,2000},{0,1000},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -46.76331510028723, 'Test: Positive case: Array. Arrays with multiple elements. 6 of 6 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative rate returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(-0.1,1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(-0.1,1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -139.35913625763695, 'Test: Negative case: Number. Negative rate returns #NUM!. 4 of 6 arguments used.');
		// Case #2: Number. Per <= 0 returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,0,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,0,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Per <= 0 returns #NUM!. 4 of 6 arguments used.');
		// Case #3: Number. Per > nper returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,13,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,13,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Per > nper returns #NUM!. 4 of 6 arguments used.');
		// Case #4: Number. Nper <= 0 returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,1,0,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,1,0,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Nper <= 0 returns #NUM!. 4 of 6 arguments used.');
		// Case #5: String. Non-numeric string rate returns #VALUE!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT("abc",1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT("abc",1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string rate returns #VALUE!. 4 of 6 arguments used.');
		// Case #6: Error. Propagates #N/A error. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(NA(),1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(NA(),1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 4 of 6 arguments used.');
		// Case #7: Empty. Empty reference for rate returns #VALUE!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(A106,1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(A106,1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '-83.33', 'Test: Negative case: Empty. Empty reference for rate returns #VALUE!. 4 of 6 arguments used.');
		// Case #8: Area. Multi-cell range for rate returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(A100:A101,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(A100:A101,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. Multi-cell range for rate returns #NUM!. 4 of 6 arguments used.');
		// Case #9: Boolean. Boolean rate returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(TRUE,1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(TRUE,1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.2442002442002149, 'Test: Negative case: Boolean. Boolean rate returns #NUM!. 4 of 6 arguments used.');
		// Case #10: Ref3D. 3D ref to text returns #VALUE!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(Sheet2!A8,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(Sheet2!A8,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D ref to text returns #VALUE!. 4 of 6 arguments used.');
		// Case #11: Name. Named range with text returns #VALUE!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(TestNameArea,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(TestNameArea,A101,A102,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 4 of 6 arguments used.');
		// Case #13: Formula. Formula resulting in #NUM! error. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(SQRT(-1),1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(SQRT(-1),1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 4 of 6 arguments used.');
		// Case #14: Number. Pv = 0 may cause #NUM! in some cases. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,1,12,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,1,12,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Pv = 0 may cause #NUM! in some cases. 4 of 6 arguments used.');
		// Case #15: Number. Rate = 0 returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(0,1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0,1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '-83.33', 'Test: Negative case: Number. Rate = 0 returns #NUM!. 4 of 6 arguments used.');
		// Case #16: Array. Array with boolean returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT({FALSE},1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT({FALSE},1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '-83.33', 'Test: Negative case: Array. Array with boolean returns #NUM!. 4 of 6 arguments used.');
		// Case #17: Number. Invalid type (2) returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,1,12,1000,0,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,1,12,1000,0,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -133.4211955, 'Test: Negative case: Number. Invalid type (2) returns #NUM!. 6 of 6 arguments used.');
		// Case #18: String. Negative pv as string, valid but context-dependent. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT("0.1",1,12,"-1000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT("0.1",1,12,"-1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 46.76331510028723, 'Test: Negative case: String. Negative pv as string, valid but context-dependent. 4 of 6 arguments used.');
		// Case #19: Area3D. 3D multi-cell range for rate returns #NUM!. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(Sheet2!A1:A2,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(Sheet2!A1:A2,A101,A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area3D. 3D multi-cell range for rate returns #NUM!. 4 of 6 arguments used.');
		// Case #20: Time. Time value (0.5) as rate, valid but context-dependent. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(TIME(12,0,0),1,12,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(TIME(12,0,0),1,12,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.8836056092311537, 'Test: Negative case: Time. Time value (0.5) as rate, valid but context-dependent. 4 of 6 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid rate and pv, nper=1. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(1E-307,1,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(1E-307,1,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Number. Minimum valid rate and pv, nper=1. 4 of 6 arguments used.');
		// Case #2: Number. Maximum valid rate, minimum pv. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(1E+307,1,1,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(1E+307,1,1,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid rate, minimum pv. 4 of 6 arguments used.');
		// Case #3: Number. Maximum valid nper (Excel integer limit). 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,1,2.147483647E+9,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,1,2.147483647E+9,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid nper (Excel integer limit). 4 of 6 arguments used.');
		// Case #4: Number. Maximum valid pv. 4 of 6 arguments used.
		oParser = new parserFormula('PPMT(0.1,1,12,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PPMT(0.1,1,12,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4.676331510028725e+305, 'Test: Bounded case: Number. Maximum valid pv. 4 of 6 arguments used.');


		// Need to fix: different results from MS, error types diff
		// Case #12: Table. Table structured references. 4 of 6 arguments used.
		// Case #8: Area. Multi-cell range for rate returns #NUM!. 4 of 6 arguments used.
		// Case #11: Name. Named range with text returns #VALUE!. 4 of 6 arguments used.
		// Case #17: Number. Invalid type (2) returns #NUM!. 6 of 6 arguments used.
		// Case #1: Number. Minimum valid rate and pv, nper=1. 4 of 6 arguments used.

		testArrayFormula2(assert, "PPMT", 4, 6);
	});

	QUnit.test("Test: \"PRICE\"", function (assert) {

		oParser = new parserFormula("PRICE(DATE(2008,2,15),DATE(2017,11,15),0.0575,0.065,100,2,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), _getprice(new cDate(Date.UTC(2008, 1, 15)), new cDate(Date.UTC(2017, 10, 15)), 0.0575, 0.065, 100, 2, 0));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("45658");
		ws.getRange2("A101").setValue("47484");
		ws.getRange2("A104").setValue("100");
		// For area
		ws.getRange2("A102").setValue("0.05");
		ws.getRange2("A103").setValue("0.06");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Date, Date, Number, Number, Number, Number, Number. All arguments valid, semiannual payments, US basis.
		oParser = new parserFormula('PRICE(DATE(2025,1,1), DATE(2030,1,1), 0.05, 0.06, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,1,1), DATE(2030,1,1), 0.05, 0.06, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.73489858161206, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. All arguments valid, semiannual payments, US basis.');
		// Case #2: Date, Date, String, String, Number, Number, Number. Coupon and yield passed as strings converted to numbers.
		oParser = new parserFormula('PRICE(DATE(2025,2,1), DATE(2030,2,1), "0.07", "0.065", 100, 1, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,2,1), DATE(2030,2,1), "0.07", "0.065", 100, 1, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 102.07783971906962, 'Test: Positive case: Date, Date, String, String, Number, Number, Number. Coupon and yield passed as strings converted to numbers.');
		// Case #3: Date, Date, Formula, Formula, Number, Number, Number. Formula-based inputs accepted and calculated before PRICE.
		oParser = new parserFormula('PRICE(DATE(2025,3,1), DATE(2030,3,1), 0.05*1, 0.04+0.01, 100, 4, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,3,1), DATE(2030,3,1), 0.05*1, 0.04+0.01, 100, 4, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '100', 'Test: Positive case: Date, Date, Formula, Formula, Number, Number, Number. Formula-based inputs accepted and calculated before PRICE.');
		// Case #4: Date, Date, Number, Number, Number, Number, Number. Reference link case, values supplied via F column.
		oParser = new parserFormula('PRICE(A100, A101, A102, A103, A104, A105, A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(A100, A101, A102, A103, A104, A105, A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.73489858161206, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Reference link case, values supplied via F column.');
		// Case #5: Date, Date, Number, Number, Number, Number, Number. 3D reference link case, Sheet2 and \'3D\' sheet values used.
		oParser = new parserFormula('PRICE(Sheet2!A1, Sheet2!A2, Sheet2!A3, Sheet2!A4, Sheet2!A5, Sheet2!A6, Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(Sheet2!A1, Sheet2!A2, Sheet2!A3, Sheet2!A4, Sheet2!A5, Sheet2!A6, Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. 3D reference link case, Sheet2 and \'3D\' sheet values used.');
		// Case #6: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,6,1), DATE(2030,6,1), 0.04+0.001*6, 0.05+0.001*6, 100, 2, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,6,1), DATE(2030,6,1), 0.04+0.001*6, 0.05+0.001*6, 100, 2, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.69103303716443, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #7: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,7,1), DATE(2030,7,1), 0.04+0.001*7, 0.05+0.001*7, 100, 3, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,7,1), DATE(2030,7,1), 0.04+0.001*7, 0.05+0.001*7, 100, 3, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #8: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,8,1), DATE(2030,8,1), 0.04+0.001*8, 0.05+0.001*8, 100, 4, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,8,1), DATE(2030,8,1), 0.04+0.001*8, 0.05+0.001*8, 100, 4, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.68660984283937, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #9: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,9,1), DATE(2030,9,1), 0.04+0.001*9, 0.05+0.001*9, 100, 1, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,9,1), DATE(2030,9,1), 0.04+0.001*9, 0.05+0.001*9, 100, 1, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.77615209196438, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #10: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,10,1), DATE(2030,10,1), 0.04+0.001*10, 0.05+0.001*10, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,10,1), DATE(2030,10,1), 0.04+0.001*10, 0.05+0.001*10, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.73489858161206, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #11: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,11,1), DATE(2030,11,1), 0.04+0.001*11, 0.05+0.001*11, 100, 3, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,11,1), DATE(2030,11,1), 0.04+0.001*11, 0.05+0.001*11, 100, 3, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #12: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,12,1), DATE(2030,12,1), 0.04+0.001*12, 0.05+0.001*12, 100, 4, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,12,1), DATE(2030,12,1), 0.04+0.001*12, 0.05+0.001*12, 100, 4, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.72892158933529, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #13: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,1,1), DATE(2030,1,1), 0.04+0.001*13, 0.05+0.001*13, 100, 1, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,1,1), DATE(2030,1,1), 0.04+0.001*13, 0.05+0.001*13, 100, 1, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.8217929826057, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #14: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,2,1), DATE(2030,2,1), 0.04+0.001*14, 0.05+0.001*14, 100, 2, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,2,1), DATE(2030,2,1), 0.04+0.001*14, 0.05+0.001*14, 100, 2, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.77810315603591, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #15: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,3,1), DATE(2030,3,1), 0.04+0.001*15, 0.05+0.001*15, 100, 3, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,3,1), DATE(2030,3,1), 0.04+0.001*15, 0.05+0.001*15, 100, 3, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #16: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,4,1), DATE(2030,4,1), 0.04+0.001*16, 0.05+0.001*16, 100, 4, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,4,1), DATE(2030,4,1), 0.04+0.001*16, 0.05+0.001*16, 100, 4, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.77064159669773, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #17: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,5,1), DATE(2030,5,1), 0.04+0.001*17, 0.05+0.001*17, 100, 1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,5,1), DATE(2030,5,1), 0.04+0.001*17, 0.05+0.001*17, 100, 1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.86665577842413, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #18: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,6,1), DATE(2030,6,1), 0.04+0.001*18, 0.05+0.001*18, 100, 2, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,6,1), DATE(2030,6,1), 0.04+0.001*18, 0.05+0.001*18, 100, 2, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.82065897118079, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #19: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,7,1), DATE(2030,7,1), 0.04+0.001*19, 0.05+0.001*19, 100, 3, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,7,1), DATE(2030,7,1), 0.04+0.001*19, 0.05+0.001*19, 100, 3, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #20: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,8,1), DATE(2030,8,1), 0.04+0.001*20, 0.05+0.001*20, 100, 4, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,8,1), DATE(2030,8,1), 0.04+0.001*20, 0.05+0.001*20, 100, 4, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.81177967381231, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #21: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,9,1), DATE(2030,9,1), 0.04+0.001*21, 0.05+0.001*21, 100, 1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,9,1), DATE(2030,9,1), 0.04+0.001*21, 0.05+0.001*21, 100, 1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.91075759547051, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');
		// Case #22: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.
		oParser = new parserFormula('PRICE(DATE(2025,10,1), DATE(2030,10,1), 0.04+0.001*22, 0.05+0.001*22, 100, 2, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,10,1), DATE(2030,10,1), 0.04+0.001*22, 0.05+0.001*22, 100, 2, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95.86257797813184, 'Test: Positive case: Date, Date, Number, Number, Number, Number, Number. Variation of valid inputs with different months, rates, frequency and basis.');

		// Negative cases:
		// Case #1: Date, Date, Number, Number, Number, Number, Number. Maturity date earlier than settlement, should return #NUM!.
		oParser = new parserFormula('PRICE(DATE(2025,1,1), DATE(2020,1,1), 0.05, 0.06, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,1,1), DATE(2020,1,1), 0.05, 0.06, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Maturity date earlier than settlement, should return #NUM!.');
		// Case #2: Date, Date, Number, Number, Number, Number, Number. Negative rate not allowed, expect #NUM!.
		oParser = new parserFormula('PRICE(DATE(2025,1,1), DATE(2030,1,1), -0.05, 0.06, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,1,1), DATE(2030,1,1), -0.05, 0.06, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Negative rate not allowed, expect #NUM!.');
		// Case #3: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,3,1), DATE(2030,3,1), 0.05, -0.01*3, 100, 3, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,3,1), DATE(2030,3,1), 0.05, -0.01*3, 100, 3, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #4: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,4,1), DATE(2030,4,1), 0.05, -0.01*4, 100, 4, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,4,1), DATE(2030,4,1), 0.05, -0.01*4, 100, 4, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #5: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,5,1), DATE(2030,5,1), 0.05, -0.01*5, 100, 0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,5,1), DATE(2030,5,1), 0.05, -0.01*5, 100, 0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #6: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,6,1), DATE(2030,6,1), 0.05, -0.01*6, 100, 1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,6,1), DATE(2030,6,1), 0.05, -0.01*6, 100, 1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #7: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,7,1), DATE(2030,7,1), 0.05, -0.01*7, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,7,1), DATE(2030,7,1), 0.05, -0.01*7, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #8: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,8,1), DATE(2030,8,1), 0.05, -0.01*8, 100, 3, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,8,1), DATE(2030,8,1), 0.05, -0.01*8, 100, 3, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #9: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,9,1), DATE(2030,9,1), 0.05, -0.01*9, 100, 4, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,9,1), DATE(2030,9,1), 0.05, -0.01*9, 100, 4, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #10: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,10,1), DATE(2030,10,1), 0.05, -0.01*10, 100, 0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,10,1), DATE(2030,10,1), 0.05, -0.01*10, 100, 0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #11: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,11,1), DATE(2030,11,1), 0.05, -0.01*11, 100, 1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,11,1), DATE(2030,11,1), 0.05, -0.01*11, 100, 1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #12: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,12,1), DATE(2030,12,1), 0.05, -0.01*12, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,12,1), DATE(2030,12,1), 0.05, -0.01*12, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #13: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,1,1), DATE(2030,1,1), 0.05, -0.01*13, 100, 3, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,1,1), DATE(2030,1,1), 0.05, -0.01*13, 100, 3, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #14: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,2,1), DATE(2030,2,1), 0.05, -0.01*14, 100, 4, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,2,1), DATE(2030,2,1), 0.05, -0.01*14, 100, 4, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #15: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,3,1), DATE(2030,3,1), 0.05, -0.01*15, 100, 0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,3,1), DATE(2030,3,1), 0.05, -0.01*15, 100, 0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #16: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,4,1), DATE(2030,4,1), 0.05, -0.01*16, 100, 1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,4,1), DATE(2030,4,1), 0.05, -0.01*16, 100, 1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #17: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,5,1), DATE(2030,5,1), 0.05, -0.01*17, 100, 2, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,5,1), DATE(2030,5,1), 0.05, -0.01*17, 100, 2, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #18: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,6,1), DATE(2030,6,1), 0.05, -0.01*18, 100, 3, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,6,1), DATE(2030,6,1), 0.05, -0.01*18, 100, 3, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #19: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,7,1), DATE(2030,7,1), 0.05, -0.01*19, 100, 4, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,7,1), DATE(2030,7,1), 0.05, -0.01*19, 100, 4, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');
		// Case #20: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.
		oParser = new parserFormula('PRICE(DATE(2025,8,1), DATE(2030,8,1), 0.05, -0.01*20, 100, 0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,8,1), DATE(2030,8,1), 0.05, -0.01*20, 100, 0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number, Number, Number, Number, Number. Yield negative or invalid frequency, should return error.');

		// Bounded cases:
		// Case #1: Date, Date, Number, Number, Number, Number, Number. Extremely long maturity, minimal non-zero rate and yield.
		oParser = new parserFormula('PRICE(DATE(2025,1,1), DATE(2100,12,31), 0.0001, 0.0001, 100, 1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,1,1), DATE(2100,12,31), 0.0001, 0.0001, 100, 1, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Bounded case: Date, Date, Number, Number, Number, Number, Number. Extremely long maturity, minimal non-zero rate and yield.');
		// Case #2: Date, Date, Number, Number, Number, Number, Number. Maximal redemption and rates, short maturity but valid case.
		oParser = new parserFormula('PRICE(DATE(2025,1,1), DATE(2025,12,31), 1, 1, 1000000, 4, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICE(DATE(2025,1,1), DATE(2025,12,31), 1, 1, 1000000, 4, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 410675.7198877732, 'Test: Bounded case: Date, Date, Number, Number, Number, Number, Number. Maximal redemption and rates, short maturity but valid case.');

		// Need to fix:
		// Case #1: Date, Date, Number, Number, Number, Number, Number. Extremely long maturity, minimal non-zero rate and yield.

		testArrayFormula2(assert, "PRICE", 6, 7, true);
	});

	QUnit.test("Test: \"PRICEDISC\"", function (assert) {

		function pricedisc(settl, matur, discount, redemption, basis) {
			return redemption * (1.0 - discount * _getdiffdate(settl, matur, basis));
		}

		oParser = new parserFormula("PRICEDISC(DATE(2008,2,16),DATE(2008,3,1),0.0525,100,2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), pricedisc(new cDate(2008, 1, 16), new cDate(2008, 2, 1), 0.0525, 100, 2));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("38777");
		ws.getRange2("A101").setValue("38838");
		ws.getRange2("A104").setValue("0");
		// For area
		ws.getRange2("A102").setValue("0.05");
		ws.getRange2("A103").setValue("100");
		ws.getRange2("A105").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(5). Valid numeric inputs, basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38838,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38838,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: Number(5). Valid numeric inputs, basis 0. 5 of 5 arguments used.');
		// Case #2: Formula(2), Number(3). Dates as formulas, valid discount and redemption. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(DATE(2006,3,1),DATE(2006,5,1),0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(DATE(2006,3,1),DATE(2006,5,1),0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: Formula(2), Number(3). Dates as formulas, valid discount and redemption. 5 of 5 arguments used.');
		// Case #3: String(2), Number(3). String dates in MM/DD/YYYY format, valid inputs. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC("03/01/2006","05/01/2006",0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC("03/01/2006","05/01/2006",0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: String(2), Number(3). String dates in MM/DD/YYYY format, valid inputs. 5 of 5 arguments used.');
		// Case #4: Reference link(5). All arguments as reference links. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: Reference link(5). All arguments as reference links. 5 of 5 arguments used.');
		// Case #5: Array(5). Single-element arrays for all arguments. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC({38777},{38838},{0.05},{100},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC({38777},{38838},{0.05},{100},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: Array(5). Single-element arrays for all arguments. 5 of 5 arguments used.');
		// Case #6: Formula(2), Number(3). Nested IF for settlement, basis 1. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),0.05,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),0.05,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16438356164383, 'Test: Positive case: Formula(2), Number(3). Nested IF for settlement, basis 1. 5 of 5 arguments used.');
		// Case #7: Ref3D(5). 3D references for all arguments. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(5). 3D references for all arguments. 5 of 5 arguments used.');
		// Case #8: Name(5). Named ranges for all arguments. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(TestName,TestName1,TestName2,TestName3,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(TestName,TestName1,TestName2,TestName3,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(5). Named ranges for all arguments. 5 of 5 arguments used.');
		// Case #9: Name3D(5). 3D named ranges for all arguments. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(5). 3D named ranges for all arguments. 5 of 5 arguments used.');
		// Case #10: Area(5). Single-cell ranges for all arguments. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: Area(5). Single-cell ranges for all arguments. 5 of 5 arguments used.');
		// Case #11: Area3D(5). 3D single-cell ranges for all arguments. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(5). 3D single-cell ranges for all arguments. 5 of 5 arguments used.');
		// Case #12: Table. Table structured references for all arguments. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 	"#NUM!", 'Test: Positive case: Table. Table structured references for all arguments. 5 of 5 arguments used.');
		// Case #13: String(2), Number(3). Short date strings, basis 2. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC("5/5/2006","6/5/2006",0.05,100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC("5/5/2006","6/5/2006",0.05,100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.56944444444444, 'Test: Positive case: String(2), Number(3). Short date strings, basis 2. 5 of 5 arguments used.');
		// Case #14: Formula(5). All arguments as formulas. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(DATE(2025,5,20),DATE(2025,6,30),SQRT(0.0025),ROUND(100,0),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(DATE(2025,5,20),DATE(2025,6,30),SQRT(0.0025),ROUND(100,0),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.44444444444444, 'Test: Positive case: Formula(5). All arguments as formulas. 5 of 5 arguments used.');
		// Case #15: Number(4). Basis omitted, valid inputs. 4 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38838,0.05,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38838,0.05,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: Number(4). Basis omitted, valid inputs. 4 of 5 arguments used.');
		// Case #16: Formula, Number(4). Settlement as SUM formula, basis 3. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(SUM(38777,1),38838,0.05,100,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(SUM(38777,1),38838,0.05,100,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.17808219178083, 'Test: Positive case: Formula, Number(4). Settlement as SUM formula, basis 3. 5 of 5 arguments used.');
		// Case #17: Array(5). Multi-element arrays, valid inputs. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC({38777,39448},{38838,39509},{0.05,0.06},{100,200},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC({38777,39448},{38838,39509},{0.05,0.06},{100,200},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: Array(5). Multi-element arrays, valid inputs. 5 of 5 arguments used.');
		// Case #18: String(3), Number(2). Discount as string convertible to number, basis 4. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC("03/01/2006","05/01/2006","0.05",100,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC("03/01/2006","05/01/2006","0.05",100,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: String(3), Number(2). Discount as string convertible to number, basis 4. 5 of 5 arguments used.');
		// Case #19: Number(5). Larger redemption value, valid inputs. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(39448,39509,0.06,200,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(39448,39509,0.06,200,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 197.96666666666667, 'Test: Positive case: Number(5). Larger redemption value, valid inputs. 5 of 5 arguments used.');
		// Case #20: Formula(2), Number(2), Formula. Basis as TIME formula adjusted to 0. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(DATE(2025,1,1),DATE(2025,6,30),0.05,100,TIME(0,0,0)+0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(DATE(2025,1,1),DATE(2025,6,30),0.05,100,TIME(0,0,0)+0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 97.51388888888889, 'Test: Positive case: Formula(2), Number(2), Formula. Basis as TIME formula adjusted to 0. 5 of 5 arguments used.');
		// Case #21: Reference link, Number(4). Settlement as reference link. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(A100,38838,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(A100,38838,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: Reference link, Number(4). Settlement as reference link. 5 of 5 arguments used.');
		// Case #22: Formula(2), Number(3). Settlement date with decimal (truncated to integer). 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(DATE(2006,3,1.5),DATE(2006,5,1),0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(DATE(2006,3,1.5),DATE(2006,5,1),0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.16666666666667, 'Test: Positive case: Formula(2), Number(3). Settlement date with decimal (truncated to integer). 5 of 5 arguments used.');

		// Negative cases:
		// Case #1: Number(5). Settlement equals maturity returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38777,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38777,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Settlement equals maturity returns #NUM!. 5 of 5 arguments used.');
		// Case #2: Number(5). Settlement > maturity returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38776,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38776,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Settlement > maturity returns #NUM!. 5 of 5 arguments used.');
		// Case #3: Number(5). Negative discount returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38838,-0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38838,-0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Negative discount returns #NUM!. 5 of 5 arguments used.');
		// Case #4: Number(5). Negative redemption returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38838,0.05,-100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38838,0.05,-100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Negative redemption returns #NUM!. 5 of 5 arguments used.');
		// Case #5: Number(5). Invalid basis (5) returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38838,0.05,100,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38838,0.05,100,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Invalid basis (5) returns #NUM!. 5 of 5 arguments used.');
		// Case #6: Number(5). Negative basis returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38838,0.05,100,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38838,0.05,100,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Negative basis returns #NUM!. 5 of 5 arguments used.');
		// Case #7: String(5). Invalid settlement string returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC("abc","05/01/2006",0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC("abc","05/01/2006",0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Invalid settlement string returns #VALUE!. 5 of 5 arguments used.');
		// Case #8: String(5). Invalid maturity string returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC("03/01/2006","abc",0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC("03/01/2006","abc",0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Invalid maturity string returns #VALUE!. 5 of 5 arguments used.');
		// Case #9: Boolean(5). Boolean settlement returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(TRUE,38838,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(TRUE,38838,0.05,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(5). Boolean settlement returns #VALUE!. 5 of 5 arguments used.');
		// Case #10: Area(5). Multi-cell range for settlement returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(A100:A101,A101:A101,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(A100:A101,A101:A101,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(5). Multi-cell range for settlement returns #NUM!. 5 of 5 arguments used.');
		// Case #11: Empty(5). Empty settlement returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(,38838,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(,38838,0.05,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(5). Empty settlement returns #VALUE!. 5 of 5 arguments used.');
		// Case #12: String(5). Empty string for settlement returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC("","05/01/2006",0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC("","05/01/2006",0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Empty string for settlement returns #VALUE!. 5 of 5 arguments used.');
		// Case #13: Formula(5). Settlement date beyond Excel limit returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(DATE(9999,12,31)+1,DATE(9999,12,31),0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(DATE(9999,12,31)+1,DATE(9999,12,31),0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(5). Settlement date beyond Excel limit returns #NUM!. 5 of 5 arguments used.');
		// Case #14: Formula(5). Maturity date beyond Excel limit returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(DATE(2006,3,1),DATE(9999,12,31)+1,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(DATE(2006,3,1),DATE(9999,12,31)+1,0.05,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(5). Maturity date beyond Excel limit returns #NUM!. 5 of 5 arguments used.');
		// Case #15: Array(5). Array with boolean settlement returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC({TRUE},38838,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC({TRUE},38838,0.05,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array(5). Array with boolean settlement returns #VALUE!. 5 of 5 arguments used.');
		// Case #16: Ref3D(5). 3D reference to non-numeric settlement returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(Sheet2!A6,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(Sheet2!A6,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(5). 3D reference to non-numeric settlement returns #VALUE!. 5 of 5 arguments used.');
		// Case #17: Name(5). Named range with non-numeric settlement returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(TestNameArea,TestName1,TestName2,TestName3,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(TestNameArea,TestName1,TestName2,TestName3,TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name(5). Named range with non-numeric settlement returns #VALUE!. 5 of 5 arguments used.');
		// Case #19: Number(5). Zero discount returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38838,0,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38838,0,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Zero discount returns #NUM!. 5 of 5 arguments used.');
		// Case #20: Number(5). Zero redemption returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(38777,38838,0.05,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(38777,38838,0.05,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Zero redemption returns #NUM!. 5 of 5 arguments used.');
		// Case #21: Area3D(5). 3D multi-cell range for settlement returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(5). 3D multi-cell range for settlement returns #NUM!. 5 of 5 arguments used.');
		// Case #22: Formula(5). Settlement as invalid formula (returns #NUM!) propagates error. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(SQRT(-1),38838,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(SQRT(-1),38838,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(5). Settlement as invalid formula (returns #NUM!) propagates error. 5 of 5 arguments used.');

		// Bounded cases:
		// Case #1: Number(5). Minimum valid Excel date (Jan 1, 1900) and smallest positive discount/redemption. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(1,2,1E-152,1E-152,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(1,2,1E-152,1E-152,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-152, 'Test: Bounded case: Number(5). Minimum valid Excel date (Jan 1, 1900) and smallest positive discount/redemption. 5 of 5 arguments used.');
		// Case #2: Formula(2), Number(3). Maximum valid Excel date (Dec 31, 9999) and largest valid discount/redemption. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(DATE(9999,12,30),DATE(9999,12,31),1E+152,1E+152,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(DATE(9999,12,30),DATE(9999,12,31),1E+152,1E+152,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+152, 'Test: Bounded case: Formula(2), Number(3). Maximum valid Excel date (Dec 31, 9999) and largest valid discount/redemption. 5 of 5 arguments used.');
		// Case #3: Number(5). Settlement at minimum Excel date (Jan 1, 1900), maturity at Jan 1, 1901. 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(1,366,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(1,366,0.05,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 95, 'Test: Bounded case: Number(5). Settlement at minimum Excel date (Jan 1, 1900), maturity at Jan 1, 1901. 5 of 5 arguments used.');
		// Case #4: Number(5). Settlement and maturity at maximum Excel dates (Dec 30, 9999 to Dec 31, 9999). 5 of 5 arguments used.
		oParser = new parserFormula('PRICEDISC(2958100,2958465,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEDISC(2958100,2958465,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 95, 'Test: Bounded case: Number(5). Settlement and maturity at maximum Excel dates (Dec 30, 9999 to Dec 31, 9999). 5 of 5 arguments used.');

		// Need to fix:
		// Case #9: Boolean(5). Boolean settlement returns #VALUE!. 5 of 5 arguments used.
		// Case #11: Empty(5). Empty settlement returns #VALUE!. 5 of 5 arguments used.
		// Case #14: Formula(5). Maturity date beyond Excel limit returns #NUM!. 5 of 5 arguments used.
		// Case #15: Array(5). Array with boolean settlement returns #VALUE!. 5 of 5 arguments used.
		// Case #17: Name(5). Named range with non-numeric settlement returns #VALUE!. 5 of 5 arguments used.
		// Case #3: Number(5). Settlement at minimum Excel date (Jan 1, 1900), maturity at Jan 1, 1901. 5 of 5 arguments used.


		testArrayFormula2(assert, "PMT", 4, 5, true);
	});

	QUnit.test("Test: \"PRICEMAT\"", function (assert) {

		function pricemat(settl, matur, iss, rate, yld, basis) {

			var fIssMat = _yearFrac(new cDate(iss), new cDate(matur), basis);
			var fIssSet = _yearFrac(new cDate(iss), new cDate(settl), basis);
			var fSetMat = _yearFrac(new cDate(settl), new cDate(matur), basis);

			var res = 1.0 + fIssMat * rate;
			res /= 1.0 + fSetMat * yld;
			res -= fIssSet * rate;
			res *= 100.0;

			return res;
		}

		oParser = new parserFormula("PRICEMAT(DATE(2008,2,15),DATE(2008,4,13),DATE(2007,11,11),0.061,0.061,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), pricemat(new cDate(2008, 1, 15), new cDate(2008, 3, 13), new cDate(2007, 10, 11), 0.061, 0.061, 0));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("38777");
		ws.getRange2("A101").setValue("38838");
		ws.getRange2("A104").setValue("0.05");
		// For area
		ws.getRange2("A102").setValue("38776");
		ws.getRange2("A103").setValue("0.05");
		ws.getRange2("A105").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(6). Valid numeric inputs, basis 0. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38838,38776,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38838,38776,0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: Number(6). Valid numeric inputs, basis 0. 6 of 6 arguments used.');
		// Case #2: Formula(3), Number(3). Dates as formulas, valid rate and yield. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,2,28),0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,2,28),0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: Formula(3), Number(3). Dates as formulas, valid rate and yield. 6 of 6 arguments used.');
		// Case #3: String(3), Number(3). String dates in MM/DD/YYYY format, valid inputs. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT("03/01/2006","05/01/2006","02/28/2006",0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT("03/01/2006","05/01/2006","02/28/2006",0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: String(3), Number(3). String dates in MM/DD/YYYY format, valid inputs. 6 of 6 arguments used.');
		// Case #4: Reference link(6). All arguments as reference links. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(A100,A101,A102,A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(A100,A101,A102,A103,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: Reference link(6). All arguments as reference links. 6 of 6 arguments used.');
		// Case #5: Array(6). Single-element arrays for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT({38777},{38838},{38776},{0.05},{0.05},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT({38777},{38838},{38776},{0.05},{0.05},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: Array(6). Single-element arrays for all arguments. 6 of 6 arguments used.');
		// Case #6: Formula(3), Number(3). Nested IF for settlement, basis 1. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),DATE(2006,2,28),0.05,0.05,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),DATE(2006,2,28),0.05,0.05,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988648058167, 'Test: Positive case: Formula(3), Number(3). Nested IF for settlement, basis 1. 6 of 6 arguments used.');
		// Case #7: Ref3D(6). 3D references for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(6). 3D references for all arguments. 6 of 6 arguments used.');
		// Case #8: Name(6). Named ranges for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(TestName,TestName1,TestName2,TestName3,TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(TestName,TestName1,TestName2,TestName3,TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(6). Named ranges for all arguments. 6 of 6 arguments used.');
		// Case #9: Name3D(6). 3D named ranges for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(6). 3D named ranges for all arguments. 6 of 6 arguments used.');
		// Case #10: Area(6). Single-cell ranges for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: Area(6). Single-cell ranges for all arguments. 6 of 6 arguments used.');
		// Case #11: Area3D(6). 3D single-cell ranges for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(6). 3D single-cell ranges for all arguments. 6 of 6 arguments used.');
		// Case #12: Table. Table structured references for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured references for all arguments. 6 of 6 arguments used.');
		// Case #13: String(3), Number(3). Short date strings, basis 2. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT("5/5/2006","6/5/2006","4/5/2006",0.05,0.05,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT("5/5/2006","6/5/2006","4/5/2006",0.05,0.05,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99821370949154, 'Test: Positive case: String(3), Number(3). Short date strings, basis 2. 6 of 6 arguments used.');
		// Case #14: Formula(6). All arguments as formulas. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),SQRT(0.0025),SQRT(0.0025),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),SQRT(0.0025),SQRT(0.0025),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99624002455494, 'Test: Positive case: Formula(6). All arguments as formulas. 6 of 6 arguments used.');
		// Case #15: Number(5). Basis omitted, valid inputs. 5 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38838,38776,0.05,0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38838,38776,0.05,0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: Number(5). Basis omitted, valid inputs. 5 of 6 arguments used.');
		// Case #16: Formula, Number(5). Settlement as SUM formula, basis 3. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(SUM(38777,1),38838,38776,0.05,0.05,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(SUM(38777,1),38838,38776,0.05,0.05,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.9997766527695, 'Test: Positive case: Formula, Number(5). Settlement as SUM formula, basis 3. 6 of 6 arguments used.');
		// Case #17: Array(6). Multi-element arrays, valid inputs. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT({38777,39448},{38838,39509},{38776,39447},{0.05,0.06},{0.05,0.06},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT({38777,39448},{38838,39509},{38776,39447},{0.05,0.06},{0.05,0.06},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: Array(6). Multi-element arrays, valid inputs. 6 of 6 arguments used.');
		// Case #18: String(4), Number(2). Rate as string convertible to number, basis 4. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT("03/01/2006","05/01/2006","02/28/2006","0.05",0.05,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT("03/01/2006","05/01/2006","02/28/2006","0.05",0.05,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99965564738292, 'Test: Positive case: String(4), Number(2). Rate as string convertible to number, basis 4. 6 of 6 arguments used.');
		// Case #19: Number(6). Larger rate and yield values, valid inputs. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(39448,39509,39447,0.06,0.06,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(39448,39509,39447,0.06,0.06,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99983226090303, 'Test: Positive case: Number(6). Larger rate and yield values, valid inputs. 6 of 6 arguments used.');
		// Case #20: Formula(3), Number(2), Formula. Basis as TIME formula adjusted to 0. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(DATE(2025,1,1),DATE(2025,6,30),DATE(2024,12,1),0.05,0.05,TIME(0,0,0)+0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(DATE(2025,1,1),DATE(2025,6,30),DATE(2024,12,1),0.05,0.05,TIME(0,0,0)+0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.98989248769033, 'Test: Positive case: Formula(3), Number(2), Formula. Basis as TIME formula adjusted to 0. 6 of 6 arguments used.');
		// Case #21: Reference link, Number(5). Settlement as reference link. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(A100,38838,38776,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(A100,38838,38776,0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: Reference link, Number(5). Settlement as reference link. 6 of 6 arguments used.');
		// Case #22: Formula(3), Number(3). Settlement date with decimal (truncated to integer). 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(DATE(2006,3,1.5),DATE(2006,5,1),DATE(2006,2,28),0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(DATE(2006,3,1.5),DATE(2006,5,1),DATE(2006,2,28),0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99988521579431, 'Test: Positive case: Formula(3), Number(3). Settlement date with decimal (truncated to integer). 6 of 6 arguments used.');

		// Negative cases:
		// Case #1: Number(6). Settlement equals maturity returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38777,38776,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38777,38776,0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Settlement equals maturity returns #NUM!. 6 of 6 arguments used.');
		// Case #2: Number(6). Settlement > maturity returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38776,38776,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38776,38776,0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Settlement > maturity returns #NUM!. 6 of 6 arguments used.');
		// Case #3: Number(6). Negative rate returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38838,38776,-0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38838,38776,-0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative rate returns #NUM!. 6 of 6 arguments used.');
		// Case #4: Number(6). Negative yield returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38838,38776,0.05,-0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38838,38776,0.05,-0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative yield returns #NUM!. 6 of 6 arguments used.');
		// Case #5: Number(6). Invalid basis (5) returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38838,38776,0.05,0.05,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38838,38776,0.05,0.05,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Invalid basis (5) returns #NUM!. 6 of 6 arguments used.');
		// Case #6: Number(6). Negative basis returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38838,38776,0.05,0.05,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38838,38776,0.05,0.05,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative basis returns #NUM!. 6 of 6 arguments used.');
		// Case #7: String(6). Invalid settlement string returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT("abc","05/01/2006","02/28/2006",0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT("abc","05/01/2006","02/28/2006",0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Invalid settlement string returns #VALUE!. 6 of 6 arguments used.');
		// Case #8: String(6). Invalid maturity string returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT("03/01/2006","abc","02/28/2006",0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT("03/01/2006","abc","02/28/2006",0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Invalid maturity string returns #VALUE!. 6 of 6 arguments used.');
		// Case #9: String(6). Invalid issue string returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT("03/01/2006","05/01/2006","abc",0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT("03/01/2006","05/01/2006","abc",0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Invalid issue string returns #VALUE!. 6 of 6 arguments used.');
		// Case #10: Area(6). Multi-cell range for settlement returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(A100:A101,A101:A101,A102:A102,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(A100:A101,A101:A101,A102:A102,0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(6). Multi-cell range for settlement returns #NUM!. 6 of 6 arguments used.');
		// Case #11: Empty(6). Empty settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(,38838,38776,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(,38838,38776,0.05,0.05,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(6). Empty settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #12: String(6). Empty string for settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT("","05/01/2006","02/28/2006",0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT("","05/01/2006","02/28/2006",0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Empty string for settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #13: Formula(6). Settlement date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(DATE(9999,12,31)+1,DATE(9999,12,31),DATE(9999,11,30),0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(DATE(9999,12,31)+1,DATE(9999,12,31),DATE(9999,11,30),0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(6). Settlement date beyond Excel limit returns #NUM!. 6 of 6 arguments used.');
		// Case #14: Formula(6). Maturity date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(DATE(2006,3,1),DATE(9999,12,31)+1,DATE(2006,2,28),0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(DATE(2006,3,1),DATE(9999,12,31)+1,DATE(2006,2,28),0.05,0.05,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(6). Maturity date beyond Excel limit returns #NUM!. 6 of 6 arguments used.');
		// Case #15: Formula(6). Issue date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(DATE(2006,3,1),DATE(2006,5,1),DATE(9999,12,31)+1,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(DATE(2006,3,1),DATE(2006,5,1),DATE(9999,12,31)+1,0.05,0.05,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(6). Issue date beyond Excel limit returns #NUM!. 6 of 6 arguments used.');
		// Case #16: Ref3D(6). 3D reference to non-numeric settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(Sheet2!A7,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(Sheet2!A7,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(6). 3D reference to non-numeric settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #17: Name(6). Named range with non-numeric settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(TestNameArea,TestName1,TestName2,TestName3,TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(TestNameArea,TestName1,TestName2,TestName3,TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name(6). Named range with non-numeric settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #18: Table(6). Table with non-numeric settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table(6). Table with non-numeric settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #19: Number(6). Zero rate returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38838,38776,0,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38838,38776,0,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.17355371900827, 'Test: Negative case: Number(6). Zero rate returns #NUM!. 6 of 6 arguments used.');
		// Case #20: Number(6). Zero yield returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(38777,38838,38776,0.05,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(38777,38838,38776,0.05,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100.83333333333333, 'Test: Negative case: Number(6). Zero yield returns #NUM!. 6 of 6 arguments used.');
		// Case #21: Area3D(6). 3D multi-cell range for settlement returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(6). 3D multi-cell range for settlement returns #NUM!. 6 of 6 arguments used.');
		// Case #22: Formula(6). Settlement as invalid formula (returns #NUM!) propagates error. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(SQRT(-1),38838,38776,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(SQRT(-1),38838,38776,0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(6). Settlement as invalid formula (returns #NUM!) propagates error. 6 of 6 arguments used.');

		// Bounded cases:
		// Case #1: Number(6). Minimum valid Excel date (Jan 1, 1900) and smallest positive rate/yield. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(1,2,1,1E-152,1E-152,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(1,2,1,1E-152,1E-152,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(6). Minimum valid Excel date (Jan 1, 1900) and smallest positive rate/yield. 6 of 6 arguments used.');
		// Case #2: Formula(3), Number(3). Maximum valid Excel date (Dec 31, 9999) and largest valid rate/yield. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(DATE(9999,12,30),DATE(9999,12,31),DATE(9999,11,30),1E+152,1E+152,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(DATE(9999,12,30),DATE(9999,12,31),DATE(9999,11,30),1E+152,1E+152,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Formula(3), Number(3). Maximum valid Excel date (Dec 31, 9999) and largest valid rate/yield. 6 of 6 arguments used.');
		// Case #3: Number(6). Settlement and issue at minimum Excel date (Jan 1, 1900), maturity at Jan 1, 1901. 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(1,366,1,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(1,366,1,0.05,0.05,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(6). Settlement and issue at minimum Excel date (Jan 1, 1900), maturity at Jan 1, 1901. 6 of 6 arguments used.');
		// Case #4: Number(6). Settlement, maturity, and issue at maximum Excel dates (Dec 30, 9999 to Dec 31, 9999). 6 of 6 arguments used.
		oParser = new parserFormula('PRICEMAT(2958100,2958465,2958099,0.05,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PRICEMAT(2958100,2958465,2958099,0.05,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Bounded case: Number(6). Settlement, maturity, and issue at maximum Excel dates (Dec 30, 9999 to Dec 31, 9999). 6 of 6 arguments used.');

		// Need to fix:
		// Case #11: Empty(6). Empty settlement returns #VALUE!. 6 of 6 arguments used.
		// Case #14: Formula(6). Maturity date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		// Case #15: Formula(6). Issue date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		// Case #1: Number(6). Minimum valid Excel date (Jan 1, 1900) and smallest positive rate/yield. 6 of 6 arguments used.
		// Case #3: Number(6). Settlement and issue at minimum Excel date (Jan 1, 1900), maturity at Jan 1, 1901. 6 of 6 arguments used.


		testArrayFormula2(assert, "PRICEMAT", 5, 6, true);
	});

	QUnit.test("Test: \"PV\"", function (assert) {

		function pv(rate, nper, pmt, fv, type) {
			if (rate != 0) {
				return -1 * (fv + pmt * (1 + rate * type) * ((Math.pow((1 + rate), nper) - 1) / rate)) / Math.pow(1 + rate, nper)
			} else {
				return -1 * (fv + pmt * nper);
			}

		}

		oParser = new parserFormula("PV(0.08/12,12*20,500,,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), pv(0.08 / 12, 12 * 20, 500, 0, 0));

		oParser = new parserFormula("PV(0,12*20,500,,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), pv(0, 12 * 20, 500, 0, 0));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: all numbers, 3 mandatory arguments used.
		oParser = new parserFormula('PV(0.05,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8863.251636448815, 'Test: Positive case: Number. Basic valid input: all numbers, 3 mandatory arguments used.');
		// Case #1: Number. All 5 arguments used, numbers only.
		oParser = new parserFormula('PV(0.1,24,-2000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.1,24,-2000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 17969.48804010459, 'Test: Positive case: Number. All 5 arguments used, numbers only.');
		// Case #2: Formula. Rate as nested formula, 3 arguments used.
		oParser = new parserFormula('PV(SQRT(0.01),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(SQRT(0.01),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6813.691822896434, 'Test: Positive case: Formula. Rate as nested formula, 3 arguments used.');
		// Case #3: String. String convertible to numbers, 3 arguments used.
		oParser = new parserFormula('PV("0.05","12","-1000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV("0.05","12","-1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8863.251636448815, 'Test: Positive case: String. String convertible to numbers, 3 arguments used.');
		// Case #4: Reference link. All arguments as cell references, 3 arguments used.
		oParser = new parserFormula('PV(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.45566894604818264, 'Test: Positive case: Reference link. All arguments as cell references, 3 arguments used.');
		// Case #5: Area. All arguments as single-cell ranges, 3 arguments used.
		oParser = new parserFormula('PV(A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. All arguments as single-cell ranges, 3 arguments used.');
		// Case #6: Array. All arguments as single-element arrays, 3 arguments used.
		oParser = new parserFormula('PV({0.05},{12},{-1000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV({0.05},{12},{-1000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8863.251636448815, 'Test: Positive case: Array. All arguments as single-element arrays, 3 arguments used.');
		// Case #7: Name. All arguments as named ranges, 3 arguments used.
		oParser = new parserFormula('PV(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -8.698484809834994, 'Test: Positive case: Name. All arguments as named ranges, 3 arguments used.');
		// Case #8: Name3D. All arguments as 3D named ranges, 3 arguments used.
		oParser = new parserFormula('PV(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.29289321881345254, 'Test: Positive case: Name3D. All arguments as 3D named ranges, 3 arguments used.');
		// Case #9: Ref3D. All arguments as 3D references, 3 arguments used.
		oParser = new parserFormula('PV(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. All arguments as 3D references, 3 arguments used.');
		// Case #10: Area3D. All arguments as 3D single-cell ranges, 3 arguments used.
		oParser = new parserFormula('PV(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. All arguments as 3D single-cell ranges, 3 arguments used.');
		// Case #11: Table. All arguments as table references, 3 arguments used.
		oParser = new parserFormula('PV(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		// todo create isolated tests with tables
		//assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Table. All arguments as table references, 3 arguments used.');
		// Case #12: Formula. PMT inside SUM formula, 3 arguments used.
		oParser = new parserFormula('SUM(PV(0.05,12,-1000),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(PV(0.05,12,-1000),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8873.251636448815, 'Test: Positive case: Formula. PMT inside SUM formula, 3 arguments used.');
		// Case #13: Number,Formula. Nper as formula, 3 arguments used.
		oParser = new parserFormula('PV(0.05,ABS(-12),-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,ABS(-12),-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8863.251636448815, 'Test: Positive case: Number,Formula. Nper as formula, 3 arguments used.');
		// Case #14: String,Number. String for rate and type, numbers for others, 5 arguments used.
		oParser = new parserFormula('PV("0.05",12,-1000,0,"0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV("0.05",12,-1000,0,"0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8863.251636448815, 'Test: Positive case: String,Number. String for rate and type, numbers for others, 5 arguments used.');
		// Case #15: Array. Multi-element arrays, 3 arguments used.
		oParser = new parserFormula('PV({0.05,0.1},{12,24},{-1000,-2000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV({0.05,0.1},{12,24},{-1000,-2000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8863.251636448815, 'Test: Positive case: Array. Multi-element arrays, 3 arguments used.');
		// Case #16: Reference link. References with all 5 arguments used.
		oParser = new parserFormula('PV(A106,A107,A108,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(A106,A107,A108,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. References with all 5 arguments used.');
		// Case #17: Date. Rate as date serial number scaled, 3 arguments used.
		oParser = new parserFormula('PV(DATE(2025,1,1)/1000000,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(DATE(2025,1,1)/1000000,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9084.35415353707, 'Test: Positive case: Date. Rate as date serial number scaled, 3 arguments used.');
		// Case #18: Time. Rate as time adjusted to valid number, 3 arguments used.
		oParser = new parserFormula('PV(TIME(12,0,0)+0.01,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(TIME(12,0,0)+0.01,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1946.8300651075524, 'Test: Positive case: Time. Rate as time adjusted to valid number, 3 arguments used.');
		// Case #19: Formula. Rate as nested IF formula, 3 arguments used.
		oParser = new parserFormula('PV(IF(TRUE,0.05,0.1),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(IF(TRUE,0.05,0.1),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8863.251636448815, 'Test: Positive case: Formula. Rate as nested IF formula, 3 arguments used.');
		// Case #20: Number. Monthly rate calculation, 3 arguments used.
		oParser = new parserFormula('PV(0.05/12,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05/12,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11681.222004298159, 'Test: Positive case: Number. Monthly rate calculation, 3 arguments used.');

		// Negative cases:
		// Case #0: Number. Negative rate returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PV(-0.05,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(-0.05,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 17012.356124434216, 'Test: Negative case: Number. Negative rate returns #NUM!. 3 arguments used.');
		// Case #1: Number. Negative nper returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PV(0.05,-12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,-12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -15917.126520442596, 'Test: Negative case: Number. Negative nper returns #NUM!. 3 arguments used.');
		// Case #2: String. Non-numeric string rate returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PV("abc",12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV("abc",12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string rate returns #VALUE!. 3 arguments used.');
		// Case #3: Error. Error propagation returns #N/A. 3 arguments used.
		oParser = new parserFormula('PV(NA(),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(NA(),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error propagation returns #N/A. 3 arguments used.');
		// Case #4: Empty. Empty rate returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PV(,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12000, 'Test: Negative case: Empty. Empty rate returns #VALUE!. 3 arguments used.');
		// Case #5: Area. Multi-cell range for rate returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PV(A109:A110,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(A109:A110,A101,A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.75, 'Test: Negative case: Area. Multi-cell range for rate returns #VALUE!. 3 arguments used.');
		// Case #6: Boolean. Boolean rate returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PV(TRUE,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(TRUE,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 999.755859375, 'Test: Negative case: Boolean. Boolean rate returns #VALUE!. 3 arguments used.');
		// Case #7: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PV(Sheet2!A7,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(Sheet2!A7,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D ref to non-numeric value returns #VALUE!. 3 arguments used.');
		// Case #8: Name. Named range with text returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PV(TestNameArea,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(TestNameArea,TestName1,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -3.075378798, 'Test: Negative case: Name. Named range with text returns #VALUE!. 3 arguments used.');
		// Case #10: Formula. Formula resulting in #NUM! returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PV(SQRT(-1),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(SQRT(-1),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! returns #NUM!. 3 arguments used.');
		// Case #11: Number. Zero rate returns #DIV/0!. 3 arguments used.
		oParser = new parserFormula('PV(0,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12000, 'Test: Negative case: Number. Zero rate returns #DIV/0!. 3 arguments used.');
		// Case #12: Number. Zero nper returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PV(0.05,0,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,0,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Zero nper returns #NUM!. 3 arguments used.');
		// Case #13: Array. Array with boolean returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PV({FALSE},{12},{-1000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV({FALSE},{12},{-1000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12000, 'Test: Negative case: Array. Array with boolean returns #VALUE!. 3 arguments used.');
		// Case #14: Empty. Empty reference returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PV(A111,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(A111,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12000, 'Test: Negative case: Empty. Empty reference returns #VALUE!. 3 arguments used.');
		// Case #15: Number. Zero pv returns 0, but invalid for most cases. 3 arguments used.
		oParser = new parserFormula('PV(0.05,12,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,12,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Zero pv returns 0, but invalid for most cases. 3 arguments used.');
		// Case #16: String. Negative rate as string returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PV("-0.05","12","-1000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV("-0.05","12","-1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 17012.356124434216, 'Test: Negative case: String. Negative rate as string returns #NUM!. 3 arguments used.');
		// Case #17: Time. Time value too small returns #NUM!. 3 arguments used.
		oParser = new parserFormula('PV(TIME(12,0,0),12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(TIME(12,0,0),12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1984.585306741482, 'Test: Negative case: Time. Time value too small returns #NUM!. 3 arguments used.');
		// Case #18: Area3D. 3D multi-cell range returns #VALUE!. 3 arguments used.
		oParser = new parserFormula('PV(Sheet2!A8:A9,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(Sheet2!A8:A9,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 3 arguments used.');
		// Case #19: Number. Invalid type value returns #NUM!. 5 arguments used.
		oParser = new parserFormula('PV(0.05,12,-1000,0,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,12,-1000,0,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 9306.414218, 'Test: Negative case: Number. Invalid type value returns #NUM!. 5 arguments used.');
		// Case #20: Formula. Nested formula returns #N/A. 3 arguments used.
		oParser = new parserFormula('PV(0.05,IF(FALSE,12,NA()),-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,IF(FALSE,12,NA()),-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Formula. Nested formula returns #N/A. 3 arguments used.');

		// Bounded cases:
		// Case #0: Number. Smallest valid rate. 3 arguments used.
		oParser = new parserFormula('PV(1E-307,12,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(1E-307,12,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Smallest valid rate. 3 arguments used.');
		// Case #1: Number. Largest valid nper. 3 arguments used.
		oParser = new parserFormula('PV(0.05,1E+307,-1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,1E+307,-1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Largest valid nper. 3 arguments used.');
		// Case #2: Number. Largest valid pv (negative). 3 arguments used.
		oParser = new parserFormula('PV(0.05,12,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,12,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8.863251636448814e+307, 'Test: Bounded case: Number. Largest valid pv (negative). 3 arguments used.');
		// Case #3: Number. Largest valid fv. 5 arguments used.
		oParser = new parserFormula('PV(0.05,12,-1000,1E+307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: PV(0.05,12,-1000,1E+307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -5.5683741817755926e+306, 'Test: Bounded case: Number. Largest valid fv. 5 arguments used.');

		// Need to fix: diff results from ms, isolated tests with tables
		// Case #5: Area. Multi-cell range for rate returns #VALUE!. 3 arguments used.
		// Case #8: Name. Named range with text returns #VALUE!. 3 arguments used.
		// Case #19: Number. Invalid type value returns #NUM!. 5 arguments used.

		testArrayFormula2(assert, "PV", 3, 5);
	});

	QUnit.test("Test: \"RATE\"", function (assert) {

		function RateIteration(fNper, fPayment, fPv, fFv, fPayType, fGuess) {
			function approxEqual(a, b) {
				if (a == b) {
					return true;
				}
				var x = a - b;
				return (x < 0.0 ? -x : x) < ((a < 0.0 ? -a : a) * (1.0 / (16777216.0 * 16777216.0)));
			}

			var bValid = true, bFound = false, fX, fXnew, fTerm, fTermDerivation, fGeoSeries, fGeoSeriesDerivation;
			var nIterationsMax = 150, nCount = 0, fEpsilonSmall = 1.0E-14, SCdEpsilon = 1.0E-7;
			fFv = fFv - fPayment * fPayType;
			fPv = fPv + fPayment * fPayType;
			if (fNper == Math.round(fNper)) {
				fX = fGuess.fGuess;
				var fPowN, fPowNminus1;
				while (!bFound && nCount < nIterationsMax) {
					fPowNminus1 = Math.pow(1.0 + fX, fNper - 1.0);
					fPowN = fPowNminus1 * (1.0 + fX);
					if (approxEqual(Math.abs(fX), 0.0)) {
						fGeoSeries = fNper;
						fGeoSeriesDerivation = fNper * (fNper - 1.0) / 2.0;
					} else {
						fGeoSeries = (fPowN - 1.0) / fX;
						fGeoSeriesDerivation = fNper * fPowNminus1 / fX - fGeoSeries / fX;
					}
					fTerm = fFv + fPv * fPowN + fPayment * fGeoSeries;
					fTermDerivation = fPv * fNper * fPowNminus1 + fPayment * fGeoSeriesDerivation;
					if (Math.abs(fTerm) < fEpsilonSmall) {
						bFound = true;
					} else {
						if (approxEqual(Math.abs(fTermDerivation), 0.0)) {
							fXnew = fX + 1.1 * SCdEpsilon;
						} else {
							fXnew = fX - fTerm / fTermDerivation;
						}
						nCount++;
						bFound = (Math.abs(fXnew - fX) < SCdEpsilon);
						fX = fXnew;
					}
				}
				bValid = (fX >= -1.0);
			} else {
				fX = (fGuess.fGuest < -1.0) ? -1.0 : fGuess.fGuest;
				while (bValid && !bFound && nCount < nIterationsMax) {
					if (approxEqual(Math.abs(fX), 0.0)) {
						fGeoSeries = fNper;
						fGeoSeriesDerivation = fNper * (fNper - 1.0) / 2.0;
					} else {
						fGeoSeries = (Math.pow(1.0 + fX, fNper) - 1.0) / fX;
						fGeoSeriesDerivation = fNper * Math.pow(1.0 + fX, fNper - 1.0) / fX - fGeoSeries / fX;
					}
					fTerm = fFv + fPv * pow(1.0 + fX, fNper) + fPayment * fGeoSeries;
					fTermDerivation = fPv * fNper * Math.pow(1.0 + fX, fNper - 1.0) + fPayment * fGeoSeriesDerivation;
					if (Math.abs(fTerm) < fEpsilonSmall) {
						bFound = true;
					} else {
						if (approxEqual(Math.abs(fTermDerivation), 0.0)) {
							fXnew = fX + 1.1 * SCdEpsilon;
						} else {
							fXnew = fX - fTerm / fTermDerivation;
						}
						nCount++;
						bFound = (Math.abs(fXnew - fX) < SCdEpsilon);
						fX = fXnew;
						bValid = (fX >= -1.0);
					}
				}
			}
			fGuess.fGuess = fX;
			return bValid && bFound;
		}

		function rate(nper, pmt, pv, fv, type, quess) {

			if (fv === undefined) {
				fv = 0;
			}
			if (type === undefined) {
				type = 0;
			}
			if (quess === undefined) {
				quess = 0.1;
			}

			var res = {fGuess: 0};

			if (RateIteration(nper, pmt, pv, fv, type, res)) {
				return res.fGuess;
			}

			return "#VALUE!"
		}

		oParser = new parserFormula("RATE(4*12,-200,8000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(difBetween(oParser.calculate().getValue(), rate(4 * 12, -200, 8000)), true);

		oParser = new parserFormula("RATE(4*12,-200,8000)*12", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(difBetween(oParser.calculate().getValue(), rate(4 * 12, -200, 8000) * 12), true);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(3). Basic valid input: 3 required arguments. Returns interest rate per period.
		oParser = new parserFormula('RATE(12,-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Positive case: Number(3). Basic valid input: 3 required arguments. Returns interest rate per period.');
		// Case #2: Number(6). All 6 arguments provided, standard financial values.
		oParser = new parserFormula('RATE(12,-100,1000,0,0,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,1000,0,0,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Positive case: Number(6). All 6 arguments provided, standard financial values.');
		// Case #3: Formula(3). Required arguments filled with formulas evaluating to numbers.
		oParser = new parserFormula('RATE(12*1,-100*1,1000*1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12*1,-100*1,1000*1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Positive case: Formula(3). Required arguments filled with formulas evaluating to numbers.');
		// Case #4: Formula(6). All arguments filled with formulas, including nested IF.
		oParser = new parserFormula('RATE(12*1,-100*1,1000*1,0*1,IF(TRUE,0,1),0.1*1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12*1,-100*1,1000*1,0*1,IF(TRUE,0,1),0.1*1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Positive case: Formula(6). All arguments filled with formulas, including nested IF.');
		// Case #5: String(3). String arguments convertible to numbers.
		oParser = new parserFormula('RATE("12","-100","1000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE("12","-100","1000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Positive case: String(3). String arguments convertible to numbers.');
		// Case #6: String(6). All arguments as strings convertible to numbers.
		oParser = new parserFormula('RATE("12","-100","1000","0","0","0.1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE("12","-100","1000","0","0","0.1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Positive case: String(6). All arguments as strings convertible to numbers.');
		// Case #7: Date(3). nper calculated using date difference (approx. 365 days).
		oParser = new parserFormula('RATE(DATE(2025,12,1)-DATE(2024,12,1),-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(DATE(2025,12,1)-DATE(2024,12,1),-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1), '0.1', 'Test: Positive case: Date(3). nper calculated using date difference (approx. 365 days).');
		// Case #8: Time(3). nper derived from time formula adjusted to number.
		oParser = new parserFormula('RATE(TIME(12,0,0)*365,-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(TIME(12,0,0)*365,-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09999999720851709, 'Test: Positive case: Time(3). nper derived from time formula adjusted to number.');
		// Case #9: Reference link(3). Reference links to cells with valid numbers.
		oParser = new parserFormula('RATE(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link(3). Reference links to cells with valid numbers.');
		// Case #10: Area(3). Single-cell ranges for required arguments.
		oParser = new parserFormula('RATE(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area(3). Single-cell ranges for required arguments.');
		// Case #11: Array(3). Arrays with single valid elements.
		oParser = new parserFormula('RATE({12},{-100},{1000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE({12},{-100},{1000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Positive case: Array(3). Arrays with single valid elements.');
		// Case #12: Name(3). Named ranges with valid numbers.
		oParser = new parserFormula('RATE(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(3). Named ranges with valid numbers.');
		// Case #13: Name3D(3). 3D named ranges with valid numbers.
		oParser = new parserFormula('RATE(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(3). 3D named ranges with valid numbers.');
		// Case #14: Ref3D(3). 3D references to cells with valid numbers.
		oParser = new parserFormula('RATE(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(3). 3D references to cells with valid numbers.');
		// Case #15: Area3D(3). 3D single-cell ranges with valid numbers.
		oParser = new parserFormula('RATE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(3). 3D single-cell ranges with valid numbers.');
		// Case #16: Table(3). Table structured references with valid numbers.
		oParser = new parserFormula('RATE(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table(3). Table structured references with valid numbers.');
		// Case #17: Formula. =RATE(SUM(10;2);-100;1000)
		oParser = new parserFormula('RATE(SUM(10,2),-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(SUM(10,2),-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Positive case: Formula. =RATE(SUM(10;2);-100;1000)');
		// Case #18: Number(4). 4 arguments with fv provided.
		oParser = new parserFormula('RATE(12,-100,1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Positive case: Number(4). 4 arguments with fv provided.');
		// Case #19: Number(5). 5 arguments with type provided (beginning of period).
		oParser = new parserFormula('RATE(12,-100,1000,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,1000,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.035031530362283556, 'Test: Positive case: Number(5). 5 arguments with type provided (beginning of period).');
		// Case #20: Number(3). =RATE(12;-100;1000;;;)
		oParser = new parserFormula('RATE(12,-100,1000,,,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,1000,,,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.029228540769133726, 'Test: Positive case: Number(3). =RATE(12;-100;1000;;;)');
		// Case #21: Number(4). =RATE(12;-100;1000;;1)
		oParser = new parserFormula('RATE(12,-100,1000,,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,1000,,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.035031530362283556, 'Test: Positive case: Number(4). =RATE(12;-100;1000;;1)');
		// Case #22: Formula(3). Complex formulas for nper and pmt.
		oParser = new parserFormula('RATE(ROUND(12.4,0),-100*SQRT(100),1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(ROUND(12.4,0),-100*SQRT(100),1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula(3). Complex formulas for nper and pmt.');

		// Negative cases:
		// Case #1: Number(2). =RATE(12;;1000)
		oParser = new parserFormula('RATE(12,,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,,1000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). =RATE(12;;1000)');
		// Case #2: Number. =RATE(12;-100;)
		oParser = new parserFormula('RATE(12,-100,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. =RATE(12;-100;)');
		// Case #3: Number(3). nper is 0, returns #NUM!.
		oParser = new parserFormula('RATE(0,-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(0,-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). nper is 0, returns #NUM!.');
		// Case #4: Number(3). nper is negative, returns #NUM!.
		oParser = new parserFormula('RATE(-1,-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(-1,-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). nper is negative, returns #NUM!.');
		// Case #5: Number(3). pmt is 0, returns #NUM!.
		oParser = new parserFormula('RATE(12,0,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,0,1000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). pmt is 0, returns #NUM!.');
		// Case #6: Number(3). pv is 0, returns #NUM!.
		oParser = new parserFormula('RATE(12,-100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). pv is 0, returns #NUM!.');
		// Case #7: String(3). nper is non-numeric string, returns #VALUE!.
		oParser = new parserFormula('RATE("abc",-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE("abc",-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). nper is non-numeric string, returns #VALUE!.');
		// Case #8: String(3). pmt is non-numeric string, returns #VALUE!.
		oParser = new parserFormula('RATE(12,"abc",1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,"abc",1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). pmt is non-numeric string, returns #VALUE!.');
		// Case #9: String(3). pv is non-numeric string, returns #VALUE!.
		oParser = new parserFormula('RATE(12,-100,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). pv is non-numeric string, returns #VALUE!.');
		// Case #10: Boolean(3). nper is boolean, returns #NUM!.
		oParser = new parserFormula('RATE(TRUE,-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(TRUE,-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.9, 'Test: Negative case: Boolean(3). nper is boolean, returns #NUM!.');
		// Case #11: Boolean(3). pmt is boolean, returns #NUM!.
		oParser = new parserFormula('RATE(12,TRUE,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,TRUE,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean(3). pmt is boolean, returns #NUM!.');
		// Case #12: Boolean(3). pv is boolean, returns #NUM!.
		oParser = new parserFormula('RATE(12,-100,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean(3). pv is boolean, returns #NUM!.');
		// Case #13: Error. nper is error, propagates #N/A.
		oParser = new parserFormula('RATE(NA(),-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(NA(),-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. nper is error, propagates #N/A.');
		// Case #14: Array. nper is multi-element array, returns #VALUE!.
		oParser = new parserFormula('RATE({12,13},-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE({12,13},-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.02922854076915833, 'Test: Negative case: Array. nper is multi-element array, returns #VALUE!.');
		// Case #15: Area. nper is multi-cell range, returns #VALUE!.
		oParser = new parserFormula('RATE(A100:A101,-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(A100:A101,-100,1000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area. nper is multi-cell range, returns #VALUE!.');
		// Case #16: Ref3D. nper is 3D multi-cell range, returns #VALUE!.
		oParser = new parserFormula('RATE(Sheet2!A1:A2,-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(Sheet2!A1:A2,-100,1000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.9, 'Test: Negative case: Ref3D. nper is 3D multi-cell range, returns #VALUE!.');
		// Case #17: Name. nper is named range with area, returns #VALUE!.
		oParser = new parserFormula('RATE(TestNameArea2,-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(TestNameArea2,-100,1000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.9, 'Test: Negative case: Name. nper is named range with area, returns #VALUE!.');
		// Case #18: Name3D. nper is 3D named range with area, returns #VALUE!.
		oParser = new parserFormula('RATE(TestNameArea3D2,-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(TestNameArea3D2,-100,1000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.9, 'Test: Negative case: Name3D. nper is 3D named range with area, returns #VALUE!.');
		// Case #19: Number(5). type is invalid (not 0 or 1), returns #NUM!.
		oParser = new parserFormula('RATE(12,-100,1000,0,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,1000,0,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.03503153, 'Test: Negative case: Number(5). type is invalid (not 0 or 1), returns #NUM!.');
		// Case #20: Number(6). guess exceeds Excelâ??s max number, returns #NUM!.
		oParser = new parserFormula('RATE(12,-100,1000,0,0,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,1000,0,0,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). guess exceeds Excelâ??s max number, returns #NUM!.');
		// Case #21: Number(6). guess is 0, may cause #NUM! if RATE cannot converge.
		oParser = new parserFormula('RATE(12,-100,1000,0,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(12,-100,1000,0,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.029228540769133726, 'Test: Negative case: Number(6). guess is 0, may cause #NUM! if RATE cannot converge.');
		// Case #22: Formula(2). =RATE(DATE(2024;12;1)-DATE(2025;12;1);-100;1000)
		oParser = new parserFormula('RATE(DATE(2024,12,1)-DATE(2025,12,1),-100,1000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(DATE(2024,12,1)-DATE(2025,12,1),-100,1000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). =RATE(DATE(2024;12;1)-DATE(2025;12;1);-100;1000)');

		// Bounded cases:
		// Case #1: Number(6). Minimum valid values for nper, pmt, pv, guess.
		oParser = new parserFormula('RATE(1,-1E-307,1E-307,0,0,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(1,-1E-307,1E-307,0,0,1E-307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -0.001, 'Test: Bounded case: Number(6). Minimum valid values for nper, pmt, pv, guess.');
		// Case #2: Number(6). Maximum valid values for nper, pmt, pv.
		oParser = new parserFormula('RATE(999999999,-9.99999999999999E+307,9.99999999999999E+307,0,0,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RATE(999999999,-9.99999999999999E+307,9.99999999999999E+307,0,0,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(6). Maximum valid values for nper, pmt, pv.');

		// Need to fix: empty handle in second argument, diff results, diff error types
		// Case #1: Number(2). =RATE(12;;1000)
		// Case #5: Number(3). pmt is 0, returns #NUM!.
		// Case #15: Area. nper is multi-cell range, returns #VALUE!.
		// Case #17: Name. nper is named range with area, returns #VALUE!.
		// Case #18: Name3D. nper is 3D named range with area, returns #VALUE!.
		// Case #19: Number(5). type is invalid (not 0 or 1), returns #NUM!.
		// Case #1: Number(6). Minimum valid values for nper, pmt, pv, guess.

		testArrayFormula2(assert, "RATE", 3, 6, true);
	});

	QUnit.test("Test: \"RECEIVED\"", function (assert) {

		function received(settlement, maturity, investment, discount, basis) {

			if (settlement >= maturity || investment <= 0 || discount <= 0 || basis < 0 || basis > 4) {
				return "#NUM!"
			}

			return investment / (1 - (discount * AscCommonExcel.yearFrac(settlement, maturity, basis)))

		}

		oParser = new parserFormula("RECEIVED(DATE(2008,2,15),DATE(2008,5,15),1000000,0.0575,2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), received(new cDate(2008, 1, 15), new cDate(2008, 4, 15), 1000000, 0.0575, 2));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("38777");
		ws.getRange2("A101").setValue("38838");
		ws.getRange2("A104").setValue("0");
		// For area
		ws.getRange2("A102").setValue("1000");
		ws.getRange2("A103").setValue("0.1");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(5). Settlement and maturity as serial numbers, investment and discount positive, basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(38777,38838,1000,0.1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(38777,38838,1000,0.1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1016.949152542373, 'Test: Positive case: Number(5). Settlement and maturity as serial numbers, investment and discount positive, basis 0. 5 of 5 arguments used.');
		// Case #2: Formula(2),Number(3). Dates filled by DATE formula, investment and discount positive, basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(DATE(2006,3,1),DATE(2006,5,1),1100,0.1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(DATE(2006,3,1),DATE(2006,5,1),1100,0.1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1118.6440677966102, 'Test: Positive case: Formula(2),Number(3). Dates filled by DATE formula, investment and discount positive, basis 0. 5 of 5 arguments used.');
		// Case #3: Formula(2),Number,Empty,Number. Dates as string format, investment and discount positive, basis 0. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(DATE(2006,3,1),DATE(2006,5,1),1000,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(DATE(2006,3,1),DATE(2006,5,1),1000,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Formula(2),Number,Empty,Number. Dates as string format, investment and discount positive, basis 0. 5 of 5 arguments used.');
		// Case #4: String(2),Number(3). Basis omitted, defaults to 0. 4 of 5 arguments used.
		oParser = new parserFormula('RECEIVED("03/01/2006","05/01/2006",1100,0.1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED("03/01/2006","05/01/2006",1100,0.1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1118.6440677966102, 'Test: Positive case: String(2),Number(3). Basis omitted, defaults to 0. 4 of 5 arguments used.');
		// Case #5: Formula(2),Number(2),Empty. Investment and discount as strings, converted to numbers. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(DATE(2006,3,1),DATE(2006,5,1),1100,0.1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(DATE(2006,3,1),DATE(2006,5,1),1100,0.1,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1118.6440677966102, 'Test: Positive case: Formula(2),Number(2),Empty. Investment and discount as strings, converted to numbers. 5 of 5 arguments used.');
		// Case #6: Formula(3),Number(2). Settlement and investment filled by formulas. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),SQRT(10000),0.1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),SQRT(10000),0.1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 101.69491525423729, 'Test: Positive case: Formula(3),Number(2). Settlement and investment filled by formulas. 5 of 5 arguments used.');
		// Case #7: Reference link(5). RECEIVED nested in SUM. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1016.949152542373, 'Test: Positive case: Reference link(5). RECEIVED nested in SUM. 5 of 5 arguments used.');
		// Case #8: Area(5). Basis filled by formula. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1016.949152542373, 'Test: Positive case: Area(5). Basis filled by formula. 5 of 5 arguments used.');
		// Case #9: Array(5). Short date strings, basis as TIME formula (truncated to 0). 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED({38777},{38838},{1000},{0.1},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED({38777},{38838},{1000},{0.1},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1016.949152542373, 'Test: Positive case: Array(5). Short date strings, basis as TIME formula (truncated to 0). 5 of 5 arguments used.');
		// Case #10: Name(5). All arguments as reference links. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(TestName,TestName1,TestName2,TestName3,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(TestName,TestName1,TestName2,TestName3,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(5). All arguments as reference links. 5 of 5 arguments used.');
		// Case #11: Name3D(5). All arguments as single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(5). All arguments as single-cell ranges. 5 of 5 arguments used.');
		// Case #12: Ref3D(5). All arguments as single-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Positive case: Ref3D(5). All arguments as single-element arrays. 5 of 5 arguments used.');
		// Case #13: Area3D(5). All arguments as multi-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(5). All arguments as multi-element arrays. 5 of 5 arguments used.');
		// Case #14: Table. All arguments as named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. All arguments as named ranges. 5 of 5 arguments used.');
		// Case #15: Formula(5). All arguments as 3D named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(DATE(2025,5,20),DATE(2025,6,30),SQRT(10000),SQRT(0.01),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(DATE(2025,5,20),DATE(2025,6,30),SQRT(10000),SQRT(0.01),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 101.12359550561797, 'Test: Positive case: Formula(5). All arguments as 3D named ranges. 5 of 5 arguments used.');
		// Case #16: Formula,Number(4). All arguments as 3D references. 5 of 5 arguments used.
		oParser = new parserFormula('SUM(RECEIVED(38777,38838,1000,0.1,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(RECEIVED(38777,38838,1000,0.1,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1026.949152542373, 'Test: Positive case: Formula,Number(4). All arguments as 3D references. 5 of 5 arguments used.');
		// Case #17: String(4),Number. All arguments as 3D single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED("05/20/2025","06/20/2025","1000","0.1",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED("05/20/2025","06/20/2025","1000","0.1",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1008.4033613445378, 'Test: Positive case: String(4),Number. All arguments as 3D single-cell ranges. 5 of 5 arguments used.');
		// Case #18: Array(5). All arguments as table references. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED({38777,38778},{38838,38839},{1000,1100},{0.1,0.2},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED({38777,38778},{38838,38839},{1000,1100},{0.1,0.2},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1016.949152542373, 'Test: Positive case: Array(5). All arguments as table references. 5 of 5 arguments used.');
		// Case #19: Number(5). Basis filled by ROUND formula. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(38777.5,38838.5,1000.5,0.15,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(38777.5,38838.5,1000.5,0.15,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1026.5925609234716, 'Test: Positive case: Number(5). Basis filled by ROUND formula. 5 of 5 arguments used.');
		// Case #20: Reference link,Formula,String,Number(2). Investment and discount as numeric strings. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(A100,DATE(2025,6,20),"1000",0.1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(A100,DATE(2025,6,20),"1000",0.1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link,Formula,String,Number(2). Investment and discount as numeric strings. 5 of 5 arguments used.');
		// Case #21: Date(2),Number(3). Discount filled by IF formula. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(DATE(2025,5,20),DATE(2025,6,30),1000,0.1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(DATE(2025,5,20),DATE(2025,6,30),1000,0.1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1011.3604876697146, 'Test: Positive case: Date(2),Number(3). Discount filled by IF formula. 5 of 5 arguments used.');
		// Case #22: Time,Formula,Number(3). Shorter maturity period, different basis (1). 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(TIME(12,0,0)+38777,DATE(2006,5,1),1000,0.1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(TIME(12,0,0)+38777,DATE(2006,5,1),1000,0.1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1016.949152542373, 'Test: Positive case: Time,Formula,Number(3). Shorter maturity period, different basis (1). 5 of 5 arguments used.');

		// Negative cases:
		// Case #1: Number(4),Boolean. Basis as boolean, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,46752,1000,0.05,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,46752,1000,0.05,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4),Boolean. Basis as boolean, returns #NUM!. 5 of 5 arguments used.');
		// Case #2: String(2),Number(2),String. Basis as text string, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED("01/01/2008","01/01/2038",1000,0.05,"Str")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED("01/01/2008","01/01/2038",1000,0.05,"Str") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2),Number(2),String. Basis as text string, returns #NUM!. 5 of 5 arguments used.');
		// Case #3: Number(3),Empty. Discount empty, returns #NUM!. 4 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,46752,1000,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,46752,1000,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3),Empty. Discount empty, returns #NUM!. 4 of 5 arguments used.');
		// Case #4: Number(4),Boolean. Discount as boolean FALSE, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,46752,1000,FALSE,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,46752,1000,FALSE,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(4),Boolean. Discount as boolean FALSE, returns #NUM!. 5 of 5 arguments used.');
		// Case #5: Formula(2),Number(3). Settlement >= maturity, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(DATE(2038,1,1),DATE(2008,1,1),1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(DATE(2038,1,1),DATE(2008,1,1),1000,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2),Number(3). Settlement >= maturity, returns #NUM!. 5 of 5 arguments used.');
		// Case #6: Number(5). Negative investment, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,46752,-1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,46752,-1000,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Negative investment, returns #NUM!. 5 of 5 arguments used.');
		// Case #7: Number(5). Negative discount, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,46752,1000,-0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,46752,1000,-0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Negative discount, returns #NUM!. 5 of 5 arguments used.');
		// Case #8: Number(5). Discount is 0, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,46752,1000,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,46752,1000,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Discount is 0, returns #NUM!. 5 of 5 arguments used.');
		// Case #9: Number(5). Negative basis, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,46752,1000,0.05,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,46752,1000,0.05,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Negative basis, returns #NUM!. 5 of 5 arguments used.');
		// Case #10: Number(5). Basis out of range (>4), returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,46752,1000,0.05,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,46752,1000,0.05,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Basis out of range (>4), returns #NUM!. 5 of 5 arguments used.');
		// Case #11: String(2),Number(3). Invalid settlement string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED("Str","01/01/2038",1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED("Str","01/01/2038",1000,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2),Number(3). Invalid settlement string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #12: String(2),Number(3). Invalid maturity string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED("01/01/2008","Str",1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED("01/01/2008","Str",1000,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2),Number(3). Invalid maturity string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #13: Empty,String,Number(3). Empty settlement string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED("","01/01/2038",1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED("","01/01/2038",1000,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Empty,String,Number(3). Empty settlement string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #14: String,Empty,Number(3). Empty maturity string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED("01/01/2008","",1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED("01/01/2008","",1000,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Empty,Number(3). Empty maturity string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #15: String(3),Number(2). Investment as text string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED("01/01/2008","01/01/2038","Str",0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED("01/01/2008","01/01/2038","Str",0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(2). Investment as text string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #16: String(3),Number(2). Discount as text string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED("01/01/2008","01/01/2038",1000,"Str",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED("01/01/2008","01/01/2038",1000,"Str",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3),Number(2). Discount as text string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #17: Number(4),Error. Basis as error, returns #N/A. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,46752,1000,0.05,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,46752,1000,0.05,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(4),Error. Basis as error, returns #N/A. 5 of 5 arguments used.');
		// Case #18: Area,Number(4). Settlement as multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(A100:A101,46752,1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(A100:A101,46752,1000,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area,Number(4). Settlement as multi-cell range, returns #VALUE!. 5 of 5 arguments used.');
		// Case #19: Number,Area,Number(3). Maturity as multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(39448,A101:A102,1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(39448,A101:A102,1000,0.05,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Area,Number(3). Maturity as multi-cell range, returns #VALUE!. 5 of 5 arguments used.');
		// Case #20: Area3D,Number(4). Settlement as 3D multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(Sheet2!A1:A2,46752,1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(Sheet2!A1:A2,46752,1000,0.05,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D,Number(4). Settlement as 3D multi-cell range, returns #VALUE!. 5 of 5 arguments used.');
		// Case #21: Name,Number(4). Settlement as named range with area, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(TestNameArea2,46752,1000,0.05,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(TestNameArea2,46752,1000,0.05,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name,Number(4). Settlement as named range with area, returns #VALUE!. 5 of 5 arguments used.');

		// Bounded cases:
		// Case #1: Number(5). Minimum valid values for investment and discount, earliest valid dates. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(2,3,0.0001,0.0001,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(2,3,0.0001,0.0001,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), '0.0001', 'Test: Bounded case: Number(5). Minimum valid values for investment and discount, earliest valid dates. 5 of 5 arguments used.');
		// Case #1: Number(5). Minimum valid values for investment and discount. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(1,2,0.0000000001,0.0000000001,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(1,2,0.0000000001,0.0000000001,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e-10, 'Test: Bounded case: Number(5). Minimum valid values for investment and discount. 5 of 5 arguments used.');
		// Case #2: Formula(2),Number(3). Maximum valid dates and investment, basis = 4. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(DATE(9999,12,30),DATE(9999,12,31),9.99999999999999E+307,0.1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(DATE(9999,12,30),DATE(9999,12,31),9.99999999999999E+307,0.1,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e+308, 'Test: Bounded case: Formula(2),Number(3). Maximum valid dates and investment, basis = 4. 5 of 5 arguments used.');
		// Case #3: Number(5). Minimum valid discount near zero. 5 of 5 arguments used.
		oParser = new parserFormula('RECEIVED(36526,36527,1000,1E-307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RECEIVED(36526,36527,1000,1E-307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Bounded case: Number(5). Minimum valid discount near zero. 5 of 5 arguments used.');

		// Need to fix: diff results from ms, error type diff
		// Case #3: Formula(2),Number,Empty,Number. Dates as string format, investment and discount positive, basis 0. 5 of 5 arguments used.
		// Case #1: Number(4),Boolean. Basis as boolean, returns #NUM!. 5 of 5 arguments used.
		// Case #3: Number(3),Empty. Discount empty, returns #NUM!. 4 of 5 arguments used.
		// Case #4: Number(4),Boolean. Discount as boolean FALSE, returns #NUM!. 5 of 5 arguments used.
		// Case #20: Area3D,Number(4). Settlement as 3D multi-cell range, returns #VALUE!. 5 of 5 arguments used.
		// Case #21: Name,Number(4). Settlement as named range with area, returns #VALUE!. 5 of 5 arguments used.
		// Case #1: Number(5). Minimum valid values for investment and discount. 5 of 5 arguments used.
		// Case #2: Formula(2),Number(3). Maximum valid dates and investment, basis = 4. 5 of 5 arguments used.


		testArrayFormula2(assert, "RECEIVED", 4, 5, true);
	});

	QUnit.test("Test: \"RRI\"", function (assert) {

		oParser = new parserFormula("RRI(96, 10000, 11000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0009933);

		oParser = new parserFormula("RRI(0, 10000, 11000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("RRI(-10, 10000, 11000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("RRI(10, 10000, -11000)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("RRI(1, 1, -1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), -2);

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("Text"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(3). Basic valid input: integers for nper, pv, fv. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(10,1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(10,1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04137974399241062, 'Test: Positive case: Number(3). Basic valid input: integers for nper, pv, fv. 3 of 3 arguments used.');
		// Case #2: Number(3). Float inputs for nper, pv, fv. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(2.5,1000,1200)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(2.5,1000,1200) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07565375693257015, 'Test: Positive case: Number(3). Float inputs for nper, pv, fv. 3 of 3 arguments used.');
		// Case #3: String(3). String inputs convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('RRI("5","1000","1500")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI("5","1000","1500") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08447177119769855, 'Test: Positive case: String(3). String inputs convertible to numbers. 3 of 3 arguments used.');
		// Case #4: Formula(3). All arguments filled with formulas. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(SQRT(25),ROUND(1000,0),ABS(1500))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(SQRT(25),ROUND(1000,0),ABS(1500)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08447177119769855, 'Test: Positive case: Formula(3). All arguments filled with formulas. 3 of 3 arguments used.');
		// Case #5: Reference link(3). All arguments as cell references. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '-0.89', 'Test: Positive case: Reference link(3). All arguments as cell references. 3 of 3 arguments used.');
		// Case #6: Area(3). All arguments as single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '-0.89', 'Test: Positive case: Area(3). All arguments as single-cell ranges. 3 of 3 arguments used.');
		// Case #7: Array(3). All arguments as single-element arrays. 3 of 3 arguments used.
		oParser = new parserFormula('RRI({5},{1000},{1500})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI({5},{1000},{1500}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08447177119769855, 'Test: Positive case: Array(3). All arguments as single-element arrays. 3 of 3 arguments used.');
		// Case #8: Name(3). All arguments as named ranges. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(3). All arguments as named ranges. 3 of 3 arguments used.');
		// Case #9: Name3D(3). All arguments as 3D named ranges. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(TestName3D,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(TestName3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(3). All arguments as 3D named ranges. 3 of 3 arguments used.');
		// Case #10: Ref3D(3). All arguments as 3D references. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(3). All arguments as 3D references. 3 of 3 arguments used.');
		// Case #11: Area3D(3). All arguments as 3D single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(3). All arguments as 3D single-cell ranges. 3 of 3 arguments used.');
		// Case #12: Table(3). All arguments as table references. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table(3). All arguments as table references. 3 of 3 arguments used.');
		// Case #13: Formula, Number(2). nper as date difference formula. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(DATE(2025,1,1)-DATE(2024,1,1),1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(DATE(2025,1,1)-DATE(2024,1,1),1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0011084420325166988, 'Test: Positive case: Formula, Number(2). nper as date difference formula. 3 of 3 arguments used.');
		// Case #14: Time, Number(2). nper as time-based formula. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(TIME(24,0,0)*365,1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(TIME(24,0,0)*365,1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Time, Number(2). nper as time-based formula. 3 of 3 arguments used.');
		// Case #15: Formula. SUM
		oParser = new parserFormula('SUM(RRI(5,1000,1500),0.01)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(RRI(5,1000,1500),0.01) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09447177119769855, 'Test: Positive case: Formula. SUM');
		// Case #16: Number(3). Smallest valid fv slightly above pv. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(1,1000,1000.0000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(1,1000,1000.0000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(3). Smallest valid fv slightly above pv. 3 of 3 arguments used.');
		// Case #17: String(2), Number. Mixed string and number inputs. 3 of 3 arguments used.
		oParser = new parserFormula('RRI("1","1000",1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI("1","1000",1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: String(2), Number. Mixed string and number inputs. 3 of 3 arguments used.');
		// Case #18: Array(3). Multi-element arrays with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('RRI({2,5},{1000,1100},{1200,1500})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI({2,5},{1000,1100},{1200,1500}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09544511501033215, 'Test: Positive case: Array(3). Multi-element arrays with valid numbers. 3 of 3 arguments used.');
		// Case #19: Formula(3). Nested IF formulas returning valid values. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(IF(TRUE,5,1),IF(TRUE,1000,500),IF(TRUE,1500,1200))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(IF(TRUE,5,1),IF(TRUE,1000,500),IF(TRUE,1500,1200)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08447177119769855, 'Test: Positive case: Formula(3). Nested IF formulas returning valid values. 3 of 3 arguments used.');
		// Case #20: Number(3). All arguments as float numbers. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(5.5,1000.5,1500.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(5.5,1000.5,1500.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.07647373427514514, 'Test: Positive case: Number(3). All arguments as float numbers. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number(3). nper is zero, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(0,1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(0,1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). nper is zero, returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number(3). nper is negative, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(-1,1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(-1,1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). nper is negative, returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number(3). pv is negative, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(5,-1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(5,-1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). pv is negative, returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number(3). fv is negative, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(5,1000,-1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(5,1000,-1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(3). fv is negative, returns #NUM!. 3 of 3 arguments used.');
		// Case #5: Empty, Number(2). nper is empty, returns #NUM!. 2 of 3 arguments used.
		oParser = new parserFormula('RRI(,1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(,1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number(2). nper is empty, returns #NUM!. 2 of 3 arguments used.');
		// Case #6: Number, Empty, Number. pv is empty, returns #NUM!. 2 of 3 arguments used.
		oParser = new parserFormula('RRI(5,,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(5,,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Empty, Number. pv is empty, returns #NUM!. 2 of 3 arguments used.');
		// Case #7: Number(2), Empty. fv is empty, returns #NUM!. 2 of 3 arguments used.
		oParser = new parserFormula('RRI(5,1000,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(5,1000,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Number(2), Empty. fv is empty, returns #NUM!. 2 of 3 arguments used.');
		// Case #8: String(3). nper as non-numeric string, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI("abc","1000","1500")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI("abc","1000","1500") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). nper as non-numeric string, returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: String(3). pv as non-numeric string, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI("5","abc","1500")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI("5","abc","1500") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). pv as non-numeric string, returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: String(3). fv as non-numeric string, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI("5","1000","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI("5","1000","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(3). fv as non-numeric string, returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Error, Number(2). nper as error, propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(NA(),1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(NA(),1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number(2). nper as error, propagates #N/A. 3 of 3 arguments used.');
		// Case #12: Area(3). Multi-cell ranges, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(A100:A101,A101:A102,A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(A100:A101,A101:A102,A102:A103) is parsed.');
		// ?assert.strictEqual(oParser.calculate().getValue(), -0.888888889, 'Test: Negative case: Area(3). Multi-cell ranges, returns #NUM!. 3 of 3 arguments used.');
		// Case #13: Boolean, Number(2). nper as boolean (0), returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(FALSE,1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(FALSE,1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number(2). nper as boolean (0), returns #NUM!. 3 of 3 arguments used.');
		// Case #14: Number, Boolean, Number. pv as boolean, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(5,TRUE,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(5,TRUE,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.3173598837665548, 'Test: Negative case: Number, Boolean, Number. pv as boolean, returns #NUM!. 3 of 3 arguments used.');
		// Case #15: Number(2), Boolean. fv as boolean (0), returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(5,1000,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(5,1000,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Negative case: Number(2), Boolean. fv as boolean (0), returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Ref3D(3). 3D references to text, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D(3). 3D references to text, returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Name(3). nper as named range with area, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(TestNameArea,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(TestNameArea,TestName1,TestName2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Negative case: Name(3). nper as named range with area, returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Name3D(3). nper as 3D named range with area, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(TestNameArea3D,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(TestNameArea3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D(3). nper as 3D named range with area, returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Area3D(3). 3D multi-cell range for nper, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(Sheet2!A4:A5,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(Sheet2!A4:A5,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(3). 3D multi-cell range for nper, returns #NUM!. 3 of 3 arguments used.');
		// Case #20: Formula(3). nper as formula resulting in #NUM!, propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(SQRT(-1),1000,1500)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(SQRT(-1),1000,1500) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(3). nper as formula resulting in #NUM!, propagates error. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number(3). Minimum valid nper and pv, smallest valid fv above pv. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(1,1E-152,1.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(1,1E-152,1.000000000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0000000000000011e+152, 'Test: Bounded case: Number(3). Minimum valid nper and pv, smallest valid fv above pv. 3 of 3 arguments used.');
		// Case #2: Number(3). Maximum valid Excel numbers for all arguments. 3 of 3 arguments used.
		oParser = new parserFormula('RRI(9.99999999999999E+153,1E+152,9.99999999999999E+153)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: RRI(9.99999999999999E+153,1E+152,9.99999999999999E+153) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(3). Maximum valid Excel numbers for all arguments. 3 of 3 arguments used.');

		// Need to fix: area, table handle
		// Case #12: Table(3). All arguments as table references. 3 of 3 arguments used.
		// Case #16: Number(3). Smallest valid fv slightly above pv. 3 of 3 arguments used.
		// Case #12: Area(3). Multi-cell ranges, returns #NUM!. 3 of 3 arguments used.
		// Case #17: Name(3). nper as named range with area, returns #NUM!. 3 of 3 arguments used.


		testArrayFormula2(assert, "RRI", 3, 3);
	});

	QUnit.test("Test: \"SLN\"", function (assert) {

		function sln(cost, salvage, life) {

			if (life == 0) {
				return "#NUM!";
			}

			return (cost - salvage) / life;
		}

		oParser = new parserFormula("SLN(30000,7500,10)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), sln(30000, 7500, 10));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: all arguments are integers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(1000,200,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(1000,200,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Number. Basic valid input: all arguments are integers. 3 of 3 arguments used.');
		// Case #1: Number. Float numbers for all arguments. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(1500.5,300.25,10.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(1500.5,300.25,10.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 114.30952380952381, 'Test: Positive case: Number. Float numbers for all arguments. 3 of 3 arguments used.');
		// Case #2: String. String convertible to numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN("1000","200","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN("1000","200","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: String. String convertible to numbers. 3 of 3 arguments used.');
		// Case #3: Formula. Nested formulas returning valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(SQRT(1000000),ABS(-100),ROUND(10,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(SQRT(1000000),ABS(-100),ROUND(10,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 90, 'Test: Positive case: Formula. Nested formulas returning valid numbers. 3 of 3 arguments used.');
		// Case #4: Reference link. Reference links to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Reference link. Reference links to valid numbers. 3 of 3 arguments used.');
		// Case #5: Area. Single-cell ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Area. Single-cell ranges with valid numbers. 3 of 3 arguments used.');
		// Case #6: Array. Arrays with single valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('SLN({1000},{200},{5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN({1000},{200},{5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Array. Arrays with single valid elements. 3 of 3 arguments used.');
		// Case #7: Name. Named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.09523809523809523, 'Test: Positive case: Name. Named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #8: Name3D. 3D named ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named ranges with valid numbers. 3 of 3 arguments used.');
		// Case #9: Ref3D. 3D references to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. 3D references to valid numbers. 3 of 3 arguments used.');
		// Case #10: Area3D. 3D single-cell ranges with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. 3D single-cell ranges with valid numbers. 3 of 3 arguments used.');
		// Case #11: Table. Table structured references with valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(Table1[Column1],Table1[Column2],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(Table1[Column1],Table1[Column2],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Table. Table structured references with valid numbers. 3 of 3 arguments used.');
		// Case #12: Date. Dates as serial numbers for cost and salvage. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(DATE(2025,1,1),DATE(2025,6,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(DATE(2025,1,1),DATE(2025,6,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -15.1, 'Test: Positive case: Date. Dates as serial numbers for cost and salvage. 3 of 3 arguments used.');
		// Case #13: Time. Time adjusted to valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(TIME(0,0,0)+1000,TIME(0,0,0)+200,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(TIME(0,0,0)+1000,TIME(0,0,0)+200,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Time. Time adjusted to valid numbers. 3 of 3 arguments used.');
		// Case #14: Formula. SLN inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(SLN(1000,200,5),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(SLN(1000,200,5),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 170, 'Test: Positive case: Formula. SLN inside SUM formula. 3 of 3 arguments used.');
		// Case #15: Formula. Nested IF formulas returning valid numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(IF(TRUE,1000,500),IF(FALSE,200,300),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(IF(TRUE,1000,500),IF(FALSE,200,300),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 140, 'Test: Positive case: Formula. Nested IF formulas returning valid numbers. 3 of 3 arguments used.');
		// Case #16: String. Strings convertible to float numbers. 3 of 3 arguments used.
		oParser = new parserFormula('SLN("1000.5","200.25","5.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN("1000.5","200.25","5.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 145.5, 'Test: Positive case: String. Strings convertible to float numbers. 3 of 3 arguments used.');
		// Case #17: Array. Arrays with multiple valid elements. 3 of 3 arguments used.
		oParser = new parserFormula('SLN({1000,1500},{200,300},{5,10})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN({1000,1500},{200,300},{5,10}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Array. Arrays with multiple valid elements. 3 of 3 arguments used.');
		// Case #18: Formula. Different nested formulas (POWER, SQRT, ABS). 3 of 3 arguments used.
		oParser = new parserFormula('SLN(POWER(10,3),SQRT(400),ABS(-5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(POWER(10,3),SQRT(400),ABS(-5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 196, 'Test: Positive case: Formula. Different nested formulas (POWER, SQRT, ABS). 3 of 3 arguments used.');
		// Case #19: Number,Formula. Mixed number and formula input. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(1000,200,ROUND(5.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(1000,200,ROUND(5.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '133.33', 'Test: Positive case: Number,Formula. Mixed number and formula input. 3 of 3 arguments used.');
		// Case #20: Reference link,String. Mixed reference link and string inputs. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(A100,"200","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(A100,"200","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -39.9, 'Test: Positive case: Reference link,String. Mixed reference link and string inputs. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number. Life is zero, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(1000,200,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(1000,200,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number. Life is zero, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #2: Number. Negative life, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(1000,200,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(1000,200,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -160, 'Test: Negative case: Number. Negative life, returns #NUM!. 3 of 3 arguments used.');
		// Case #3: String. Non-numeric string for cost, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN("abc","200","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN("abc","200","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for cost, returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: String. Non-numeric string for salvage, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN("1000","abc","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN("1000","abc","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for salvage, returns #VALUE!. 3 of 3 arguments used.');
		// Case #5: String. Non-numeric string for life, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN("1000","200","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN("1000","200","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for life, returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Error. Error input for cost, propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(NA(),200,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(NA(),200,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error input for cost, propagates #N/A. 3 of 3 arguments used.');
		// Case #7: Empty. Empty cell reference for cost, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(A103,200,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(A103,200,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -40, 'Test: Negative case: Empty. Empty cell reference for cost, returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Area. Multi-cell range for cost, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(A100:A101,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(A100:A101,A101:A101,A102:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Negative case: Area. Multi-cell range for cost, returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Boolean. Boolean TRUE for cost, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(TRUE,200,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(TRUE,200,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -39.8, 'Test: Negative case: Boolean. Boolean TRUE for cost, returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Ref3D. 3D reference to non-numeric value, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(Sheet2!A6,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(Sheet2!A6,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to non-numeric value, returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Name. Named range with non-numeric value, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(TestName,TestName1,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(TestName,TestName1,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Negative case: Name. Named range with non-numeric value, returns #VALUE!. 3 of 3 arguments used.');
		// Case #13: Formula. Formula resulting in #NUM!, propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(SQRT(-1),200,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(SQRT(-1),200,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM!, propagates error. 3 of 3 arguments used.');
		// Case #14: Array. Array with boolean value, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN({FALSE},{200},{5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN({FALSE},{200},{5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -40, 'Test: Negative case: Array. Array with boolean value, returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Area3D. 3D multi-cell range, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(Sheet2!A6:A7,Sheet2!A2:A2,Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(Sheet2!A6:A7,Sheet2!A2:A2,Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range, returns #VALUE!. 3 of 3 arguments used.');
		// Case #16: Name. Named range with area, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(TestNameArea2,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(TestNameArea2,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.028571428571428574, 'Test: Negative case: Name. Named range with area, returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Name3D. 3D named range with area, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(TestNameArea3D2,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(TestNameArea3D2,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.6, 'Test: Negative case: Name3D. 3D named range with area, returns #VALUE!. 3 of 3 arguments used.');
		// Case #18: Date. Zero life via date formula, returns #DIV/0!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(DATE(2025,1,1),DATE(2025,6,1),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(DATE(2025,1,1),DATE(2025,6,1),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Date. Zero life via date formula, returns #DIV/0!. 3 of 3 arguments used.');
		// Case #19: Time. Negative life via time formula, returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(TIME(12,0,0)+1000,TIME(12,0,0)+200,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(TIME(12,0,0)+1000,TIME(12,0,0)+200,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -160, 'Test: Negative case: Time. Negative life via time formula, returns #NUM!. 3 of 3 arguments used.');
		// Case #20: String. Empty string for life, returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('SLN("1000","200","")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN("1000","200","") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string for life, returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number. Maximum valid cost, minimum valid life. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(1.79E+307,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(1.79E+307,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.79e+307, 'Test: Bounded case: Number. Maximum valid cost, minimum valid life. 3 of 3 arguments used.');
		// Case #2: Number. Minimum valid cost, minimum valid life. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(-1.79E+307,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(-1.79E+307,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.79e+307, 'Test: Bounded case: Number. Minimum valid cost, minimum valid life. 3 of 3 arguments used.');
		// Case #3: Number. Maximum valid life. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(1000,200,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(1000,200,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8e-305, 'Test: Bounded case: Number. Maximum valid life. 3 of 3 arguments used.');
		// Case #4: Number. Minimum valid cost and salvage. 3 of 3 arguments used.
		oParser = new parserFormula('SLN(0,0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SLN(0,0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid cost and salvage. 3 of 3 arguments used.');

		// Need to fix:
		// Case #8: Area. Multi-cell range for cost, returns #VALUE!. 3 of 3 arguments used.

		testArrayFormula2(assert, "SLN", 3, 3);
	});

	QUnit.test("Test: \"SYD\"", function (assert) {

		function syd(cost, salvage, life, per) {

			if (life == -1 || life == 0) {
				return "#NUM!";
			}

			var res = 2;
			res *= cost - salvage;
			res *= life + 1 - per;
			res /= (life + 1) * life;

			return res < 0 ? "#NUM!" : res;
		}

		oParser = new parserFormula("SYD(30000,7500,10,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), syd(30000, 7500, 10, 1));

		oParser = new parserFormula("SYD(30000,7500,-1,10)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), syd(30000, 7500, -1, 10));

		oParser = new parserFormula("SYD(30000,7500,-10,10)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), syd(30000, 7500, -10, 10));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("-1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(4). All arguments are integers. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(10000,1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(10000,1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2400, 'Test: Positive case: Number(4). All arguments are integers. 4 of 4 arguments used.');
		// Case #2: Number(4). All arguments are floats. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(10000.5,1000.5,5.5,2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(10000.5,1000.5,5.5,2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2013.986013986014, 'Test: Positive case: Number(4). All arguments are floats. 4 of 4 arguments used.');
		// Case #3: String(4). All arguments as numeric strings, convertible to numbers. 4 of 4 arguments used.
		oParser = new parserFormula('SYD("10000","1000","5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD("10000","1000","5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2400, 'Test: Positive case: String(4). All arguments as numeric strings, convertible to numbers. 4 of 4 arguments used.');
		// Case #4: Formula(4). All arguments filled with formulas. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(ABS(-10000),ROUND(1000,0),SQRT(25),CEILING(2,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(ABS(-10000),ROUND(1000,0),SQRT(25),CEILING(2,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2400, 'Test: Positive case: Formula(4). All arguments filled with formulas. 4 of 4 arguments used.');
		// Case #5: Reference link(4). All arguments as Reference link. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(A100,A101,A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(A100,A101,A102,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link(4). All arguments as Reference link. 4 of 4 arguments used.');
		// Case #6: Area(4). All arguments as single-cell Area. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(A100:A100,A101:A101,A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(A100:A100,A101:A101,A102:A102,A103:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area(4). All arguments as single-cell Area. 4 of 4 arguments used.');
		// Case #7: Array(4). All arguments as single-element Array. 4 of 4 arguments used.
		oParser = new parserFormula('SYD({10000},{1000},{5},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD({10000},{1000},{5},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2400, 'Test: Positive case: Array(4). All arguments as single-element Array. 4 of 4 arguments used.');
		// Case #8: Name(4). All arguments as Name. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(TestName,TestName1,TestName2,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(TestName,TestName1,TestName2,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.19047619047619047, 'Test: Positive case: Name(4). All arguments as Name. 4 of 4 arguments used.');
		// Case #9: Name3D(4). All arguments as Name3D. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(4). All arguments as Name3D. 4 of 4 arguments used.');
		// Case #10: Ref3D(4). All arguments as Ref3D. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(4). All arguments as Ref3D. 4 of 4 arguments used.');
		// Case #11: Area3D(4). All arguments as single-cell Area3D. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(4). All arguments as single-cell Area3D. 4 of 4 arguments used.');
		// Case #12: Table(4). All arguments as Table references. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table(4). All arguments as Table references. 4 of 4 arguments used.');
		// Case #13: Date(2), Number(2). Cost and salvage as Date (serial numbers). 4 of 4 arguments used.
		oParser = new parserFormula('SYD(DATE(2025,1,1),DATE(2025,12,31),5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(DATE(2025,1,1),DATE(2025,12,31),5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -97.06666666666666, 'Test: Positive case: Date(2), Number(2). Cost and salvage as Date (serial numbers). 4 of 4 arguments used.');
		// Case #14: Time(2), Number(2). Cost and salvage as Time adjusted to valid numbers. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(TIME(0,0,0)+10000,TIME(0,0,0)+1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(TIME(0,0,0)+10000,TIME(0,0,0)+1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2400, 'Test: Positive case: Time(2), Number(2). Cost and salvage as Time adjusted to valid numbers. 4 of 4 arguments used.');
		// Case #15: Formula(2), Number(2). Cost and salvage filled with IF formulas. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(IF(TRUE,10000,0),IF(TRUE,1000,0),5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(IF(TRUE,10000,0),IF(TRUE,1000,0),5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2400, 'Test: Positive case: Formula(2), Number(2). Cost and salvage filled with IF formulas. 4 of 4 arguments used.');
		// Case #16: Number(2), Formula(2). Life and per filled with formulas. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(10000,1000,SQRT(25),ROUND(2,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(10000,1000,SQRT(25),ROUND(2,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2400, 'Test: Positive case: Number(2), Formula(2). Life and per filled with formulas. 4 of 4 arguments used.');
		// Case #17: String(2), Number(2). Cost and salvage as float strings. 4 of 4 arguments used.
		oParser = new parserFormula('SYD("10000.5","1000.5",5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD("10000.5","1000.5",5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2400, 'Test: Positive case: String(2), Number(2). Cost and salvage as float strings. 4 of 4 arguments used.');
		// Case #18: Array(2), Number(2). Cost and salvage as multi-element arrays. 4 of 4 arguments used.
		oParser = new parserFormula('SYD({10000,20000},{1000,2000},5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD({10000,20000},{1000,2000},5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2400, 'Test: Positive case: Array(2), Number(2). Cost and salvage as multi-element arrays. 4 of 4 arguments used.');
		// Case #19: Number(4). Life as very small decimal above integer. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(10000,1000,5.000000000000001,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(10000,1000,5.000000000000001,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '2400', 'Test: Positive case: Number(4). Life as very small decimal above integer. 4 of 4 arguments used.');
		// Case #20: Reference link(2), Number(2). Cost and salvage as Reference link. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(A100,A101,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(A100,A101,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.26666666666666666, 'Test: Positive case: Reference link(2), Number(2). Cost and salvage as Reference link. 4 of 4 arguments used.');

		// Negative cases:
		// Case #1: Number(4). Salvage > cost, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(1000,10000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(1000,10000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2400, 'Test: Negative case: Number(4). Salvage > cost, returns #NUM!. 4 of 4 arguments used.');
		// Case #2: Number(4). Life is negative, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(10000,1000,-5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(10000,1000,-5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Life is negative, returns #NUM!. 4 of 4 arguments used.');
		// Case #3: Number(4). Per is negative, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(10000,1000,5,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(10000,1000,5,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Per is negative, returns #NUM!. 4 of 4 arguments used.');
		// Case #4: Number(4). Per > life, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(10000,1000,5,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(10000,1000,5,6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(4). Per > life, returns #NUM!. 4 of 4 arguments used.');
		// Case #5: String(4). Cost as non-numeric string, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD("abc","1000","5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD("abc","1000","5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Cost as non-numeric string, returns #VALUE!. 4 of 4 arguments used.');
		// Case #6: String(4). Salvage as non-numeric string, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD("10000","abc","5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD("10000","abc","5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Salvage as non-numeric string, returns #VALUE!. 4 of 4 arguments used.');
		// Case #7: String(4). Life as non-numeric string, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD("10000","1000","abc","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD("10000","1000","abc","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Life as non-numeric string, returns #VALUE!. 4 of 4 arguments used.');
		// Case #8: String(4). Per as non-numeric string, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD("10000","1000","5","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD("10000","1000","5","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(4). Per as non-numeric string, returns #VALUE!. 4 of 4 arguments used.');
		// Case #9: Error(1), Number(3). Cost as error, propagates #N/A. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(NA(),1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(NA(),1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(1), Number(3). Cost as error, propagates #N/A. 4 of 4 arguments used.');
		// Case #10: Boolean(1), Number(3). Cost as boolean, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(TRUE,1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(TRUE,1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -266.4, 'Test: Negative case: Boolean(1), Number(3). Cost as boolean, returns #VALUE!. 4 of 4 arguments used.');
		// Case #11: Empty(1), Number(3). Cost as empty cell, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(A104,1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(A104,1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -266.93333333333334, 'Test: Negative case: Empty(1), Number(3). Cost as empty cell, returns #VALUE!. 4 of 4 arguments used.');
		// Case #12: Number(2), Empty(1), Number. Life as empty cell, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(10000,1000,A105,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(10000,1000,A105,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2), Empty(1), Number. Life as empty cell, returns #VALUE!. 4 of 4 arguments used.');
		// Case #13: Area(1), Number(3). Cost as multi-cell Area, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(A100:A101,1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(A100:A101,1000,5,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -266.5333333, 'Test: Negative case: Area(1), Number(3). Cost as multi-cell Area, returns #NUM!. 4 of 4 arguments used.');
		// Case #14: Array(1), Number(3). Cost as array with boolean, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD({TRUE},1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD({TRUE},1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -266.4, 'Test: Negative case: Array(1), Number(3). Cost as array with boolean, returns #NUM!. 4 of 4 arguments used.');
		// Case #15: Ref3D(1), Number(3). Cost as Ref3D with invalid data (100), returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(Sheet2!A5,1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(Sheet2!A5,1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -266.6666666666667, 'Test: Negative case: Ref3D(1), Number(3). Cost as Ref3D with invalid data (100), returns #VALUE!. 4 of 4 arguments used.');
		// Case #16: Area3D(1), Number(3). Cost as multi-cell Area3D, returns #NUM!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(Sheet2!A5:A6,1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(Sheet2!A5:A6,1000,5,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -266.6666666666667, 'Test: Negative case: Area3D(1), Number(3). Cost as multi-cell Area3D, returns #NUM!. 4 of 4 arguments used.');
		// Case #17: Name(1), Number(3). Cost as Name with Area, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(TestNameArea2,1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(TestNameArea2,1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -266.4533333333333, 'Test: Negative case: Name(1), Number(3). Cost as Name with Area, returns #VALUE!. 4 of 4 arguments used.');
		// Case #18: Name3D(1), Number(3). Cost as Name3D with Area, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(TestNameArea3D2,1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(TestNameArea3D2,1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -266.4533333333333, 'Test: Negative case: Name3D(1), Number(3). Cost as Name3D with Area, returns #VALUE!. 4 of 4 arguments used.');
		// Case #19: Table(1), Number(3). Cost as Table with invalid data, returns #VALUE!. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table(1), Number(3). Cost as Table with invalid data, returns #VALUE!. 4 of 4 arguments used.');
		// Case #20: Formula(1), Number(3). Cost as formula returning #NUM!, propagates error. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(SQRT(-1),1000,5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(SQRT(-1),1000,5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(1), Number(3). Cost as formula returning #NUM!, propagates error. 4 of 4 arguments used.');

		// Bounded cases:
		// Case #1: Number(4). Minimum valid cost and life, salvage 0, per equals life. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(1E-307,0,1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(1E-307,0,1,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number(4). Minimum valid cost and life, salvage 0, per equals life. 4 of 4 arguments used.');
		// Case #2: Number(4). Maximum valid cost, life, and per, salvage 0. 4 of 4 arguments used.
		oParser = new parserFormula('SYD(9.99999999999999E+307,0,1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SYD(9.99999999999999E+307,0,1E+307,1E+307) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Bounded case: Number(4). Maximum valid cost, life, and per, salvage 0. 4 of 4 arguments used.');

		// Need to fix: many results diff, error types dif

		testArrayFormula2(assert, "SYD", 4, 4);
	});

	QUnit.test("Test: \"TBILLEQ\"", function (assert) {

		function tbilleq(settlement, maturity, discount) {

			maturity = cDate.prototype.getDateFromExcel(maturity.getExcelDate() + 1);

			var d1 = settlement, d2 = maturity;
			var date1 = d1.getDate(), month1 = d1.getMonth(), year1 = d1.getFullYear(), date2 = d2.getDate(), month2 = d2.getMonth(), year2 = d2.getFullYear();

			var nDiff = GetDiffDate360(date1, month1, year1, date2, month2, year2, true);

			if (settlement >= maturity || discount <= 0 || nDiff > 360) {
				return "#NUM!";
			}

			return (365 * discount) / (360 - discount * nDiff);

		}

		oParser = new parserFormula("TBILLEQ(DATE(2008,3,31),DATE(2008,6,1),0.0914)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), tbilleq(new cDate(Date.UTC(2008, 2, 31)), new cDate(Date.UTC(2008, 5, 1)), 0.0914));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("45658");
		ws.getRange2("A101").setValue("45838");
		ws.getRange2("A104").setValue("");
		// For area
		ws.getRange2("A102").setValue("0.05");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("");
		ws.getRange2("A106").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2



		// Positive cases:
		// Case #1: Date, Date, Number. Settlement and maturity are valid dates, discount positive.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,1), DATE(2025,6,30), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,1), DATE(2025,6,30), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.051994301994301995, 'Test: Positive case: Date, Date, Number. Settlement and maturity are valid dates, discount positive.');
		// Case #2: Date, Date, Number. Valid 6-month T-bill with discount 10%.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,15), DATE(2025,8,15), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,15), DATE(2025,8,15), 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10675636150921322, 'Test: Positive case: Date, Date, Number. Valid 6-month T-bill with discount 10%.');
		// Case #3: Date, Date, Formula. Discount entered as formula expression.
		oParser = new parserFormula('TBILLEQ(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.051994301994301995, 'Test: Positive case: Date, Date, Formula. Discount entered as formula expression.');
		// Case #4: Date, Date, String. Numeric string converted to number.
		oParser = new parserFormula('TBILLEQ(DATE(2025,4,1), DATE(2025,10,1), "0.08")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,4,1), DATE(2025,10,1), "0.08") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.0845103033109516, 'Test: Positive case: Date, Date, String. Numeric string converted to number.');
		// Case #5: Date, Date, Reference link. Discount value taken from reference link.
		oParser = new parserFormula('TBILLEQ(DATE(2025,5,1), DATE(2025,11,1), A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,5,1), DATE(2025,11,1), A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Date, Date, Reference link. Discount value taken from reference link.');
		// Case #6: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,6), DATE(2025,7,6), 0.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,6), DATE(2025,7,6), 0.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.09515645092156, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #7: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,7), DATE(2025,7,7), 0.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,7), DATE(2025,7,7), 0.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.3568773234200744, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #8: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,8), DATE(2025,7,8), 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,8), DATE(2025,7,8), 0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6666666666666667, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #9: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,9), DATE(2025,7,9), 0.10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,9), DATE(2025,7,9), 0.10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10675636150921322, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #10: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,10), DATE(2025,7,10), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,10), DATE(2025,7,10), 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10675636150921322, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #11: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,11), DATE(2025,7,11), 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,11), DATE(2025,7,11), 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22544780728844965, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #12: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,12), DATE(2025,7,12), 0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,12), DATE(2025,7,12), 0.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.35819430814524045, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #13: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,13), DATE(2025,7,13), 0.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,13), DATE(2025,7,13), 0.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5076495132127955, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #14: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,14), DATE(2025,7,14), 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,14), DATE(2025,7,14), 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6771799628942486, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #15: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,15), DATE(2025,7,15), 0.6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,15), DATE(2025,7,15), 0.6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8711217183770883, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #16: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,16), DATE(2025,7,16), 0.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,16), DATE(2025,7,16), 0.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.09515645092156, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #17: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,17), DATE(2025,7,17), 0.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,17), DATE(2025,7,17), 0.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.3568773234200744, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #18: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,18), DATE(2025,7,18), 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,18), DATE(2025,7,18), 0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6666666666666667, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #19: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,19), DATE(2025,7,19), 0.10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,19), DATE(2025,7,19), 0.10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10675636150921322, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #20: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,20), DATE(2025,7,20), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,20), DATE(2025,7,20), 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.10675636150921322, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #21: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,21), DATE(2025,7,21), 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,21), DATE(2025,7,21), 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.22544780728844965, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #22: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,22), DATE(2025,7,22), 0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,22), DATE(2025,7,22), 0.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.35819430814524045, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');

		// Negative cases:
		// Case #1: Date, Date, Number. Settlement later than maturity returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,12,1), DATE(2025,6,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,12,1), DATE(2025,6,1), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Settlement later than maturity returns #NUM!.');
		// Case #2: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,1), DATE(2026,6,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,1), DATE(2026,6,1), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #3: Date, Date, Number. Discount = 0 returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,1), DATE(2025,6,1), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,1), DATE(2025,6,1), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Discount = 0 returns #NUM!.');
		// Case #4: Date, Date, Number. Negative discount returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,1), DATE(2025,6,1), -0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,1), DATE(2025,6,1), -0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Negative discount returns #NUM!.');
		// Case #5: String, Date, Number. Invalid settlement date string returns #VALUE!.
		oParser = new parserFormula('TBILLEQ("NotADate", DATE(2025,6,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ("NotADate", DATE(2025,6,1), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Date, Number. Invalid settlement date string returns #VALUE!.');
		// Case #6: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,6), DATE(2027,2,6), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,6), DATE(2027,2,6), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #7: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,7), DATE(2027,2,7), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,7), DATE(2027,2,7), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #8: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,8), DATE(2027,2,8), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,8), DATE(2027,2,8), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #9: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,9), DATE(2027,2,9), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,9), DATE(2027,2,9), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #10: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,10), DATE(2027,2,10), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,10), DATE(2027,2,10), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #11: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,11), DATE(2027,2,11), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,11), DATE(2027,2,11), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #12: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,12), DATE(2027,2,12), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,12), DATE(2027,2,12), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #13: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,13), DATE(2027,2,13), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,13), DATE(2027,2,13), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #14: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,14), DATE(2027,2,14), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,14), DATE(2027,2,14), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #15: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,15), DATE(2027,2,15), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,15), DATE(2027,2,15), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #16: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,16), DATE(2027,2,16), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,16), DATE(2027,2,16), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #17: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,17), DATE(2027,2,17), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,17), DATE(2027,2,17), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #18: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,18), DATE(2027,2,18), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,18), DATE(2027,2,18), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #19: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,19), DATE(2027,2,19), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,19), DATE(2027,2,19), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #20: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLEQ(DATE(2025,2,20), DATE(2027,2,20), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,2,20), DATE(2027,2,20), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');

		// Bounded cases:
		// Case #1: Date, Date, Number. Minimum valid period (1 day).
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,1), DATE(2025,1,2), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,1), DATE(2025,1,2), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.050708530147263134, 'Test: Bounded case: Date, Date, Number. Minimum valid period (1 day).');
		// Case #2: Date, Date, Number. Maximum valid period (exactly 1 year).
		oParser = new parserFormula('TBILLEQ(DATE(2025,1,1), DATE(2026,1,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(DATE(2025,1,1), DATE(2026,1,1), 0.05) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.0527071, 'Test: Bounded case: Date, Date, Number. Maximum valid period (exactly 1 year).');
		// Case #3: Number, Number, Number. Minimal positive discount.
		oParser = new parserFormula('TBILLEQ(38748,38808,0.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(38748,38808,0.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0138889063503089e-7, 'Test: Bounded case: Number, Number, Number. Minimal positive discount.');
		// Case #4: Number, Number, Number. Discount close to 1.
		oParser = new parserFormula('TBILLEQ(38748,38808,0.9999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLEQ(38748,38808,0.9999999) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.216666521, 'Test: Bounded case: Number, Number, Number. Discount close to 1.');

		// Need to fix:
		//  Case #5: Date, Date, Reference link. Discount value taken from reference link.
		// Case #2: Date, Date, Number. Maximum valid period (exactly 1 year).
		// Case #4: Number, Number, Number. Discount close to 1.


		testArrayFormula2(assert, "TBILLEQ", 3, 3, true);
	});

	QUnit.test("Test: \"TBILLPRICE\"", function (assert) {

		function tbillprice(settlement, maturity, discount) {

			maturity = cDate.prototype.getDateFromExcel(maturity.getExcelDate() + 1)

			var d1 = settlement
			var d2 = maturity

			var fFraction = AscCommonExcel.yearFrac(d1, d2, 0);

			if (fFraction - Math.floor(fFraction) == 0) {
				return "#NUM!";
			}

			return 100 * (1 - discount * fFraction);

		}

		oParser = new parserFormula("TBILLPRICE(DATE(2008,3,31),DATE(2008,6,1),0.09)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), tbillprice(new cDate(Date.UTC(2008, 2, 31)), new cDate(Date.UTC(2008, 5, 1)), 0.09));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("45658");
		ws.getRange2("A101").setValue("45838");
		ws.getRange2("A104").setValue("");
		// For area
		ws.getRange2("A102").setValue("0.05");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("");
		ws.getRange2("A106").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Date, Date, Number. Settlement and maturity are valid dates, discount positive.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,1), DATE(2025,6,30), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,1), DATE(2025,6,30), 0.05) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.051994302, 'Test: Positive case: Date, Date, Number. Settlement and maturity are valid dates, discount positive.');
		// Case #2: Date, Date, Number. Valid 6-month T-bill with discount 10%.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,15), DATE(2025,8,15), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,15), DATE(2025,8,15), 0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.106756362, 'Test: Positive case: Date, Date, Number. Valid 6-month T-bill with discount 10%.');
		// Case #3: Date, Date, Formula. Discount entered as formula expression.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,3,1), DATE(2025,9,1), 0.05+0.02)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,3,1), DATE(2025,9,1), 0.05+0.02) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.073583599, 'Test: Positive case: Date, Date, Formula. Discount entered as formula expression.');
		// Case #4: Date, Date, String. Numeric string converted to number.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,4,1), DATE(2025,10,1), "0.08")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,4,1), DATE(2025,10,1), "0.08") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.084539692, 'Test: Positive case: Date, Date, String. Numeric string converted to number.');
		// Case #5: Date, Date, Reference link. Discount value taken from reference link.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,5,1), DATE(2025,11,1), A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,5,1), DATE(2025,11,1), A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Date, Date, Reference link. Discount value taken from reference link.');
		// Case #6: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,6), DATE(2025,7,6), 0.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,6), DATE(2025,7,6), 0.7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.095156451, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #7: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,7), DATE(2025,7,7), 0.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,7), DATE(2025,7,7), 0.8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.356877323, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #8: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,8), DATE(2025,7,8), 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,8), DATE(2025,7,8), 0.9) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.666666667, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #9: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,9), DATE(2025,7,9), 0.10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,9), DATE(2025,7,9), 0.10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.106756362, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #10: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,10), DATE(2025,7,10), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,10), DATE(2025,7,10), 0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.106756362, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #11: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,11), DATE(2025,7,11), 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,11), DATE(2025,7,11), 0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.225447807, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #12: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,12), DATE(2025,7,12), 0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,12), DATE(2025,7,12), 0.3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.358194308, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #13: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,13), DATE(2025,7,13), 0.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,13), DATE(2025,7,13), 0.4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.507649513, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #14: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,14), DATE(2025,7,14), 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,14), DATE(2025,7,14), 0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.677179963, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #15: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,15), DATE(2025,7,15), 0.6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,15), DATE(2025,7,15), 0.6) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.871121718, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #16: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,16), DATE(2025,7,16), 0.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,16), DATE(2025,7,16), 0.7) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.095156451, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #17: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,17), DATE(2025,7,17), 0.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,17), DATE(2025,7,17), 0.8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.356877323, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #18: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,18), DATE(2025,7,18), 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,18), DATE(2025,7,18), 0.9) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.666666667, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #19: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,19), DATE(2025,7,19), 0.10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,19), DATE(2025,7,19), 0.10) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.106756362, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #20: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,20), DATE(2025,7,20), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,20), DATE(2025,7,20), 0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.106756362, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #21: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,21), DATE(2025,7,21), 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,21), DATE(2025,7,21), 0.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.225447807, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #22: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,22), DATE(2025,7,22), 0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,22), DATE(2025,7,22), 0.3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.358194308, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');

		// Negative cases:
		// Case #1: Date, Date, Number. Settlement later than maturity returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,12,1), DATE(2025,6,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,12,1), DATE(2025,6,1), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Settlement later than maturity returns #NUM!.');
		// Case #2: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,1), DATE(2026,6,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,1), DATE(2026,6,1), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #3: Date, Date, Number. Discount = 0 returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,1), DATE(2025,6,1), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,1), DATE(2025,6,1), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Discount = 0 returns #NUM!.');
		// Case #4: Date, Date, Number. Negative discount returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,1), DATE(2025,6,1), -0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,1), DATE(2025,6,1), -0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Negative discount returns #NUM!.');
		// Case #5: String, Date, Number. Invalid settlement date string returns #VALUE!.
		oParser = new parserFormula('TBILLPRICE("NotADate", DATE(2025,6,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE("NotADate", DATE(2025,6,1), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Date, Number. Invalid settlement date string returns #VALUE!.');
		// Case #6: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,6), DATE(2027,2,6), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,6), DATE(2027,2,6), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #7: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,7), DATE(2027,2,7), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,7), DATE(2027,2,7), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #8: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,8), DATE(2027,2,8), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,8), DATE(2027,2,8), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #9: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,9), DATE(2027,2,9), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,9), DATE(2027,2,9), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #10: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,10), DATE(2027,2,10), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,10), DATE(2027,2,10), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #11: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,11), DATE(2027,2,11), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,11), DATE(2027,2,11), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #12: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,12), DATE(2027,2,12), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,12), DATE(2027,2,12), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #13: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,13), DATE(2027,2,13), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,13), DATE(2027,2,13), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #14: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,14), DATE(2027,2,14), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,14), DATE(2027,2,14), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #15: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,15), DATE(2027,2,15), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,15), DATE(2027,2,15), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #16: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,16), DATE(2027,2,16), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,16), DATE(2027,2,16), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #17: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,17), DATE(2027,2,17), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,17), DATE(2027,2,17), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #18: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,18), DATE(2027,2,18), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,18), DATE(2027,2,18), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #19: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,19), DATE(2027,2,19), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,19), DATE(2027,2,19), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #20: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLPRICE(DATE(2025,2,20), DATE(2027,2,20), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,2,20), DATE(2027,2,20), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');

		// Bounded cases:
		// Case #1: Date, Date, Number. Minimum valid period (1 day).
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,1), DATE(2025,1,2), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,1), DATE(2025,1,2), 0.05) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.050701486, 'Test: Bounded case: Date, Date, Number. Minimum valid period (1 day).');
		// Case #2: Date, Date, Number. Maximum valid period (exactly 1 year).
		oParser = new parserFormula('TBILLPRICE(DATE(2025,1,1), DATE(2026,1,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(DATE(2025,1,1), DATE(2026,1,1), 0.05) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.0527071, 'Test: Bounded case: Date, Date, Number. Maximum valid period (exactly 1 year).');
		// Case #3: Number, Number, Number. Minimal positive discount.
		oParser = new parserFormula('TBILLPRICE(38748,38808,0.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(38748,38808,0.0000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.99999833333332, 'Test: Bounded case: Number, Number, Number. Minimal positive discount.');
		// Case #4: Number, Number, Number. Discount close to 1.
		oParser = new parserFormula('TBILLPRICE(38748,38808,0.9999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLPRICE(38748,38808,0.9999999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 83.33333499999999, 'Test: Bounded case: Number, Number, Number. Discount close to 1.');

		// Need to fix: different results from ms in positive and boundary cases
		// Case #1: Date, Date, Number. Settlement and maturity are valid dates, discount positive.
		// Case #2: Date, Date, Number. Valid 6-month T-bill with discount 10%.
		// Case #3: Date, Date, Formula. Discount entered as formula expression.
		// Case #4: Date, Date, String. Numeric string converted to number.
		// Case #5: Date, Date, Reference link. Discount value taken from reference link.


		testArrayFormula2(assert, "TBILLPRICE", 3, 3, true);
	});

	QUnit.test("Test: \"TBILLYIELD\"", function (assert) {
		let array;

		function tbillyield(settlement, maturity, pr) {

			var d1 = settlement;
			var d2 = maturity;
			var date1 = d1.getDate(), month1 = d1.getMonth(), year1 = d1.getFullYear(), date2 = d2.getDate(), month2 = d2.getMonth(), year2 = d2.getFullYear();

			var nDiff = GetDiffDate360(date1, month1, year1, date2, month2, year2, true);
			nDiff++;
			if (settlement >= maturity || pr <= 0 || nDiff > 360) {
				return "#NUM!";
			}

			return ((100 - pr) / pr) * (360 / nDiff);

		}

		oParser = new parserFormula("TBILLYIELD(DATE(2008,3,31),DATE(2008,6,1),98.45)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), tbillyield(new cDate(2008, 2, 31), new cDate(2008, 5, 1), 98.45));

		// errs
		oParser = new parserFormula('TBILLYIELD(#N/A,2,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(#N/A,2,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", 'Result of TBILLYIELD(#N/A,2,2)');

		oParser = new parserFormula('TBILLYIELD(1,#DIV/0!,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,#DIV/0!,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Result of TBILLYIELD(1,#DIV/0!,2)');

		oParser = new parserFormula('TBILLYIELD(1,2,#NUM!)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,2,#NUM!)');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Result of TBILLYIELD(1,2,#NUM!)');

		oParser = new parserFormula('TBILLYIELD(#N/A,2,#NUM!)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(#N/A,2,#NUM!)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", 'Result of TBILLYIELD(#N/A,2,#NUM!)');

		// string
		oParser = new parserFormula('TBILLYIELD("1","2","2")', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD("1","2","2")');
		assert.strictEqual(oParser.calculate().getValue(), 17640, 'Result of TBILLYIELD("1","2","2")');

		oParser = new parserFormula('TBILLYIELD("1s","2","2")', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD("1s","2","2")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of TBILLYIELD("1s","2","2")');

		oParser = new parserFormula('TBILLYIELD("1","2s","2")', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD("1","2s","2")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of TBILLYIELD("1","2s","2")');

		oParser = new parserFormula('TBILLYIELD("1","2","2s")', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD("1","2","2s")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of TBILLYIELD("1","2","2s")');

		// bool
		oParser = new parserFormula('TBILLYIELD(FALSE,2,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(FALSE,2,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of TBILLYIELD(FALSE,2,2)');

		oParser = new parserFormula('TBILLYIELD(TRUE,2,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(TRUE,2,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of TBILLYIELD(TRUE,2,2)');

		oParser = new parserFormula('TBILLYIELD(1,TRUE,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,TRUE,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of TBILLYIELD(1,TRUE,2)');

		oParser = new parserFormula('TBILLYIELD(1,2,TRUE)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,2,TRUE)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of TBILLYIELD(1,2,TRUE)');

		// array
		oParser = new parserFormula('TBILLYIELD(1,{1,2,3;2,3,4},{1,2,3;2,3,4})', "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:H109").bbox);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,{1,2,3;2,3,4},{1,2,3;2,3,4})');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), "#NUM!", "Result of TBILLYIELD(1,{1,2,3;2,3,4},{1,2,3;2,3,4}) [0,0]");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 17640, "Result of TBILLYIELD(1,{1,2,3;2,3,4},{1,2,3;2,3,4}) [1,0]");
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), 17640, "Result of TBILLYIELD(1,{1,2,3;2,3,4},{1,2,3;2,3,4}) [0,1]");
		assert.strictEqual(array.getElementRowCol(1, 1).getValue(), 5820, "Result of TBILLYIELD(1,{1,2,3;2,3,4},{1,2,3;2,3,4}) [1,1]");
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), 5820, "Result of TBILLYIELD(1,{1,2,3;2,3,4},{1,2,3;2,3,4}) [0,1]");
		assert.strictEqual(array.getElementRowCol(1, 2).getValue(), 2880, "Result of TBILLYIELD(1,{1,2,3;2,3,4},{1,2,3;2,3,4}) [1,1]");

		oParser = new parserFormula('TBILLYIELD(,2,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(,2,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", 'Result of TBILLYIELD(,2,2)');

		oParser = new parserFormula('TBILLYIELD(1,,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,,2)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", 'Result of TBILLYIELD(1,,2)');

		oParser = new parserFormula('TBILLYIELD(1,,)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,,)');
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", 'Result of TBILLYIELD(1,,)');

		oParser = new parserFormula('TBILLYIELD(1,2,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,2,2)');
		assert.strictEqual(oParser.calculate().getValue(), 17640, 'Result of TBILLYIELD(1,2,2)');

		oParser = new parserFormula('TBILLYIELD(1,3,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,3,2)');
		assert.strictEqual(oParser.calculate().getValue(), 8820, 'Result of TBILLYIELD(1,3,2)');

		oParser = new parserFormula('TBILLYIELD(1,4,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,4,2)');
		assert.strictEqual(oParser.calculate().getValue(), 5880, 'Result of TBILLYIELD(1,4,2)');

		oParser = new parserFormula('TBILLYIELD(1,5,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,5,2)');
		assert.strictEqual(oParser.calculate().getValue(), 4410, 'Result of TBILLYIELD(1,5,2)');

		oParser = new parserFormula('TBILLYIELD(1,32,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,32,2)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), "569.0323", 'Result of TBILLYIELD(1,32,2)');

		oParser = new parserFormula('TBILLYIELD(1,33,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,33,2)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), "551.25", 'Result of TBILLYIELD(1,33,2)');

		oParser = new parserFormula('TBILLYIELD(1,59,2)', "A2", ws);
		assert.ok(oParser.parse(), 'TBILLYIELD(1,59,2)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4), "304.1379", 'Result of TBILLYIELD(1,59,2)');

		// oParser = new parserFormula('TBILLYIELD(1,60,2)', "A2", ws);
		// assert.ok(oParser.parse(), 'TBILLYIELD(1,60,2)');
		// assert.strictEqual(oParser.calculate().getValue().toFixed(4), "298.9831", 'Result of TBILLYIELD(1,60,2)');

		// oParser = new parserFormula('TBILLYIELD(1,61,2)', "A2", ws);
		// assert.ok(oParser.parse(), 'TBILLYIELD(1,61,2)');
		// assert.strictEqual(oParser.calculate().getValue().toFixed(4), 294, 'Result of TBILLYIELD(1,61,2)');

		// days between - 101
		// oParser = new parserFormula('TBILLYIELD(500,601,2)', "A2", ws);
		// assert.ok(oParser.parse(), 'TBILLYIELD(500,601,2)');
		// assert.strictEqual(oParser.calculate().getValue().toFixed(4), 174.6535, 'Result of TBILLYIELD(500,601,2)');

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("45658");
		ws.getRange2("A101").setValue("45838");
		ws.getRange2("A104").setValue("");
		// For area
		ws.getRange2("A102").setValue("0.05");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("");
		ws.getRange2("A106").setValue("");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Date, Date, Number. Settlement and maturity are valid dates, discount positive.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,1), DATE(2025,6,30), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,1), DATE(2025,6,30), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3998, 'Test: Positive case: Date, Date, Number. Settlement and maturity are valid dates, discount positive.');
		// Case #2: Date, Date, Number. Valid 6-month T-bill with discount 10%.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,15), DATE(2025,8,15), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,15), DATE(2025,8,15), 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1986.9613259668508, 'Test: Positive case: Date, Date, Number. Valid 6-month T-bill with discount 10%.');
		// Case #3: Date, Date, Formula. Discount entered as formula expression.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,3,1), DATE(2025,9,1), 0.05+0.02)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,3,1), DATE(2025,9,1), 0.05+0.02) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2793.074534, 'Test: Positive case: Date, Date, Formula. Discount entered as formula expression.');
		// Case #4: Date, Date, String. Numeric string converted to number.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,4,1), DATE(2025,10,1), "0.08")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,4,1), DATE(2025,10,1), "0.08") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2457.04918, 'Test: Positive case: Date, Date, String. Numeric string converted to number.');
		// Case #5: Date, Date, Reference link. Discount value taken from reference link.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,5,1), DATE(2025,11,1), A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,5,1), DATE(2025,11,1), A100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1.952236572, 'Test: Positive case: Date, Date, Reference link. Discount value taken from reference link.');
		// Case #6: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,6), DATE(2025,7,6), 0.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,6), DATE(2025,7,6), 0.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 282.14680347277033, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #7: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,7), DATE(2025,7,7), 0.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,7), DATE(2025,7,7), 0.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 246.62983425414365, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #8: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,8), DATE(2025,7,8), 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,8), DATE(2025,7,8), 0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 219.00552486187843, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #9: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,9), DATE(2025,7,9), 0.10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,9), DATE(2025,7,9), 0.10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1986.9613259668508, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #10: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,10), DATE(2025,7,10), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,10), DATE(2025,7,10), 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1986.9613259668508, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #11: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,11), DATE(2025,7,11), 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,11), DATE(2025,7,11), 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 992.4861878453038, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #12: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,12), DATE(2025,7,12), 0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,12), DATE(2025,7,12), 0.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 660.9944751381216, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #13: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,13), DATE(2025,7,13), 0.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,13), DATE(2025,7,13), 0.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 495.2486187845303, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #14: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,14), DATE(2025,7,14), 0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,14), DATE(2025,7,14), 0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 395.8011049723757, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #15: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,15), DATE(2025,7,15), 0.6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,15), DATE(2025,7,15), 0.6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 329.50276243093924, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #16: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,16), DATE(2025,7,16), 0.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,16), DATE(2025,7,16), 0.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 282.14680347277033, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #17: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,17), DATE(2025,7,17), 0.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,17), DATE(2025,7,17), 0.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 246.62983425414365, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #18: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,18), DATE(2025,7,18), 0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,18), DATE(2025,7,18), 0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 219.00552486187843, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #19: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,19), DATE(2025,7,19), 0.10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,19), DATE(2025,7,19), 0.10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1986.9613259668508, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #20: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,20), DATE(2025,7,20), 0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,20), DATE(2025,7,20), 0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1986.9613259668508, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #21: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,21), DATE(2025,7,21), 0.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,21), DATE(2025,7,21), 0.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 992.4861878453038, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');
		// Case #22: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,22), DATE(2025,7,22), 0.3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,22), DATE(2025,7,22), 0.3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 660.9944751381216, 'Test: Positive case: Date, Date, Number. Standard case with valid settlement, maturity within 1 year, and positive discount.');

		// Negative cases:
		// Case #1: Date, Date, Number. Settlement later than maturity returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,12,1), DATE(2025,6,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,12,1), DATE(2025,6,1), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Settlement later than maturity returns #NUM!.');
		// Case #2: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,1), DATE(2026,6,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,1), DATE(2026,6,1), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #3: Date, Date, Number. Discount = 0 returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,1), DATE(2025,6,1), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,1), DATE(2025,6,1), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Discount = 0 returns #NUM!.');
		// Case #4: Date, Date, Number. Negative discount returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,1), DATE(2025,6,1), -0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,1), DATE(2025,6,1), -0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Negative discount returns #NUM!.');
		// Case #5: String, Date, Number. Invalid settlement date string returns #VALUE!.
		oParser = new parserFormula('TBILLYIELD("NotADate", DATE(2025,6,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD("NotADate", DATE(2025,6,1), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Date, Number. Invalid settlement date string returns #VALUE!.');
		// Case #6: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,6), DATE(2027,2,6), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,6), DATE(2027,2,6), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #7: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,7), DATE(2027,2,7), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,7), DATE(2027,2,7), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #8: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,8), DATE(2027,2,8), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,8), DATE(2027,2,8), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #9: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,9), DATE(2027,2,9), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,9), DATE(2027,2,9), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #10: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,10), DATE(2027,2,10), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,10), DATE(2027,2,10), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #11: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,11), DATE(2027,2,11), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,11), DATE(2027,2,11), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #12: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,12), DATE(2027,2,12), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,12), DATE(2027,2,12), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #13: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,13), DATE(2027,2,13), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,13), DATE(2027,2,13), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #14: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,14), DATE(2027,2,14), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,14), DATE(2027,2,14), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #15: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,15), DATE(2027,2,15), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,15), DATE(2027,2,15), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #16: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,16), DATE(2027,2,16), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,16), DATE(2027,2,16), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #17: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,17), DATE(2027,2,17), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,17), DATE(2027,2,17), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #18: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,18), DATE(2027,2,18), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,18), DATE(2027,2,18), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #19: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,19), DATE(2027,2,19), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,19), DATE(2027,2,19), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');
		// Case #20: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.
		oParser = new parserFormula('TBILLYIELD(DATE(2025,2,20), DATE(2027,2,20), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,2,20), DATE(2027,2,20), 0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date, Date, Number. Maturity more than 1 year after settlement returns #NUM!.');

		// Bounded cases:
		// Case #1: Date, Date, Number. Minimum valid period (1 day).
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,1), DATE(2025,1,2), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,1), DATE(2025,1,2), 0.05) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 719640, 'Test: Bounded case: Date, Date, Number. Minimum valid period (1 day).');
		// Case #2: Date, Date, Number. Maximum valid period (exactly 1 year).
		oParser = new parserFormula('TBILLYIELD(DATE(2025,1,1), DATE(2026,1,1), 0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(DATE(2025,1,1), DATE(2026,1,1), 0.05) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1971.616438, 'Test: Bounded case: Date, Date, Number. Maximum valid period (exactly 1 year).');
		// Case #3: Number, Number, Number. Minimal positive discount.
		oParser = new parserFormula('TBILLYIELD(38748,38808,0.0000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(38748,38808,0.0000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5999999994, 'Test: Bounded case: Number, Number, Number. Minimal positive discount.');
		// Case #4: Number, Number, Number. Discount close to 1.
		oParser = new parserFormula('TBILLYIELD(38748,38808,0.9999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: TBILLYIELD(38748,38808,0.9999999) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 594.00006, 'Test: Bounded case: Number, Number, Number. Discount close to 1.');

		// Need to fix: boundary cases, different results from MS
		// Case #3: Date, Date, Formula. Discount entered as formula expression.
		// Case #4: Date, Date, String. Numeric string converted to number.
		// Case #5: Date, Date, Reference link. Discount value taken from reference link.
		// Case #1: Date, Date, Number. Minimum valid period (1 day).
		// Case #2: Date, Date, Number. Maximum valid period (exactly 1 year).
		// Case #3: Number, Number, Number. Minimal positive discount.
		// Case #4: Number, Number, Number. Discount close to 1.


	});

	QUnit.test("Test: \"VDB\"", function (assert) {
		function _getVDB(cost, salvage, life, life1, startperiod, factor) {
			var end;
			var fVdb = 0, nLoopEnd = end = Math.ceil(startperiod), fTerm, fLia = 0, fRestwert = cost - salvage, bNowLia = false, fGda;

			for (var i = 1; i <= nLoopEnd; i++) {
				if (!bNowLia) {

					fGda = _getDDB(cost, salvage, life, i, factor);
					fLia = fRestwert / (life1 - (i - 1));

					if (fLia > fGda) {
						fTerm = fLia;
						bNowLia = true;
					} else {
						fTerm = fGda;
						fRestwert -= fGda;
					}

				} else {
					fTerm = fLia;
				}

				if (i == nLoopEnd) {
					fTerm *= (startperiod + 1.0 - end);
				}

				fVdb += fTerm;
			}
			return fVdb;
		}

		function vdb(cost, salvage, life, startPeriod, endPeriod, factor, flag) {

			if (factor === undefined || factor === null) {
				factor = 2;
			}
			if (flag === undefined || flag === null) {
				flag = false;
			}

			var start = Math.floor(startPeriod), end = Math.ceil(endPeriod), loopStart = start, loopEnd = end;

			var res = 0;
			if (flag) {
				for (var i = loopStart + 1; i <= loopEnd; i++) {
					var ddb = _getDDB(cost, salvage, life, i, factor);

					if (i == loopStart + 1) {
						ddb *= (Math.min(endPeriod, start + 1) - startPeriod);
					} else if (i == loopEnd) {
						ddb *= (endPeriod + 1 - end);
					}

					res += ddb;
				}
			} else {

				var life1 = life;

				if (!Math.approxEqual(startPeriod, Math.floor(startPeriod))) {
					if (factor > 1) {
						if (startPeriod > life / 2 || Math.approxEqual(startPeriod, life / 2)) {
							var fPart = startPeriod - life / 2;
							startPeriod = life / 2;
							endPeriod -= fPart;
							life1 += 1;
						}
					}
				}

				cost -= _getVDB(cost, salvage, life, life1, startPeriod, factor);
				res = _getVDB(cost, salvage, life, life - startPeriod, endPeriod - startPeriod, factor);
			}

			return res;
		}

		oParser = new parserFormula("VDB(2400,300,10*365,0,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), vdb(2400, 300, 10 * 365, 0, 1));

		oParser = new parserFormula("VDB(2400,300,10*12,0,1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), vdb(2400, 300, 10 * 12, 0, 1));

		oParser = new parserFormula("VDB(2400,300,10*12,6,18)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), vdb(2400, 300, 10 * 12, 6, 18));

		oParser = new parserFormula("VDB(0,0,0,0,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!");

		oParser = new parserFormula("VDB(100,0,5,3,4,2,{1,2,3})", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 8.64);

		oParser = new parserFormula('VDB(100,0,5,3,4,2,1)', "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 8.64);

		oParser = new parserFormula('VDB(100,0,5,3,4,2,FALSE)', "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 10.8);

		oParser = new parserFormula('VDB(100,0,5,3,4,2,"test")', "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// bug case
		oParser = new parserFormula("VDB(100,300,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,300,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), -200, "Result of VDB(100,300,8,0,1)");

		oParser = new parserFormula("VDB(0,10000,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(0,10000,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), -10000, "Result of VDB(0,10000,8,0,1)");

		oParser = new parserFormula("VDB(100,200,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), -100, "Result of VDB(100,200,8,0,1)");

		oParser = new parserFormula("VDB(100,200,8,0,0.75)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,0.75)");
		assert.strictEqual(oParser.calculate().getValue(), -75, "Result of VDB(100,200,8,0,0.75)");	

		oParser = new parserFormula("VDB(100,200,8,0.70,0.75)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0.70,0.75)");
		assert.strictEqual(oParser.calculate().getValue().toFixed() - 0, -5, "Result of VDB(100,200,8,0.70,0.75)");

		oParser = new parserFormula("VDB(100,200,8,1,0.75)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0.70,0.75)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of VDB(100,200,8,0.70,0.75)");

		oParser = new parserFormula("VDB(100,200,8,0.70,8)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0.70,8)");
		assert.strictEqual(oParser.calculate().getValue(), -100, "Result of VDB(100,200,8,0.70,8)");

		oParser = new parserFormula("VDB(100,200,8,1,2)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,1,2)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(100,200,8,1,2)");

		oParser = new parserFormula("VDB(100,200,8,1,8)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,1,8)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(100,200,8,1,8)");

		oParser = new parserFormula("VDB(100,200,8,0,8,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,8,1)");
		assert.strictEqual(oParser.calculate().getValue(), -100, "Result of VDB(100,200,8,0,8,1)");

		oParser = new parserFormula("VDB(100,200,8,0,8,-1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,8,-1)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of VDB(100,200,8,0,8,-1)");

		oParser = new parserFormula("VDB(100,200,8,0,8,10000000)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,8,10000000)");
		assert.strictEqual(oParser.calculate().getValue(), -100, "Result of VDB(100,200,8,0,8,10000000)");

		oParser = new parserFormula("VDB(100,200,8,0,8,0.75)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,8,0.75)");
		assert.strictEqual(oParser.calculate().getValue(), -100, "Result of VDB(100,200,8,0,8,0.75)");

		oParser = new parserFormula("VDB(100,200,8,0,1,5,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,1,5,TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(100,200,8,0,1,5,TRUE)");

		oParser = new parserFormula("VDB(100,200,8,0,1,1,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,1,1,FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), -100, "Result of VDB(100,200,8,0,1,1,FALSE)");

		oParser = new parserFormula("VDB(100,200,8,0,1,1,0)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,1,1,0)");
		assert.strictEqual(oParser.calculate().getValue(), -100, "Result of VDB(100,200,8,0,1,1,0)");

		oParser = new parserFormula("VDB(100,200,8,0,1,1,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,1,1,1)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(100,200,8,0,1,1,1)");

		oParser = new parserFormula("VDB(100,200,8,0,1,1,123)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100,200,8,0,1,1,123)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(100,200,8,0,1,1,123)");

		// normal case
		oParser = new parserFormula("VDB(,11000,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(,11000,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), -11000, "Result of VDB(,11000,8,0,1)");

		oParser = new parserFormula("VDB({1},11000,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB({1},11000,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), -10999, "Result of VDB({1},11000,8,0,1)");

		oParser = new parserFormula("VDB({100000;15000},11000,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB({100000;15000},11000,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB({100000;15000},11000,8,0,1)");

		oParser = new parserFormula("VDB(100000,,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,,8,0,1)");

		oParser = new parserFormula("VDB(100000,{1},8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,{1},8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,{1},8,0,1)");

		oParser = new parserFormula("VDB(100000,{1},8,1,5)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,{1},8,1,5)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 51269.53, "Result of VDB(100000,{1},8,1,5)");

		oParser = new parserFormula("VDB(100000,{11000;25000;30000},8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,{11000;25000;30000},8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,{11000;25000;30000},8,0,1)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1)");

		oParser = new parserFormula("VDB(100000,11000,8,0,2)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,2)");
		assert.strictEqual(oParser.calculate().getValue(), 43750, "VDB(100000,11000,8,0,2)");

		oParser = new parserFormula("VDB(100000,11000,8,0,3)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,3)");
		assert.strictEqual(oParser.calculate().getValue(), 57812.50, "VDB(100000,11000,8,0,3)");

		oParser = new parserFormula("VDB(100000,11000,8,0,4)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 68359.38, "VDB(100000,11000,8,0,4)");

		oParser = new parserFormula("VDB(100000,11000,8,0,5)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,5)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 76269.53, "VDB(100000,11000,8,0,5)");

		oParser = new parserFormula("VDB(100000,11000,8,0,6)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,6)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 82202.15, "VDB(100000,11000,8,0,6)");

		oParser = new parserFormula("VDB(100000,11000,8,0,7)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,7)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 86651.61, "VDB(100000,11000,8,0,7)");

		oParser = new parserFormula("VDB(100000,11000,8,0,8)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,8)");
		assert.strictEqual(oParser.calculate().getValue(), 89000, "VDB(100000,11000,8,0,8)");

		oParser = new parserFormula("VDB(100000,11000,8,0,9)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,9)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "VDB(100000,11000,8,0,9)");

		oParser = new parserFormula("VDB(100000,11000,8,1,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,1,1)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "VDB(100000,11000,8,1,1)");

		oParser = new parserFormula("VDB(100000,11000,8,1,2)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,1,2)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 18750, "VDB(100000,11000,8,1,2)");

		oParser = new parserFormula("VDB(100000,11000,8,1,3)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,1,3)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 32812.5, "VDB(100000,11000,8,1,3)");

		oParser = new parserFormula("VDB(100000,11000,8,1,4)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,1,4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 43359.38, "VDB(100000,11000,8,1,4)");

		oParser = new parserFormula("VDB(100000,11000,8,2,5)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,2,5)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 32519.53, "VDB(100000,11000,8,2,5)");

		oParser = new parserFormula("VDB(100000,11000,8,3,4)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,3,4)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 10546.88, "VDB(100000,11000,8,3,4)");

		oParser = new parserFormula("VDB(100000,11000,8,7,8)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,7,8)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 2348.39, "VDB(100000,11000,8,7,8)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,,)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,,)");
		assert.strictEqual(oParser.calculate().getValue(), 11125, "Result of VDB(100000,11000,8,0,1,,)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,)");
		assert.strictEqual(oParser.calculate().getValue(), 11125, "Result of VDB(100000,11000,8,0,1,)");

		oParser = new parserFormula("VDB(TRUE,11000,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(TRUE,11000,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), -10999, "Result of VDB(TRUE,11000,8,0,1)");	

		oParser = new parserFormula("VDB(FALSE,11000,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(FALSE,11000,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), -11000, "Result of VDB(FALSE,11000,8,0,1)");	

		oParser = new parserFormula("VDB(100000,TRUE,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,TRUE,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,TRUE,8,0,1)");

		oParser = new parserFormula("VDB(100000,FALSE,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,FALSE,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,FALSE,8,0,1)");

		oParser = new parserFormula("VDB(TRUE,TRUE,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(TRUE,TRUE,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(TRUE,TRUE,8,0,1)");

		oParser = new parserFormula("VDB(TRUE,FALSE,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(TRUE,FALSE,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 0.25, "Result of VDB(TRUE,FALSE,8,0,1)");

		oParser = new parserFormula("VDB(FALSE,TRUE,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(FALSE,TRUE,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), -1, "Result of VDB(FALSE,TRUE,8,0,1)");

		oParser = new parserFormula("VDB(FALSE,FALSE,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(FALSE,FALSE,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(FALSE,FALSE,8,0,1)");

		// arg[2]
		oParser = new parserFormula("VDB(100000,11000,TRUE,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,TRUE,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 89000, "Result of VDB(100000,11000,TRUE,0,1)");

		oParser = new parserFormula("VDB(100000,11000,FALSE,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,FALSE,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of VDB(100000,11000,FALSE,0,1)");

		oParser = new parserFormula("VDB(100000,11000,-1,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,-1,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of VDB(100000,11000,-1,0,1)");

		oParser = new parserFormula("VDB(100000,11000,0.75,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,0.75,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of VDB(100000,11000,0.75,0,1)");

		oParser = new parserFormula("VDB(100000,11000,9999999999999999999999999999,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,9999999999999999999999999999,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 8.9e-24, "Result of VDB(100000,11000,9999999999999999999999999999,0,1)"); // 2E-23

		oParser = new parserFormula("VDB(100000,11000,9999999999999999999999999999,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,9999999999999999999999999999,0,1)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0, "Result of VDB(100000,11000,9999999999999999999999999999,0,1)");

		oParser = new parserFormula("VDB(100000,11000,string,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,string,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", "Result of VDB(100000,11000,string,0,1)");	

		oParser = new parserFormula("VDB(100000,11000,{2},0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,{2},0,1)");
		assert.strictEqual(oParser.calculate().getValue(), 89000, "Result of VDB(100000,11000,{2},0,1)");	

		oParser = new parserFormula("VDB(100000,11000,{9;5;8},0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,{9;5;8},0,1)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 22222.22, "Result of VDB(100000,11000,{9;5;8},0,1)");

		// arg[3]
		oParser = new parserFormula("VDB(100000,11000,8,TRUE,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,TRUE,1)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(100000,11000,8,TRUE,1)");

		oParser = new parserFormula("VDB(100000,11000,8,FALSE,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,FALSE,1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,FALSE,1)");	

		oParser = new parserFormula("VDB(100000,11000,8,string,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,string,1)");
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", "Result of VDB(100000,11000,8,string,1)");

		oParser = new parserFormula("VDB(100000,11000,8,{1},5)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,{1},5)");
		assert.strictEqual(oParser.calculate().getValue(), 51269.53125, "Result of VDB(100000,11000,8,{1},5)");	

		oParser = new parserFormula("VDB(100000,11000,8,{1;2;3;4;5},5)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,{1;2;3;4;5},5)");
		assert.strictEqual(oParser.calculate().getValue(), 51269.53125, "Result of VDB(100000,11000,8,{1;2;3;4;5},5)");

		oParser = new parserFormula("VDB(100000,11000,8,{5;4;3;2;1},5)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,{5;4;3;2;1},5)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(100000,11000,8,{5;4;3;2;1},5)");

		// arg[4]
		oParser = new parserFormula("VDB(100000,11000,8,0,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,TRUE)");

		oParser = new parserFormula("VDB(100000,11000,8,0,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(100000,11000,8,0,FALSE)");	

		oParser = new parserFormula("VDB(100000,11000,8,0,string)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,string,1)");
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", "Result of VDB(100000,11000,8,string,1)");

		oParser = new parserFormula("VDB(100000,11000,8,0,{1})", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,{1})");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,{1})");	

		oParser = new parserFormula("VDB(100000,11000,8,0,{1;2;3;4;5})", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,{1;2;3;4;5})");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,{1;2;3;4;5})");

		oParser = new parserFormula("VDB(100000,11000,8,0,{5;4;3;2;1})", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,{5;4;3;2;1})");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 76269.53, "Result of VDB(100000,11000,8,0,{5;4;3;2;1})");	

		// arg[5]
		oParser = new parserFormula("VDB(100000,11000,8,0,1,2)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,3)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,3)");
		assert.strictEqual(oParser.calculate().getValue(), 37500, "Result of VDB(100000,11000,8,0,1,3)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,10)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,10)");
		assert.strictEqual(oParser.calculate().getValue(), 89000, "Result of VDB(100000,11000,8,0,1,10)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,10000)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,10000)");
		assert.strictEqual(oParser.calculate().getValue(), 89000, "Result of VDB(100000,11000,8,0,1,10000)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,-1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,-1)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of VDB(100000,11000,8,0,1,-1)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,0.75)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,0.75)");
		assert.strictEqual(oParser.calculate().getValue(), 11125, "Result of VDB(100000,11000,8,0,1,0.75)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,0.00000075)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,0.00000075)");
		assert.strictEqual(oParser.calculate().getValue(), 11125, "Result of VDB(100000,11000,8,0,1,0.00000075)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,1.25)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,1.25)");
		assert.strictEqual(oParser.calculate().getValue(), 15625, "Result of VDB(100000,11000,8,0,1,1.25)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), 12500, "Result of VDB(100000,11000,8,0,1,TRUE)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,FALSE)");
		assert.strictEqual(oParser.calculate().getValue(), 11125, "Result of VDB(100000,11000,8,0,1,FALSE)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,format)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,format)");
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", "Result of VDB(100000,11000,8,0,1,format)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,{1})", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,{1})");
		assert.strictEqual(oParser.calculate().getValue(), 12500, "Result of VDB(100000,11000,8,0,1,{1})");	

		oParser = new parserFormula("VDB(100000,11000,8,0,1,{5;2;3;4;5})", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,{5;2;3;4;5})");
		assert.strictEqual(oParser.calculate().getValue(), 62500, "Result of VDB(100000,11000,8,0,1,{5;2;3;4;5})");	

		// arg[6]
		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,0)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,0)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,0)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,1)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,2)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,2)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,2)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,10)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,10)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,10)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,9999999999999999999999999)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,9999999999999999999999999)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,9999999999999999999999999)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,-1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,-1)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,-1)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,0.75)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,0.75)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,0.75)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,1.25)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,1.25)");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,1.25)");

		oParser = new parserFormula("VDB(100000,11000,8,0,5,2,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,5,2,TRUE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 76269.53, "Result of VDB(100000,11000,8,0,5,2,TRUE)");

		oParser = new parserFormula("VDB(100000,11000,8,0,5,2,FALSE)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,5,2,FALSE)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 76269.53, "Result of VDB(100000,11000,8,0,5,2,FALSE)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,format)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,format)");
		assert.strictEqual(oParser.calculate().getValue(), "#NAME?", "Result of VDB(100000,11000,8,0,1,2,format)");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,{1})", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,{1})");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,{1})");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,{-1})", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,{-1})");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,{-1})");

		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,{5;2;3;4;5})", "A2", ws);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,{5;2;3;4;5})");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB(100000,11000,8,0,1,2,{5;2;3;4;5})");
		
		oParser = new parserFormula("VDB(TRUE,TRUE,TRUE,TRUE,TRUE)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(TRUE,TRUE,TRUE,TRUE,TRUE)");
		assert.strictEqual(oParser.calculate().getValue(), 0, "Result of VDB(TRUE,TRUE,TRUE,TRUE,TRUE)");

		oParser = new parserFormula("VDB({100000},{11000},{8},{0},{1},{2},{-1})", "A2", ws);
		assert.ok(oParser.parse(), "VDB({100000},{11000},{8},{0},{1},{2},{-1})");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB({100000},{11000},{8},{0},{1},{2},{-1})");

		oParser = new parserFormula("VDB({100000,25000},{11000,25000},{8,5,8},{0,1,2},{1,0,-1},{2,1,3},{-1,0,1})", "A2", ws);
		assert.ok(oParser.parse(), "VDB({100000,25000},{11000,25000},{8,5,8},{0,1,2},{1,0,-1},{2,1,3},{-1,0,1})");
		assert.strictEqual(oParser.calculate().getValue(), 25000, "Result of VDB({100000,25000},{11000,25000},{8,5,8},{0,1,2},{1,0,-1},{2,1,3},{-1,0,1})");

		ws.getRange2("F2").setValue("100000");
		ws.getRange2("F3").setValue("11000");
		ws.getRange2("F4").setValue("");

		ws.getRange2("F5").setValue("11000");
		ws.getRange2("F6").setValue("25000");
		ws.getRange2("F7").setValue("");

		ws.getRange2("F8").setValue("8");
		ws.getRange2("F9").setValue("0");
		ws.getRange2("F10").setValue("1");
		ws.getRange2("F11").setValue("");
		ws.getRange2("F12").setValue("12");

		ws.getRange2("F13").setValue("test2");
		ws.getRange2("F14").setValue("TRUE");
		ws.getRange2("F15").setValue("#N/A");

	
		oParser = new parserFormula("VDB(F2:F4,11000,8,0,1)", "A2", ws);
		assert.ok(oParser.parse(), "VDB(F2:F4,11000,8,0,1)");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", "Result of VDB(F2:F4,11000,8,0,1)");

		// cellsRange (arg0)
		oParser = new parserFormula("VDB(F2:F4,11000,8,0,1)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("F2:F4").bbox);
		assert.ok(oParser.parse(), "VDB(F2:F4,11000,8,0,1)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 25000, "Result in [0,0] VDB(F2:F4,11000,8,0,1)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 0, "Result in [1,0] VDB(F2:F4,11000,8,0,1)");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), -11000, "Result in [2,0] VDB(F2:F4,11000,8,0,1)");	
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), "", "Result in [3,0] VDB(F2:F4,11000,8,0,1)");
		assert.strictEqual(array.getElementRowCol(3, 3).getValue(), "#N/A", "Result in [3,3] VDB(F2:F4,11000,8,0,1)");

		// cellsRange (arg1)
		oParser = new parserFormula("VDB(100000,F5:F7,8,1,5)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("F5:F7").bbox);
		assert.ok(oParser.parse(), "VDB(100000,F5:F7,8,0,1)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue().toFixed(2) - 0, 51269.53, "Result in [0,0] VDB(100000,F5:F7,8,0,1)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 50000, "Result in [1,0] VDB(100000,F5:F7,8,0,1)");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue().toFixed(2) - 0, 51269.53, "Result in [2,0] VDB(100000,F5:F7,8,0,1)");	
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), "", "Result in [3,0] VDB(100000,F5:F7,8,0,1)");
		assert.strictEqual(array.getElementRowCol(3, 3).getValue(), "#N/A", "Result in [3,3] VDB(100000,F5:F7,8,0,1)");

		// cellsRange (arg2)
		oParser = new parserFormula("VDB(100000,11000,F8:F15,0,1)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("F8:F15").bbox);
		assert.ok(oParser.parse(), "VDB(100000,11000,F8:F15,0,1)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 25000, "Result in [0,0] VDB(100000,11000,F8:F15,0,1)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#NUM!", "Result in [1,0] VDB(100000,11000,F8:F15,0,1)");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 89000, "Result in [2,0] VDB(100000,11000,F8:F15,0,1)");	
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), "#NUM!", "Result in [3,0] VDB(100000,11000,F8:F15,0,1)");
		assert.strictEqual(array.getElementRowCol(4, 0).getValue().toFixed(3) - 0, 16666.667, "Result in [4,0] VDB(100000,11000,F8:F15,0,1)");
		assert.strictEqual(array.getElementRowCol(5, 0).getValue(), "#VALUE!", "Result in [5,0] VDB(100000,11000,F8:F15,0,1)");
		assert.strictEqual(array.getElementRowCol(6, 0).getValue(), 89000, "Result in [6,0] VDB(100000,11000,F8:F15,0,1)");
		assert.strictEqual(array.getElementRowCol(3, 3).getValue(), "#N/A", "Result in [3,3] VDB(100000,11000,F8:F15,0,1)");

		// cellsRange (arg3)
		oParser = new parserFormula("VDB(100000,11000,8,F9:F15,1)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("F9:F15").bbox);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,F9:F15,1)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 25000, "Result in [0,0] VDB(100000,11000,8,F9:F15,1)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 0, "Result in [1,0] VDB(100000,11000,8,F9:F15,1)");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 25000, "Result in [2,0] VDB(100000,11000,8,F9:F15,1)");	
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), "#NUM!", "Result in [3,0] VDB(100000,11000,8,F9:F15,1)");
		assert.strictEqual(array.getElementRowCol(4, 0).getValue(), "#VALUE!", "Result in [4,0] VDB(100000,11000,8,F9:F15,1)");
		assert.strictEqual(array.getElementRowCol(5, 0).getValue(), 0, "Result in [5,0] VDB(100000,11000,8,F9:F15,1)");
		assert.strictEqual(array.getElementRowCol(6, 0).getValue(), "#N/A", "Result in [6,0] VDB(100000,11000,8,F9:F15,1)");
		assert.strictEqual(array.getElementRowCol(5, 5).getValue(), "#N/A", "Result in [5,5] VDB(100000,11000,8,F9:F15,1)");

		// cellsRange (arg4)
		oParser = new parserFormula("VDB(100000,11000,8,0,F9:F15)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("F9:F15").bbox);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,F9:F15)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result in [0,0] VDB(100000,11000,8,0,F9:F15)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 25000, "Result in [1,0] VDB(100000,11000,8,0,F9:F15)");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 0, "Result in [2,0] VDB(100000,11000,8,0,F9:F15)");	
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), "#NUM!", "Result in [3,0] VDB(100000,11000,8,0,F9:F15)");
		assert.strictEqual(array.getElementRowCol(4, 0).getValue(), "#VALUE!", "Result in [4,0] VDB(100000,11000,8,0,F9:F15)");
		assert.strictEqual(array.getElementRowCol(5, 0).getValue(), 25000, "Result in [5,0] VDB(100000,11000,8,0,F9:F15)");
		assert.strictEqual(array.getElementRowCol(6, 0).getValue(), "#N/A", "Result in [6,0] VDB(100000,11000,8,0,F9:F15)");
		assert.strictEqual(array.getElementRowCol(5, 5).getValue(), "#N/A", "Result in [5,5] VDB(100000,11000,8,0,F9:F15)");

		// cellsRange (arg5)
		oParser = new parserFormula("VDB(100000,11000,8,0,1,F9:F15)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("F9:F15").bbox);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,F9:F15)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 11125, "Result in [0,0] VDB(100000,11000,8,0,1,F9:F15)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 12500, "Result in [1,0] VDB(100000,11000,8,0,1,F9:F15)");	
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 11125, "Result in [2,0] VDB(100000,11000,8,0,1,F9:F15)");	
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), 89000, "Result in [3,0] VDB(100000,11000,8,0,1,F9:F15)");
		assert.strictEqual(array.getElementRowCol(4, 0).getValue(), "#VALUE!", "Result in [4,0] VDB(100000,11000,8,0,1,F9:F15)");
		assert.strictEqual(array.getElementRowCol(5, 0).getValue(), 12500, "Result in [5,0] VDB(100000,11000,8,0,1,F9:F15)");
		assert.strictEqual(array.getElementRowCol(6, 0).getValue(), "#N/A", "Result in [6,0] VDB(100000,11000,8,0,1,F9:F15)");
		assert.strictEqual(array.getElementRowCol(7, 0).getValue(), "", "Result in [7,0] VDB(100000,11000,8,0,1,F9:F15)");
		assert.strictEqual(array.getElementRowCol(8, 0).getValue(), "#N/A", "Result in [8,0] VDB(100000,11000,8,0,1,F9:F15)");
		assert.strictEqual(array.getElementRowCol(5, 5).getValue(), "#N/A", "Result in [5,5] VDB(100000,11000,8,0,1,F9:F15)");

		// cellsRange (arg6)
		oParser = new parserFormula("VDB(100000,11000,8,0,1,2,F9:F15)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("F9:F15").bbox);
		assert.ok(oParser.parse(), "VDB(100000,11000,8,0,1,2,F9:F15)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 25000, "Result in [0,0] VDB(100000,11000,8,0,1,2,F9:F15)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), 25000, "Result in [1,0] VDB(100000,11000,8,0,1,2,F9:F15)");	
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 25000, "Result in [2,0] VDB(100000,11000,8,0,1,2,F9:F15)");	
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), 25000, "Result in [3,0] VDB(100000,11000,8,0,1,2,F9:F15)");
		assert.strictEqual(array.getElementRowCol(4, 0).getValue(), "#VALUE!", "Result in [4,0] VDB(100000,11000,8,0,1,2,F9:F15)");
		assert.strictEqual(array.getElementRowCol(5, 0).getValue(), 25000, "Result in [5,0] VDB(100000,11000,8,0,1,2,F9:F15)");
		assert.strictEqual(array.getElementRowCol(6, 0).getValue(), "#N/A", "Result in [6,0] VDB(100000,11000,8,0,1,2,F9:F15)");
		assert.strictEqual(array.getElementRowCol(7, 0).getValue(), "", "Result in [7,0] VDB(100000,11000,8,0,1,2,F9:F15)");
		assert.strictEqual(array.getElementRowCol(8, 0).getValue(), "#N/A", "Result in [8,0] VDB(100000,11000,8,0,1,2,F9:F15)");
		assert.strictEqual(array.getElementRowCol(5, 5).getValue(), "#N/A", "Result in [5,5] VDB(100000,11000,8,0,1,2,F9:F15)");

		// cellsRange (all)
		oParser = new parserFormula("VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("F2:F15").bbox);
		assert.ok(oParser.parse(), "VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result in [0,0] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#NUM!", "Result in [1,0] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15)");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 0, "Result in [2,0] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15)");
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), "", "Result in [3,0] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15)");
		assert.strictEqual(array.getElementRowCol(5, 5).getValue(), "#N/A", "Result in [5,5] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15)");

		oParser = new parserFormula("VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15,F9:F15,F9:F15)", "A2", ws);
		oParser.setArrayFormulaRef(ws.getRange2("F2:F15").bbox);
		assert.ok(oParser.parse(), "VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15,F9:F15,F9:F15)");
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), 0, "Result in [0,0] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15,F9:F15,F9:F15)");
		assert.strictEqual(array.getElementRowCol(1, 0).getValue(), "#NUM!", "Result in [1,0] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15,F9:F15,F9:F15)");
		assert.strictEqual(array.getElementRowCol(2, 0).getValue(), 0, "Result in [2,0] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15,F9:F15,F9:F15)");
		assert.strictEqual(array.getElementRowCol(3, 0).getValue(), "", "Result in [3,0] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15,F9:F15,F9:F15)");
		assert.strictEqual(array.getElementRowCol(5, 5).getValue(), "#N/A", "Result in [5,5] VDB(F2:F4,F5:F7,F8:F15,F9:F15,F9:F15,F9:F15,F9:F15)");


		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1000");
		ws.getRange2("A101").setValue("500");
		ws.getRange2("A104").setValue("2");
		// For area
		ws.getRange2("A102").setValue("10");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: all numbers, all arguments specified. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Number. Basic valid input: all numbers, all arguments specified. 7 of 7 arguments used.');
		// Case #2: Number,Empty. Factor omitted, valid numbers. 6 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,1,2,,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,1,2,,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number,Empty. Factor omitted, valid numbers. 6 of 7 arguments used.');
		// Case #3: Number,Empty. Both factor and no_switch omitted. 5 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Number,Empty. Both factor and no_switch omitted. 5 of 7 arguments used.');
		// Case #4: String. All arguments as strings convertible to numbers or boolean. 7 of 7 arguments used.
		oParser = new parserFormula('VDB("1000","500","10","1","2","2","FALSE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB("1000","500","10","1","2","2","FALSE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: String. All arguments as strings convertible to numbers or boolean. 7 of 7 arguments used.');
		// Case #5: Formula. Nested formulas for cost, salvage, life. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(SQRT(1000000),ABS(-500),ROUND(10,0),1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(SQRT(1000000),ABS(-500),ROUND(10,0),1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Formula. Nested formulas for cost, salvage, life. 7 of 7 arguments used.');
		// Case #6: Reference link. All arguments as reference links to valid values. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(A100,A101,A102,A103,A104,A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(A100,A101,A102,A103,A104,A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Reference link. All arguments as reference links to valid values. 7 of 7 arguments used.');
		// Case #7: Area. All arguments as single-cell ranges. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Area. All arguments as single-cell ranges. 7 of 7 arguments used.');
		// Case #8: Array. All arguments as single-element arrays. 7 of 7 arguments used.
		oParser = new parserFormula('VDB({1000},{500},{10},{1},{2},{2},{FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB({1000},{500},{10},{1},{2},{2},{FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Array. All arguments as single-element arrays. 7 of 7 arguments used.');
		// Case #9: Name. Arguments using named ranges. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(TestName,TestName1,TestName2,TestName3,A104,A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(TestName,TestName1,TestName2,TestName3,A104,A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Arguments using named ranges. 7 of 7 arguments used.');
		// Case #10: Name3D. Arguments using 3D named ranges. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(TestName3D,TestName3D,TestName3D,TestName3D,A104,A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(TestName3D,TestName3D,TestName3D,TestName3D,A104,A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. Arguments using 3D named ranges. 7 of 7 arguments used.');
		// Case #11: Ref3D. All arguments as 3D references. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D. All arguments as 3D references. 7 of 7 arguments used.');
		// Case #12: Area3D. All arguments as 3D single-cell ranges. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D. All arguments as 3D single-cell ranges. 7 of 7 arguments used.');
		// Case #13: Table. All arguments as table structured references. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. All arguments as table structured references. 7 of 7 arguments used.');
		// Case #14: Date. Cost and salvage as date serial numbers. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(DATE(2025,1,1),DATE(2025,1,1),10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(DATE(2025,1,1),DATE(2025,1,1),10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date. Cost and salvage as date serial numbers. 7 of 7 arguments used.');
		// Case #15: Time. Cost and salvage adjusted with time values. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(TIME(10,0,0)+1000,TIME(10,0,0)+500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(TIME(10,0,0)+1000,TIME(10,0,0)+500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160.0666666666666, 'Test: Positive case: Time. Cost and salvage adjusted with time values. 7 of 7 arguments used.');
		// Case #16: Formula. VDB with SUM for cost and salvage. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(SUM(500,500),SUM(200,300),10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(SUM(500,500),SUM(200,300),10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Formula. VDB with SUM for cost and salvage. 7 of 7 arguments used.');
		// Case #17: Number. Very small start_period. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,0.000001,1,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,0.000001,1,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 199.99976000003997, 'Test: Positive case: Number. Very small start_period. 7 of 7 arguments used.');
		// Case #18: String. All arguments as float strings. 7 of 7 arguments used.
		oParser = new parserFormula('VDB("1000,5","500,5","10,5","1,5","2,5","2,5","TRUE")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB("1000,5","500,5","10,5","1,5","2,5","2,5","TRUE") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: String. All arguments as float strings. 7 of 7 arguments used.');
		// Case #19: Array. Multi-element arrays for arguments. 7 of 7 arguments used.
		oParser = new parserFormula('VDB({1000,2000},{500,1000},{10,20},{1,2},{2,3},{2},{FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB({1000,2000},{500,1000},{10,20},{1,2},{2,3},{2},{FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Array. Multi-element arrays for arguments. 7 of 7 arguments used.');
		// Case #20: Formula. Nested IF formulas for arguments. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(IF(TRUE,1000,500),IF(TRUE,500,200),10,IF(TRUE,1,0),2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(IF(TRUE,1000,500),IF(TRUE,500,200),10,IF(TRUE,1,0),2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Formula. Nested IF formulas for arguments. 7 of 7 arguments used.');
		// Case #21: Number. Salvage set to 0. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,0,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,0,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Number. Salvage set to 0. 7 of 7 arguments used.');
		// Case #22: Formula,Number. Cost with ABS formula, no_switch TRUE. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(ABS(-1000),500,10,1,2,2,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(ABS(-1000),500,10,1,2,2,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '160', 'Test: Positive case: Formula,Number. Cost with ABS formula, no_switch TRUE. 7 of 7 arguments used.');

		// Negative cases:
		// Case #1: Number. Negative cost returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(-1000,500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(-1000,500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative cost returns #NUM!. 7 of 7 arguments used.');
		// Case #2: Number. Negative salvage returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,-500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,-500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative salvage returns #NUM!. 7 of 7 arguments used.');
		// Case #3: Number. Negative life returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,-10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,-10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative life returns #NUM!. 7 of 7 arguments used.');
		// Case #4: Number. Negative start_period returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,-1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,-1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative start_period returns #NUM!. 7 of 7 arguments used.');
		// Case #5: Number. Negative end_period returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,1,-2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,1,-2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative end_period returns #NUM!. 7 of 7 arguments used.');
		// Case #6: Number. Start_period > end_period returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,2,1,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,2,1,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Start_period > end_period returns #NUM!. 7 of 7 arguments used.');
		// Case #7: Number. Start_period > life returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,11,12,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,11,12,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Start_period > life returns #NUM!. 7 of 7 arguments used.');
		// Case #8: Number. End_period > life returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,1,12,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,1,12,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. End_period > life returns #NUM!. 7 of 7 arguments used.');
		// Case #9: String. Non-numeric string for cost returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB("abc",500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB("abc",500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string for cost returns #VALUE!. 7 of 7 arguments used.');
		// Case #10: Error. Propagates #N/A error. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(NA(),500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(NA(),500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 7 of 7 arguments used.');
		// Case #11: Area. Multi-cell range returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(A100:A101,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(A100:A101,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Negative case: Area. Multi-cell range returns #NUM!. 7 of 7 arguments used.');
		// Case #12: Empty. Empty reference link returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(A107,500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(A107,500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty. Empty reference link returns #VALUE!. 7 of 7 arguments used.');
		// Case #13: String. Empty string returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB("",500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB("",500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string returns #VALUE!. 7 of 7 arguments used.');
		// Case #14: Boolean. Boolean cost returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(TRUE,500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(TRUE,500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Boolean. Boolean cost returns #NUM!. 7 of 7 arguments used.');
		// Case #15: Ref3D. 3D reference to text returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(Sheet2!A8,500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(Sheet2!A8,500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 7 of 7 arguments used.');
		// Case #16: Name. Named range with text returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(TestNameArea2,500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(TestNameArea2,500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with text returns #VALUE!. 7 of 7 arguments used.');
		// Case #17: Table. Table column with text returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Table. Table column with text returns #VALUE!. 7 of 7 arguments used.');
		// Case #18: Formula. Formula resulting in #NUM! error. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(SQRT(-1),500,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(SQRT(-1),500,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 7 of 7 arguments used.');
		// Case #19: Number. Zero life returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,0,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,0,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Zero life returns #NUM!. 7 of 7 arguments used.');
		// Case #20: Number. Negative factor returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,10,1,2,-2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1000,500,10,1,2,-2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative factor returns #NUM!. 7 of 7 arguments used.');
		// Case #21: Number. Cost < salvage returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(500,1000,10,1,2,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(500,1000,10,1,2,2,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number. Cost < salvage returns #NUM!. 7 of 7 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid values for cost, start_period. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1E-307,0,1,0.000001,1,2,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: VDB(1E-307,0,1,0.000001,1,2,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum valid values for cost, start_period. 7 of 7 arguments used.');
		// Case #2: Number. Maximum valid values for cost, life, end_period. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(9,99999999999999E+307,0,1E+307,0,1E+307,2,FALSE)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: VDB(9,99999999999999E+307,0,1E+307,0,1E+307,2,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '`=VDB(9.99999999999999E+307,0,1E+307,0,1E+307,2,FALSE)', 'Test: Bounded case: Number. Maximum valid values for cost, life, end_period. 7 of 7 arguments used.');
		// Case #3: Number. Start_period and end_period at maximum valid range relative to life. 7 of 7 arguments used.
		oParser = new parserFormula('VDB(1000,500,1E+307,1E+307-1,1E+307,2,FALSE)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: VDB(1000,500,1E+307,1E+307-1,1E+307,2,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Start_period and end_period at maximum valid range relative to life. 7 of 7 arguments used.');

		// TODO: in boundary cases calculation is too long. Critical problem
		// Need to fix:
		// Case #11: Area. Multi-cell range returns #NUM!. 7 of 7 arguments used.
		// Case #1: Number. Minimum valid values for cost, start_period. 7 of 7 arguments used.
		// Case #2: Number. Maximum valid values for cost, life, end_period. 7 of 7 arguments used. - crit
		// Case #3: Number. Start_period and end_period at maximum valid range relative to life. 7 of 7 arguments used. - crit

		testArrayFormula2(assert, "VDB", 5, 7);
	});

	QUnit.test("Test: \"XIRR\"", function (assert) {
		function lcl_sca_XirrResult(rValues, rDates, fRate) {
			var D_0 = rDates[0];
			var r = fRate + 1;
			var fResult = rValues[0];
			for (var i = 1, nCount = rValues.length; i < nCount; ++i) {
				fResult += rValues[i] / Math.pow(r, (rDates[i] - D_0) / 365);
			}
			return fResult;
		}

		function lcl_sca_XirrResult_Deriv1(rValues, rDates, fRate) {
			var D_0 = rDates[0];
			var r = fRate + 1;
			var fResult = 0;
			for (var i = 1, nCount = rValues.length; i < nCount; ++i) {
				var E_i = (rDates[i] - D_0) / 365;
				fResult -= E_i * rValues[i] / Math.pow(r, E_i + 1);
			}
			return fResult;
		}

		function xirr(valueArray, dateArray, rate) {

			var res = rate
			if (res <= -1) {
				return "#NUM!"
			}

			var fMaxEps = 1e-6, maxIter = 100;

			var newRate, eps, xirrRes, bContLoop;
			do {
				xirrRes = lcl_sca_XirrResult(valueArray, dateArray, res);
				newRate = res - xirrRes / lcl_sca_XirrResult_Deriv1(valueArray, dateArray, res);
				eps = Math.abs(newRate - res);
				res = newRate;
				bContLoop = (eps > fMaxEps) && (Math.abs(xirrRes) > fMaxEps);
			} while (--maxIter && bContLoop);

			if (bContLoop) {
				return "#NUM!";
			}

			return res;

		}

		ws.getRange2("F100").setValue("1/1/2008");
		ws.getRange2("G100").setValue("3/1/2008");
		ws.getRange2("H100").setValue("10/30/2008");
		ws.getRange2("I100").setValue("2/15/2009");
		ws.getRange2("J100").setValue("4/1/2009");

		oParser = new parserFormula("XIRR({-10000,2750,4250,3250,2750},F100:J100,0.1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(difBetween(oParser.calculate().getValue(), 0.3733625335188316));

		ws.getRange2("F100").setValue(0);
		assert.ok(oParser.parse());
		assert.ok(difBetween(oParser.calculate().getValue(), 0.0024114950175866895));

		ws.getRange2("A200").setValue("-10000");
		ws.getRange2("A201").setValue("2750");
		ws.getRange2("A202").setValue("4250");
		ws.getRange2("A203").setValue("3250");
		ws.getRange2("A204").setValue("2750");
		ws.getRange2("B200").setValue("1111");
		ws.getRange2("B201").setValue("1113");
		ws.getRange2("B202").setValue("1213");
		ws.getRange2("B203").setValue("1313");
		ws.getRange2("B204").setValue("1399");

		ws.getRange2("A100:A104").setValue("");
		ws.getRange2("B100:B104").setValue("");

		oParser = new parserFormula("XIRR(A100:A104,B100:B104)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(A100:A104,B100:B104)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of XIRR(A100:A104,B100:B104) - empty cellRanges check");

		oParser = new parserFormula("XIRR(A100:A104,B200:B204)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(A100:A104,B200:B204)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of XIRR(A100:A104,B200:B204) - first argument is empty cellRange");

		oParser = new parserFormula("XIRR(A200:A204,B100:B104)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(A200:A204,B100:B104)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", "Result of XIRR(A200:A204,B100:B104) - second argument is empty cellRange");

		oParser = new parserFormula("XIRR(A200:A204,B200:B204)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(A200:A204,B200:B204)");
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), "1.03", "Result of XIRR(A200:A204,B200:B204)");

		oParser = new parserFormula("XIRR(,)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(,)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of XIRR(,)");

		oParser = new parserFormula("XIRR(12,)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(12,)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of XIRR(12,)");

		oParser = new parserFormula("XIRR(,12)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(,12)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of XIRR(,12)");

		oParser = new parserFormula("XIRR(,,)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(,,)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of XIRR(,,)");

		oParser = new parserFormula("XIRR(12,,)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(12,,)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of XIRR(12,,)");

		oParser = new parserFormula("XIRR(,,12)", "A2", ws);
		assert.ok(oParser.parse(), "XIRR(,,12)");
		assert.strictEqual(oParser.calculate().getValue(), "#N/A", "Result of XIRR(,,12)");

		oParser = new parserFormula('XIRR("str",12)', "A2", ws);
		assert.ok(oParser.parse(), 'XIRR("str",12)');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of XIRR("str",12)');

		oParser = new parserFormula('XIRR(12,"str")', "A2", ws);
		assert.ok(oParser.parse(), 'XIRR(12,"str")');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Result of XIRR(12,"str")');

		oParser = new parserFormula('XIRR(#DIV/0!,)', "A2", ws);
		assert.ok(oParser.parse(), 'XIRR(#DIV/0!,)');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Result of XIRR(#DIV/0!,)');

		oParser = new parserFormula('XIRR(A200:A204,#DIV/0!)', "A2", ws);
		assert.ok(oParser.parse(), 'XIRR(A200:A204,#DIV/0!)');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Result of XIRR(A200:A204,#DIV/0!)');

		oParser = new parserFormula('XIRR(A200:A204,A200:A204,#DIV/0!)', "A2", ws);
		assert.ok(oParser.parse(), 'XIRR(A200:A204,A200:A204,#DIV/0!)');
		assert.strictEqual(oParser.calculate().getValue(), "#DIV/0!", 'Result of XIRR(A200:A204,A200:A204,#DIV/0!)');

		let wsName = ws.getName();
		oParser = new parserFormula('XIRR('+ wsName + '!A200:A204,'+ wsName + '!B200:B204)', "A2", ws);
		assert.ok(oParser.parse(), 'XIRR(SheetName!A200:A204,SheetName!B200:B204)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), "1.03", 'Result of XIRR(SheetName!A200:A204,SheetName!B200:B204)');

		oParser = new parserFormula('XIRR(A200:A204,'+ wsName + '!B200:B204)', "A2", ws);
		assert.ok(oParser.parse(), 'XIRR(A200:A204,SheetName!B200:B204)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), "1.03", 'Result of XIRR(A200:A204,SheetName!B200:B204)');

		oParser = new parserFormula('XIRR('+ wsName + '!A200:A204,B200:B204)', "A2", ws);
		assert.ok(oParser.parse(), 'XIRR(SheetName!A200:A204,B200:B204)');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), "1.03", 'Result of XIRR(SheetName!A200:A204,B200:B204)');

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A104").setValue("5");
		// For area
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A105").setValue("6");
		ws.getRange2("A106").setValue("7");
		ws.getRange2("A107").setValue("8");
		ws.getRange2("A108").setValue("9");
		ws.getRange2("A109").setValue("10");
		ws.getRange2("A110").setValue("11");
		ws.getRange2("A111").setValue("11");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number,Number,Number. Basic valid input: cash flows and dates as arrays, guess provided. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{38777,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{38777,38838},0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.98023e-9, 'Test: Positive case: Number,Number,Number. Basic valid input: cash flows and dates as arrays, guess provided. 3 of 3 arguments used.');
		// Case #2: Number,Number. Valid input without guess. 2 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{38777,38838}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.98023e-9, 'Test: Positive case: Number,Number. Valid input without guess. 2 of 3 arguments used.');
		// Case #4: String,String,Number. String inputs convertible to numbers and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({"-1000","1000"},{"03/01/2006","05/01/2006"},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({"-1000","1000"},{"03/01/2006","05/01/2006"},0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.98023e-9, 'Test: Positive case: String,String,Number. String inputs convertible to numbers and dates. 3 of 3 arguments used.');
		// Case #5: Reference link,Reference link,Number. Reference to valid ranges for values and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(A100:A101,A102:A103,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(A100:A101,A102:A103,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link,Reference link,Number. Reference to valid ranges for values and dates. 3 of 3 arguments used.');
		// Case #6: Area,Area,Number. Single-cell ranges for values and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(A100:A100,A102:A102,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(A100:A100,A102:A102,0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area,Area,Number. Single-cell ranges for values and dates. 3 of 3 arguments used.');
		// Case #7: Array,Array,Number. Multi-element arrays (3 elements) for values and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,500,1000},{38777,38800,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,500,1000},{38777,38800,38838},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 22.465336534417826, 'Test: Positive case: Array,Array,Number. Multi-element arrays (3 elements) for values and dates. 3 of 3 arguments used.');
		// Case #8: Name,Name,Number. Named ranges for values and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(TestName,TestName1,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(TestName,TestName1,0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Name,Name,Number. Named ranges for values and dates. 3 of 3 arguments used.');
		// Case #9: Name3D,Name3D,Number. 3D named ranges for values and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(TestName3D,TestName3D,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(TestName3D,TestName3D,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Positive case: Name3D,Name3D,Number. 3D named ranges for values and dates. 3 of 3 arguments used.');
		// Case #10: Ref3D,Ref3D,Number. 3D references for values and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(Sheet2!A1:A2,Sheet2!A3:A4,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(Sheet2!A1:A2,Sheet2!A3:A4,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D,Ref3D,Number. 3D references for values and dates. 3 of 3 arguments used.');
		// Case #11: Area3D,Area3D,Number. 3D single-cell ranges for values and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(Sheet2!A1:A1,Sheet2!A3:A3,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(Sheet2!A1:A1,Sheet2!A3:A3,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D,Area3D,Number. 3D single-cell ranges for values and dates. 3 of 3 arguments used.');
		// Case #12: Table,Table,Number. Table structured references for values and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(Table1[Column1],Table1[Column1],0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(Table1[Column1],Table1[Column1],0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Positive case: Table,Table,Number. Table structured references for values and dates. 3 of 3 arguments used.');
		// Case #14: Time,Time,Number. Time-adjusted dates. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{0+38777,0+38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{0+38777,0+38838},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Time,Time,Number. Time-adjusted dates. 3 of 3 arguments used.');
		// Case #15: Formula,Formula,Formula. Nested IF formulas for all arguments. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(IF(TRUE,{-1000,1000},{0,0}),IF(TRUE,{38777,38838},{0,0}),IF(TRUE,0.1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(IF(TRUE,{-1000,1000},{0,0}),IF(TRUE,{38777,38838},{0,0}),IF(TRUE,0.1,0)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.98023e-9, 'Test: Positive case: Formula,Formula,Formula. Nested IF formulas for all arguments. 3 of 3 arguments used.');
		// Case #16: Number,Number,String. Guess as string convertible to number. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{38777,38838},"0.1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{38777,38838},"0.1") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.98023e-9, 'Test: Positive case: Number,Number,String. Guess as string convertible to number. 3 of 3 arguments used.');
		// Case #17: String,String,Formula. Float strings for values and dates, guess as formula. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({"-1000.5","1000.5"},{"01/01/2025","06/01/2025"},SQRT(0.01))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({"-1000.5","1000.5"},{"01/01/2025","06/01/2025"},SQRT(0.01)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.98023e-9, 'Test: Positive case: String,String,Formula. Float strings for values and dates, guess as formula. 3 of 3 arguments used.');
		// Case #18: Array,Array,Number. Array with zero cash flow. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,0,1000},{38777,38800,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,0,1000},{38777,38800,38838},0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.98023e-9, 'Test: Positive case: Array,Array,Number. Array with zero cash flow. 3 of 3 arguments used.');
		// Case #19: Formula,Formula,Number. XIRR inside SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(XIRR({-1000,1000},{38777,38838},0.1),0.05)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(XIRR({-1000,1000},{38777,38838},0.1),0.05) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999999999999989, 'Test: Positive case: Formula,Formula,Number. XIRR inside SUM formula. 3 of 3 arguments used.');
		// Case #20: Reference link,Reference link,Reference link. All arguments as references. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(A104:A105,A106:A107,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(A104:A105,A106:A107,A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link,Reference link,Reference link. All arguments as references. 3 of 3 arguments used.');
		// Case #21: Area,Area,Area. All arguments as single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(A104:A104,A106:A106,A108:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(A104:A104,A106:A106,A108:A108) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Positive case: Area,Area,Area. All arguments as single-cell ranges. 3 of 3 arguments used.');
		// Case #22: Table,Table,Table. All arguments as table references. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(Table1[Column1],Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(Table1[Column1],Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Positive case: Table,Table,Table. All arguments as table references. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number,Number,Number. All zero cash flows return #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({0,0},{38777,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({0,0},{38777,38838},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Number,Number. All zero cash flows return #NUM!. 3 of 3 arguments used.');
		// Case #2: Number,Number,Number. Duplicate dates return #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{38777,38777},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{38777,38777},0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.98023e-9, 'Test: Negative case: Number,Number,Number. Duplicate dates return #NUM!. 3 of 3 arguments used.');
		// Case #3: String,String,Number. Non-numeric string in values returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({"abc","1000"},{"01/03/2006","01/05/2006"},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({"abc","1000"},{"01/03/2006","01/05/2006"},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,String,Number. Non-numeric string in values returns #VALUE!. 3 of 3 arguments used.');
		// Case #4: Error,Number,Number. Error in values propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(NA(),{38777,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(NA(),{38777,38838},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Number,Number. Error in values propagates #N/A. 3 of 3 arguments used.');
		// Case #5: Area,Area,Number. Multi-cell range with invalid data returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(A109:A110,A111:A112,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(A109:A110,A111:A112,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Area,Area,Number. Multi-cell range with invalid data returns #VALUE!. 3 of 3 arguments used.');
		// Case #6: Empty,Number,Number. Empty range for values returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(A109:A109,{38777,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(A109:A109,{38777,38838},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty,Number,Number. Empty range for values returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Number,Empty,Number. Empty range for dates returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},A111:A111,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},A111:A111,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Empty,Number. Empty range for dates returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Boolean,Number,Number. Boolean values return #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({FALSE,TRUE},{38777,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({FALSE,TRUE},{38777,38838},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean,Number,Number. Boolean values return #NUM!. 3 of 3 arguments used.');
		// Case #9: Ref3D,Ref3D,Number. 3D reference to text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(Sheet2!A5:A6,Sheet2!A7:A8,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(Sheet2!A5:A6,Sheet2!A7:A8,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D,Ref3D,Number. 3D reference to text returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Name,Name,Number. Named range with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(TestNameArea2,TestName1,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(TestNameArea2,TestName1,0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name,Name,Number. Named range with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Table,Table,Number. Table with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(Table2[Column2],Table2[Column2],0.1)', 'A2', ws);
		//? assert.ok(oParser.parse(), 'Test: XIRR(Table2[Column2],Table2[Column2],0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '=XIRR(Table2[Values],Table2[Dates],0.1)', 'Test: Negative case: Table,Table,Number. Table with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Formula,Number,Number. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(SQRT(-1),{38777,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(SQRT(-1),{38777,38838},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Number,Number. Formula resulting in #NUM! propagates error. 3 of 3 arguments used.');
		// Case #13: Number,String,Number. Invalid date string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{"abc","01/05/2006"},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{"abc","01/05/2006"},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String,Number. Invalid date string returns #VALUE!. 3 of 3 arguments used.');
		// Case #14: Number,Number,Boolean. Boolean guess returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{38777,38838},TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{38777,38838},TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Number,Boolean. Boolean guess returns #VALUE!. 3 of 3 arguments used.');
		// Case #15: Array,Array,Number. Invalid date (0) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{0,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{0,38838},0.1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.98023e-9, 'Test: Negative case: Array,Array,Number. Invalid date (0) returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Number,Number,Number. Large negative guess may return #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({1000,-1000},{38777,38838},-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({1000,-1000},{38777,38838},-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Number,Number. Large negative guess may return #NUM!. 3 of 3 arguments used.');
		// Case #17: Number,Formula,Number. Date beyond Excel limit returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{9999+1,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{9999+1,38838},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Formula,Number. Date beyond Excel limit returns #NUM!. 3 of 3 arguments used.');
		// Case #18: Array,Array,Number. Array with booleans returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({TRUE,FALSE},{38777,38838},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({TRUE,FALSE},{38777,38838},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array,Array,Number. Array with booleans returns #NUM!. 3 of 3 arguments used.');
		// Case #19: Area3D,Area3D,Number. 3D range with invalid data returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(Sheet2!A1:A2,Sheet2!A3:A4,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(Sheet2!A1:A2,Sheet2!A3:A4,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D,Area3D,Number. 3D range with invalid data returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Name3D,Name3D,Number. 3D named range with text returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR(TestNameArea3D2,TestName3D2,0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR(TestNameArea3D2,TestName3D2,0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Negative case: Name3D,Name3D,Number. 3D named range with text returns #VALUE!. 3 of 3 arguments used.');
		// Case #21: String,String,Number. Empty string in values returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({"","1000"},{"01/03/2006","01/05/2006"},0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({"","1000"},{"01/03/2006","01/05/2006"},0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,String,Number. Empty string in values returns #VALUE!. 3 of 3 arguments used.');
		// Case #22: Number,Number,String. Non-numeric string guess returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1000,1000},{38777,38838},"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1000,1000},{38777,38838},"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Number,String. Non-numeric string guess returns #VALUE!. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number,Number,Number. Minimum valid Excel numbers for values, minimum dates, small guess. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-1E-307,1E-307},{1,2},0.000000000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-1E-307,1E-307},{1,2},0.000000000000001) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 5e-16, 'Test: Bounded case: Number,Number,Number. Minimum valid Excel numbers for values, minimum dates, small guess. 3 of 3 arguments used.');
		// Case #2: Number,Number,Number. Maximum valid Excel numbers for values, maximum dates, large guess. 3 of 3 arguments used.
		oParser = new parserFormula('XIRR({-9.99999999999999E+307,9.99999999999999E+307},{2958465,2958466},0.999999999999999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-9.99999999999999E+307,9.99999999999999E+307},{2958465,2958466},0.999999999999999) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number,Number,Number. Maximum valid Excel numbers for values, maximum dates, large guess. 3 of 3 arguments used.');
		// Case #3: Array. Guess = 0, extreme dates.
		oParser = new parserFormula('XIRR({-100,200},{1,2958465},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-100,200},{1,2958465},0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.00008552057243167095, 'Test: Bounded case: Array. Guess = 0, extreme dates.');
		// Case #4: Array. Negative guess with extreme dates.
		oParser = new parserFormula('XIRR({-100,200},{1,2958465},-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XIRR({-100,200},{1,2958465},-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Array. Negative guess with extreme dates.');

		// TODO множественное расхождение в базовых результатах с ms
		// Need to fix:
		// Case #1: Number,Number,Number. Basic valid input: cash flows and dates as arrays, guess provided. 3 of 3 arguments used.
		// Case #2: Number,Number. Valid input without guess. 2 of 3 arguments used.
		// Case #4: String,String,Number. String inputs convertible to numbers and dates. 3 of 3 arguments used.
		// Case #6: Area,Area,Number. Single-cell ranges for values and dates. 3 of 3 arguments used.
		// Case #8: Name,Name,Number. Named ranges for values and dates. 3 of 3 arguments used.
		// Case #15: Formula,Formula,Formula. Nested IF formulas for all arguments. 3 of 3 arguments used.
		// Case #16: Number,Number,String. Guess as string convertible to number. 3 of 3 arguments used.
		// Case #17: String,String,Formula. Float strings for values and dates, guess as formula. 3 of 3 arguments used.
		// Case #18: Array,Array,Number. Array with zero cash flow. 3 of 3 arguments used.
		// Case #2: Number,Number,Number. Duplicate dates return #NUM!. 3 of 3 arguments used.
		// Case #10: Name,Name,Number. Named range with text returns #VALUE!. 3 of 3 arguments used.
		// Case #11: Table,Table,Number. Table with text returns #VALUE!. 3 of 3 arguments used.
		// Case #14: Number,Number,Boolean. Boolean guess returns #VALUE!. 3 of 3 arguments used.
		// Case #15: Array,Array,Number. Invalid date (0) returns #NUM!. 3 of 3 arguments used.
		// Case #1: Number,Number,Number. Minimum valid Excel numbers for values, minimum dates, small guess. 3 of 3 arguments used.
		// Case #2: Number,Number,Number. Maximum valid Excel numbers for values, maximum dates, large guess. 3 of 3 arguments used.

		ws.getRange2("A200:B204").cleanAll();
	});

	QUnit.test("Test: \"XNPV\"", function (assert) {

		function xnpv(rate, valueArray, dateArray) {
			var res = 0, r = rate;

			var d1 = dateArray[0];

			for (var i = 0; i < dateArray.length; i++) {

				res += valueArray[i] / (Math.pow((1 + r), (dateArray[i] - d1) / 365))
			}

			return res;
		}

		ws.getRange2("A701").setValue("39448");
		ws.getRange2("A702").setValue("39508");
		ws.getRange2("A703").setValue("39751");
		ws.getRange2("A704").setValue("39859");
		ws.getRange2("A705").setValue("39904");

		oParser = new parserFormula("XNPV(0.09,{-10000,2750,4250,3250,2750},A701:A705)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), xnpv(0.09, [-10000, 2750, 4250, 3250, 2750], [39448, 39508, 39751, 39859, 39904]));

		ws.getRange2("A705").setValue("43191");

		oParser = new parserFormula("XNPV(0.09,{-10000,2750,4250,3250,2750},A701:A705)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), xnpv(0.09, [-10000, 2750, 4250, 3250, 2750], [39448, 39508, 39751, 39859, 43191]));

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number,Array. Basic valid input: number rate, array of cash flows, array of dates. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -96.83952757528081, 'Test: Positive case: Number,Array. Basic valid input: number rate, array of cash flows, array of dates. 3 of 3 arguments used.');
		// Case #2: Formula,Array. Rate as formula, valid arrays for values and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(SQRT(0.01),{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(SQRT(0.01),{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -96.83952757528081, 'Test: Positive case: Formula,Array. Rate as formula, valid arrays for values and dates. 3 of 3 arguments used.');
		// Case #3: String,Array. Rate as string convertible to number. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV("0.1",{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV("0.1",{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -96.83952757528081, 'Test: Positive case: String,Array. Rate as string convertible to number. 3 of 3 arguments used.');
		// Case #4: Number,Array. Larger array with multiple cash flows and dates. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.05,{100,-200,300},{38777,38838,38899})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.05,{100,-200,300},{38777,38838,38899}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 196.7714566396027, 'Test: Positive case: Number,Array. Larger array with multiple cash flows and dates. 3 of 3 arguments used.');
		// Case #5: Reference link,Array. Rate as reference link to valid number. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(A100,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(A100,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -86.89644709906835, 'Test: Positive case: Reference link,Array. Rate as reference link to valid number. 3 of 3 arguments used.');
		// Case #6: Area,Array. Rate as single-cell range. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(A101:A101,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(A101:A101,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -71.60303046914854, 'Test: Positive case: Area,Array. Rate as single-cell range. 3 of 3 arguments used.');
		// Case #7: Number,Area,Area. Values and dates as single-cell ranges. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number,Area,Area. Values and dates as single-cell ranges. 3 of 3 arguments used.');
		// Case #8: Name,Array. Rate as named range. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(TestName,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(TestName,{100,-200},{38777,38838}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name,Array. Rate as named range. 3 of 3 arguments used.');
		// Case #9: Name3D,Array. Rate as 3D named range. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(TestName3D,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(TestName3D,{100,-200},{38777,38838}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D,Array. Rate as 3D named range. 3 of 3 arguments used.');
		// Case #10: Ref3D,Array. Rate as 3D reference. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(Sheet2!A1,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(Sheet2!A1,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -78.12335767189683, 'Test: Positive case: Ref3D,Array. Rate as 3D reference. 3 of 3 arguments used.');
		// Case #11: Area3D,Array. Rate as 3D single-cell range. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(Sheet2!A2:A2,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(Sheet2!A2:A2,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -66.45311347117047, 'Test: Positive case: Area3D,Array. Rate as 3D single-cell range. 3 of 3 arguments used.');
		// Case #12: Table,Array. Rate as table reference. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(Table1[Column1],{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(Table1[Column1],{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -78.12335767189683, 'Test: Positive case: Table,Array. Rate as table reference. 3 of 3 arguments used.');
		// Case #13: Date,Array. Rate as date converted to small number. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(DATE(2025,1,1)/36525,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(DATE(2025,1,1)/36525,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -74.65078815142928, 'Test: Positive case: Date,Array. Rate as date converted to small number. 3 of 3 arguments used.');
		// Case #14: Time,Array. Rate as time adjusted to valid number. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(TIME(12,0,0)*2,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(TIME(12,0,0)*2,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -78.12335767189683, 'Test: Positive case: Time,Array. Rate as time adjusted to valid number. 3 of 3 arguments used.');
		// Case #15: Formula,Area,Area. Rate as nested IF, values and dates as ranges. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(IF(TRUE,0.1,0.2),A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(IF(TRUE,0.1,0.2),A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula,Area,Area. Rate as nested IF, values and dates as ranges. 3 of 3 arguments used.');
		// Case #16: Number,Table,Table. Values and dates as table references. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number,Table,Table. Values and dates as table references. 3 of 3 arguments used.');
		// Case #17: Number,Array. Large cash flow values. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{1000000,-2000000},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{1000000,-2000000},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -968395.275752808, 'Test: Positive case: Number,Array. Large cash flow values. 3 of 3 arguments used.');
		// Case #18: Number,Array. Fractional dates (times included). 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},{38777.5,38838.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},{38777.5,38838.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -96.83952757528081, 'Test: Positive case: Number,Array. Fractional dates (times included). 3 of 3 arguments used.');
		// Case #19: Number,Array. Non-standard: larger arrays with multiple cash flows. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200,300,-400},{38777,38838,38899,38960})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200,300,-400},{38777,38838,38899,38960}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -187.5812750524175, 'Test: Positive case: Number,Array. Non-standard: larger arrays with multiple cash flows. 3 of 3 arguments used.');
		// Case #20: Formula,Formula,Formula. XNPV as part of SUM formula. 3 of 3 arguments used.
		oParser = new parserFormula('SUM(XNPV(0.1,A102:A103,A104:A105),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(XNPV(0.1,A102:A103,A104:A105),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula,Formula,Formula. XNPV as part of SUM formula. 3 of 3 arguments used.');
		// Case #21: Number,Area3D,Area3D. Values and dates as 3D ranges. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,Sheet2!A3:A4,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,Sheet2!A3:A4,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number,Area3D,Area3D. Values and dates as 3D ranges. 3 of 3 arguments used.');
		// Case #22: Formula,Array. Rate rounded by formula. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(ROUND(0.1,2),{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(ROUND(0.1,2),{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -96.83952757528081, 'Test: Positive case: Formula,Array. Rate rounded by formula. 3 of 3 arguments used.');

		// Negative cases:
		// Case #1: Number,Array. Rate = -1 returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(-1,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(-1,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Array. Rate = -1 returns #NUM!. 3 of 3 arguments used.');
		// Case #2: Number,Array. No negative value in cash flows returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 296.83952757528084, 'Test: Negative case: Number,Array. No negative value in cash flows returns #NUM!. 3 of 3 arguments used.');
		// Case #3: Number,Array. No positive value in cash flows returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{-100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{-100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -296.83952757528084, 'Test: Negative case: Number,Array. No positive value in cash flows returns #NUM!. 3 of 3 arguments used.');
		// Case #4: Number,Array. Dates not in chronological order (second date before first) returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},{38838,38777})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},{38838,38777}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Array. Dates not in chronological order (second date before first) returns #NUM!. 3 of 3 arguments used.');
		// Case #5: Error,Array. Rate as #N/A error propagates #N/A. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(NA(),{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(NA(),{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error,Array. Rate as #N/A error propagates #N/A. 3 of 3 arguments used.');
		// Case #6: String,Array. Non-numeric rate string returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV("abc",{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV("abc",{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String,Array. Non-numeric rate string returns #VALUE!. 3 of 3 arguments used.');
		// Case #7: Number,Array. Non-numeric value in cash flow array returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,"abc"},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,"abc"},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Array. Non-numeric value in cash flow array returns #VALUE!. 3 of 3 arguments used.');
		// Case #8: Number,Array. Non-date value in dates array returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},{38777,"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},{38777,"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Array. Non-date value in dates array returns #VALUE!. 3 of 3 arguments used.');
		// Case #9: Empty,Array. Empty rate returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(,{100,-200},{38777,38838}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty,Array. Empty rate returns #VALUE!. 3 of 3 arguments used.');
		// Case #10: Number,Empty,Array. Empty values argument returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,,{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,,{38777,38838}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Empty,Array. Empty values argument returns #VALUE!. 3 of 3 arguments used.');
		// Case #11: Number,Array,Empty. Empty dates argument returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number,Array,Empty. Empty dates argument returns #VALUE!. 3 of 3 arguments used.');
		// Case #12: Boolean,Array. Boolean rate (FALSE = 0) may cause unexpected results or #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(FALSE,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(FALSE,{100,-200},{38777,38838}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean,Array. Boolean rate (FALSE = 0) may cause unexpected results or #NUM!. 3 of 3 arguments used.');
		// Case #13: Number,Array. Single value with no negative cash flow returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100},{38777})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100},{38777}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Negative case: Number,Array. Single value with no negative cash flow returns #NUM!. 3 of 3 arguments used.');
		// Case #14: Number,Area. Multi-cell range (>2 cells) for values returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,A106:A108,A109:A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,A106:A108,A109:A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Area. Multi-cell range (>2 cells) for values returns #NUM!. 3 of 3 arguments used.');
		// Case #15: Number,Array,Area3D. Multi-cell 3D range (>2 cells) for dates returns #NUM!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},Sheet2!A7:A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},Sheet2!A7:A9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Array,Area3D. Multi-cell 3D range (>2 cells) for dates returns #NUM!. 3 of 3 arguments used.');
		// Case #16: Number,Name,Array. Values as named range with area returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,TestNameArea2,{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,TestNameArea2,{38777,38838}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.968395276, 'Test: Negative case: Number,Name,Array. Values as named range with area returns #VALUE!. 3 of 3 arguments used.');
		// Case #17: Number,Array,Name3D. Dates as 3D named range with area returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Array,Name3D. Dates as 3D named range with area returns #VALUE!. 3 of 3 arguments used.');
		// Case #18: Number,Table,Array. Table column with text values returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,Table1[Column2],{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,Table1[Column2],{38777,38838}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,Table,Array. Table column with text values returns #VALUE!. 3 of 3 arguments used.');
		// Case #19: Number,Array,Table. Table column with text dates returns #VALUE!. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Array,Table. Table column with text dates returns #VALUE!. 3 of 3 arguments used.');
		// Case #20: Formula,Array. Rate as formula returning #NUM! propagates error. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(SQRT(-1),{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(SQRT(-1),{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula,Array. Rate as formula returning #NUM! propagates error. 3 of 3 arguments used.');

		// Bounded cases:
		// Case #1: Number,Array. Minimum valid rate (smallest positive number). 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(1E-307,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(1E-307,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -100, 'Test: Bounded case: Number,Array. Minimum valid rate (smallest positive number). 3 of 3 arguments used.');
		// Case #2: Number,Array. Maximum valid rate. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(9.99999999999999E+307,{100,-200},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(9.99999999999999E+307,{100,-200},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Bounded case: Number,Array. Maximum valid rate. 3 of 3 arguments used.');
		// Case #3: Number,Array. Minimum valid cash flow values. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{1E-307,-1E-307},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{1E-307,-1E-307},{38777,38838}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number,Array. Minimum valid cash flow values. 3 of 3 arguments used.');
		// Case #4: Number,Array. Maximum valid cash flow values. 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{9.99999999999999E+307,-9.99999999999999E+307},{38777,38838})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{9.99999999999999E+307,-9.99999999999999E+307},{38777,38838}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5802362123595948e+306, 'Test: Bounded case: Number,Array. Maximum valid cash flow values. 3 of 3 arguments used.');
		// Case #5: Number,Array. Minimum valid Excel dates (1/1/1900 + 1). 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},{2,3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},{2,3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -99.94778206191222, 'Test: Bounded case: Number,Array. Minimum valid Excel dates (1/1/1900 + 1). 3 of 3 arguments used.');
		// Case #6: Number,Array. Maximum valid Excel dates (12/31/9999). 3 of 3 arguments used.
		oParser = new parserFormula('XNPV(0.1,{100,-200},{2958465,2958466})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: XNPV(0.1,{100,-200},{2958465,2958466}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number,Array. Maximum valid Excel dates (12/31/9999). 3 of 3 arguments used.');

		// Need to fix: empty handle, diff results from MS
		// Case #8: Name,Array. Rate as named range. 3 of 3 arguments used.
		// Case #9: Name3D,Array. Rate as 3D named range. 3 of 3 arguments used.
		// Case #4: Number,Array. Dates not in chronological order (second date before first) returns #NUM!. 3 of 3 arguments used.
		// Case #9: Empty,Array. Empty rate returns #VALUE!. 3 of 3 arguments used.
		// Case #10: Number,Empty,Array. Empty values argument returns #VALUE!. 3 of 3 arguments used.
		// Case #11: Number,Array,Empty. Empty dates argument returns #VALUE!. 3 of 3 arguments used.
		// Case #12: Boolean,Array. Boolean rate (FALSE = 0) may cause unexpected results or #NUM!. 3 of 3 arguments used.
		// Case #16: Number,Name,Array. Values as named range with area returns #VALUE!. 3 of 3 arguments used.
		// Case #17: Number,Array,Name3D. Dates as 3D named range with area returns #VALUE!. 3 of 3 arguments used.
		// Case #18: Number,Table,Array. Table column with text values returns #VALUE!. 3 of 3 arguments used.
		// Case #3: Number,Array. Minimum valid cash flow values. 3 of 3 arguments used.

	});

	QUnit.test("Test: \"YIELD\"", function (assert) {

		oParser = new parserFormula("YIELD(DATE(2008,2,15),DATE(2016,11,15),0.0575,95.04287,100,2,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), _getYield(new cDate(Date.UTC(2008, 1, 15)), new cDate(Date.UTC(2016, 10, 15)), 0.0575, 95.04287, 100, 2, 0));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("38777");
		ws.getRange2("A101").setValue("38838");
		ws.getRange2("A104").setValue("110");
		// For area
		ws.getRange2("A102").setValue("0.1");
		ws.getRange2("A103").setValue("110");
		ws.getRange2("A105").setValue("2");
		ws.getRange2("A106").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(7). All arguments are numbers. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09677419354838754, 'Test: Positive case: Number(7). All arguments are numbers. 7 of 7 arguments used.');
		// Case #2: Formula(2), Number(5). Dates filled by DATE formula. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(DATE(2006,3,1),DATE(2006,5,1),0.1,110,110,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(DATE(2006,3,1),DATE(2006,5,1),0.1,110,110,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08823529411764741, 'Test: Positive case: Formula(2), Number(5). Dates filled by DATE formula. 7 of 7 arguments used.');
		// Case #3: Formula(2), Number(4). Dates filled by DATE, basis omitted. 6 of 7 arguments used.
		oParser = new parserFormula('YIELD(DATE(2006,3,1),DATE(2006,5,1),0.1,110,110,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(DATE(2006,3,1),DATE(2006,5,1),0.1,110,110,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08823529411764741, 'Test: Positive case: Formula(2), Number(4). Dates filled by DATE, basis omitted. 6 of 7 arguments used.');
		// Case #4: String(2), Number(5). Dates as strings. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD("03/01/2006","05/01/2006",01,110,110,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD("03/01/2006","05/01/2006",01,110,110,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.6976744186046512, 'Test: Positive case: String(2), Number(5). Dates as strings. 7 of 7 arguments used.');
		// Case #5: Formula(3), Number(4). Nested IF and SQRT for arguments. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),SQRT(0.01),110,110,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),SQRT(0.01),110,110,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08823529411764741, 'Test: Positive case: Formula(3), Number(4). Nested IF and SQRT for arguments. 7 of 7 arguments used.');
		// Case #6: Reference link(7). All arguments as reference links. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(A100,A101,A102,A103,A104,A105,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(A100,A101,A102,A103,A104,A105,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08823529411764741, 'Test: Positive case: Reference link(7). All arguments as reference links. 7 of 7 arguments used.');
		// Case #7: Area(7). All arguments as single-cell ranges. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105,A106:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.08823529411764741, 'Test: Positive case: Area(7). All arguments as single-cell ranges. 7 of 7 arguments used.');
		// Case #8: Array(7). All arguments as single-element arrays. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD({38777},{38838},{0.1},{100},{100},{2},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD({38777},{38838},{0.1},{100},{100},{2},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09677419354838754, 'Test: Positive case: Array(7). All arguments as single-element arrays. 7 of 7 arguments used.');
		// Case #9: Name(7). All arguments as named ranges. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(TestName,TestName1,TestName2,TestName3,TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(TestName,TestName1,TestName2,TestName3,TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(7). All arguments as named ranges. 7 of 7 arguments used.');
		// Case #10: Name3D(7). All arguments as 3D named ranges. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(7). All arguments as 3D named ranges. 7 of 7 arguments used.');
		// Case #11: Ref3D(7). All arguments as 3D references. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6,Sheet2!A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(7). All arguments as 3D references. 7 of 7 arguments used.');
		// Case #12: Area3D(7). All arguments as 3D single-cell ranges. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6,Sheet2!A7:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(7). All arguments as 3D single-cell ranges. 7 of 7 arguments used.');
		// Case #14: Formula(2), String(2), Number(3). Dates as formulas, rate and pr as strings. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(DATE(2025,5,1),DATE(2025,6,1),"0.1","100",100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(DATE(2025,5,1),DATE(2025,6,1),"0.1","100",100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '0.096', 'Test: Positive case: Formula(2), String(2), Number(3). Dates as formulas, rate and pr as strings. 7 of 7 arguments used.');
		// Case #15: Formula, Number(6). YIELD inside SUM formula. 7 of 7 arguments used.
		oParser = new parserFormula('SUM(YIELD(38777,38838,0.1,100,100,2,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(YIELD(38777,38838,0.1,100,100,2,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10.096774193548388, 'Test: Positive case: Formula, Number(6). YIELD inside SUM formula. 7 of 7 arguments used.');
		// Case #16: Number(6), Empty. Basis omitted. 6 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,100,100,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,100,100,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09677419354838754, 'Test: Positive case: Number(6), Empty. Basis omitted. 6 of 7 arguments used.');
		// Case #17: Array(7). Arrays with multiple elements. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD({38777,45792},{38838,45793},{0.1,0.2},{100,110},{100,110},{2,3},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD({38777,45792},{38838,45793},{0.1,0.2},{100,110},{100,110},{2,3},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09677419354838754, 'Test: Positive case: Array(7). Arrays with multiple elements. 7 of 7 arguments used.');
		// Case #18: Number(7). All arguments as float numbers. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777.5,38838.5,0.75,100.5,100.5,2.5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777.5,38838.5,0.75,100.5,100.5,2.5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5976095617529882, 'Test: Positive case: Number(7). All arguments as float numbers. 7 of 7 arguments used.');
		// Case #19: Formula(7). All arguments filled with formulas. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(DATE(2025,5,1),DATE(2025,6,1),SQRT(0.01),ROUND(100,0),ROUND(100,0),ABS(2),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(DATE(2025,5,1),DATE(2025,6,1),SQRT(0.01),ROUND(100,0),ROUND(100,0),ABS(2),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '0.096', 'Test: Positive case: Formula(7). All arguments filled with formulas. 7 of 7 arguments used.');
		// Case #20: Reference link(2), Number(5). Settlement and maturity as reference links. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(A100,A101,0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(A100,A101,0.1,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09677419354838754, 'Test: Positive case: Reference link(2), Number(5). Settlement and maturity as reference links. 7 of 7 arguments used.');
		// Case #21: Date(2), Number(5). Dates as DATE formulas. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(DATE(2025,5,1),DATE(2025,6,1),0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(DATE(2025,5,1),DATE(2025,6,1),0.1,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '0.096', 'Test: Positive case: Date(2), Number(5). Dates as DATE formulas. 7 of 7 arguments used.');
		// Case #22: Time, Formula, Number(5). Settlement as TIME adjusted to valid date. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(TIME(12,0,0)+38777,DATE(2025,6,1),0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(TIME(12,0,0)+38777,DATE(2025,6,1),0.1,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09996402806913697, 'Test: Positive case: Time, Formula, Number(5). Settlement as TIME adjusted to valid date. 7 of 7 arguments used.');

		// Negative cases:
		// Case #1: Number(6), Empty. Basis omitted but valid. 6 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,100,100,2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,100,100,2,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09677419354838754, 'Test: Negative case: Number(6), Empty. Basis omitted but valid. 6 of 7 arguments used.');
		// Case #2: Number(7). Settlement >= maturity, returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38838,38777,0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38838,38777,0.1,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(7). Settlement >= maturity, returns #NUM!. 7 of 7 arguments used.');
		// Case #3: Number(7). Negative rate, returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,-0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,-0.1,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(7). Negative rate, returns #NUM!. 7 of 7 arguments used.');
		// Case #4: Number(7). Price <= 0, returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,0,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,0,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(7). Price <= 0, returns #NUM!. 7 of 7 arguments used.');
		// Case #5: Number(7). Redemption <= 0, returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,100,0,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,100,0,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(7). Redemption <= 0, returns #NUM!. 7 of 7 arguments used.');
		// Case #6: Number(7). Invalid frequency (0), returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,100,100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,100,100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(7). Invalid frequency (0), returns #NUM!. 7 of 7 arguments used.');
		// Case #7: Number(7). Invalid frequency (5), returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,100,100,5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,100,100,5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(7). Invalid frequency (5), returns #NUM!. 7 of 7 arguments used.');
		// Case #8: Number(7). Invalid basis (-1), returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,100,100,2,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,100,100,2,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(7). Invalid basis (-1), returns #NUM!. 7 of 7 arguments used.');
		// Case #9: Number(7). Invalid basis (5), returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,100,100,2,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,100,100,2,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(7). Invalid basis (5), returns #NUM!. 7 of 7 arguments used.');
		// Case #10: String(7). Invalid date string, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD("abc","05/01/2006","0.1","100","100","2","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD("abc","05/01/2006","0.1","100","100","2","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(7). Invalid date string, returns #VALUE!. 7 of 7 arguments used.');
		// Case #11: String(7). Invalid maturity string, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD("03/01/2006","abc","0.1","100","100","2","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD("03/01/2006","abc","0.1","100","100","2","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(7). Invalid maturity string, returns #VALUE!. 7 of 7 arguments used.');
		// Case #12: String(7). Non-numeric rate string, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD("03/01/2006","05/01/2006","abc","100","100","2","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD("03/01/2006","05/01/2006","abc","100","100","2","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(7). Non-numeric rate string, returns #VALUE!. 7 of 7 arguments used.');
		// Case #13: String(7). Non-numeric price string, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD("03/01/2006","05/01/2006","0.1","abc","100","2","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD("03/01/2006","05/01/2006","0.1","abc","100","2","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(7). Non-numeric price string, returns #VALUE!. 7 of 7 arguments used.');
		// Case #14: Empty, Number(6). Empty settlement, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(,38838,0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(,38838,0.1,100,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(6). Empty settlement, returns #VALUE!. 7 of 7 arguments used.');
		// Case #15: Number, Empty, Number(5). Empty maturity, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,,0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,,0.1,100,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number(5). Empty maturity, returns #VALUE!. 7 of 7 arguments used.');
		// Case #16: Number(2), Empty, Number(4). Empty rate, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,,100,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty, Number(4). Empty rate, returns #VALUE!. 7 of 7 arguments used.');
		// Case #17: Number(3), Empty, Number(3). Empty price, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.1,,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.1,,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Empty, Number(3). Empty price, returns #VALUE!. 7 of 7 arguments used.');
		// Case #18: Boolean, Number(6). Boolean settlement, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(TRUE,38838,0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(TRUE,38838,0.1,100,100,2,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(6). Boolean settlement, returns #VALUE!. 7 of 7 arguments used.');
		// Case #19: Area, Number(6). Multi-cell range for settlement, returns #NUM!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(A100:A101,38838,0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(A100:A101,38838,0.1,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(6). Multi-cell range for settlement, returns #NUM!. 7 of 7 arguments used.');
		// Case #20: Name, Number(6). Named range with area, returns #VALUE!. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(TestNameArea,38838,0.1,100,100,2,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(TestNameArea,38838,0.1,100,100,2,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number(6). Named range with area, returns #VALUE!. 7 of 7 arguments used.');

		// Bounded cases:
		// Case #1: Number(7). Minimum valid values for rate, price, redemption. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(1,2,1E-152,1E-152,1E-152,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(1,2,1E-152,1E-152,1E-152,1,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(7). Minimum valid values for rate, price, redemption. 7 of 7 arguments used.');
		// Case #2: Formula(2), Number(5). Maximum valid values for dates, rate, price, redemption. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(DATE(9999,12,30),DATE(9999,12,31),1E+152,1E+152,1E+152,3,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(DATE(9999,12,30),DATE(9999,12,31),1E+152,1E+152,1E+152,3,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula(2), Number(5). Maximum valid values for dates, rate, price, redemption. 7 of 7 arguments used.');
		// Case #3: Number(7). Smallest positive values for rate, price, redemption. 7 of 7 arguments used.
		oParser = new parserFormula('YIELD(38777,38838,0.0000000001,0.0000000001,0.0000000001,1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELD(38777,38838,0.0000000001,0.0000000001,0.0000000001,1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1857707509881417, 'Test: Bounded case: Number(7). Smallest positive values for rate, price, redemption. 7 of 7 arguments used.');

		// Need to fix: error types diff, results diff from ms
		// Case #14: Empty, Number(6). Empty settlement, returns #VALUE!. 7 of 7 arguments used.
		// Case #15: Number, Empty, Number(5). Empty maturity, returns #VALUE!. 7 of 7 arguments used.
		// Case #16: Number(2), Empty, Number(4). Empty rate, returns #VALUE!. 7 of 7 arguments used.
		// Case #17: Number(3), Empty, Number(3). Empty price, returns #VALUE!. 7 of 7 arguments used.
		// Case #18: Boolean, Number(6). Boolean settlement, returns #VALUE!. 7 of 7 arguments used.
		// Case #1: Number(7). Minimum valid values for rate, price, redemption. 7 of 7 arguments used.


		testArrayFormula2(assert, "YIELD", 6, 7, true);
	});

	QUnit.test("Test: \"YIELDDISC\"", function (assert) {

		function yielddisc(settlement, maturity, pr, redemption, basis) {

			var fRet = (redemption / pr) - 1.0;
			fRet /= _yearFrac(settlement, maturity, basis);
			return fRet;

		}

		oParser = new parserFormula("YIELDDISC(DATE(2008,2,16),DATE(2008,3,1),99.795,100,2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), yielddisc(new cDate(2008, 1, 16), new cDate(2008, 2, 1), 99.795, 100, 2));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("38777");
		ws.getRange2("A101").setValue("38838");
		ws.getRange2("A104").setValue("100");
		// For area
		ws.getRange2("A102").setValue("38776");
		ws.getRange2("A103").setValue("0.05");
		ws.getRange2("A105").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number(5). All arguments are numbers. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,100,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(5). All arguments are numbers. 5 of 5 arguments used.');
		// Case #2: Formula(2), Number(3). Dates filled by DATE formula. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(DATE(2006,3,1),DATE(2006,5,1),110,110,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(DATE(2006,3,1),DATE(2006,5,1),110,110,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula(2), Number(3). Dates filled by DATE formula. 5 of 5 arguments used.');
		// Case #3: Formula(2), Number(2). Dates filled by DATE, basis omitted. 4 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(DATE(2006,3,1),DATE(2006,5,1),110,110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(DATE(2006,3,1),DATE(2006,5,1),110,110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula(2), Number(2). Dates filled by DATE, basis omitted. 4 of 5 arguments used.');
		// Case #4: String(2), Number(3). Dates as strings. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC("03/01/2006","05/01/2006",110,110,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC("03/01/2006","05/01/2006",110,110,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String(2), Number(3). Dates as strings. 5 of 5 arguments used.');
		// Case #5: Formula(3), Number(2). Nested IF and SQRT for arguments. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),SQRT(121),110,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),SQRT(121),110,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 54, 'Test: Positive case: Formula(3), Number(2). Nested IF and SQRT for arguments. 5 of 5 arguments used.');
		// Case #6: Reference link(5). All arguments as reference links. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(A100,A101,A102,A103,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(A100,A101,A102,A103,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link(5). All arguments as reference links. 5 of 5 arguments used.');
		// Case #7: Area(5). All arguments as single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area(5). All arguments as single-cell ranges. 5 of 5 arguments used.');
		// Case #8: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC({38777},{38838},{100},{100},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC({38777},{38838},{100},{100},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array(5). All arguments as single-element arrays. 5 of 5 arguments used.');
		// Case #9: Name(5). All arguments as named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(TestName,TestName1,TestName2,TestName3,TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(TestName,TestName1,TestName2,TestName3,TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(5). All arguments as named ranges. 5 of 5 arguments used.');
		// Case #10: Name3D(5). All arguments as 3D named ranges. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Name3D(5). All arguments as 3D named ranges. 5 of 5 arguments used.');
		// Case #11: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(5). All arguments as 3D references. 5 of 5 arguments used.');
		// Case #12: Area3D(5). All arguments as 3D single-cell ranges. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(5). All arguments as 3D single-cell ranges. 5 of 5 arguments used.');
		// Case #14: Formula(2), String(2), Number. Dates as formulas, pr and redemption as strings. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(DATE(2025,5,1),DATE(2025,6,1),"100","100",0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(DATE(2025,5,1),DATE(2025,6,1),"100","100",0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula(2), String(2), Number. Dates as formulas, pr and redemption as strings. 5 of 5 arguments used.');
		// Case #15: Formula, Number(4). YIELDDISC inside SUM formula. 5 of 5 arguments used.
		oParser = new parserFormula('SUM(YIELDDISC(38777,38838,100,100,0),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(YIELDDISC(38777,38838,100,100,0),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula, Number(4). YIELDDISC inside SUM formula. 5 of 5 arguments used.');
		// Case #16: Number(4), Empty. Basis omitted. 4 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,100,100,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,100,100,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(4), Empty. Basis omitted. 4 of 5 arguments used.');
		// Case #17: Array(5). Arrays with multiple elements. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC({38777,45792},{38838,45793},{100,110},{100,110},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC({38777,45792},{38838,45793},{100,110},{100,110},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array(5). Arrays with multiple elements. 5 of 5 arguments used.');
		// Case #18: Number(5). All arguments as float numbers. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777.5,38838.5,100.5,100.5,0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777.5,38838.5,100.5,100.5,0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(5). All arguments as float numbers. 5 of 5 arguments used.');
		// Case #19: Formula(5). All arguments filled with formulas. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(DATE(2025,5,1),DATE(2025,6,1),ROUND(100,0),ROUND(100,0),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(DATE(2025,5,1),DATE(2025,6,1),ROUND(100,0),ROUND(100,0),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula(5). All arguments filled with formulas. 5 of 5 arguments used.');
		// Case #20: Reference link(2), Number(3). Settlement and maturity as reference links. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(A100,A101,100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(A100,A101,100,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link(2), Number(3). Settlement and maturity as reference links. 5 of 5 arguments used.');
		// Case #21: Date(2), Number(3). Dates as DATE formulas. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(DATE(2025,5,1),DATE(2025,6,1),100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(DATE(2025,5,1),DATE(2025,6,1),100,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date(2), Number(3). Dates as DATE formulas. 5 of 5 arguments used.');
		// Case #22: Time, Formula, Number(3). Settlement as TIME adjusted to valid date. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(TIME(12,0,0)+38777,DATE(2025,6,1),100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(TIME(12,0,0)+38777,DATE(2025,6,1),100,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time, Formula, Number(3). Settlement as TIME adjusted to valid date. 5 of 5 arguments used.');

		// Negative cases:
		// Case #1: Number(5). Settlement >= maturity, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38838,38777,100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38838,38777,100,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Settlement >= maturity, returns #NUM!. 5 of 5 arguments used.');
		// Case #2: Number(5). Price <= 0, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,0,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,0,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Price <= 0, returns #NUM!. 5 of 5 arguments used.');
		// Case #3: Number(5). Redemption <= 0, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,100,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,100,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Redemption <= 0, returns #NUM!. 5 of 5 arguments used.');
		// Case #4: Number(5). Invalid basis (-1), returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,100,100,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,100,100,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Invalid basis (-1), returns #NUM!. 5 of 5 arguments used.');
		// Case #5: Number(5). Invalid basis (5), returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,100,100,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,100,100,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(5). Invalid basis (5), returns #NUM!. 5 of 5 arguments used.');
		// Case #6: String(5). Invalid date string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC("abc","05/01/2006","100","100","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC("abc","05/01/2006","100","100","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Invalid date string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #7: String(5). Invalid maturity string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC("03/01/2006","abc","100","100","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC("03/01/2006","abc","100","100","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Invalid maturity string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #8: String(5). Non-numeric price string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC("03/01/2006","05/01/2006","abc","100","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC("03/01/2006","05/01/2006","abc","100","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Non-numeric price string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #9: String(5). Non-numeric redemption string, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC("03/01/2006","05/01/2006","100","abc","0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC("03/01/2006","05/01/2006","100","abc","0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(5). Non-numeric redemption string, returns #VALUE!. 5 of 5 arguments used.');
		// Case #10: Empty, Number(4). Empty settlement, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(,38838,100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(,38838,100,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number(4). Empty settlement, returns #VALUE!. 5 of 5 arguments used.');
		// Case #11: Number, Empty, Number(3). Empty maturity, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,,100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,,100,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty, Number(3). Empty maturity, returns #VALUE!. 5 of 5 arguments used.');
		// Case #12: Number(2), Empty, Number(2). Empty price, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Empty, Number(2). Empty price, returns #VALUE!. 5 of 5 arguments used.');
		// Case #13: Number(3), Empty, Number. Empty redemption, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,100,,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,100,,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(3), Empty, Number. Empty redemption, returns #VALUE!. 5 of 5 arguments used.');
		// Case #14: Boolean, Number(4). Boolean settlement, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(TRUE,38838,100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(TRUE,38838,100,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number(4). Boolean settlement, returns #VALUE!. 5 of 5 arguments used.');
		// Case #15: Area, Number(4). Multi-cell range for settlement, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(A100:A101,38838,100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(A100:A101,38838,100,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number(4). Multi-cell range for settlement, returns #NUM!. 5 of 5 arguments used.');
		// Case #16: Name, Number(4). Named range with area, returns #VALUE!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(TestNameArea,38838,100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(TestNameArea,38838,100,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number(4). Named range with area, returns #VALUE!. 5 of 5 arguments used.');
		// Case #17: Formula(2), Number(3). Settlement exceeds maximum valid date, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(DATE(9999,12,31)+1,DATE(9999,12,31),100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(DATE(9999,12,31)+1,DATE(9999,12,31),100,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2), Number(3). Settlement exceeds maximum valid date, returns #NUM!. 5 of 5 arguments used.');
		// Case #18: Number, Area, Number(3). Multi-cell range for maturity, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,A100:A101,100,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,A100:A101,100,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area, Number(3). Multi-cell range for maturity, returns #NUM!. 5 of 5 arguments used.');
		// Case #19: Number(2), Array, Number(2). Price as array with boolean, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,{FALSE},100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,{FALSE},100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Array, Number(2). Price as array with boolean, returns #NUM!. 5 of 5 arguments used.');
		// Case #20: Number(3), Array, Number. Redemption as array with boolean, returns #NUM!. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,100,{FALSE},0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,100,{FALSE},0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3), Array, Number. Redemption as array with boolean, returns #NUM!. 5 of 5 arguments used.');

		// Bounded cases:
		// Case #1: Number(5). Minimum valid values for price, redemption. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(1,2,1E-152,1E-152,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(1,2,1E-152,1E-152,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(5). Minimum valid values for price, redemption. 5 of 5 arguments used.');
		// Case #2: Formula(2), Number(3). Maximum valid values for dates, price, redemption. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(DATE(9999,12,30),DATE(9999,12,31),1E+152,1E+152,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(DATE(9999,12,30),DATE(9999,12,31),1E+152,1E+152,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Formula(2), Number(3). Maximum valid values for dates, price, redemption. 5 of 5 arguments used.');
		// Case #3: Number(5). Smallest positive values for price, redemption. 5 of 5 arguments used.
		oParser = new parserFormula('YIELDDISC(38777,38838,0.0000000001,0.0000000001,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDDISC(38777,38838,0.0000000001,0.0000000001,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(5). Smallest positive values for price, redemption. 5 of 5 arguments used.');

		// Need to fix: error type diff
		// Case #10: Empty, Number(4). Empty settlement, returns #VALUE!. 5 of 5 arguments used.
		// Case #11: Number, Empty, Number(3). Empty maturity, returns #VALUE!. 5 of 5 arguments used.
		// Case #12: Number(2), Empty, Number(2). Empty price, returns #VALUE!. 5 of 5 arguments used.
		// Case #13: Number(3), Empty, Number. Empty redemption, returns #VALUE!. 5 of 5 arguments used.
		// Case #14: Boolean, Number(4). Boolean settlement, returns #VALUE!. 5 of 5 arguments used.
		// Case #19: Number(2), Array, Number(2). Price as array with boolean, returns #NUM!. 5 of 5 arguments used.
		// Case #20: Number(3), Array, Number. Redemption as array with boolean, returns #NUM!. 5 of 5 arguments used.


		testArrayFormula2(assert, "YIELDDISC", 4, 5, true);
	});

	QUnit.test("Test: \"YIELDMAT\"", function (assert) {

		oParser = new parserFormula("YIELDMAT(DATE(2008,3,15),DATE(2008,11,3),DATE(2007,11,8),0.0625,100.0123,0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), _getyieldmat(new cDate(2008, 2, 15), new cDate(2008, 10, 3), new cDate(2007, 10, 8), 0.0625, 100.0123, 0));

		// Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("38777");
		ws.getRange2("A101").setValue("38838");
		ws.getRange2("A104").setValue("100");
		// For area
		ws.getRange2("A102").setValue("38776");
		ws.getRange2("A103").setValue("0.05");
		ws.getRange2("A105").setValue("0");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number(6). Valid numeric inputs, basis 0. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38838,38776,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38838,38776,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: Number(6). Valid numeric inputs, basis 0. 6 of 6 arguments used.');
		// Case #2: Formula(3), Number(3). Dates as formulas, valid rate and price. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,2,28),0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(DATE(2006,3,1),DATE(2006,5,1),DATE(2006,2,28),0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: Formula(3), Number(3). Dates as formulas, valid rate and price. 6 of 6 arguments used.');
		// Case #3: String(3), Number(3). String dates in MM/DD/YYYY format, valid inputs. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT("03/01/2006","05/01/2006","02/28/2006",0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT("03/01/2006","05/01/2006","02/28/2006",0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: String(3), Number(3). String dates in MM/DD/YYYY format, valid inputs. 6 of 6 arguments used.');
		// Case #4: Reference link(6). All arguments as reference links. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(A100,A101,A102,A103,A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(A100,A101,A102,A103,A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: Reference link(6). All arguments as reference links. 6 of 6 arguments used.');
		// Case #5: Array(6). Single-element arrays for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT({38777},{38838},{38776},{0.05},{100},{0})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT({38777},{38838},{38776},{0.05},{100},{0}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: Array(6). Single-element arrays for all arguments. 6 of 6 arguments used.');
		// Case #6: Formula(3), Number(3). Nested IF for settlement, basis 1. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),DATE(2006,2,28),0.05,100,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(IF(TRUE,DATE(2006,3,1),DATE(2000,1,1)),DATE(2006,5,1),DATE(2006,2,28),0.05,100,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.049993151623065134, 'Test: Positive case: Formula(3), Number(3). Nested IF for settlement, basis 1. 6 of 6 arguments used.');
		// Case #7: Ref3D(6). 3D references for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(Sheet2!A1,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Ref3D(6). 3D references for all arguments. 6 of 6 arguments used.');
		// Case #8: Name(6). Named ranges for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(TestName,TestName1,TestName2,TestName3,TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(TestName,TestName1,TestName2,TestName3,TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name(6). Named ranges for all arguments. 6 of 6 arguments used.');
		// Case #9: Name3D(6). 3D named ranges for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(TestName3D,TestName3D,TestName3D,TestName3D,TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D(6). 3D named ranges for all arguments. 6 of 6 arguments used.');
		// Case #10: Area(6). Single-cell ranges for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(A100:A100,A101:A101,A102:A102,A103:A103,A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: Area(6). Single-cell ranges for all arguments. 6 of 6 arguments used.');
		// Case #11: Area3D(6). 3D single-cell ranges for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area3D(6). 3D single-cell ranges for all arguments. 6 of 6 arguments used.');
		// Case #12: Table. Table structured references for all arguments. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1],Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!", 'Test: Positive case: Table. Table structured references for all arguments. 6 of 6 arguments used.');
		// Case #13: String(3), Number(3). Short date strings, basis 2. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT("5/5/2006","6/5/2006","4/5/2006",0.05,100,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT("5/5/2006","6/5/2006","4/5/2006",0.05,100,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04979253112033177, 'Test: Positive case: String(3), Number(3). Short date strings, basis 2. 6 of 6 arguments used.');
		// Case #14: Formula(6). All arguments as formulas. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),SQRT(0.0025),ROUND(100,0),ABS(0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(DATE(2025,5,20),DATE(2025,6,30),DATE(2025,4,1),SQRT(0.0025),ROUND(100,0),ABS(0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04966202234791073, 'Test: Positive case: Formula(6). All arguments as formulas. 6 of 6 arguments used.');
		// Case #15: Number(5). Basis omitted, valid inputs. 5 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38838,38776,0.05,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38838,38776,0.05,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: Number(5). Basis omitted, valid inputs. 5 of 6 arguments used.');
		// Case #16: Formula, Number(5). Settlement as SUM formula, basis 3. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(SUM(38777,1),38838,38776,0.05,100,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(SUM(38777,1),38838,38776,0.05,100,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04998630512188555, 'Test: Positive case: Formula, Number(5). Settlement as SUM formula, basis 3. 6 of 6 arguments used.');
		// Case #17: Array(6). Multi-element arrays, valid inputs. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT({38777,39448},{38838,39509},{38776,39447},{0.05,0.06},{100,200},{0,1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT({38777,39448},{38838,39509},{38776,39447},{0.05,0.06},{100,200},{0,1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: Array(6). Multi-element arrays, valid inputs. 6 of 6 arguments used.');
		// Case #18: String(4), Number(2). Rate as string convertible to number, basis 4. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT("03/01/2006","05/01/2006","02/28/2006","0.05",100,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT("03/01/2006","05/01/2006","02/28/2006","0.05",100,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.049979175343607185, 'Test: Positive case: String(4), Number(2). Rate as string convertible to number, basis 4. 6 of 6 arguments used.');
		// Case #19: Number(6). Larger price value, valid inputs. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(39448,39509,39447,0.06,200,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(39448,39509,39447,0.06,200,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.9205762907735835, 'Test: Positive case: Number(6). Larger price value, valid inputs. 6 of 6 arguments used.');
		// Case #20: Formula(3), Number(2), Formula. Basis as TIME formula adjusted to 0. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(DATE(2025,1,1),DATE(2025,6,30),DATE(2024,12,1),0.05,100,TIME(0,0,0)+0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(DATE(2025,1,1),DATE(2025,6,30),DATE(2024,12,1),0.05,100,TIME(0,0,0)+0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04979253112033222, 'Test: Positive case: Formula(3), Number(2), Formula. Basis as TIME formula adjusted to 0. 6 of 6 arguments used.');
		// Case #21: Reference link, Number(5). Settlement as reference link. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(A100,38838,38776,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(A100,38838,38776,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: Reference link, Number(5). Settlement as reference link. 6 of 6 arguments used.');
		// Case #22: Formula(3), Number(3). Settlement date with decimal (truncated to integer). 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(DATE(2006,3,1.5),DATE(2006,5,1),DATE(2006,2,28),0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(DATE(2006,3,1.5),DATE(2006,5,1),DATE(2006,2,28),0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04999305651992758, 'Test: Positive case: Formula(3), Number(3). Settlement date with decimal (truncated to integer). 6 of 6 arguments used.');

		// Negative cases:
		// Case #1: Number(6). Settlement equals maturity returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38777,38776,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38777,38776,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Settlement equals maturity returns #NUM!. 6 of 6 arguments used.');
		// Case #2: Number(6). Settlement > maturity returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38776,38776,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38776,38776,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Settlement > maturity returns #NUM!. 6 of 6 arguments used.');
		// Case #3: Number(6). Negative rate returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38838,38776,-0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38838,38776,-0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative rate returns #NUM!. 6 of 6 arguments used.');
		// Case #4: Number(6). Negative price returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38838,38776,0.05,-100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38838,38776,0.05,-100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative price returns #NUM!. 6 of 6 arguments used.');
		// Case #5: Number(6). Invalid basis (5) returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38838,38776,0.05,100,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38838,38776,0.05,100,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Invalid basis (5) returns #NUM!. 6 of 6 arguments used.');
		// Case #6: Number(6). Negative basis returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38838,38776,0.05,100,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38838,38776,0.05,100,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Negative basis returns #NUM!. 6 of 6 arguments used.');
		// Case #7: String(6). Invalid settlement string returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT("abc","05/01/2006","02/28/2006",0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT("abc","05/01/2006","02/28/2006",0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Invalid settlement string returns #VALUE!. 6 of 6 arguments used.');
		// Case #8: String(6). Invalid maturity string returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT("03/01/2006","abc","02/28/2006",0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT("03/01/2006","abc","02/28/2006",0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Invalid maturity string returns #VALUE!. 6 of 6 arguments used.');
		// Case #9: String(6). Invalid issue string returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT("03/01/2006","05/01/2006","abc",0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT("03/01/2006","05/01/2006","abc",0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Invalid issue string returns #VALUE!. 6 of 6 arguments used.');
		// Case #10: Area(6). Multi-cell range for settlement returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(A100:A101,A101:A101,A102:A102,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(A100:A101,A101:A101,A102:A102,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(6). Multi-cell range for settlement returns #NUM!. 6 of 6 arguments used.');
		// Case #11: Empty(6). Empty settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(,38838,38776,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(,38838,38776,0.05,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(6). Empty settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #12: String(6). Empty string for settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT("","05/01/2006","02/28/2006",0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT("","05/01/2006","02/28/2006",0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(6). Empty string for settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #13: Formula(6). Settlement date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(DATE(9999,12,31)+1,DATE(9999,12,31),DATE(9999,11,30),0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(DATE(9999,12,31)+1,DATE(9999,12,31),DATE(9999,11,30),0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(6). Settlement date beyond Excel limit returns #NUM!. 6 of 6 arguments used.');
		// Case #14: Formula(6). Maturity date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(DATE(2006,3,1),DATE(9999,12,31)+1,DATE(2006,2,28),0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(DATE(2006,3,1),DATE(9999,12,31)+1,DATE(2006,2,28),0.05,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(6). Maturity date beyond Excel limit returns #NUM!. 6 of 6 arguments used.');
		// Case #15: Formula(6). Issue date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(DATE(2006,3,1),DATE(2006,5,1),DATE(9999,12,31)+1,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(DATE(2006,3,1),DATE(2006,5,1),DATE(9999,12,31)+1,0.05,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(6). Issue date beyond Excel limit returns #NUM!. 6 of 6 arguments used.');
		// Case #16: Ref3D(6). 3D reference to non-numeric settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(Sheet2!A7,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(Sheet2!A7,Sheet2!A2,Sheet2!A3,Sheet2!A4,Sheet2!A5,Sheet2!A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(6). 3D reference to non-numeric settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #17: Name(6). Named range with non-numeric settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(TestNameArea,TestName1,TestName2,TestName3,TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(TestNameArea,TestName1,TestName2,TestName3,TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name(6). Named range with non-numeric settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #18: Table(6). Table with non-numeric settlement returns #VALUE!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table(6). Table with non-numeric settlement returns #VALUE!. 6 of 6 arguments used.');
		// Case #19: Number(6). Zero rate returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38838,38776,0,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38838,38776,0,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Number(6). Zero rate returns #NUM!. 6 of 6 arguments used.');
		// Case #20: Number(6). Zero price returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(38777,38838,38776,0.05,0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(38777,38838,38776,0.05,0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(6). Zero price returns #NUM!. 6 of 6 arguments used.');
		// Case #21: Area3D(6). 3D multi-cell range for settlement returns #NUM!. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(Sheet2!A1:A2,Sheet2!A2:A2,Sheet2!A3:A3,Sheet2!A4:A4,Sheet2!A5:A5,Sheet2!A6:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(6). 3D multi-cell range for settlement returns #NUM!. 6 of 6 arguments used.');
		// Case #22: Formula(6). Settlement as invalid formula (returns #NUM!) propagates error. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(SQRT(-1),38838,38776,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(SQRT(-1),38838,38776,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(6). Settlement as invalid formula (returns #NUM!) propagates error. 6 of 6 arguments used.');

		// Bounded cases:
		// Case #1: Number(6). Minimum valid Excel date (Jan 1, 1900) and smallest positive rate/price. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(1,2,1,1E-152,1E-152,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(1,2,1,1E-152,1E-152,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(6). Minimum valid Excel date (Jan 1, 1900) and smallest positive rate/price. 6 of 6 arguments used.');
		// Case #2: Formula(3), Number(3). Maximum valid Excel date (Dec 31, 9999) and largest valid rate/price. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(DATE(9999,12,30),DATE(9999,12,31),DATE(9999,11,30),1E+152,1E+152,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(DATE(9999,12,30),DATE(9999,12,31),DATE(9999,11,30),1E+152,1E+152,4) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Formula(3), Number(3). Maximum valid Excel date (Dec 31, 9999) and largest valid rate/price. 6 of 6 arguments used.');
		// Case #3: Number(6). Settlement and issue at minimum Excel date (Jan 1, 1900), maturity at Jan 1, 1901. 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(1,366,1,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(1,366,1,0.05,100,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number(6). Settlement and issue at minimum Excel date (Jan 1, 1900), maturity at Jan 1, 1901. 6 of 6 arguments used.');
		// Case #4: Number(6). Settlement, maturity, and issue at maximum Excel dates (Dec 30, 9999 to Dec 31, 9999). 6 of 6 arguments used.
		oParser = new parserFormula('YIELDMAT(2958100,2958465,2958099,0.05,100,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: YIELDMAT(2958100,2958465,2958099,0.05,100,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2), '0.05', 'Test: Bounded case: Number(6). Settlement, maturity, and issue at maximum Excel dates (Dec 30, 9999 to Dec 31, 9999). 6 of 6 arguments used.');

		// Need to fix: error types diff, boundary cases
		// Case #11: Empty(6). Empty settlement returns #VALUE!. 6 of 6 arguments used.
		// Case #14: Formula(6). Maturity date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		// Case #15: Formula(6). Issue date beyond Excel limit returns #NUM!. 6 of 6 arguments used.
		// Case #19: Number(6). Zero rate returns #NUM!. 6 of 6 arguments used.
		// Case #1: Number(6). Minimum valid Excel date (Jan 1, 1900) and smallest positive rate/price. 6 of 6 arguments used.
		// Case #2: Formula(3), Number(3). Maximum valid Excel date (Dec 31, 9999) and largest valid rate/price. 6 of 6 arguments used.
		// Case #3: Number(6). Settlement and issue at minimum Excel date (Jan 1, 1900), maturity at Jan 1, 1901. 6 of 6 arguments used.


		testArrayFormula2(assert, "YIELDMAT", 5, 6, true);
	});

	wb.dependencyFormulas.unlockRecal();
});
