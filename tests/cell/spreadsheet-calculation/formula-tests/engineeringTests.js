/*
 * (c) Copyright Ascensio System SIA 2010-2025
 *
 * This program is a free software product. You can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License (AGPL)
 * version 3 as published by the Free Software Foundation. In accordance with
 * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect
 * that Ascensio System SIA expressly excludes the warranty of non-infringement
 * of any third-party rights.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For
 * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html
 *
 * You can contact Ascensio System SIA at 20A-6 Ernesta Birznieka-Upish
 * street, Riga, Latvia, EU, LV-1050.
 *
 * The  interactive user interfaces in modified source and object code versions
 * of the Program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU AGPL version 3.
 *
 * Pursuant to Section 7(b) of the License you must retain the original Product
 * logo when distributing the program. Pursuant to Section 7(e) we decline to
 * grant you any rights under trademark law for use of our trademarks.
 *
 * All the Product's GUI elements, including illustrations and icon sets, as
 * well as technical writing content are licensed under the terms of the
 * Creative Commons Attribution-ShareAlike 4.0 International. See the License
 * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode
 *
 */


$(function () {
	// Mocks for API Testing
	Asc.spreadsheet_api.prototype._init = function () {
		this._loadModules();
	};
	Asc.spreadsheet_api.prototype._loadFonts = function (fonts, callback) {
		callback();
	};
	AscCommonExcel.WorkbookView.prototype._calcMaxDigitWidth = function () {
	};
	AscCommonExcel.WorkbookView.prototype._init = function () {
	};
	AscCommonExcel.WorkbookView.prototype._isLockedUserProtectedRange = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorkbookView.prototype._onWSSelectionChanged = function () {
	};
	AscCommonExcel.WorkbookView.prototype.showWorksheet = function () {
	};
	AscCommonExcel.WorkbookView.prototype.recalculateDrawingObjects = function () {
	};
	AscCommonExcel.WorkbookView.prototype.restoreFocus = function () {
	};
	AscCommonExcel.WorksheetView.prototype._init = function () {
	};
	AscCommonExcel.WorksheetView.prototype.updateRanges = function () {
	};
	AscCommonExcel.WorksheetView.prototype._autoFitColumnsWidth = function () {
	};
	AscCommonExcel.WorksheetView.prototype.cleanSelection = function () {
	};
	AscCommonExcel.WorksheetView.prototype._drawSelection = function () {
	};
	AscCommonExcel.WorksheetView.prototype._scrollToRange = function () {
	};
	AscCommonExcel.WorksheetView.prototype.draw = function () {
	};
	AscCommonExcel.WorksheetView.prototype._prepareDrawingObjects = function () {
	};
	AscCommonExcel.WorksheetView.prototype._initCellsArea = function () {
	};
	AscCommonExcel.WorksheetView.prototype.getZoom = function () {
	};
	AscCommonExcel.WorksheetView.prototype._prepareCellTextMetricsCache = function () {
	};

	AscCommon.baseEditorsApi.prototype._onEndLoadSdk = function () {
	};

	AscCommon.baseEditorsApi.prototype._onEndLoadSdk = function () {
	};
	Asc.ReadDefTableStyles = function () {
	};
	AscCommonExcel.WorksheetView.prototype._isLockedCells = function (oFromRange, subType, callback) {
		callback(true);
		return true;
	};
	AscCommonExcel.WorksheetView.prototype._isLockedAll = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorksheetView.prototype._isLockedFrozenPane = function (callback) {
		callback(true);
	};
	AscCommonExcel.WorksheetView.prototype._updateVisibleColsCount = function () {
	};
	AscCommonExcel.WorksheetView.prototype._calcActiveCellOffset = function () {
	};

	// Init basic data
	const parserFormula = AscCommonExcel.parserFormula;
	const g_oIdCounter = AscCommon.g_oIdCounter;
    const c_msPerDay = AscCommonExcel.c_msPerDay;
	const GetDiffDate360 = AscCommonExcel.GetDiffDate360;
	const fSortAscending = AscCommon.fSortAscending;
	const ParseResult = AscCommonExcel.ParseResult;
	const c_oAscError = Asc.c_oAscError;

	let oParser, wb, ws, sData = AscCommon.getEmpty(), tmp, dif = 1e-9;

	if (AscCommon.c_oSerFormat.Signature === sData.substring(0, AscCommon.c_oSerFormat.Signature.length)) {

		Asc.spreadsheet_api.prototype._init = function() {
			this.isLoadFullApi = true;
		};


		let api = new Asc.spreadsheet_api({
			'id-view': 'editor_sdk'
		});
		api.FontLoader = {
			LoadDocumentFonts: function () {
			}
		};

		let docInfo = new Asc.asc_CDocInfo();
		docInfo.asc_putTitle("TeSt.xlsx");
		api.DocInfo = docInfo;


		window["Asc"]["editor"] = api;
		AscCommon.g_oTableId.init(api);
		api._onEndLoadSdk();
		api.isOpenOOXInBrowser = false;
		api.OpenDocumentFromBin(null, AscCommon.getEmpty());
		api.initCollaborativeEditing({});
		wb = new AscCommonExcel.Workbook(new AscCommonExcel.asc_CHandlersList(), api, true);
		api.wbModel = wb;
		api.wb = new AscCommonExcel.WorkbookView(api.wbModel, api.controller, api.handlers, api.HtmlElement,
			api.topLineEditorElement, api, api.collaborativeEditing, api.fontRenderingMode);
		AscCommon.History.init(wb);
		// There is no operation with history, disabled to avoid unnecessary serializations.
		AscCommon.History.TurnOff();
		wb.maxDigitWidth = 7;
		wb.paddingPlusBorder = 5;

		api.initCollaborativeEditing({});

		if (this.User) {
			g_oIdCounter.Set_UserId(this.User.asc_getId());
		}

		AscCommonExcel.g_oUndoRedoCell = new AscCommonExcel.UndoRedoCell(wb);
		AscCommonExcel.g_oUndoRedoWorksheet = new AscCommonExcel.UndoRedoWoorksheet(wb);
		AscCommonExcel.g_oUndoRedoWorkbook = new AscCommonExcel.UndoRedoWorkbook(wb);
		AscCommonExcel.g_oUndoRedoCol = new AscCommonExcel.UndoRedoRowCol(wb, false);
		AscCommonExcel.g_oUndoRedoRow = new AscCommonExcel.UndoRedoRowCol(wb, true);
		AscCommonExcel.g_oUndoRedoComment = new AscCommonExcel.UndoRedoComment(wb);
		AscCommonExcel.g_oUndoRedoAutoFilters = new AscCommonExcel.UndoRedoAutoFilters(wb);
		AscCommonExcel.g_DefNameWorksheet = new AscCommonExcel.Worksheet(wb, -1);
		g_oIdCounter.Set_Load(false);

		const oBinaryFileReader = new AscCommonExcel.BinaryFileReader();
		oBinaryFileReader.Read(sData, wb);
		ws = wb.getWorksheet(wb.getActive());
		AscCommonExcel.getFormulasInfo();
	}

	// Init basic functions
	function testArrayFormula(assert, func, dNotSupportAreaArg) {

		const getValue = function (ref) {
			oParser = new parserFormula(func + "(" + ref + ")", "A2", ws);
			assert.ok(oParser.parse(), 'Formula is parsed');
			return oParser.calculate().getValue();
		};
		const description = `Test: testArrayFormula. ${func}. `;

		//***array-formula***
		ws.getRange2("A100").setValue("1");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("C100").setValue("-4");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B101").setValue("4");
		ws.getRange2("C101").setValue("5");


		oParser = new parserFormula(func + "(A100:C101)", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
		assert.ok(oParser.parse(), 'Formula is parsed.');
		let array = oParser.calculate();
		if (AscCommonExcel.cElementType.array === array.type) {
			assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue("A100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue("B100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue("C100"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 0).getValue(), getValue("A101"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 1).getValue(), getValue("B101"), description + 'Reference Link. Area.');
			assert.strictEqual(array.getElementRowCol(1, 2).getValue(), getValue("C101"), description + 'Reference Link. Area.');
		} else {
			if (!dNotSupportAreaArg) {
				assert.strictEqual(false, true, 'func: ' + func + ' don\'t support area argument.');
			}
			//consoleLog("func: " + func + " don't return area array");
		}

		oParser = new parserFormula(func + "({1,2,-3})", "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
		assert.ok(oParser.parse(), 'Formula is parsed.');
		array = oParser.calculate();
		assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue(1), description + 'Number.');
		assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue(2), description + 'Number.');
		assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue(-3), description + 'Number.');
	}
	//returnOnlyValue - those functions that must always be fed arrays as input and that return a single value
	function testArrayFormula2(assert, func, minArgCount, maxArgCount, dNotSupportAreaArg, returnOnlyValue) {

		const getValue = function (ref, countArg) {
			let argStr = "(";
			for (let j = 1; j <= countArg; j++) {
				argStr += ref;
				if (i !== j) {
					argStr += ",";
				} else {
					argStr += ")";
				}
			}
			oParser = new parserFormula(func + argStr, "A2", ws);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + argStr + ' is parsed.');
			return oParser.calculate().getValue();
		};


		//***array-formula***
		ws.getRange2("A100").setValue("1");
		ws.getRange2("B100").setValue("3");
		ws.getRange2("C100").setValue("-4");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("B101").setValue("4");
		ws.getRange2("C101").setValue("5");

		//формируем массив значений
		const randomArray = [];
		let randomStrArray = "{";
		let maxArg = 4;
		for (let i = 1; i <= maxArg; i++) {
			let randVal = Math.random();
			randomArray.push(randVal);
			randomStrArray += randVal;
			if (i !== maxArg) {
				randomStrArray += ",";
			} else {
				randomStrArray += "}";
			}
		}

		for (var i = minArgCount; i <= maxArgCount; i++) {
			let argStrArr = "(";
			let randomArgStrArr = "(";
			for (let j = 1; j <= i; j++) {
				argStrArr += "A100:C101";
				randomArgStrArr += randomStrArray;
				if (i !== j) {
					argStrArr += ",";
					randomArgStrArr += ",";
				} else {
					argStrArr += ")";
					randomArgStrArr += ")";
				}
			}

			oParser = new parserFormula(func + argStrArr, "A1", ws);
			oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + argStrArr + ' is parsed.');
			let array = oParser.calculate();
			if (AscCommonExcel.cElementType.array === array.type) {
				assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue("A100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue("B100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue("C100", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 0).getValue(), getValue("A101", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 1).getValue(), getValue("B101", i), 'Test: testArrayFormula2. Area.');
				assert.strictEqual(array.getElementRowCol(1, 2).getValue(), getValue("C101", i), 'Test: testArrayFormula2. Area.');
			} else {
				if (!(dNotSupportAreaArg || returnOnlyValue)) {
					assert.strictEqual(false, true);
				}
				//consoleLog("func: " + func + " don't return area array");
			}

			oParser = new parserFormula(func + randomArgStrArr, "A1", ws);
			oParser.setArrayFormulaRef(ws.getRange2("E106:H107").bbox);
			assert.ok(oParser.parse(), 'Test: Formula ' + func + randomArgStrArr + ' is parsed.');
			array = oParser.calculate();
			if (AscCommonExcel.cElementType.array === array.type) {
				assert.strictEqual(array.getElementRowCol(0, 0).getValue(), getValue(randomArray[0], i), 'Test: testArrayFormula2. Random array');
				assert.strictEqual(array.getElementRowCol(0, 1).getValue(), getValue(randomArray[1], i), 'Test: testArrayFormula2. Random array');
				assert.strictEqual(array.getElementRowCol(0, 2).getValue(), getValue(randomArray[2], i), 'Test: testArrayFormula2. Random array');
			} else {
				if (!returnOnlyValue) {
					assert.strictEqual(false, true);
				}
				//consoleLog("func: " + func + " don't return array");
			}
		}
	}

	function testArrayFormulaEqualsValues(assert, str, formula, isNotLowerCase) {
		//***array-formula***
		ws.getRange2("A1").setValue("1");
		ws.getRange2("B1").setValue("3.123");
		ws.getRange2("C1").setValue("-4");
		ws.getRange2("A2").setValue("2");
		ws.getRange2("B2").setValue("4");
		ws.getRange2("C2").setValue("5");

		oParser = new parserFormula(formula, "A1", ws);
		oParser.setArrayFormulaRef(ws.getRange2("E6:H8").bbox);
		assert.ok(oParser.parse());
		var array = oParser.calculate();

		var splitStr = str.split(";");

		for (var i = 0; i < splitStr.length; i++) {
			var subSplitStr = splitStr[i].split(",");
			for (var j = 0; j < subSplitStr.length; j++) {
				var valMs = subSplitStr[j];
				var element;
				if (array.getElementRowCol) {
					var row = 1 === array.array.length ? 0 : i;
					var col = 1 === array.array[0].length ? 0 : j;
					if (array.array[row] && array.array[row][col]) {
						element = array.getElementRowCol(row, col);
					} else {
						element = new window['AscCommonExcel'].cError(window['AscCommonExcel'].cErrorType.not_available);
					}
				} else {
					element = array;
				}
				var ourVal = element && undefined != element.value ? element.value.toString() : "#N/A";
				if (!isNotLowerCase) {
					valMs = valMs.toLowerCase();
					ourVal = ourVal.toLowerCase();
				}
				assert.strictEqual(valMs, ourVal, "formula: " + formula + " i: " + i + " j: " + j)
			}
		}
	}


	/**
	 * Function creates table or edit existed table.
	 * * Creating happened when the function was called for the first time in the code totally.
	 * In that case, you should set range coordinates like you're creating table, select needed range.
	 * * For editing table you should consider that you have constant row with header and one data row as minimum required.
	 * In that case your minimum row coordinates must be equal 2 rows.
	 * For filling data use cells A601:L6**
	 * @param {number} r1
	 * @param {number} c1
	 * @param {number} r2
	 * @param {number} c2
	 * @returns {TablePart}
	 */
	function getTableType(r1, c1, r2, c2) {
		const range = new window["Asc"].Range(c1, r1, c2, r2);
		const  tableName = 'Table1';
		const tableParts = ws.TableParts;
		/** @type {TablePart} */
		const foundedTable = tableParts.find(function(table) { return table.DisplayName === tableName});
		if (foundedTable) {
			// Change table
			ws.autoFilters.changeTableRange(tableName, range);
			return foundedTable;
		}
		// Create table
		const tableOptFormat = ws.autoFilters.getAddFormatTableOptions(range);
		const styleName = 'TableStyleMedium2';
		ws.autoFilters.addAutoFilter(styleName, range, tableOptFormat);

		return tableParts[tableParts.length - 1]
	}
	function getSecondSheet () {
		let ws2 = wb.getWorksheetByName('Sheet2');
		if (!ws2) {
			ws2 = wb.createWorksheet(null, 'Sheet2');
		}

		return ws2;
	}
	function initDefNames() {
		const defName = new Asc.asc_CDefName('TestName', ws.getName() + '!$A$201');
		const defName2 = new Asc.asc_CDefName('TestName1', ws.getName() + '!$A$202');
		const defName3 = new Asc.asc_CDefName('TestName2', ws.getName() + '!$A$203');
		const defName4 = new Asc.asc_CDefName('TestName3', ws.getName() + '!$A$204');
		const defName5 = new Asc.asc_CDefName('TestName4', ws.getName() + '!$A$205');
		const defNameArea = new Asc.asc_CDefName('TestNameArea', ws.getName() + '!$A$206:$A$207');
		const defNameArea2 = new Asc.asc_CDefName('TestNameArea2', ws.getName() + '!$A$208:$B$208');
		const ws2 = getSecondSheet();
		const defName3D = new Asc.asc_CDefName('TestName3D', ws2.getName() + '!$A$11');
		const defName3D2 = new Asc.asc_CDefName('TestName3D1', ws2.getName() + '!$A$12');
		const defName3D3 = new Asc.asc_CDefName('TestName3D2', ws2.getName() + '!$A$13');
		const defName3D4 = new Asc.asc_CDefName('TestName3D3', ws2.getName() + '!$A$14');
		const defName3D5 = new Asc.asc_CDefName('TestName3D4', ws2.getName() + '!$A$15');
		const defNameArea3D = new Asc.asc_CDefName('TestNameArea3D', ws2.getName() + '!$A$16:$A$17');
		const defNameArea3D2 = new Asc.asc_CDefName('TestNameArea3D2', ws2.getName() + '!$A$18:$B$18');

		wb.editDefinesNames(null, defName);
		wb.editDefinesNames(null, defName2);
		wb.editDefinesNames(null, defName3);
		wb.editDefinesNames(null, defName4);
		wb.editDefinesNames(null, defName5);
		wb.editDefinesNames(null, defNameArea);
		wb.editDefinesNames(null, defNameArea2);
		wb.editDefinesNames(null, defName3D);
		wb.editDefinesNames(null, defName3D2);
		wb.editDefinesNames(null, defName3D3);
		wb.editDefinesNames(null, defName3D4);
		wb.editDefinesNames(null, defName3D5);
		wb.editDefinesNames(null, defNameArea3D);
		wb.editDefinesNames(null, defNameArea3D2);
	}

	wb.dependencyFormulas.lockRecal();
	getTableType(599, 0, 599, 0); // Init table
	initDefNames();

	QUnit.module('Engineering formulas');

	QUnit.test("Test: \"BESSELI\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1.5");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("6");
		ws.getRange2("A104").setValue("3");
		ws.getRange2("A105").setValue("");
		ws.getRange2("A106").setValue("text");
		ws.getRange2("A107").setValue("TRUE");
		ws.getRange2("A108").setValue("#N/A");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("2.5"); // Column1
		ws.getRange2("B601").setValue("1"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("4");
		ws2.getRange2("A2").setValue("1");
		ws2.getRange2("A3").setValue("-1");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("5"); // TestName
		ws.getRange2("A202").setValue("0"); // TestName1
		ws.getRange2("A206").setValue("7"); // TestNameArea
		ws.getRange2("A207").setValue("8"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("6") // TestName3D
		ws2.getRange2("A12").setValue("3") // TestName3D1
		ws2.getRange2("A16").setValue("9"); // TestNameArea3D
		ws2.getRange2("A17").setValue("10"); // TestNameArea3D

		// Positive cases:

		// Has differents in comparison with excel with some formulas (inaccuracy in the 7th digit after the decimal)
		// Case #1: Number(2). Example from documentation. Bessel 1.5 order 1.
		oParser = new parserFormula('BESSELI(1.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(1.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.981666, 'Test: Positive case: Number(2). Example from documentation. Bessel 1.5 order 1.');
		// Case #2: Number(2). Bessel function 1 with an order of 2.
		oParser = new parserFormula('BESSELI(1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1357476697670383, 'Test: Positive case: Number(2). Bessel function 1 with an order of 2.');
		// Case #3: Number(2). Bessel function -1 with an order of 2.
		oParser = new parserFormula('BESSELI(-1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(-1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.1357476697670383, 'Test: Positive case: Number(2). Bessel function -1 with an order of 2.');
		// Case #4: Number, Number. Both arguments are integers.
		oParser = new parserFormula('BESSELI(2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.21273995923985262, 'Test: Positive case: Number, Number. Both arguments are integers.');
		// Case #5: Number, Number. X is a float number.
		oParser = new parserFormula('BESSELI(1.5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(1.5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3378346183356807, 'Test: Positive case: Number, Number. X is a float number.');
		// Case #6: Number, Number. N is a float, will be truncated to 2.
		oParser = new parserFormula('BESSELI(2.5, 2.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2.5, 2.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 1.276466, 'Test: Positive case: Number, Number. N is a float, will be truncated to 2.');
		// Case #7: Number, Number. X is a negative number.
		oParser = new parserFormula('BESSELI(-5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(-5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 17.505615, 'Test: Positive case: Number, Number. X is a negative number.');
		// Case #8: String, String. Both arguments are numeric strings.
		oParser = new parserFormula('BESSELI("2","3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI("2","3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.21273995923985262, 'Test: Positive case: String, String. Both arguments are numeric strings.');
		// Case #9: Formula, Formula. Both arguments are formulas.
		oParser = new parserFormula('BESSELI(SUM(1,1),ABS(-3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(SUM(1,1),ABS(-3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.21273995923985262, 'Test: Positive case: Formula, Formula. Both arguments are formulas.');
		// Case #10: Reference link, Reference link. Both arguments are references to cells with numbers.
		oParser = new parserFormula('BESSELI(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.3378346183356807, 'Test: Positive case: Reference link, Reference link. Both arguments are references to cells with numbers.');
		// Case #11: Reference link, Number. First argument is a reference, second is a number (zero).
		oParser = new parserFormula('BESSELI(A102, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(A102, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.8807925858650245, 'Test: Positive case: Reference link, Number. First argument is a reference, second is a number (zero).');
		// Case #12: Number, Empty. Second argument N is a reference to an empty cell, treated as 0.
		oParser = new parserFormula('BESSELI(5, A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(5, A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 27.23987182360445, 'Test: Positive case: Number, Empty. Second argument N is a reference to an empty cell, treated as 0.');
		// Case #13: Area, Area. Arguments are single-cell ranges.
		oParser = new parserFormula('BESSELI(A103:A103, A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(A103:A103, A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30.15054029946387, 'Test: Positive case: Area, Area. Arguments are single-cell ranges.');
		// Case #14: Name, Name. Arguments are named ranges pointing to numbers.
		oParser = new parserFormula('BESSELI(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 27.23987182360445, 'Test: Positive case: Name, Name. Arguments are named ranges pointing to numbers.');
		// Case #15: Ref3D, Ref3D. Arguments are 3D references.
		oParser = new parserFormula('BESSELI(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 9.759465, 'Test: Positive case: Ref3D, Ref3D. Arguments are 3D references.');
		// Case #16: Name3D, Name3D. Arguments are 3D named ranges.
		oParser = new parserFormula('BESSELI(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 30.15054, 'Test: Positive case: Name3D, Name3D. Arguments are 3D named ranges.');
		// Case #17: Table, Table. Arguments are references to a table.
		oParser = new parserFormula('BESSELI(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 2.516716, 'Test: Positive case: Table, Table. Arguments are references to a table.');
		// Case #18: Array, Array. Arguments are single-element arrays.
		oParser = new parserFormula('BESSELI({5},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI({5},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 17.505615, 'Test: Positive case: Array, Array. Arguments are single-element arrays.');
		// Case #19: Formula. BESSELI is a part of another formula.
		oParser = new parserFormula('ABS(BESSELI(-10,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula ABS(BESSELI(-10,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 2281.518968, 'Test: Positive case: Formula. BESSELI is a part of another formula.');
		// Case #20: Formula. BESSELI is used in an arithmetic operation.
		oParser = new parserFormula('BESSELI(5,2)+10', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(5,2)+10 is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 27.505615, 'Test: Positive case: Formula. BESSELI is used in an arithmetic operation.');
		// Case #21: Number, Number. X is zero, N is a positive integer.
		oParser = new parserFormula('BESSELI(0, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(0, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Number. X is zero, N is a positive integer.');
		// Case #22: Number, Number. Both X and N are zero.
		oParser = new parserFormula('BESSELI(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Number. Both X and N are zero.');
		// Case #23: Formula, Number. X is a reference to a date (serial number).
		oParser = new parserFormula('BESSELI(DATE(1900,1,1), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(DATE(1900,1,1), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.135748, 'Test: Positive case: Formula, Number. X is a reference to a date (serial number).');
		// Case #24: Number, Time. N is a reference to a time (serial number), truncated to 0.
		oParser = new parserFormula('BESSELI(4, TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(4, TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 11.301922, 'Test: Positive case: Number, Time. N is a reference to a time (serial number), truncated to 0.');
		// Case #22: Reference link, Number. X is a reference to an empty cell, treated as 0
		oParser = new parserFormula('BESSELI(A105, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(A105, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link, Number. X is a reference to an empty cell, treated as 0');

		// Negative cases:

		// Case #1: Number(2). Bessel function with incorrect order (< 0)
		oParser = new parserFormula('BESSELI(1,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(1,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Bessel function with incorrect order (< 0)');
		// Case #2: Number, Number. N is negative, results in #NUM!.
		oParser = new parserFormula('BESSELI(2, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. N is negative, results in #NUM!.');
		// Case #3: Number, Number. N is negative float, results in #NUM!.
		oParser = new parserFormula('BESSELI(5, -0.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(5, -0.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. N is negative float, results in #NUM!.');
		// Case #4: String, Number. X is a non-numeric string, results in #VALUE!.
		oParser = new parserFormula('BESSELI("text", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI("text", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. X is a non-numeric string, results in #VALUE!.');
		// Case #5: Number, String. N is a non-numeric string, results in #VALUE!.
		oParser = new parserFormula('BESSELI(2, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. N is a non-numeric string, results in #VALUE!.');
		// Case #6: Boolean, Number. X is a boolean value, results in #VALUE!.
		oParser = new parserFormula('BESSELI(TRUE, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(TRUE, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. X is a boolean value, results in #VALUE!.');
		// Case #7: Number, Boolean. N is a boolean value, results in #VALUE!.
		oParser = new parserFormula('BESSELI(2, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. N is a boolean value, results in #VALUE!.');
		// Case #8: Error, Number. X is a reference to an error, results in #N/A.
		oParser = new parserFormula('BESSELI(A108, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(A108, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Number. X is a reference to an error, results in #N/A.');
		// Case #9: Number, Error. N is a reference to an error, results in #N/A.
		oParser = new parserFormula('BESSELI(2, A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, A108) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Error. N is a reference to an error, results in #N/A.');
		// Case #10: Reference link, Number. X is a reference to a non-numeric string.
		oParser = new parserFormula('BESSELI(A106, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(A106, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. X is a reference to a non-numeric string.');
		// Case #11: Number, Reference link. N is a reference to a boolean value.
		oParser = new parserFormula('BESSELI(2, A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, A107) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. N is a reference to a boolean value.');
		// Case #12: Area, Number. X is a multi-cell range, results in #VALUE!.
		oParser = new parserFormula('BESSELI(A100:A101, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(A100:A101, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. X is a multi-cell range, results in #VALUE!.');
		// Case #13: Number, Area. N is a multi-cell range, results in #VALUE!.
		oParser = new parserFormula('BESSELI(2, A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. N is a multi-cell range, results in #VALUE!.');
		// Case #14: Name, Number. X is a named range referring to multiple cells.
		oParser = new parserFormula('BESSELI(TestNameArea, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(TestNameArea, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number. X is a named range referring to multiple cells.');
		// Case #15: Number, Name. N is a named range referring to multiple cells.
		oParser = new parserFormula('BESSELI(2, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name. N is a named range referring to multiple cells.');
		// Case #16: Area3D, Number. X is a 3D multi-cell range.
		oParser = new parserFormula('BESSELI(Sheet2!A1:A2, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(Sheet2!A1:A2, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number. X is a 3D multi-cell range.');
		// Case #17: Number, Area3D. N is a 3D multi-cell range.
		oParser = new parserFormula('BESSELI(2, Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, Sheet2!A1:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D. N is a 3D multi-cell range.');
		// Case #18: Number, Name3D. N is a 3D named range referring to multiple cells.
		oParser = new parserFormula('BESSELI(2, TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name3D. N is a 3D named range referring to multiple cells.');
		// Case #19: Empty, Number. X is Empty.
		oParser = new parserFormula('BESSELI(, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. X is Empty.');
		// Case #20: Empty, Empty. Missing both arguments.
		oParser = new parserFormula('BESSELI(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Empty. Missing both arguments.');
		// Case #21: Number, Empty. Missing argument N.
		oParser = new parserFormula('BESSELI(2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty. Missing argument N.');
		// Case #22: Ref3D, Number. N is a reference to a negative number, but X is valid.
		oParser = new parserFormula('BESSELI(2, Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(2, Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D, Number. N is a reference to a negative number, but X is valid.');

		// Bounded cases:

		// Case #1: Number, Number. Minimum valid value for N (N=0).
		oParser = new parserFormula('BESSELI(10, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(10, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2815.716628466255, 'Test: Bounded case: Number, Number. Minimum valid value for N (N=0).');
		// Case #2: Number, Number. Float value for N that is truncated to the minimum valid value 0.
		oParser = new parserFormula('BESSELI(10, 0.9999)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(10, 0.9999) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2815.716628466255, 'Test: Bounded case: Number, Number. Float value for N that is truncated to the minimum valid value 0.');
		// Case #3: Number, Number. Maximum value for X (with N=1) that does not result in a #NUM! error.
		oParser = new parserFormula('BESSELI(709, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(709, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.2307e+306, 'Test: Bounded case: Number, Number. Maximum value for X (with N=1) that does not result in a #NUM! error.');
		// Case #4: Number, Number. Large negative value for X that is processed without error.
		oParser = new parserFormula('BESSELI(-709, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(-709, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.2305e+306, 'Test: Bounded case: Number, Number. Large negative value for X that is processed without error.');
		// Case #5: Number, Number. A combination of large X and large N that does not cause an overflow error.
		oParser = new parserFormula('BESSELI(10, 244)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELI(10, 244) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 2.7848e-308, 'Test: Bounded case: Number, Number. A combination of large X and large N that does not cause an overflow error.');

        // Need to fix: diff results in boundary cases, empty handle, error type diff, diff results from ms
        // Case #6: Boolean, Number. X is a boolean value, results in #VALUE!.
        // Case #7: Number, Boolean. N is a boolean value, results in #VALUE!.
        // Case #8: Error, Number. X is a reference to an error, results in #N/A.
        // Case #9: Number, Error. N is a reference to an error, results in #N/A.
        // Case #11: Number, Reference link. N is a reference to a boolean value.
        // Case #16: Area3D, Number. X is a 3D multi-cell range.
        // Case #17: Number, Area3D. N is a 3D multi-cell range.
        // Case #19: Empty, Number. X is Empty.
        // Case #20: Empty, Empty. Missing both arguments.
        // Case #21: Number, Empty. Missing argument N.
        // Case #3: Number, Number. Maximum value for X (with N=1) that does not result in a #NUM! error.
        // Case #4: Number, Number. Large negative value for X that is processed without error.
        // Case #5: Number, Number. A combination of large X and large N that does not cause an overflow error.

		testArrayFormula2(assert, "BESSELI", 2, 2, true, null);
	});

	QUnit.test("Test: \"BESSELJ\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.7652");
		ws.getRange2("A101").setValue("0.5767");
		ws.getRange2("A102").setValue("1");
		ws.getRange2("A103").setValue("0");
		ws.getRange2("A104").setValue("0.4347");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("2"); // Column1
		ws.getRange2("B601").setValue("5"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("3.5");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("2"); // TestName
		ws.getRange2("A202").setValue("3"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("2") // TestName3D
		ws2.getRange2("A12").setValue("3") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Example fron documentation.
		oParser = new parserFormula('BESSELJ(1.9, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1.9, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.329925728, 'Test: Positive case: Number(2). Example fron documentation.');
		// Case #2: Number(2). N decimal number
		oParser = new parserFormula('BESSELJ(1.9, 2.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1.9, 2.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.329925728, 'Test: Positive case: Number(2). N decimal number');
		// Case #3: Number(2). X negative number N decimal number
		oParser = new parserFormula('BESSELJ(-1.9, 2.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(-1.9, 2.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.329925728, 'Test: Positive case: Number(2). X negative number N decimal number');
		// Case #4: Number(2). Basic case: x=1, n=0 (order 0). 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.765197687, 'Test: Positive case: Number(2). Basic case: x=1, n=0 (order 0). 2 arguments used.');
		// Case #5: Number(2). Basic case: x=2, n=1 (order 1). 2 arguments used.
		oParser = new parserFormula('BESSELJ(2, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(2, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.576724808, 'Test: Positive case: Number(2). Basic case: x=2, n=1 (order 1). 2 arguments used.');
		// Case #6: Number(2). Special case: x=0, n=0. Should return 1. 2 arguments used.
		oParser = new parserFormula('BESSELJ(0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1, 'Test: Positive case: Number(2). Special case: x=0, n=0. Should return 1. 2 arguments used.');
		// Case #7: Number(2). Special case: x=0, n=1. Should return 0. 2 arguments used.
		oParser = new parserFormula('BESSELJ(0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Special case: x=0, n=1. Should return 0. 2 arguments used.');
		// Case #8: Number(2). Fractional x value, integer n value. 2 arguments used.
		oParser = new parserFormula('BESSELJ(3.5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(3.5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.45862918, 'Test: Positive case: Number(2). Fractional x value, integer n value. 2 arguments used.');
		// Case #9: Number(2). Large x value, integer n. 2 arguments used.
		oParser = new parserFormula('BESSELJ(10, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(10, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.058379379, 'Test: Positive case: Number(2). Large x value, integer n. 2 arguments used.');
		// Case #10: String(2). Both arguments are strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('BESSELJ("2", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ("2", "1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.576724808, 'Test: Positive case: String(2). Both arguments are strings convertible to numbers. 2 arguments used.');
		// Case #11: Formula(2). Both arguments are formula results. 2 arguments used.
		oParser = new parserFormula('BESSELJ(SQRT(4), INT(1.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(SQRT(4), INT(1.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.576724808, 'Test: Positive case: Formula(2). Both arguments are formula results. 2 arguments used.');
		// Case #12: Reference link(2). Both arguments are cell references. 2 arguments used.
		oParser = new parserFormula('BESSELJ(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.858887881, 'Test: Positive case: Reference link(2). Both arguments are cell references. 2 arguments used.');
		// Case #13: Area(2). Both arguments are single-cell ranges. 2 arguments used.
		oParser = new parserFormula('BESSELJ(A102:A102, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(A102:A102, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.765197687, 'Test: Positive case: Area(2). Both arguments are single-cell ranges. 2 arguments used.');
		// Case #14: Array(2). Both arguments are arrays with single elements. 2 arguments used.
		oParser = new parserFormula('BESSELJ({2}, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ({2}, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.576724808, 'Test: Positive case: Array(2). Both arguments are arrays with single elements. 2 arguments used.');
		// Case #15: Name(2). Both arguments are named ranges. 2 arguments used.
		oParser = new parserFormula('BESSELJ(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.12894325, 'Test: Positive case: Name(2). Both arguments are named ranges. 2 arguments used.');
		// Case #16: Name3D(2). Both arguments are 3D named ranges. 2 arguments used.
		oParser = new parserFormula('BESSELJ(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.12894325, 'Test: Positive case: Name3D(2). Both arguments are 3D named ranges. 2 arguments used.');
		// Case #17: Ref3D(2). Both arguments are 3D references. 2 arguments used.
		oParser = new parserFormula('BESSELJ(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.019563354, 'Test: Positive case: Ref3D(2). Both arguments are 3D references. 2 arguments used.');
		// Case #18: Area3D(2). Both arguments are 3D single-cell ranges. 2 arguments used.
		oParser = new parserFormula('BESSELJ(Sheet2!A1:A1, Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(Sheet2!A1:A1, Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.019563354, 'Test: Positive case: Area3D(2). Both arguments are 3D single-cell ranges. 2 arguments used.');
		// Case #19: Table(2). Both arguments are table references. 2 arguments used.
		oParser = new parserFormula('BESSELJ(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.00703963, 'Test: Positive case: Table(2). Both arguments are table references. 2 arguments used.');
		// Case #20: Number, Formula. First argument is a number, second is a formula result. 2 arguments used.
		oParser = new parserFormula('BESSELJ(2, SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(2, SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.352834, 'Test: Positive case: Number, Formula. First argument is a number, second is a formula result. 2 arguments used.');
		// Case #21: String, Number. First argument is a string convertible to number, second is a number. 2 arguments used.
		oParser = new parserFormula('BESSELJ("3.5", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ("3.5", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.45862918, 'Test: Positive case: String, Number. First argument is a string convertible to number, second is a number. 2 arguments used.');
		// Case #22: Number, String. First argument is a number, second is a string convertible to number. 2 arguments used.
		oParser = new parserFormula('BESSELJ(3.5, "2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(3.5, "2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.45862918, 'Test: Positive case: Number, String. First argument is a number, second is a string convertible to number. 2 arguments used.');
		// Case #23: Formula. BESSELJ used inside another formula (SUM). 2 arguments for BESSELJ used.
		oParser = new parserFormula('SUM(BESSELJ(2, 1), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BESSELJ(2, 1), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 1.576724808, 'Test: Positive case: Formula. BESSELJ used inside another formula (SUM). 2 arguments for BESSELJ used.');
		// Case #24: Number(2). Fractional x value between 0 and 1, integer n. 2 arguments used.
		oParser = new parserFormula('BESSELJ(0.5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(0.5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.030604023, 'Test: Positive case: Number(2). Fractional x value between 0 and 1, integer n. 2 arguments used.');
		// Case #25: Number(2). Small x value, integer n. 2 arguments used.
		oParser = new parserFormula('BESSELJ(0.1, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(0.1, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10) - 0, 0.0000208203, 'Test: Positive case: Number(2). Small x value, integer n. 2 arguments used.');
		// Case #26: Number(2). Integer x > 1, n = 0. 2 arguments used.
		oParser = new parserFormula('BESSELJ(5, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(5, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -0.17759677, 'Test: Positive case: Number(2). Integer x > 1, n = 0. 2 arguments used.');
		// Case #27: Number(2). Equal integer values for x and n. 2 arguments used.
		oParser = new parserFormula('BESSELJ(5, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(5, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.261140546, 'Test: Positive case: Number(2). Equal integer values for x and n. 2 arguments used.');
		// Case #28: Number(2). Fractional x value between 0 and 1, n = 0. 2 arguments used.
		oParser = new parserFormula('BESSELJ(0.5, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(0.5, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.938469807, 'Test: Positive case: Number(2). Fractional x value between 0 and 1, n = 0. 2 arguments used.');
		// Case #29: Formula, Number. First argument is date as serial number, second is number. 2 arguments used.
		oParser = new parserFormula('BESSELJ(DATE(2023,1,1), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(DATE(2023,1,1), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.000492086, 'Test: Positive case: Formula, Number. First argument is date as serial number, second is number. 2 arguments used.');
		// Case #30: Number, Formula. First argument is number, second is date as serial number. 2 arguments used.
		oParser = new parserFormula('BESSELJ(2, DATE(1900,4,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(2, DATE(1900,4,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7.953620955763735e-143, 'Test: Positive case: Number, Formula. First argument is number, second is date as serial number. 2 arguments used.');
		// Case #31: Formula, Number. First argument is time+1, second is number. 2 arguments used.
		oParser = new parserFormula('BESSELJ(TIME(12,0,0)+1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(TIME(12,0,0)+1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.23208767, 'Test: Positive case: Formula, Number. First argument is time+1, second is number. 2 arguments used.');
		// Case #32: Number, Formula. First argument is number, second is time+1. 2 arguments used.
		oParser = new parserFormula('BESSELJ(2, TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(2, TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.576724808, 'Test: Positive case: Number, Formula. First argument is number, second is time+1. 2 arguments used.');
		// Case #33: String(2). First argument is date as string, second is string with number. 2 arguments used.
		oParser = new parserFormula('BESSELJ("01/01/2023", "2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ("01/01/2023", "2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.000492086, 'Test: Positive case: String(2). First argument is date as string, second is string with number. 2 arguments used.');
		// Case #34: Array, Number. First argument is array with multiple elements. 2 arguments used.
		oParser = new parserFormula('BESSELJ({1, 2}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ({1, 2}, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.440050586, 'Test: Positive case: Array, Number. First argument is array with multiple elements. 2 arguments used.');
		// Case #35: Number, Array. Second argument is array with multiple elements. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, {1, 2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, {1, 2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.440050586, 'Test: Positive case: Number, Array. Second argument is array with multiple elements. 2 arguments used.');

		// Negative cases:

		// Case #1: Number(2). N negative number
		oParser = new parserFormula('BESSELJ(-1.9, -2.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(-1.9, -2.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). N negative number');
		// Case #2: Empty, Number. First argument is empty. 2 arguments used.
		oParser = new parserFormula('BESSELJ(, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. First argument is empty. 2 arguments used.');
		// Case #3: Number, Empty. Second argument is empty. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, ) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty. Second argument is empty. 2 arguments used.');
		// Case #4: String, Number. First argument is non-numeric string. 2 arguments used.
		oParser = new parserFormula('BESSELJ("abc", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ("abc", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. First argument is non-numeric string. 2 arguments used.');
		// Case #5: Number, String. Second argument is non-numeric string. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Second argument is non-numeric string. 2 arguments used.');
		// Case #6: String(2). Both arguments are non-numeric strings. 2 arguments used.
		oParser = new parserFormula('BESSELJ("abc", "def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ("abc", "def") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Both arguments are non-numeric strings. 2 arguments used.');
		// Case #7: Number(2). Negative x and fractional n. Should return error. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, -0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, -0.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative x and fractional n. Should return error. 2 arguments used.');
		// Case #8: Number(2). Negative x and fractional n. Should return error. 2 arguments used.
		oParser = new parserFormula('BESSELJ(2, -1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(2, -1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative x and fractional n. Should return error. 2 arguments used.');
		// Case #9: Error, Number. First argument is #N/A error. 2 arguments used.
		oParser = new parserFormula('BESSELJ(NA(), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(NA(), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. First argument is #N/A error. 2 arguments used.');
		// Case #10: Number, Error. Second argument is #N/A error. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Second argument is #N/A error. 2 arguments used.');
		// Case #11: Error(2). Both arguments are #N/A errors. 2 arguments used.
		oParser = new parserFormula('BESSELJ(NA(), NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(NA(), NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). Both arguments are #N/A errors. 2 arguments used.');
		// Case #12: Formula, Number. First argument is formula returning error. 2 arguments used.
		oParser = new parserFormula('BESSELJ(SQRT(-1), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(SQRT(-1), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. First argument is formula returning error. 2 arguments used.');
		// Case #13: Number, Formula. Second argument is formula returning error. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Second argument is formula returning error. 2 arguments used.');
		// Case #14: Number(2). x=0, negative n. Should return division by zero error. 2 arguments used.
		oParser = new parserFormula('BESSELJ(0, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(0, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). x=0, negative n. Should return division by zero error. 2 arguments used.');
		// Case #15: Number(2). x=0, negative n. Should return division by zero error. 2 arguments used.
		oParser = new parserFormula('BESSELJ(0, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(0, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). x=0, negative n. Should return division by zero error. 2 arguments used.');
		// Case #16: Area, Number. First argument is multi-cell range. 2 arguments used.
		oParser = new parserFormula('BESSELJ(A104:A105, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(A104:A105, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. First argument is multi-cell range. 2 arguments used.');
		// Case #17: Number, Area. Second argument is multi-cell range. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Second argument is multi-cell range. 2 arguments used.');
		// Case #18: Number(2). Very large negative x value. 2 arguments used.
		oParser = new parserFormula('BESSELJ(-1E+307, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(-1E+307, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Very large negative x value. 2 arguments used.');
		// Case #19: Number(2). Very large negative n value. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, -1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, -1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Very large negative n value. 2 arguments used.');
		// Case #20: String(2). Both arguments are empty strings. 2 arguments used.
		oParser = new parserFormula('BESSELJ("", "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ("", "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Both arguments are empty strings. 2 arguments used.');

		// Bounded cases:

		// Case #1: Number(2). Minimum positive x value, n=0. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1E-307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1E-307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Minimum positive x value, n=0. 2 arguments used.');
		// Case #2: Number(2). x=1, minimum positive n value. 2 arguments used.
		oParser = new parserFormula('BESSELJ(1, 1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(1, 1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7651976865579666, 'Test: Bounded case: Number(2). x=1, minimum positive n value. 2 arguments used.');
		// Case #3: Number(2). Maximum positive x value, n=0. 2 arguments used.
		oParser = new parserFormula('BESSELJ(100000000, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(100000000, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.00003206, 'Test: Bounded case: Number(2). Maximum positive x value, n=0. 2 arguments used.');
		// Case #4: Number(2). x=1, maximum positive n value. 2 arguments used.
		oParser = new parserFormula('BESSELJ(10000000, 10000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELJ(10000000, 10000000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.000038477, 'Test: Bounded case: Number(2). x=1, maximum positive n value. 2 arguments used.');

        // Need to fix: empty handle, results diff from MS
        // Case #2: Empty, Number. First argument is empty. 2 arguments used.
        // Case #3: Number, Empty. Second argument is empty. 2 arguments used.
        // Case #18: Number(2). Very large negative x value. 2 arguments used.
        // Case #4: Number(2). x=1, maximum positive n value. 2 arguments used.

		testArrayFormula2(assert, "BESSELJ", 2, 2, true, null);
	});


	QUnit.test("Test: \"BESSELK\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("-1");
		ws.getRange2("A104").setValue("abc");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Column1
		ws.getRange2("B601").setValue("2"); // Column2
		ws.getRange2("C601").setValue("test"); // Column3
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1.5");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("text");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1"); // TestName
		ws.getRange2("A202").setValue("2"); // TestName1
		ws.getRange2("A206").setValue("text"); // TestNameArea
		ws.getRange2("A207").setValue("10"); // TestNameArea
		ws.getRange2("A208").setValue(""); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("5") // TestName3D
		ws2.getRange2("A12").setValue("2") // TestName3D1
		ws2.getRange2("A13").setValue("") // TestName3D2

		// Positive cases:

		// Case #1: Number(2). Example from documentation
		oParser = new parserFormula('BESSELK(1.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.277387804, 'Test: Positive case: Number(2). Example from documentation');
		// Case #2: Number(2). Both number are integer
		oParser = new parserFormula('BESSELK(1, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 7.10126281, 'Test: Positive case: Number(2). Both number are integer');
		// Case #1: Number(2). Basic valid input: float x>0, integer n. 2 arguments used.
		oParser = new parserFormula('BESSELK(1.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.277387804, 'Test: Positive case: Number(2). Basic valid input: float x>0, integer n. 2 arguments used.');
		// Case #2: Number(2). Basic valid input: integer x>0, integer n. 2 arguments used.
		oParser = new parserFormula('BESSELK(5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.005308944, 'Test: Positive case: Number(2). Basic valid input: integer x>0, integer n. 2 arguments used.');
		// Case #3: String(2). Strings convertible to numbers. 2 arguments used.
		oParser = new parserFormula('BESSELK("1.5", "1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK("1.5", "1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.277387804, 'Test: Positive case: String(2). Strings convertible to numbers. 2 arguments used.');
		// Case #4: Formula(2). Nested formulas returning valid numbers. 2 arguments used.
		oParser = new parserFormula('BESSELK(SQRT(4), MAX(1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(SQRT(4), MAX(1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.25375976, 'Test: Positive case: Formula(2). Nested formulas returning valid numbers. 2 arguments used.');
		// Case #5: Reference link(2). Ref to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('BESSELK(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.13986588, 'Test: Positive case: Reference link(2). Ref to cells with valid numbers. 2 arguments used.');
		// Case #6: Area(2). Single-cell ranges. 2 arguments used.
		oParser = new parserFormula('BESSELK(A100:A100, A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(A100:A100, A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.13986588, 'Test: Positive case: Area(2). Single-cell ranges. 2 arguments used.');
		// Case #7: Array(2). Arrays with single element. 2 arguments used.
		oParser = new parserFormula('BESSELK({1.5}, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK({1.5}, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.277387804, 'Test: Positive case: Array(2). Arrays with single element. 2 arguments used.');
		// Case #8: Name(2). Named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('BESSELK(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6248388961291051, 'Test: Positive case: Name(2). Named ranges with valid numbers. 2 arguments used.');
		// Case #9: Name3D(2). 3D named ranges with valid numbers. 2 arguments used.
		oParser = new parserFormula('BESSELK(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.005308944, 'Test: Positive case: Name3D(2). 3D named ranges with valid numbers. 2 arguments used.');
		// Case #10: Ref3D(2). 3D references to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('BESSELK(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.58365597, 'Test: Positive case: Ref3D(2). 3D references to cells with valid numbers. 2 arguments used.');
		// Case #11: Area3D(2). 3D single-cell ranges. 2 arguments used.
		oParser = new parserFormula('BESSELK(Sheet2!A1:A1, Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(Sheet2!A1:A1, Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.58365597, 'Test: Positive case: Area3D(2). 3D single-cell ranges. 2 arguments used.');
		// Case #12: Table(2). Table structured references. 2 arguments used.
		oParser = new parserFormula('BESSELK(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6248388961291051, 'Test: Positive case: Table(2). Table structured references. 2 arguments used.');
		// Case #13: Number(2). x>0, n=0. 2 arguments used.
		oParser = new parserFormula('BESSELK(0.5, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(0.5, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.924419, 'Test: Positive case: Number(2). x>0, n=0. 2 arguments used.');
		// Case #14: Number(2). n is truncated to 1. 2 arguments used.
		oParser = new parserFormula('BESSELK(3, 1.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(3, 1.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.040156431, 'Test: Positive case: Number(2). n is truncated to 1. 2 arguments used.');
		// Case #15: Number(2). n is truncated to 3. 2 arguments used.
		oParser = new parserFormula('BESSELK(10, 3.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(10, 3.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(10) - 0, 0.0000272527, 'Test: Positive case: Number(2). n is truncated to 3. 2 arguments used.');
		// Case #16: Formula. BESSELK inside another formula. 2 arguments used for BESSELK.
		oParser = new parserFormula('SUM(BESSELK(2,1), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BESSELK(2,1), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 1.13986588, 'Test: Positive case: Formula. BESSELK inside another formula. 2 arguments used for BESSELK.');
		// Case #17: Array(2). Multi-element arrays. 2 arguments used.
		oParser = new parserFormula('BESSELK({1, 2}, {0, 1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK({1, 2}, {0, 1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.4210244, 'Test: Positive case: Array(2). Multi-element arrays. 2 arguments used.');
		// Case #18: Number(2). Very small positive x. 2 arguments used.
		oParser = new parserFormula('BESSELK(1E-10, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1E-10, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 23.14178245, 'Test: Positive case: Number(2). Very small positive x. 2 arguments used.');

		// Negative cases:

		// Case #1: Number(2). X is negative number
		oParser = new parserFormula('BESSELK(-1.123,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(-1.123,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). X is negative number');
		// Case #2: Number(2). N is negative number
		oParser = new parserFormula('BESSELK(1,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). N is negative number');
		// Case #1: Number(2). x=0 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('BESSELK(0, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(0, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). x=0 returns #NUM!. 2 arguments used.');
		// Case #2: Number(2). x<0 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('BESSELK(-1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(-1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). x<0 returns #NUM!. 2 arguments used.');
		// Case #3: String(2). Non-numeric string for x returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('BESSELK("abc", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK("abc", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric string for x returns #VALUE!. 2 arguments used.');
		// Case #4: String(2). Non-numeric string for n returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('BESSELK("1.5", "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK("1.5", "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Non-numeric string for n returns #VALUE!. 2 arguments used.');
		// Case #5: Error(2). Propagates #N/A error from x. 2 arguments used.
		oParser = new parserFormula('BESSELK(NA(), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(NA(), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). Propagates #N/A error from x. 2 arguments used.');
		// Case #6: Error(2). Propagates #N/A error from n. 2 arguments used.
		oParser = new parserFormula('BESSELK(1, NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1, NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error(2). Propagates #N/A error from n. 2 arguments used.');
		// Case #7: Empty(2). Both arguments empty returns #N/A. 2 arguments used.
		oParser = new parserFormula('BESSELK(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(2). Both arguments empty returns #N/A. 2 arguments used.');
		// Case #8: Empty, Number. x empty returns #N/A. 2 arguments used.
		oParser = new parserFormula('BESSELK(, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. x empty returns #N/A. 2 arguments used.');
		// Case #9: Number, Empty. n empty returns #N/A. 2 arguments used.
		oParser = new parserFormula('BESSELK(1,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty. n empty returns #N/A. 2 arguments used.');
		// Case #10: Reference link(2). Ref to cell with text for x returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('BESSELK(A104, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(A104, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(2). Ref to cell with text for x returns #VALUE!. 2 arguments used.');
		// Case #11: Reference link(2). Ref to cell with text for n returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('BESSELK(A100, A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(A100, A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(2). Ref to cell with text for n returns #VALUE!. 2 arguments used.');
		// Case #12: Area(2). Single-cell range with text for x returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('BESSELK(A104:A104, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(A104:A104, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2). Single-cell range with text for x returns #VALUE!. 2 arguments used.');
		// Case #13: Name(2). Named range with text for x returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('BESSELK(TestNameArea, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(TestNameArea, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name(2). Named range with text for x returns #VALUE!. 2 arguments used.');
		// Case #14: Ref3D(2). 3D ref to cell with text for x returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('BESSELK(Sheet2!A3, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(Sheet2!A3, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D(2). 3D ref to cell with text for x returns #VALUE!. 2 arguments used.');
		// Case #15: Table(2). Table column with text for x returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('BESSELK(Table1[Column3], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(Table1[Column3], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table(2). Table column with text for x returns #VALUE!. 2 arguments used.');
		// Case #16: Number(2). n<0 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('BESSELK(1, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). n<0 returns #NUM!. 2 arguments used.');
		// Case #17: Number(2). n<0 (truncated to -1) returns #NUM!. 2 arguments used.
		oParser = new parserFormula('BESSELK(1, -1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1, -1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). n<0 (truncated to -1) returns #NUM!. 2 arguments used.');
		// Case #18: Formula(2). Formula resulting in #NUM! for x. 2 arguments used.
		oParser = new parserFormula('BESSELK(SQRT(-1), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(SQRT(-1), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula(2). Formula resulting in #NUM! for x. 2 arguments used.');
		// Case #19: Array(2). Array with negative x returns #NUM!. 2 arguments used.
		oParser = new parserFormula('BESSELK({-1}, {1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK({-1}, {1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array(2). Array with negative x returns #NUM!. 2 arguments used.');
		// Case #20: Array(2). Array with negative n returns #NUM!. 2 arguments used.
		oParser = new parserFormula('BESSELK({1}, {-1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK({1}, {-1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array(2). Array with negative n returns #NUM!. 2 arguments used.');

		// Bounded cases:

		// Case #1: Number(2). Min positive x (double-precision float min). n=0. 2 arguments used.
		oParser = new parserFormula('BESSELK(2.2250738585072E-307, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(2.2250738585072E-307, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 706.209765, 'Test: Bounded case: Number(2). Min positive x (double-precision float min). n=0. 2 arguments used.');
		// Case #2: Number(2). x slightly above 1. n=0. 2 arguments used.
		oParser = new parserFormula('BESSELK(1.00000000000002, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1.00000000000002, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.421024, 'Test: Bounded case: Number(2). x slightly above 1. n=0. 2 arguments used.');
		// Case #4: Number(2). x=1, n=0. 2 arguments used.
		oParser = new parserFormula('BESSELK(1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELK(1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.421024, 'Test: Bounded case: Number(2). x=1, n=0. 2 arguments used.');

        // Need to fix: empty handle
        // Case #7: Empty(2). Both arguments empty returns #N/A. 2 arguments used.
        // Case #8: Empty, Number. x empty returns #N/A. 2 arguments used.
        // Case #9: Number, Empty. n empty returns #N/A. 2 arguments used.

		testArrayFormula2(assert, "BESSELK", 2, 2, true, null);

	});

	QUnit.test("Test: \"BESSELY\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("2.5");
		ws.getRange2("A101").setValue("1");
		ws.getRange2("A102").setValue("2");
		ws.getRange2("A103").setValue("#N/A");
		ws.getRange2("A104").setValue("");
		ws.getRange2("A105").setValue("text");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("2.5"); // Column1
		ws.getRange2("B601").setValue("1"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("2.5");
		ws2.getRange2("A2").setValue("1");
		ws2.getRange2("A3").setValue("#NULL!");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("2.5"); // TestName
		ws.getRange2("A202").setValue("1"); // TestName1
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("2.5") // TestName3D
		ws2.getRange2("A12").setValue("1") // TestName3D1
		ws2.getRange2("A16").setValue("1"); // TestNameArea3D
		ws2.getRange2("A17").setValue("2"); // TestNameArea3D

		// Positive cases:

		// Case #1: Number(2). Example from documentation
		oParser = new parserFormula('BESSELY(2.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(2.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.1459181, 'Test: Positive case: Number(2). Example from documentation');
		// Case #1: Number, Number. Basic test with a float number for X and an integer for N.
		oParser = new parserFormula('BESSELY(2.5, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(2.5, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.1459181, 'Test: Positive case: Number, Number. Basic test with a float number for X and an integer for N.');
		// Case #2: Number, Number. Testing with N=0, which is a valid boundary condition.
		oParser = new parserFormula('BESSELY(5, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(5, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, -0.3085176, 'Test: Positive case: Number, Number. Testing with N=0, which is a valid boundary condition.');
		// Case #3: Number, Number. The non-integer order N=2.7 is truncated to 2.
		oParser = new parserFormula('BESSELY(4, 2.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(4, 2.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 0.21590, 'Test: Positive case: Number, Number. The non-integer order N=2.7 is truncated to 2.');
		// Case #4: String, Number. The first argument is a numeric string that should be converted to a number.
		oParser = new parserFormula('BESSELY("3", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY("3", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, -0.160400, 'Test: Positive case: String, Number. The first argument is a numeric string that should be converted to a number.');
		// Case #5: Reference link, Number. X is a reference to a cell containing a valid number.
		oParser = new parserFormula('BESSELY(A100, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(A100, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.145918, 'Test: Positive case: Reference link, Number. X is a reference to a cell containing a valid number.');
		// Case #6: Number, Reference link. N is a reference to a cell containing a valid number.
		oParser = new parserFormula('BESSELY(1.5, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(1.5, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.412308627, 'Test: Positive case: Number, Reference link. N is a reference to a cell containing a valid number.');
		// Case #7: Reference link, Number. X is a reference to a cell with a numeric string "3", testing type conversion.
		oParser = new parserFormula('BESSELY(A102, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(A102, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, -0.617408, 'Test: Positive case: Reference link, Number. X is a reference to a cell with a numeric string "3", testing type conversion.');
		// Case #8: Formula, Formula. Both arguments are nested formulas that return valid numbers.
		oParser = new parserFormula('BESSELY(ABS(-2), ROUNDUP(1.1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(ABS(-2), ROUNDUP(1.1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.107032432, 'Test: Positive case: Formula, Formula. Both arguments are nested formulas that return valid numbers.');
		// Case #9: Formula. BESSELY is used as part of a parent formula SUM.
		oParser = new parserFormula('SUM(BESSELY(2, 1), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BESSELY(2, 1), 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.892967568, 'Test: Positive case: Formula. BESSELY is used as part of a parent formula SUM.');
		// Case #10: Formula. BESSELY is used inside a logical parent formula IF.
		oParser = new parserFormula('IF(BESSELY(3,2)>0, "Positive", "Not Positive")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(BESSELY(3,2)>0, "Positive", "Not Positive") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'Not Positive', 'Test: Positive case: Formula. BESSELY is used inside a logical parent formula IF.');
		// Case #11: Area, Number. X is a reference to a single-cell area.
		oParser = new parserFormula('BESSELY(A102:A102, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(A102:A102, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.107032432, 'Test: Positive case: Area, Number. X is a reference to a single-cell area.');
		// Case #12: Number, Area. N is a reference to a single-cell area with a float number.
		oParser = new parserFormula('BESSELY(6, A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(6, A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, -0.28819469, 'Test: Positive case: Number, Area. N is a reference to a single-cell area with a float number.');
		// Case #13: Name, Number. X is a reference to a named range (Name).
		oParser = new parserFormula('BESSELY(TestName, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(TestName, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.1459181, 'Test: Positive case: Name, Number. X is a reference to a named range (Name).');
		// Case #14: Number, Name. N is a reference to a named range (Name).
		oParser = new parserFormula('BESSELY(1, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(1, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.781212821, 'Test: Positive case: Number, Name. N is a reference to a named range (Name).');
		// Case #15: Ref3D, Number. X is a 3D reference to a single cell in another sheet.
		oParser = new parserFormula('BESSELY(Sheet2!A1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(Sheet2!A1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.1459181, 'Test: Positive case: Ref3D, Number. X is a 3D reference to a single cell in another sheet.');
		// Case #16: Number, Ref3D. N is a 3D reference to a single cell in another sheet.
		oParser = new parserFormula('BESSELY(2, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(2, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.107032432, 'Test: Positive case: Number, Ref3D. N is a 3D reference to a single cell in another sheet.');
		// Case #17: Area3D, Number. X is a 3D reference to a single-cell area in another sheet.
		oParser = new parserFormula('BESSELY(Sheet2!A2:A2, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(Sheet2!A2:A2, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -1.650682613, 'Test: Positive case: Area3D, Number. X is a 3D reference to a single-cell area in another sheet.');
		// Case #18: Name3D, Number. X is a reference to a 3D named range (Name3D).
		oParser = new parserFormula('BESSELY(TestName3D, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(TestName3D, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, -0.381335848, 'Test: Positive case: Name3D, Number. X is a reference to a 3D named range (Name3D).');
		// Case #19: Number, Name3D. N is a reference to a 3D named range (Name3D).
		oParser = new parserFormula('BESSELY(10, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(10, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.249015424, 'Test: Positive case: Number, Name3D. N is a reference to a 3D named range (Name3D).');
		// Case #20: Formula, Number. Using a DATE() formula as a valid numeric input for X.
		oParser = new parserFormula('BESSELY(DATE(2025,1,1), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(DATE(2025,1,1), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.003364636, 'Test: Positive case: Formula, Number. Using a DATE() formula as a valid numeric input for X.');
		// Case #21: Table. Reference to a whole table column
		oParser = new parserFormula('BESSELY(Table1[Column1], 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(Table1[Column1], 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.1459181, 'Test: Positive case: Table. Reference to a whole table column');
		// Case #22: String, String. A date string for X
		oParser = new parserFormula('BESSELY("01/01/2025", "2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY("01/01/2025", "2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.001619508, 'Test: Positive case: String, String. A date string for X');

		// Negative cases:

		// Case #1: Number, Boolean. Boolean TRUE for the order N.
		oParser = new parserFormula('BESSELY(5, TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(5, TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Boolean TRUE for the order N.');
		// Case #2: Number(2). N is negative number
		oParser = new parserFormula('BESSELY(1,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(1,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). N is negative number');
		// Case #3: Number(2). X nagative number
		oParser = new parserFormula('BESSELY(-1,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(-1,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). X nagative number');
		// Case #4: Number, Number. The order N is negative, which returns a #NUM! error.
		oParser = new parserFormula('BESSELY(5, -1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(5, -1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. The order N is negative, which returns a #NUM! error.');
		// Case #5: Number, Number. X is zero. The function is undefined at X=0 and returns #NUM! error.
		oParser = new parserFormula('BESSELY(0, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(0, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. X is zero. The function is undefined at X=0 and returns #NUM! error.');
		// Case #6: String, Number. X is a non-numeric string, resulting in a #VALUE! error.
		oParser = new parserFormula('BESSELY("text", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY("text", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. X is a non-numeric string, resulting in a #VALUE! error.');
		// Case #7: Number, String. N is a non-numeric string, resulting in a #VALUE! error.
		oParser = new parserFormula('BESSELY(2, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(2, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. N is a non-numeric string, resulting in a #VALUE! error.');
		// Case #8: Error, Number. The formula propagates the incoming error from the first argument.
		oParser = new parserFormula('BESSELY(#N/A, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(#N/A, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. The formula propagates the incoming error from the first argument.');
		// Case #9: Empty, Number. X refers to an empty cell, which is treated as 0, returning #NUM! error.
		oParser = new parserFormula('BESSELY(A104, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(A104, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. X refers to an empty cell, which is treated as 0, returning #NUM! error.');
		// Case #10: Area, Number. X is a multi-cell range, which results in a #VALUE! error.
		oParser = new parserFormula('BESSELY(A100:A101, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(A100:A101, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. X is a multi-cell range, which results in a #VALUE! error.');
		// Case #11: Reference link, Number. Reference to a cell containing an error value for X.
		oParser = new parserFormula('BESSELY(A103, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(A103, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Reference link, Number. Reference to a cell containing an error value for X.');
		// Case #12: Number, Reference link. Reference to a cell containing an error value for N.
		oParser = new parserFormula('BESSELY(1, A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(1, A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Reference link. Reference to a cell containing an error value for N.');
		// Case #13: Reference link, Number. Reference to a cell containing non-numeric text.
		oParser = new parserFormula('BESSELY(A105, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(A105, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to a cell containing non-numeric text.');
		// Case #14: Name, Number. X is a named range referring to multiple cells, causing a #VALUE! error.
		oParser = new parserFormula('BESSELY(TestNameArea, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(TestNameArea, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number. X is a named range referring to multiple cells, causing a #VALUE! error.');
		// Case #15: Number, Name. N is a named range referring to multiple cells, causing a #VALUE! error.
		oParser = new parserFormula('BESSELY(1, TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(1, TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name. N is a named range referring to multiple cells, causing a #VALUE! error.');
		// Case #16: Ref3D, Number. 3D Reference to a cell containing an error.
		oParser = new parserFormula('BESSELY(Sheet2!A3, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(Sheet2!A3, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Ref3D, Number. 3D Reference to a cell containing an error.');
		// Case #17: Area3D, Number. 3D Reference to a multi-cell area.
		oParser = new parserFormula('BESSELY(Sheet2!A1:A2, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(Sheet2!A1:A2, 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number. 3D Reference to a multi-cell area.');
		// Case #18: Name3D, Number. Name3D referring to a multi-cell area.
		oParser = new parserFormula('BESSELY(TestNameArea3D, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(TestNameArea3D, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D, Number. Name3D referring to a multi-cell area.');
		// Case #19: Number, Number. X must be non-negative. A negative X returns #NUM! error.
		oParser = new parserFormula('BESSELY(-1, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(-1, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. X must be non-negative. A negative X returns #NUM! error.');

		// Bounded cases:

		// Case #1: Number, Number. Minimum valid integer for N is 0.
		oParser = new parserFormula('BESSELY(1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(1, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.088256971, 'Test: Bounded case: Number, Number. Minimum valid integer for N is 0.');
		// Case #2: Number, Number. Approaching the maximum positive float number for X.
		oParser = new parserFormula('BESSELY(100000000, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(100000000, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.00007306, 'Test: Bounded case: Number, Number. Approaching the maximum positive float number for X.');
		// Case #3: Number, Number. Approaching the minimum positive float number (closest to zero) for X.
		oParser = new parserFormula('BESSELY(9.99E-307, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(9.99E-307, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -6.3725702902902906e+305, 'Test: Bounded case: Number, Number. Approaching the minimum positive float number (closest to zero) for X.');
		// Case #4: Number, Formula. Using a very large integer for the order N.
		oParser = new parserFormula('BESSELY(1, 2147483647)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BESSELY(1, 2147483647) is parsed.');
		//?! assert.strictEqual(oParser.calculate().getValue(), -5.1999e+307, 'Test: Bounded case: Number, Formula. Using a very large integer for the order N.');

        // Need to fix: long calculation in boundary test, boolean handle, results diff from MS
        // Case #1: Number, Boolean. Boolean TRUE for the order N.
        // Case #17: Area3D, Number. 3D Reference to a multi-cell area.
        // Case #4: Number, Formula. Using a very large integer for the order N. - long calc

		testArrayFormula2(assert, "BESSELY", 2, 2, true, null);

	});


	QUnit.test("Test: \"BIN2DEC\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1100100");
		ws.getRange2("A101").setValue("Test");
		ws.getRange2("A102").setValue("1001");
		ws.getRange2("A103").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1001"); // Column1
		ws.getRange2("B601").setValue("Test"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1001");
		ws2.getRange2("A2").setValue("Test");
		ws2.getRange2("A3").setValue("10001");
		ws2.getRange2("A4").setValue("10");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1001"); // TestName
		ws.getRange2("A202").setValue("Test"); // TestName1
		ws.getRange2("A206").setValue("Text"); // TestNameArea
		ws.getRange2("A207").setValue("Test"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1001") // TestName3D
		ws2.getRange2("A12").setValue("Test") // TestName3D1

		// Positive cases:

		// Case #1: Number. Example from documentation
		oParser = new parserFormula('BIN2DEC(101010)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(101010) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 42, 'Test: Positive case: Number. Example from documentation');
		// Case #2: String. Example from documentation in string format
		oParser = new parserFormula('BIN2DEC("101010")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("101010") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 42, 'Test: Positive case: String. Example from documentation in string format');
		// Case #3: Number. Example from documentation bin to dec must be 511
		oParser = new parserFormula('BIN2DEC(111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 511, 'Test: Positive case: Number. Example from documentation bin to dec must be 511');
		// Case #4: Number. Bin must be converting to -512
		oParser = new parserFormula('BIN2DEC(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -512, 'Test: Positive case: Number. Bin must be converting to -512');
		// Case #5: Number. Binary must be converting to -1
		oParser = new parserFormula('BIN2DEC(1111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Number. Binary must be converting to -1');
		// Case #6: Number. Basic valid input: positive binary number as integer.
		oParser = new parserFormula('BIN2DEC(1010)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1010) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number. Basic valid input: positive binary number as integer.');
		// Case #7: String. Basic valid input: positive binary number as string.
		oParser = new parserFormula('BIN2DEC("1010")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1010") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String. Basic valid input: positive binary number as string.');
		// Case #8: String. Zero as string.
		oParser = new parserFormula('BIN2DEC("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Zero as string.');
		// Case #9: Number. Zero as number.
		oParser = new parserFormula('BIN2DEC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero as number.');
		// Case #10: String. Maximum 10-bit binary number as string.
		oParser = new parserFormula('BIN2DEC("1111111111")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1111111111") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: String. Maximum 10-bit binary number as string.');
		// Case #11: Number. Maximum 10-bit binary number as number.
		oParser = new parserFormula('BIN2DEC(1111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Number. Maximum 10-bit binary number as number.');
		// Case #12: String. 10-bit negative binary number as string (sign bit is 1).
		oParser = new parserFormula('BIN2DEC("1000000000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1000000000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -512, 'Test: Positive case: String. 10-bit negative binary number as string (sign bit is 1).');
		// Case #13: Number. 10-bit negative binary number as number (sign bit is 1).
		oParser = new parserFormula('BIN2DEC(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -512, 'Test: Positive case: Number. 10-bit negative binary number as number (sign bit is 1).');
		// Case #14: Formula. Simple formula that evaluates to a binary number.
		oParser = new parserFormula('BIN2DEC(1*1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1*1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Simple formula that evaluates to a binary number.');
		// Case #15: Formula. String concatenation formula.
		oParser = new parserFormula('BIN2DEC(CONCATENATE("10","10"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(CONCATENATE("10","10")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. String concatenation formula.');
		// Case #16: Reference link. Reference to a cell containing a valid binary number.
		oParser = new parserFormula('BIN2DEC(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Reference link. Reference to a cell containing a valid binary number.');
		// Case #17: Area. Single-cell range containing a valid binary number.
		oParser = new parserFormula('BIN2DEC(A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Area. Single-cell range containing a valid binary number.');
		// Case #18: Array. Array with a single valid binary number.
		oParser = new parserFormula('BIN2DEC({101})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC({101}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Array with a single valid binary number.');
		// Case #19: Name. Named range with a valid binary number.
		oParser = new parserFormula('BIN2DEC(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Name. Named range with a valid binary number.');
		// Case #20: Name3D. 3D named range with a valid binary number.
		oParser = new parserFormula('BIN2DEC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Name3D. 3D named range with a valid binary number.');
		// Case #21: Ref3D. 3D reference to a cell with a valid binary number.
		oParser = new parserFormula('BIN2DEC(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Ref3D. 3D reference to a cell with a valid binary number.');
		// Case #22: Area3D. 3D single-cell range with a valid binary number.
		oParser = new parserFormula('BIN2DEC(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Area3D. 3D single-cell range with a valid binary number.');
		// Case #23: Table. Table reference with a valid binary number.
		oParser = new parserFormula('BIN2DEC(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Table. Table reference with a valid binary number.');
		// Case #24: Formula. BIN2DEC used inside another formula.
		oParser = new parserFormula('SUM(BIN2DEC(101),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BIN2DEC(101),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. BIN2DEC used inside another formula.');
		// Case #25: Formula. Nested IF formula returning a valid binary number.
		oParser = new parserFormula('BIN2DEC(IF(TRUE,101,111))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(IF(TRUE,101,111)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Nested IF formula returning a valid binary number.');
		// Case #26: String. Binary with leading zeros as string.
		oParser = new parserFormula('BIN2DEC("0000000101")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("0000000101") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. Binary with leading zeros as string.');
		// Case #27: Number. Binary with leading zeros as number.
		oParser = new parserFormula('BIN2DEC(0000000101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(0000000101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number. Binary with leading zeros as number.');
		// Case #28: String. All zeros (10 bits) as string.
		oParser = new parserFormula('BIN2DEC("0000000000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("0000000000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. All zeros (10 bits) as string.');
		// Case #29: Number. All zeros (10 bits) as number.
		oParser = new parserFormula('BIN2DEC(0000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(0000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. All zeros (10 bits) as number.');
		// Case #30: Formula. Binary number from VALUE formula.
		oParser = new parserFormula('BIN2DEC(VALUE("101"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(VALUE("101")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Binary number from VALUE formula.');
		// Case #31: Formula. Binary number from INT formula.
		oParser = new parserFormula('BIN2DEC(INT(101.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(INT(101.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Binary number from INT formula.');
		// Case #32: Formula. Binary number from ROUND formula.
		oParser = new parserFormula('BIN2DEC(ROUND(101.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(ROUND(101.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Binary number from ROUND formula.');
		// Case #33: Formula. Binary number from TEXT formula.
		oParser = new parserFormula('BIN2DEC(TEXT(101,"000000"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(TEXT(101,"000000")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Binary number from TEXT formula.');
		// Case #34: String. Mixed bits (10-bit negative number).
		oParser = new parserFormula('BIN2DEC("1111100000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1111100000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -32, 'Test: Positive case: String. Mixed bits (10-bit negative number).');
		// Case #35: String. Almost maximum negative 10-bit value.
		oParser = new parserFormula('BIN2DEC("1111111110")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1111111110") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: String. Almost maximum negative 10-bit value.');
		// Case #36: String. Medium length binary number.
		oParser = new parserFormula('BIN2DEC("101010")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("101010") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 42, 'Test: Positive case: String. Medium length binary number.');
		// Case #37: Formula. Substring binary from text function.
		oParser = new parserFormula('BIN2DEC(MID("101010",2,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(MID("101010",2,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Substring binary from text function.');
		// Case #38: Formula. Right part of binary string.
		oParser = new parserFormula('BIN2DEC(RIGHT("0000101",3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(RIGHT("0000101",3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Right part of binary string.');
		// Case #39: Formula. BIN2DEC as an argument to another function.
		oParser = new parserFormula('POWER(2,BIN2DEC(101))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula POWER(2,BIN2DEC(101)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 32, 'Test: Positive case: Formula. BIN2DEC as an argument to another function.');
		// Case #40: Formula. Multiple BIN2DEC calls in one formula.
		oParser = new parserFormula('AVERAGE(BIN2DEC(101),BIN2DEC(111))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula AVERAGE(BIN2DEC(101),BIN2DEC(111)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. Multiple BIN2DEC calls in one formula.');
		// Case #41: Formula. CHOOSE formula returning binary string.
		oParser = new parserFormula('BIN2DEC(CHOOSE(2,"100","101","110"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(CHOOSE(2,"100","101","110")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. CHOOSE formula returning binary string.');
		// Case #42: Formula. Boolean TRUE converted to binary.
		oParser = new parserFormula('BIN2DEC(TRUE*1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(TRUE*1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Boolean TRUE converted to binary.');
		// Case #43: Formula. Boolean FALSE converted to binary.
		oParser = new parserFormula('BIN2DEC(FALSE*1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(FALSE*1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula. Boolean FALSE converted to binary.');
		// Case #44: Empty. Reference to empty cell.
		oParser = new parserFormula('BIN2DEC(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty. Reference to empty cell.');
		// Case #45: String. Empty string.
		oParser = new parserFormula('BIN2DEC("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Empty string.');
		// Case #46: Formula. UNICHAR function returning "1".
		oParser = new parserFormula('BIN2DEC(UNICHAR(49))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(UNICHAR(49)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. UNICHAR function returning "1".');

		// Negative cases:

		// Case #1: Number. Incorrect binary number
		oParser = new parserFormula('BIN2DEC(1234567890)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1234567890) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Incorrect binary number');
		// Case #2: String. Incorrect behavior using text instead of bin number
		oParser = new parserFormula('BIN2DEC("Hello World!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("Hello World!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Incorrect behavior using text instead of bin number');
		// Case #3: String. Invalid binary digit (2) in string.
		oParser = new parserFormula('BIN2DEC("10102")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("10102") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Invalid binary digit (2) in string.');
		// Case #4: Number. Invalid binary digit (2) in number.
		oParser = new parserFormula('BIN2DEC(10102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(10102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Invalid binary digit (2) in number.');
		// Case #5: String. Invalid binary character (A) in string.
		oParser = new parserFormula('BIN2DEC("10A10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("10A10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Invalid binary character (A) in string.');
		// Case #6: String. Invalid decimal point in binary string.
		oParser = new parserFormula('BIN2DEC("10.10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("10.10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Invalid decimal point in binary string.');
		// Case #7: String. Negative sign not allowed (use two\'s complement).
		oParser = new parserFormula('BIN2DEC("-101")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("-101") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Negative sign not allowed (use two\'s complement).');
		// Case #8: String. Binary number exceeds 10 bits.
		oParser = new parserFormula('BIN2DEC("00000000001")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("00000000001") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Binary number exceeds 10 bits.');
		// Case #9: String. Binary number exceeds maximum 10 bits.
		oParser = new parserFormula('BIN2DEC("11111111111")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("11111111111") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Binary number exceeds maximum 10 bits.');
		// Case #10: Number. Binary number exceeds maximum 10 bits.
		oParser = new parserFormula('BIN2DEC(11111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(11111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Binary number exceeds maximum 10 bits.');
		// Case #11: Error. Error value as input.
		oParser = new parserFormula('BIN2DEC(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value as input.');
		// Case #12: Error. Division by zero error.
		oParser = new parserFormula('BIN2DEC(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1/0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error. Division by zero error.');
		// Case #13: Formula. Formula resulting in error.
		oParser = new parserFormula('BIN2DEC(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(SQRT(-1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in error.');
		// Case #14: Area. Multi-cell range.
		oParser = new parserFormula('BIN2DEC(A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range.');
		// Case #15: String. Scientific notation not allowed in binary.
		oParser = new parserFormula('BIN2DEC("1E+2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1E+2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Scientific notation not allowed in binary.');
		// Case #16: Name. Named range with multiple cells.
		oParser = new parserFormula('BIN2DEC(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with multiple cells.');
		// Case #17: Formula. Formula with string operation resulting in non-binary value.
		oParser = new parserFormula('BIN2DEC(LEFT("10101",3)+RIGHT("10101",2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(LEFT("10101",3)+RIGHT("10101",2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula with string operation resulting in non-binary value.');
		// Case #18: String. Non-numeric string.
		oParser = new parserFormula('BIN2DEC("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string.');
		// Case #19: Formula. Date serial number (not binary).
		oParser = new parserFormula('BIN2DEC(DATE(2023,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(DATE(2023,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Date serial number (not binary).');
		// Case #20: Formula. Time value (not binary).
		oParser = new parserFormula('BIN2DEC(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Time value (not binary).');
		// Case #21: Formula. PI function (not binary).
		oParser = new parserFormula('BIN2DEC(PI())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(PI()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. PI function (not binary).');
		// Case #22: Formula. Formula evaluates to non-binary (5).
		oParser = new parserFormula('BIN2DEC(2+3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(2+3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula evaluates to non-binary (5).');
		// Case #23: String. String with mathematical operators.
		oParser = new parserFormula('BIN2DEC("1+1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1+1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String with mathematical operators.');
		// Case #24: Formula. Formula returning a non-binary value.
		oParser = new parserFormula('BIN2DEC(LEN("101010"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(LEN("101010")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula returning a non-binary value.');
		// Case #25: String. Invalid binary digit (9).
		oParser = new parserFormula('BIN2DEC("9")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("9") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Invalid binary digit (9).');
		// Case #26: Number. Invalid binary digit (9) as number.
		oParser = new parserFormula('BIN2DEC(9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Invalid binary digit (9) as number.');
		// Case #27: String. Binary with commas.
		oParser = new parserFormula('BIN2DEC("1,0,1,0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1,0,1,0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Binary with commas.');
		// Case #28: String. Binary with spaces between digits.
		oParser = new parserFormula('BIN2DEC("1 0 1 0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1 0 1 0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Binary with spaces between digits.');
		// Case #29: Reference link. Reference to a cell with invalid binary value.
		oParser = new parserFormula('BIN2DEC(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Reference to a cell with invalid binary value.');
		// Case #30: Name3D. 3D Named range with invalid binary value.
		oParser = new parserFormula('BIN2DEC(TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D Named range with invalid binary value.');
		// Case #31: Table. Table reference with invalid binary value.
		oParser = new parserFormula('BIN2DEC(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table. Table reference with invalid binary value.');
		// Case #32: String. Binary number as string with trailing spaces.
		oParser = new parserFormula('BIN2DEC("101 ")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("101 ") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Binary number as string with trailing spaces.');
		// Case #33: String. Binary number as string with leading spaces.
		oParser = new parserFormula('BIN2DEC(" 101")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(" 101") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Binary number as string with leading spaces.');

		// Bounded cases:

		// Case #1: String. Minimum valid input (zero).
		oParser = new parserFormula('BIN2DEC("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: String. Minimum valid input (zero).');
		// Case #2: Number. Minimum valid input as number (zero).
		oParser = new parserFormula('BIN2DEC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid input as number (zero).');
		// Case #3: String. Maximum positive 10-bit binary value.
		oParser = new parserFormula('BIN2DEC("0111111111")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("0111111111") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 511, 'Test: Bounded case: String. Maximum positive 10-bit binary value.');
		// Case #4: Number. Maximum positive 10-bit binary value as number.
		oParser = new parserFormula('BIN2DEC(0111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(0111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 511, 'Test: Bounded case: Number. Maximum positive 10-bit binary value as number.');
		// Case #5: String. Minimum negative 10-bit binary value.
		oParser = new parserFormula('BIN2DEC("1000000000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1000000000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -512, 'Test: Bounded case: String. Minimum negative 10-bit binary value.');
		// Case #6: Number. Minimum negative 10-bit binary value as number.
		oParser = new parserFormula('BIN2DEC(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -512, 'Test: Bounded case: Number. Minimum negative 10-bit binary value as number.');
		// Case #7: String. Minimum length binary number.
		oParser = new parserFormula('BIN2DEC("1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: String. Minimum length binary number.');
		// Case #8: Number. Minimum length binary number as number.
		oParser = new parserFormula('BIN2DEC(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum length binary number as number.');
		// Case #9: String. Maximum negative 10-bit binary value.
		oParser = new parserFormula('BIN2DEC("1111111111")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC("1111111111") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: String. Maximum negative 10-bit binary value.');
		// Case #10: Number. Maximum negative 10-bit binary value as number.
		oParser = new parserFormula('BIN2DEC(1111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2DEC(1111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Bounded case: Number. Maximum negative 10-bit binary value as number.');

        // Need to fix: error types diff, error handle
        // Case #11: Error. Error value as input.
        // Case #12: Error. Division by zero error.
        // Case #13: Formula. Formula resulting in error.

		testArrayFormula2(assert, "BIN2DEC", 1, 1, true);
	});

	QUnit.test("Test: \"BIN2HEX\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("11111011");
		ws.getRange2("A101").setValue("1110");
		ws.getRange2("A102").setValue("1111111111");
		ws.getRange2("A103").setValue("4");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1110"); // Column1
		ws.getRange2("B601").setValue("4"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("11111011");
		ws2.getRange2("A2").setValue("1110");
		ws2.getRange2("A3").setValue("1111111111");
		ws2.getRange2("A4").setValue("4");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("11111011"); // TestName
		ws.getRange2("A202").setValue("1110"); // TestName1
		ws.getRange2("A203").setValue("1111111111"); // TestName2
		ws.getRange2("A204").setValue("4"); // TestName3
		ws.getRange2("A206").setValue("11111011"); // TestNameArea
		ws.getRange2("A207").setValue("1110"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("11111011") // TestName3D
		ws2.getRange2("A12").setValue("1110") // TestName3D1
		ws2.getRange2("A13").setValue("1111111111") // TestName3D2
		ws2.getRange2("A14").setValue("4") // TestName3D3
		ws2.getRange2("A16").setValue("11111011"); // TestNameArea3D
		ws2.getRange2("A17").setValue("1110"); // TestNameArea3D

		// Positive cases:

		// Case #1: Number. Bin to hex must be  2A. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(101010)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101010) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2A', 'Test: Positive case: Number. Bin to hex must be  2A. 1 of 2 arguments used.');
		// Case #2: String. Bin to hex must be 2A . 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX("101010")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX("101010") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2A', 'Test: Positive case: String. Bin to hex must be 2A . 1 of 2 arguments used.');
		// Case #3: Number. Bin to hex must be 1FF. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1FF', 'Test: Positive case: Number. Bin to hex must be 1FF. 1 of 2 arguments used.');
		// Case #4: Number. Bin to hex must be  FFFFFFFE00. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFE00', 'Test: Positive case: Number. Bin to hex must be  FFFFFFFE00. 1 of 2 arguments used.');
		// Case #5: Number. Bin to hex must be  FFFFFFFFF. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(1111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFFFF', 'Test: Positive case: Number. Bin to hex must be  FFFFFFFFF. 1 of 2 arguments used.');
		// Case #6: Number(2). Bin to hex must be 2A. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(101010,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101010,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2A', 'Test: Positive case: Number(2). Bin to hex must be 2A. 2 of 2 arguments used.');
		// Case #7: Number(2). Bin to hex must be 002A. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(101010,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101010,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '002A', 'Test: Positive case: Number(2). Bin to hex must be 002A. 2 of 2 arguments used.');
		// Case #8: Number(2). Bin to hex must be   002A. Second arg  float number. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(101010,4.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101010,4.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '002A', 'Test: Positive case: Number(2). Bin to hex must be   002A. Second arg  float number. 2 of 2 arguments used.');
		// Case #9: Number. Standard positive number conversion.
		oParser = new parserFormula('BIN2HEX(1111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'F', 'Test: Positive case: Number. Standard positive number conversion.');
		// Case #10: Number,Number. Positive number conversion with places. Pads with leading zeros.
		oParser = new parserFormula('BIN2HEX(1111,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1111,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00F', 'Test: Positive case: Number,Number. Positive number conversion with places. Pads with leading zeros.');
		// Case #11: String. Numeric string converted to number. Confirms robust type coercion.
		oParser = new parserFormula('BIN2HEX("1010")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX("1010") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'A', 'Test: Positive case: String. Numeric string converted to number. Confirms robust type coercion.');
		// Case #12: String,Number. Numeric string conversion with places.
		oParser = new parserFormula('BIN2HEX("1010",4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX("1010",4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000A', 'Test: Positive case: String,Number. Numeric string conversion with places.');
		// Case #13: Number. Negative number conversion. Places argument should be ignored.
		oParser = new parserFormula('BIN2HEX(1111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFFFF', 'Test: Positive case: Number. Negative number conversion. Places argument should be ignored.');
		// Case #14: Formula. Nested formula generates valid binary input.
		oParser = new parserFormula('BIN2HEX(CONCATENATE("101","10"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(CONCATENATE("101","10")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "16", 'Test: Positive case: Formula. Nested formula generates valid binary input.');
		// Case #15: Formula,Number. Nested formula with both arguments generated by functions.
		oParser = new parserFormula('BIN2HEX(DEC2BIN(15),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(DEC2BIN(15),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000000000F', 'Test: Positive case: Formula,Number. Nested formula with both arguments generated by functions.');
		// Case #16: Formula. BIN2HEX is a part of a parent formula.
		oParser = new parserFormula('LEN(BIN2HEX(1110))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula LEN(BIN2HEX(1110)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. BIN2HEX is a part of a parent formula.');
		// Case #17: Number. Conversion of zero.
		oParser = new parserFormula('BIN2HEX(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "0", 'Test: Positive case: Number. Conversion of zero.');
		// Case #18: Empty. Empty cell converted to zero. F1 is an empty cell.
		oParser = new parserFormula('BIN2HEX(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FB', 'Test: Positive case: Empty. Empty cell converted to zero. F1 is an empty cell.');
		// Case #19: Reference link. Reference to a cell containing a valid number.
		oParser = new parserFormula('BIN2HEX(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FB', 'Test: Positive case: Reference link. Reference to a cell containing a valid number.');
		// Case #20: Reference link,Number. Reference to a cell with places argument.
		oParser = new parserFormula('BIN2HEX(A101,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(A101,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0000E', 'Test: Positive case: Reference link,Number. Reference to a cell with places argument.');
		// Case #21: Reference link. Reference to a 10-bit number.
		oParser = new parserFormula('BIN2HEX(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFFFF', 'Test: Positive case: Reference link. Reference to a 10-bit number.');
		// Case #22: Area. Area of a single cell. Correctly processed.
		oParser = new parserFormula('BIN2HEX(A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFFFF', 'Test: Positive case: Area. Area of a single cell. Correctly processed.');
		// Case #23: Name. Named range reference to a single cell.
		oParser = new parserFormula('BIN2HEX(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FB', 'Test: Positive case: Name. Named range reference to a single cell.');
		// Case #24: Name,Number. Named range reference with places argument.
		oParser = new parserFormula('BIN2HEX(TestName1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(TestName1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000E', 'Test: Positive case: Name,Number. Named range reference with places argument.');
		// Case #25: Table(2). Table reference to a single cell within a table.
		oParser = new parserFormula('BIN2HEX(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000E', 'Test: Positive case: Table(2). Table reference to a single cell within a table.');
		// Case #26: Ref3D. 3D reference to a single cell on another sheet. B54 on sheet \'3D\' contains the value.
		oParser = new parserFormula('BIN2HEX(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FB', 'Test: Positive case: Ref3D. 3D reference to a single cell on another sheet. B54 on sheet \'3D\' contains the value.');
		// Case #27: Name3D. Named 3D reference to a single cell on another sheet.
		oParser = new parserFormula('BIN2HEX(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FB', 'Test: Positive case: Name3D. Named 3D reference to a single cell on another sheet.');
		// Case #28: Area3D. 3D area reference to a single cell. Correctly processed.
		oParser = new parserFormula('BIN2HEX(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FB', 'Test: Positive case: Area3D. 3D area reference to a single cell. Correctly processed.');
		// Case #29: Number. Valid binary number conversion.
		oParser = new parserFormula('BIN2HEX(1011)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1011) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'B', 'Test: Positive case: Number. Valid binary number conversion.');
		// Case #30: Number,Number. Valid binary number with places argument.
		oParser = new parserFormula('BIN2HEX(1110,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1110,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000E', 'Test: Positive case: Number,Number. Valid binary number with places argument.');
		// Case #31: Number,Number. Places argument too small.
		oParser = new parserFormula('BIN2HEX(1111,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1111,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'F', 'Test: Positive case: Number,Number. Places argument too small.');
		// Case #32: Array(2). Number and places are array. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX({1011}, {2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX({1011}, {2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0B', 'Test: Positive case: Array(2). Number and places are array. 2 of 2 arguments used.');
		// Case #33: Number,String. Place is  number in string. 2 of 2 argumenrs used.
		oParser = new parserFormula('BIN2HEX(1010,"4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1010,"4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000A', 'Test: Positive case: Number,String. Place is  number in string. 2 of 2 argumenrs used.');
		// Case #34: Reference link(2). Checking place as ref link to cell with correct value. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(A100, A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(A100, A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00FB', 'Test: Positive case: Reference link(2). Checking place as ref link to cell with correct value. 2 of 2 arguments used.');
		// Case #35: Reference link, Area. Place area with one element. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(A100, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(A100, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00FB', 'Test: Positive case: Reference link, Area. Place area with one element. 2 of 2 arguments used.');
		// Case #36: Number, Ref3D. Plaсe checking Ref3D link to cell with correct value. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(1010,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1010,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000A', 'Test: Positive case: Number, Ref3D. Plaсe checking Ref3D link to cell with correct value. 2 of 2 arguments used.');
		// Case #37: Number, Area3D. Place checking  area3D with one element. 2 of 2 argument used
		oParser = new parserFormula('BIN2HEX(1010,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1010,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000A', 'Test: Positive case: Number, Area3D. Place checking  area3D with one element. 2 of 2 argument used');
		// Case #38: Number, Name. Place checking  name with one element. 2 of 2 argument used
		oParser = new parserFormula('BIN2HEX(1010,TestName3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1010,TestName3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000A', 'Test: Positive case: Number, Name. Place checking  name with one element. 2 of 2 argument used');
		// Case #39: Number, Name3D. Place checking  name3e with one element. 2 of 2 argument used
		oParser = new parserFormula('BIN2HEX(1010,TestName3D3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1010,TestName3D3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000A', 'Test: Positive case: Number, Name3D. Place checking  name3e with one element. 2 of 2 argument used');

		// Negative cases:

		// Case #1: Number. Incorrect number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(1234567890)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1234567890) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Incorrect number. 1 of 2 arguments used.');
		// Case #2: String. Incorrect sting text instead of bin number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX("Hello World!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX("Hello World!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Incorrect sting text instead of bin number. 1 of 2 arguments used.');
		// Case #3: Number. Incorrect number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(101010101010)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101010101010) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Incorrect number. 1 of 2 arguments used.');
		// Case #4: Number(2). Incorrect number. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(101010,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101010,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Incorrect number. 2 of 2 arguments used.');
		// Case #5: Number(2). Incorrect places - negative number. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(101010,-4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101010,-4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Incorrect places - negative number. 2 of 2 arguments used.');
		// Case #6: Number, String. Incorrect places text instead of number. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(101010, "Hello World!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101010, "Hello World!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Incorrect places text instead of number. 2 of 2 arguments used.');
		// Case #1: String. #NUM! error. Invalid binary digit.
		oParser = new parserFormula('BIN2HEX("102")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX("102") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. #NUM! error. Invalid binary digit.');
		// Case #2: String. #NUM! error. More than 10 characters.
		oParser = new parserFormula('BIN2HEX("11111111111")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX("11111111111") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. #NUM! error. More than 10 characters.');
		// Case #3: String. #NUM! error. Non-binary string input.
		oParser = new parserFormula('BIN2HEX("some text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX("some text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. #NUM! error. Non-binary string input.');
		// Case #4: Number. #NUM! error. More than 10 bits.
		oParser = new parserFormula('BIN2HEX(10000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(10000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. #NUM! error. More than 10 bits.');
		// Case #5: Number. #NUM! error. Not a valid binary number.
		oParser = new parserFormula('BIN2HEX(1234567890)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1234567890) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. #NUM! error. Not a valid binary number.');
		// Case #6: Number. #NUM! error. Excessive length.
		oParser = new parserFormula('BIN2HEX(11111111111111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(11111111111111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. #NUM! error. Excessive length.');
		// Case #7: Number,String. #VALUE! error. Non-numeric places argument.
		oParser = new parserFormula('BIN2HEX(1111,"five")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1111,"five") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number,String. #VALUE! error. Non-numeric places argument.');
		// Case #8: Number,Number. #NUM! error. Negative places argument.
		oParser = new parserFormula('BIN2HEX(1111,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1111,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Number. #NUM! error. Negative places argument.');
		// Case #9: Area. #VALUE! error. Two-cell area input, function cannot process an array.
		oParser = new parserFormula('BIN2HEX(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(A100:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. #VALUE! error. Two-cell area input, function cannot process an array.');
		// Case #10: Area. #VALUE! error. Three-cell area input.
		oParser = new parserFormula('BIN2HEX(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(A100:A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. #VALUE! error. Three-cell area input.');
		// Case #11: Name,Area. #VALUE! error. Named range of two cells.
		oParser = new parserFormula('BIN2HEX(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name,Area. #VALUE! error. Named range of two cells.');
		// Case #12: Name3D,Area3D. #VALUE! error. Named 3D range of two cells.
		oParser = new parserFormula('BIN2HEX(TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(TestNameArea3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D,Area3D. #VALUE! error. Named 3D range of two cells.');
		// Case #13: Formula. #NUM! error. Nested formula creates a >10 bit string.
		oParser = new parserFormula('BIN2HEX(CONCATENATE("111111111","11"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(CONCATENATE("111111111","11")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. #NUM! error. Nested formula creates a >10 bit string.');
		// Case #14: Number. #NUM! error. Input with a decimal point is not a valid binary number.
		oParser = new parserFormula('BIN2HEX(10.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(10.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. #NUM! error. Input with a decimal point is not a valid binary number.');
		// Case #15: Area3D. #VALUE! error. True 3D reference is an array input, which is not supported.
		oParser = new parserFormula('BIN2HEX(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(Sheet2!A1:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. #VALUE! error. True 3D reference is an array input, which is not supported.');
		// Case #16: Number,Number. #NUM! error. Places argument cannot be 0.
		oParser = new parserFormula('BIN2HEX(1000,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1000,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Number. #NUM! error. Places argument cannot be 0.');
		// Case #17: Number,Number. #NUM! error. Places argument is negative.
		oParser = new parserFormula('BIN2HEX(101,-2.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101,-2.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number,Number. #NUM! error. Places argument is negative.');
		// Case #18: Error. #VALUE! error. Input is an error value.
		oParser = new parserFormula('BIN2HEX(#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(#VALUE!) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error. #VALUE! error. Input is an error value.');
		// Case #19: Boolean. Number is TRUE. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Number is TRUE. 1 of 2 arguments used.');
		// Case #20: Boolean. Number is FALSE. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Number is FALSE. 1 of 2 arguments used.');
		// Case #21: Boolean(2). Places is TRUE. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(1111,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1111,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Places is TRUE. 2 of 2 arguments used.');
		// Case #22: Boolean(2). Places is FALSE. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2HEX(101, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(101, FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Places is FALSE. 2 of 2 arguments used.');

		// Bounded cases:

		// Case #1: Number. Conversion of maximum positive number (511 dec) with 9 bits. Result 1FF.
		oParser = new parserFormula('BIN2HEX(111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1FF', 'Test: Bounded case: Number. Conversion of maximum positive number (511 dec) with 9 bits. Result 1FF.');
		// Case #2: Number. Conversion of minimum negative number (-512 dec) with 10 bits. Result FFFFFFFE00.
		oParser = new parserFormula('BIN2HEX(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFE00', 'Test: Bounded case: Number. Conversion of minimum negative number (-512 dec) with 10 bits. Result FFFFFFFE00.');
		// Case #3: Number,Number. Max positive number with max places. Padding with leading zeros.
		oParser = new parserFormula('BIN2HEX(111111111,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(111111111,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000001FF', 'Test: Bounded case: Number,Number. Max positive number with max places. Padding with leading zeros.');
		// Case #4: Number,Number. Places argument is decimal. Should be truncated to 3.
		oParser = new parserFormula('BIN2HEX(111111111,3.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(111111111,3.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1FF', 'Test: Bounded case: Number,Number. Places argument is decimal. Should be truncated to 3.');
		// Case #5: Number. Conversion of -511 decimal. Next value after minimum negative.
		oParser = new parserFormula('BIN2HEX(1000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFE01', 'Test: Bounded case: Number. Conversion of -511 decimal. Next value after minimum negative.');
		// Case #6: Number,Number. Places argument ignored for negative number. 10-char result expected.
		oParser = new parserFormula('BIN2HEX(1000000000,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2HEX(1000000000,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFE00', 'Test: Bounded case: Number,Number. Places argument ignored for negative number. 10-char result expected.');

        // Need to fix: error types diff, error handle, results diff from MS
        // Case #9: Area. #VALUE! error. Two-cell area input, function cannot process an array.
        // Case #10: Area. #VALUE! error. Three-cell area input.
        // Case #11: Name,Area. #VALUE! error. Named range of two cells.
        // Case #12: Name3D,Area3D. #VALUE! error. Named 3D range of two cells.
        // Case #15: Area3D. #VALUE! error. True 3D reference is an array input, which is not supported.
        // Case #18: Error. #VALUE! error. Input is an error value.
        // Case #19: Boolean. Number is TRUE. 1 of 2 arguments used.
        // Case #20: Boolean. Number is FALSE. 1 of 2 arguments used.
        // Case #21: Boolean(2). Places is TRUE. 2 of 2 arguments used.
        // Case #22: Boolean(2). Places is FALSE. 2 of 2 arguments used.

		testArrayFormula2(assert, "BIN2HEX", 1, 2, true)

	});

	QUnit.test("Test: \"BIN2OCT\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1001");
		ws.getRange2("A101").setValue("1100100");
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("text");
		ws.getRange2("A104").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1100100"); // Column1
		ws.getRange2("B601").setValue("3"); // Column2
		ws.getRange2("C601").setValue("text"); // Column3
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("1001");
		ws2.getRange2("A2").setValue("1100100");
		ws2.getRange2("A3").setValue("3");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("1001"); // TestName
		ws.getRange2("A202").setValue("1100100"); // TestName1
		ws.getRange2("A203").setValue("3"); // TestName2
		ws.getRange2("A206").setValue("1001"); // TestNameArea
		ws.getRange2("A207").setValue("1100100"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1001") // TestName3D
		ws2.getRange2("A12").setValue("1100100") // TestName3D1
		ws2.getRange2("A13").setValue("3") // TestName3D2

		// Positive cases:

		// Case #1: Number. Bin to oct must be 52. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101010)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101010) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '52', 'Test: Positive case: Number. Bin to oct must be 52. 1 of 2 arguments used.');
		// Case #2: String. Bin (number in string) to oct must be 52. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("101010")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("101010") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '52', 'Test: Positive case: String. Bin (number in string) to oct must be 52. 1 of 2 arguments used.');
		// Case #3: Number. Bin to oct must be 777. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '777', 'Test: Positive case: Number. Bin to oct must be 777. 1 of 2 arguments used.');
		// Case #4: Number. Bin to oct must be 7777777000. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777000', 'Test: Positive case: Number. Bin to oct must be 7777777000. 1 of 2 arguments used.');
		// Case #5: Number. Bin to oct must be 7777777777. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777777', 'Test: Positive case: Number. Bin to oct must be 7777777777. 1 of 2 arguments used.');
		// Case #6: Number(2). Bin to oct must be 52. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101010, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101010, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '52', 'Test: Positive case: Number(2). Bin to oct must be 52. 2 of 2 arguments used.');
		// Case #7: Number(2). Bin to oct must be 0052. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101010, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101010, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0052', 'Test: Positive case: Number(2). Bin to oct must be 0052. 2 of 2 arguments used.');
		// Case #8: Number(2). Bin to oct must be 0052 (Places float number). 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101010, 4.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101010, 4.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0052', 'Test: Positive case: Number(2). Bin to oct must be 0052 (Places float number). 2 of 2 arguments used.');
		// Case #9: Number. Basic binary number (decimal 1). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Number. Basic binary number (decimal 1). 1 of 2 arguments used.');
		// Case #10: Number. Binary number 10 (decimal 2). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2', 'Test: Positive case: Number. Binary number 10 (decimal 2). 1 of 2 arguments used.');
		// Case #11: Number. Binary number 1010 (decimal 10). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1010)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1010) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '12', 'Test: Positive case: Number. Binary number 1010 (decimal 10). 1 of 2 arguments used.');
		// Case #12: Number(2). Binary with places specified (3). 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1010,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1010,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '012', 'Test: Positive case: Number(2). Binary with places specified (3). 2 of 2 arguments used.');
		// Case #13: Number(2). Binary with more places than needed (5). 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1010,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1010,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00012', 'Test: Positive case: Number(2). Binary with more places than needed (5). 2 of 2 arguments used.');
		// Case #14: Number. Zero as binary number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Number. Zero as binary number. 1 of 2 arguments used.');
		// Case #15: Number. Maximum 10-digit binary (negative number). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777777', 'Test: Positive case: Number. Maximum 10-digit binary (negative number). 1 of 2 arguments used.');
		// Case #16: Number. Negative binary number (10th bit as sign). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777000', 'Test: Positive case: Number. Negative binary number (10th bit as sign). 1 of 2 arguments used.');
		// Case #17: String. Binary number as string. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("101")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("101") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5', 'Test: Positive case: String. Binary number as string. 1 of 2 arguments used.');
		// Case #18: String(2). Binary string with places specified. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("1010",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("1010",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '12', 'Test: Positive case: String(2). Binary string with places specified. 2 of 2 arguments used.');
		// Case #19: String. Zero as binary string. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("0")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("0") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: String. Zero as binary string. 1 of 2 arguments used.');
		// Case #20: String. Binary with leading zeros as string. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("0000101")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("0000101") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5', 'Test: Positive case: String. Binary with leading zeros as string. 1 of 2 arguments used.');
		// Case #21: Formula. Binary from formula result (11). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(10+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(10+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3', 'Test: Positive case: Formula. Binary from formula result (11). 1 of 2 arguments used.');
		// Case #22: Formula(2). Binary and places from formula results. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101,1+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101,1+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '05', 'Test: Positive case: Formula(2). Binary and places from formula results. 2 of 2 arguments used.');
		// Case #23: Formula. Binary from INT function. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(INT(101.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(INT(101.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5', 'Test: Positive case: Formula. Binary from INT function. 1 of 2 arguments used.');
		// Case #24: Formula. BIN2OCT inside another formula. 1 argument for BIN2OCT.
		oParser = new parserFormula('SUM(1,BIN2OCT(101))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(1,BIN2OCT(101)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. BIN2OCT inside another formula. 1 argument for BIN2OCT.');
		// Case #25: Reference link. Reference to cell with binary number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11', 'Test: Positive case: Reference link. Reference to cell with binary number. 1 of 2 arguments used.');
		// Case #26: Reference link(2). References for both arguments. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A100,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A100,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '011', 'Test: Positive case: Reference link(2). References for both arguments. 2 of 2 arguments used.');
		// Case #27: Area. Single-cell range with binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '144', 'Test: Positive case: Area. Single-cell range with binary. 1 of 2 arguments used.');
		// Case #28: Area(2). Single-cell ranges for both arguments. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '144', 'Test: Positive case: Area(2). Single-cell ranges for both arguments. 2 of 2 arguments used.');
		// Case #29: Array. Array with single binary number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT({101})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT({101}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5', 'Test: Positive case: Array. Array with single binary number. 1 of 2 arguments used.');
		// Case #30: Array(2). Arrays for both arguments. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT({101},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT({101},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '05', 'Test: Positive case: Array(2). Arrays for both arguments. 2 of 2 arguments used.');
		// Case #31: Name. Named range with binary number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11', 'Test: Positive case: Name. Named range with binary number. 1 of 2 arguments used.');
		// Case #32: Name(2). Named ranges for both arguments. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(TestName,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(TestName,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '011', 'Test: Positive case: Name(2). Named ranges for both arguments. 2 of 2 arguments used.');
		// Case #33: Name3D. 3D named range with binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11', 'Test: Positive case: Name3D. 3D named range with binary. 1 of 2 arguments used.');
		// Case #34: Ref3D. 3D reference to cell with binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11', 'Test: Positive case: Ref3D. 3D reference to cell with binary. 1 of 2 arguments used.');
		// Case #35: Ref3D(2). 3D references for both arguments. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(Sheet2!A1,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(Sheet2!A1,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '011', 'Test: Positive case: Ref3D(2). 3D references for both arguments. 2 of 2 arguments used.');
		// Case #36: Area3D. 3D single-cell range with binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11', 'Test: Positive case: Area3D. 3D single-cell range with binary. 1 of 2 arguments used.');
		// Case #37: Table. Table reference with binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '144', 'Test: Positive case: Table. Table reference with binary. 1 of 2 arguments used.');
		// Case #38: Number, Empty. Binary with empty places parameter. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '5', 'Test: Positive case: Number, Empty. Binary with empty places parameter. 2 of 2 arguments used.');
		// Case #39: Number(2). Places as decimal (should be truncated to 1). 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(111,1.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(111,1.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7', 'Test: Positive case: Number(2). Places as decimal (should be truncated to 1). 2 of 2 arguments used.');
		// Case #40: Number(2). Zero with specified places (3). 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(0,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(0,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000', 'Test: Positive case: Number(2). Zero with specified places (3). 2 of 2 arguments used.');
		// Case #41: String(2). Both arguments as strings. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("101","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("101","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '05', 'Test: Positive case: String(2). Both arguments as strings. 2 of 2 arguments used.');
		// Case #42: String. 10-digit binary with leading zeros. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("0000000101")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("0000000101") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5', 'Test: Positive case: String. 10-digit binary with leading zeros. 1 of 2 arguments used.');
		// Case #43: Formula(2). Both arguments as IF formulas. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(IF(TRUE,101,111),IF(TRUE,2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(IF(TRUE,101,111),IF(TRUE,2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '05', 'Test: Positive case: Formula(2). Both arguments as IF formulas. 2 of 2 arguments used.');
		// Case #44: Formula. Binary from text concatenation. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(CONCATENATE("10","1"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(CONCATENATE("10","1")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5', 'Test: Positive case: Formula. Binary from text concatenation. 1 of 2 arguments used.');
		// Case #45: Number(2). Large places parameter (10). 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0000000005', 'Test: Positive case: Number(2). Large places parameter (10). 2 of 2 arguments used.');
		// Case #46: Number. 9-digit binary number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '777', 'Test: Positive case: Number. 9-digit binary number. 1 of 2 arguments used.');
		// Case #47: Number(2). Negative binary with places (ignored). 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1000000000,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1000000000,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777000', 'Test: Positive case: Number(2). Negative binary with places (ignored). 2 of 2 arguments used.');
		// Case #48: Reference link, Formula. Reference for binary, formula for places. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A100,ROUND(2.7,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A100,ROUND(2.7,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '011', 'Test: Positive case: Reference link, Formula. Reference for binary, formula for places. 2 of 2 arguments used.');
		// Case #49: Number. Smallest positive binary number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Number. Smallest positive binary number. 1 of 2 arguments used.');
		// Case #50: Number(2). Smallest positive binary with places=1. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Number(2). Smallest positive binary with places=1. 2 of 2 arguments used.');
		// Case #51: Number(2). Smallest positive binary with max places. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0000000001', 'Test: Positive case: Number(2). Smallest positive binary with max places. 2 of 2 arguments used.');
		// Case #52: Number. 10-digit binary representing -2. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1111111110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1111111110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777776', 'Test: Positive case: Number. 10-digit binary representing -2. 1 of 2 arguments used.');
		// Case #53: String. Empty string as binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: String. Empty string as binary. 1 of 2 arguments used.');
		// Case #54: Array. Array with multiple values. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT({101,111})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT({101,111}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5', 'Test: Positive case: Array. Array with multiple values. 1 of 2 arguments used.');
		// Case #55: Reference link. Ref link to  empty cell. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Reference link. Ref link to  empty cell. 1 of 2 arguments used.');

		// Negative cases:

		// Case #1: String. Incorrect string. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("Hello World!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("Hello World!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Incorrect string. 1 of 2 arguments used.');
		// Case #2: Number. Incorrect number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1234567890)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1234567890) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Incorrect number. 1 of 2 arguments used.');
		// Case #3: Number. Incorrect bin number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101010101010)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101010101010) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Incorrect bin number. 1 of 2 arguments used.');
		// Case #4: Number(2). Incorrect bin number. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101010, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101010, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Incorrect bin number. 2 of 2 arguments used.');
		// Case #5: Number(2). Incorrect number for places arg. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101010, -4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101010, -4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Incorrect number for places arg. 2 of 2 arguments used.');
		// Case #6: Number, String. Incorrect places arg. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101010, "Hello World!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101010, "Hello World!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Incorrect places arg. 2 of 2 arguments used.');
		// Case #7: Number. Invalid binary digit (2). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Invalid binary digit (2). 1 of 2 arguments used.');
		// Case #8: Number. Binary with invalid digits. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1234567890)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1234567890) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Binary with invalid digits. 1 of 2 arguments used.');
		// Case #9: String. Binary string with invalid character. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("1A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("1A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Binary string with invalid character. 1 of 2 arguments used.');
		// Case #10: String. Non-numeric string. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("Binary")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("Binary") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string. 1 of 2 arguments used.');
		// Case #11: Number. Binary with more than 10 digits. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(11111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(11111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Binary with more than 10 digits. 1 of 2 arguments used.');
		// Case #12: String. Binary string with more than 10 digits. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("11111111111")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("11111111111") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Binary string with more than 10 digits. 1 of 2 arguments used.');
		// Case #13: Number(2). Negative places parameter. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative places parameter. 2 of 2 arguments used.');
		// Case #14: Number(2). Places as non-numeric string. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2). Places as non-numeric string. 2 of 2 arguments used.');
		// Case #15: Empty, Number. Empty number parameter. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. Empty number parameter. 2 of 2 arguments used.');
		// Case #16: Error. Error value as input. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Error value as input. 1 of 2 arguments used.');
		// Case #17: Number, Error. Error value as places. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101,NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error value as places. 2 of 2 arguments used.');
		// Case #18: Number. Negative number (not binary). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number (not binary). 1 of 2 arguments used.');
		// Case #19: Number. Binary with decimal point. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1.1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1.1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Binary with decimal point. 1 of 2 arguments used.');
		// Case #20: Boolean. Boolean as binary (not supported). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean as binary (not supported). 1 of 2 arguments used.');
		// Case #21: Date. Date function as binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(DATE(2023,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(DATE(2023,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date function as binary. 1 of 2 arguments used.');
		// Case #22: Time. Time function as binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(TIME(10,30,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(TIME(10,30,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Time. Time function as binary. 1 of 2 arguments used.');
		// Case #23: Area. Multi-cell range. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A102:A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range. 1 of 2 arguments used.');
		// Case #24: Array. Array with invalid binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT({12})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT({12}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with invalid binary. 1 of 2 arguments used.');
		// Case #25: Name. Named range with multiple cells. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with multiple cells. 1 of 2 arguments used.');
		// Case #26: Area3D. 3D range with multiple cells. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(Sheet2!A1:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D range with multiple cells. 1 of 2 arguments used.');
		// Case #27: Number(2). Places parameter > 10 (maximum). 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places parameter > 10 (maximum). 2 of 2 arguments used.');
		// Case #28: Number, String. Places as non-convertible string. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Places as non-convertible string. 2 of 2 arguments used.');
		// Case #29: Number(2). Places parameter as zero. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(101,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(101,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places parameter as zero. 2 of 2 arguments used.');
		// Case #30: Reference link. Ref link to cell with text. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Ref link to cell with text. 1 of 2 arguments used.');
		// Case #31: Reference link(2). Ref link to cell with text for places arg. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A100,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A100,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(2). Ref link to cell with text for places arg. 2 of 2 arguments used.');
		// Case #32: Table. Table column with text. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Table. Table column with text. 1 of 2 arguments used.');
		// Case #33: Reference link(2). Ref link to empty cell for places arg. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(A100, A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(A100, A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link(2). Ref link to empty cell for places arg. 2 of 2 arguments used.');

		// Bounded cases:

		// Case #1: Number. Minimum valid binary number (0). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number. Minimum valid binary number (0). 1 of 2 arguments used.');
		// Case #2: Number. Maximum 10-digit binary number (negative). 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777777', 'Test: Bounded case: Number. Maximum 10-digit binary number (negative). 1 of 2 arguments used.');
		// Case #3: Number. Maximum 9-digit positive binary. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(111111111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(111111111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '777', 'Test: Bounded case: Number. Maximum 9-digit positive binary. 1 of 2 arguments used.');
		// Case #4: Number(2). Minimum places parameter. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number(2). Minimum places parameter. 2 of 2 arguments used.');
		// Case #5: Number(2). Maximum places parameter. 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0000000001', 'Test: Bounded case: Number(2). Maximum places parameter. 2 of 2 arguments used.');
		// Case #6: Number. 10-digit negative binary number. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1000000001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1000000001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777001', 'Test: Bounded case: Number. 10-digit negative binary number. 1 of 2 arguments used.');
		// Case #7: Number(2). 10-digit negative binary with places (ignored). 2 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT(1000000000,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT(1000000000,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777000', 'Test: Bounded case: Number(2). 10-digit negative binary with places (ignored). 2 of 2 arguments used.');
		// Case #8: String. 10-digit negative binary as string. 1 of 2 arguments used.
		oParser = new parserFormula('BIN2OCT("1000000000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BIN2OCT("1000000000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777000', 'Test: Bounded case: String. 10-digit negative binary as string. 1 of 2 arguments used.');

        // Need to fix: error handle, error types diff, diff results from MS
        // Case #38: Number, Empty. Binary with empty places parameter. 2 of 2 arguments used.
        // Case #15: Empty, Number. Empty number parameter. 2 of 2 arguments used.
        // Case #16: Error. Error value as input. 1 of 2 arguments used.
        // Case #17: Number, Error. Error value as places. 2 of 2 arguments used.
        // Case #20: Boolean. Boolean as binary (not supported). 1 of 2 arguments used.
        // Case #23: Area. Multi-cell range. 1 of 2 arguments used.
        // Case #25: Name. Named range with multiple cells. 1 of 2 arguments used.
        // Case #26: Area3D. 3D range with multiple cells. 1 of 2 arguments used.


		testArrayFormula2(assert, "BIN2OCT", 1, 2, true);
	});

	QUnit.test("Test: \"BITAND\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("15");
		ws.getRange2("A101").setValue("51");
		ws.getRange2("A102").setValue("255");
		ws.getRange2("A103").setValue("85");
		ws.getRange2("A104").setValue("36");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Column1
		ws.getRange2("B601").setValue("9"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("13");
		ws2.getRange2("A2").setValue("25");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("15"); // TestName
		ws.getRange2("A202").setValue("51"); // TestName1
		ws.getRange2("A203").setValue("12"); // TestName2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1") // TestName3D
		ws2.getRange2("A12").setValue("9") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Compares the binary representations of 1 and 5.
		oParser = new parserFormula('BITAND(1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Compares the binary representations of 1 and 5.');
		// Case #2: Number(2). Compares the binary representations of 13 and 25.
		oParser = new parserFormula('BITAND(13,25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(13,25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Number(2). Compares the binary representations of 13 and 25.');
		// Case #3: Number(2). Basic test with integers. Compares binary representations: 1 (1 in binary) and 5 (101 in binary). Result is 1 because only rightmost bit matches.
		oParser = new parserFormula('BITAND(1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Basic test with integers. Compares binary representations: 1 (1 in binary) and 5 (101 in binary). Result is 1 because only rightmost bit matches.');
		// Case #4: Number(2). Example from documentation. Compares binary 1101 (13) and 11001 (25). Result is 9 (1001 in binary) because bits match at positions 2^0 and 2^3.
		oParser = new parserFormula('BITAND(13,25)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(13,25) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Number(2). Example from documentation. Compares binary 1101 (13) and 11001 (25). Result is 9 (1001 in binary) because bits match at positions 2^0 and 2^3.');
		// Case #5: Number(2). Test with zero. Any bit AND with 0 is 0, so result is 0.
		oParser = new parserFormula('BITAND(0,15)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(0,15) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Test with zero. Any bit AND with 0 is 0, so result is 0.');
		// Case #6: Number(2). Test with identical numbers. Result should be the same number (255) since all bits match.
		oParser = new parserFormula('BITAND(255,255)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(255,255) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Number(2). Test with identical numbers. Result should be the same number (255) since all bits match.');
		// Case #7: String(2). Numeric strings converted to numbers 12 (1100 in binary) and 10 (1010 in binary). Result is 8 (1000 in binary).
		oParser = new parserFormula('BITAND("12","10")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND("12","10") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: String(2). Numeric strings converted to numbers 12 (1100 in binary) and 10 (1010 in binary). Result is 8 (1000 in binary).');
		// Case #8: Formula(2). Using formulas that return numbers 9 and 25. Result is 9 (1001) AND 25 (11001) = 1 (0001).
		oParser = new parserFormula('BITAND(3^2,5^2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(3^2,5^2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Formula(2). Using formulas that return numbers 9 and 25. Result is 9 (1001) AND 25 (11001) = 1 (0001).');
		// Case #9: Formula. BITAND nested in SUM formula. 7 (111) AND 3 (11) = 3 (11), then 3+10=13.
		oParser = new parserFormula('SUM(BITAND(7,3),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BITAND(7,3),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Positive case: Formula. BITAND nested in SUM formula. 7 (111) AND 3 (11) = 3 (11), then 3+10=13.');
		// Case #10: Formula. Nested IF formulas returning 12 and 4. Result is 4 (100 in binary).
		oParser = new parserFormula('BITAND(IF(TRUE,12,0),IF(FALSE,0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(IF(TRUE,12,0),IF(FALSE,0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Nested IF formulas returning 12 and 4. Result is 4 (100 in binary).');
		// Case #11: Reference link(2). References to cells containing values 15 and 51. Result is 3 (11 in binary).
		oParser = new parserFormula('BITAND(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Reference link(2). References to cells containing values 15 and 51. Result is 3 (11 in binary).');
		// Case #12: Area(2). Single-cell ranges containing 255 and 85. Result is 85 (1010101 in binary).
		oParser = new parserFormula('BITAND(A102:A102,A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(A102:A102,A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 85, 'Test: Positive case: Area(2). Single-cell ranges containing 255 and 85. Result is 85 (1010101 in binary).');
		// Case #13: Array(2). Arrays with single elements. 63 (111111) AND 15 (1111) = 15 (1111).
		oParser = new parserFormula('BITAND({63},{15})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND({63},{15}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Array(2). Arrays with single elements. 63 (111111) AND 15 (1111) = 15 (1111).');
		// Case #14: Name(2). Named ranges containing values 15 and 51. Result is 3.
		oParser = new parserFormula('BITAND(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Name(2). Named ranges containing values 15 and 51. Result is 3.');
		// Case #15: Name3D(2). 3D named ranges with values 1 and 9. Result is 1.
		oParser = new parserFormula('BITAND(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Name3D(2). 3D named ranges with values 1 and 9. Result is 1.');
		// Case #16: Ref3D(2). 3D references with values 13 and 25. Result is 8.
		oParser = new parserFormula('BITAND(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Ref3D(2). 3D references with values 13 and 25. Result is 8.');
		// Case #17: Area3D(2). 3D single-cell areas with values 65535 and 65280. Result is 65280.
		oParser = new parserFormula('BITAND(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Area3D(2). 3D single-cell areas with values 65535 and 65280. Result is 65280.');
		// Case #18: Table(2). Table references with values 1 and 9. Result is 1.
		oParser = new parserFormula('BITAND(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table(2). Table references with values 1 and 9. Result is 1.');
		// Case #19: Number, Reference link. Mixed type test: number and reference. 48 (110000) AND 36 (100100) = 32 (100000).
		oParser = new parserFormula('BITAND(48,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(48,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 32, 'Test: Positive case: Number, Reference link. Mixed type test: number and reference. 48 (110000) AND 36 (100100) = 32 (100000).');
		// Case #20: Number, Formula. Number and formula returning 15. Result is 15 as both operands are identical.
		oParser = new parserFormula('BITAND(15,INT(15.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(15,INT(15.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Number, Formula. Number and formula returning 15. Result is 15 as both operands are identical.');
		// Case #21: Formula, Number. Date as serial number (44927) AND 10 (1010). Result is 10.
		oParser = new parserFormula('BITAND(DATE(2023,1,1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(DATE(2023,1,1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula, Number. Date as serial number (44927) AND 10 (1010). Result is 10.');
		// Case #22: Formula, Name. Formula returning 4 and named range with value 12. Result is 4 (100 in binary).
		oParser = new parserFormula('BITAND(SQRT(16),TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(SQRT(16),TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula, Name. Formula returning 4 and named range with value 12. Result is 4 (100 in binary).');
		// Case #23: Number(2). Test with powers of 2. 1024 AND 1023 = 0 as no bits match.
		oParser = new parserFormula('BITAND(2^10,2^10-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(2^10,2^10-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Test with powers of 2. 1024 AND 1023 = 0 as no bits match.');
		// Case #24: Number(2). Test with boundary values. 65535 AND 255 = 255 (all 8 lower bits match).
		oParser = new parserFormula('BITAND(2^16-1,2^8-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(2^16-1,2^8-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Number(2). Test with boundary values. 65535 AND 255 = 255 (all 8 lower bits match).');
		// Case #25: Number(2). Test with alternating bit patterns. 43690 (1010...1010) AND 21845 (0101...0101) = 0.
		oParser = new parserFormula('BITAND(43690,21845)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(43690,21845) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Test with alternating bit patterns. 43690 (1010...1010) AND 21845 (0101...0101) = 0.');
		// Case #26: Area, Number. Multi-cell range with values 42 and 99. Result is array {10; 2}.
		oParser = new parserFormula('BITAND(A105:A106,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(A105:A106,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area, Number. Multi-cell range with values 42 and 99. Result is array {10; 2}.');
		// Case #27: Number, Area. Number with multi-cell range. Result is array {10; 2}.
		oParser = new parserFormula('BITAND(10,A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(10,A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Number, Area. Number with multi-cell range. Result is array {10; 2}.');
		// Case #28: Array, Number. Multi-element array with number. Result is array {0; 4}.
		oParser = new parserFormula('BITAND({10,20},5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND({10,20},5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array, Number. Multi-element array with number. Result is array {0; 4}.');
		// Case #29: Number, Array. Number with multi-element array. Result is array {0; 4}.
		oParser = new parserFormula('BITAND(5,{10,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(5,{10,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Array. Number with multi-element array. Result is array {0; 4}.');
		// Case #30: Empty, Number. Empty cell treated as 0. Result is 0 (0 AND 10 = 0).
		oParser = new parserFormula('BITAND(,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number. Empty cell treated as 0. Result is 0 (0 AND 10 = 0).');
		// Case #31: Number, Empty. Empty cell treated as 0. Result is 0 (15 AND 0 = 0).
		oParser = new parserFormula('BITAND(15,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(15,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Empty. Empty cell treated as 0. Result is 0 (15 AND 0 = 0).');
		// Case #32: Boolean, Number. Boolean TRUE treated as 1. Result is 1 (1 AND 5 = 1).
		oParser = new parserFormula('BITAND(TRUE,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(TRUE,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean, Number. Boolean TRUE treated as 1. Result is 1 (1 AND 5 = 1).');
		// Case #33: Number, Boolean. Boolean FALSE treated as 0. Result is 0 (5 AND 0 = 0).
		oParser = new parserFormula('BITAND(5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(5,FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Boolean. Boolean FALSE treated as 0. Result is 0 (5 AND 0 = 0).');

		// Negative cases:

		// Case #1: String, Number. Non-numeric string can\'t be converted to a number. Returns #VALUE! error.
		oParser = new parserFormula('BITAND("abc",10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND("abc",10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string can\'t be converted to a number. Returns #VALUE! error.');
		// Case #2: Number, Error. Error value as second argument propagates through. Returns #N/A error.
		oParser = new parserFormula('BITAND(5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error value as second argument propagates through. Returns #N/A error.');
		// Case #3: Error, Number. Error value as first argument propagates through. Returns #N/A error.
		oParser = new parserFormula('BITAND(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error value as first argument propagates through. Returns #N/A error.');
		// Case #4: Number(2). Negative number in first argument returns #NUM! error.
		oParser = new parserFormula('BITAND(-1,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(-1,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative number in first argument returns #NUM! error.');
		// Case #5: Number(2). Negative number in second argument returns #NUM! error.
		oParser = new parserFormula('BITAND(5,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(5,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative number in second argument returns #NUM! error.');
		// Case #6: Number(2). Number too large (outside Excel\'s safe integer range) returns #NUM! error.
		oParser = new parserFormula('BITAND(2^48,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(2^48,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number too large (outside Excel\'s safe integer range) returns #NUM! error.');
		// Case #7: Number(2). Number too large in second argument returns #NUM! error.
		oParser = new parserFormula('BITAND(1,2^48)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(1,2^48) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number too large in second argument returns #NUM! error.');
		// Case #8: Number(2). Non-integer (decimal) in first argument returns #NUM! error.
		oParser = new parserFormula('BITAND(1.5,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(1.5,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Non-integer (decimal) in first argument returns #NUM! error.');
		// Case #9: String(2). Binary notation not supported directly. Returns #VALUE! error.
		oParser = new parserFormula('BITAND("0b1010","0b1100")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND("0b1010","0b1100") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Binary notation not supported directly. Returns #VALUE! error.');
		// Case #10: String(2). Hexadecimal notation not supported directly. Returns #VALUE! error.
		oParser = new parserFormula('BITAND("0x10","0x11")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND("0x10","0x11") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Hexadecimal notation not supported directly. Returns #VALUE! error.');
		// Case #11: Number(2). Decimal numbers for both arguments
		oParser = new parserFormula('BITAND(2.9,3.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(2.9,3.9) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Decimal numbers for both arguments');
		// Case #12: Number, String. Number and string with decimal number
		oParser = new parserFormula('BITAND(10,"10.9")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(10,"10.9") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, String. Number and string with decimal number');
		// Case #13: Number(2). Non-integer in second argument returns #NUM! error
		oParser = new parserFormula('BITAND(5,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(5,1.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Non-integer in second argument returns #NUM! error');

		// Bounded cases:

		// Case #1: Number(2). Minimum valid values. 0 AND 0 = 0.
		oParser = new parserFormula('BITAND(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Minimum valid values. 0 AND 0 = 0.');
		// Case #2: Number(2). Maximum safe integer values Excel can handle for bitwise operations. Result equals the input.
		oParser = new parserFormula('BITAND(2^48-1,2^48-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(2^48-1,2^48-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 281475000000000, 'Test: Bounded case: Number(2). Maximum safe integer values Excel can handle for bitwise operations. Result equals the input.');
		// Case #3: Number(2). Testing different magnitude boundaries. 4294967295 AND 65535 = 65535.
		oParser = new parserFormula('BITAND(2^32-1,2^16-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(2^32-1,2^16-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 65535, 'Test: Bounded case: Number(2). Testing different magnitude boundaries. 4294967295 AND 65535 = 65535.');
		// Case #4: Number(2). Testing power of 2 boundary. 65536 AND 65536 = 65536.
		oParser = new parserFormula('BITAND(2^16,2^16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(2^16,2^16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 65536, 'Test: Bounded case: Number(2). Testing power of 2 boundary. 65536 AND 65536 = 65536.');
		// Case #5: Number(2). Max value AND 0 = 0.
		oParser = new parserFormula('BITAND(2^48-1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(2^48-1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Max value AND 0 = 0.');
		// Case #6: Number(2). Testing larger numbers. 65792 AND 65793 = 65792 (all bits match except last).
		oParser = new parserFormula('BITAND(2^16+2^8,2^16+2^8+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITAND(2^16+2^8,2^16+2^8+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 65792, 'Test: Bounded case: Number(2). Testing larger numbers. 65792 AND 65793 = 65792 (all bits match except last).');

        // Need to fix: diff results from MS
        // Case #6: Number(2). Number too large (outside Excel\'s safe integer range) returns #NUM! error.
        // Case #7: Number(2). Number too large in second argument returns #NUM! error.
        // Case #8: Number(2). Non-integer (decimal) in first argument returns #NUM! error.
        // Case #9: String(2). Binary notation not supported directly. Returns #VALUE! error.
        // Case #11: Number(2). Decimal numbers for both arguments
        // Case #12: Number, String. Number and string with decimal number
        // Case #13: Number(2). Non-integer in second argument returns #NUM! error
        // Case #2: Number(2). Maximum safe integer values Excel can handle for bitwise operations. Result equals the input.

		testArrayFormula2(assert, "BITAND", 2, 2);
	});

	QUnit.test("Test: \"BITLSHIFT\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("4");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("");
		ws.getRange2("A103").setValue("text");
		ws.getRange2("A104").setValue("#N/A");
		ws.getRange2("A105").setValue("01/01/2025");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("4"); // Column1
		ws.getRange2("B601").setValue("2"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("4");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("test");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("4"); // TestName
		ws.getRange2("A202").setValue("2"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A16").setValue("4"); // TestNameArea3D
		ws2.getRange2("A17").setValue("8"); // TestNameArea3D
		ws2.getRange2("A18").setValue("2"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("4"); // TestNameArea3D2

		// Positive cases:

		// Case #1: Number(2). Shifts bits left for the number by adding zeros (0) to the right of the number represented in binary
		oParser = new parserFormula('BITLSHIFT(4,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(4,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Number(2). Shifts bits left for the number by adding zeros (0) to the right of the number represented in binary');
		// Case #2: Number, Number. Basic test with two positive integer arguments.
		oParser = new parserFormula('BITLSHIFT(13, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(13, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 52, 'Test: Positive case: Number, Number. Basic test with two positive integer arguments.');
		// Case #3: Number, Number. A negative shift_amount performs a right shift.
		oParser = new parserFormula('BITLSHIFT(13, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(13, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number, Number. A negative shift_amount performs a right shift.');
		// Case #4: Number, Number. A shift_amount of 0 returns the original number.
		oParser = new parserFormula('BITLSHIFT(10, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(10, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number, Number. A shift_amount of 0 returns the original number.');
		// Case #5: String, String. Both arguments are numeric strings, which should be converted to numbers.
		oParser = new parserFormula('BITLSHIFT("16", "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT("16", "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 128, 'Test: Positive case: String, String. Both arguments are numeric strings, which should be converted to numbers.');
		// Case #6: Number, Formula. Second argument is a nested formula.
		oParser = new parserFormula('BITLSHIFT(5, SUM(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(5, SUM(1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Number, Formula. Second argument is a nested formula.');
		// Case #7: Formula. BITLSHIFT is used as part of a larger formula.
		oParser = new parserFormula('BITLSHIFT(10, 1)+5', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(10, 1)+5 is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Formula. BITLSHIFT is used as part of a larger formula.');
		// Case #8: Number, Number. The float shift_amount is truncated to an integer (4).
		oParser = new parserFormula('BITLSHIFT(10, 4.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(10, 4.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 160, 'Test: Positive case: Number, Number. The float shift_amount is truncated to an integer (4).');
		// Case #9: Boolean, Number. The boolean value TRUE is converted to 1.
		oParser = new parserFormula('BITLSHIFT(TRUE, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(TRUE, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Boolean, Number. The boolean value TRUE is converted to 1.');
		// Case #10: Empty, Number. Reference to an empty cell is treated as 0.
		oParser = new parserFormula('BITLSHIFT(A102, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(A102, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number. Reference to an empty cell is treated as 0.');
		// Case #11: Number, Empty. Reference to an empty cell for shift_amount is treated as 0.
		oParser = new parserFormula('BITLSHIFT(25, A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(25, A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, Empty. Reference to an empty cell for shift_amount is treated as 0.');
		// Case #12: Reference link, Reference link. Both arguments are references to cells with numbers.
		oParser = new parserFormula('BITLSHIFT(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Reference link, Reference link. Both arguments are references to cells with numbers.');
		// Case #13: Name, Name. Both arguments are named ranges.
		oParser = new parserFormula('BITLSHIFT(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Name, Name. Both arguments are named ranges.');
		// Case #14: Array, Array. Array as both arguments should spill results element-wise.
		oParser = new parserFormula('BITLSHIFT({4;8}, {1;2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT({4;8}, {1;2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Array, Array. Array as both arguments should spill results element-wise.');
		// Case #15: Ref3D, Ref3D. Both arguments are 3D references to another sheet.
		oParser = new parserFormula('BITLSHIFT(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Ref3D, Ref3D. Both arguments are 3D references to another sheet.');
		// Case #16: Reference link, Number. Date is converted to its serial number before the shift.
		oParser = new parserFormula('BITLSHIFT(A105, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(A105, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 91316, 'Test: Positive case: Reference link, Number. Date is converted to its serial number before the shift.');
		// Case #17: Table, Table. Both arguments are references to values within a table.
		oParser = new parserFormula('BITLSHIFT(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Table, Table. Both arguments are references to values within a table.');
		// Case #18: Formula. Nested ROUND function in BITLSHIFT.
		oParser = new parserFormula('BITLSHIFT(ROUND(5,1),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(ROUND(5,1),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Formula. Nested ROUND function in BITLSHIFT.');
		// Case #19: Area, Area. Both arguments are references to single-cell areas.
		oParser = new parserFormula('BITLSHIFT(A100:A100, A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(A100:A100, A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Area, Area. Both arguments are references to single-cell areas.');
		// Case #20: Name3D, Name3D. Both arguments are named ranges referring to areas.
		oParser = new parserFormula('BITLSHIFT(TestNameArea3D, TestNameArea3D2)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(TestNameArea3D, TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 16, 'Test: Positive case: Name3D, Name3D. Both arguments are named ranges referring to areas.');
		// Case #21: Number, Boolean. The boolean value FALSE is converted to 0 for shift_amount.
		oParser = new parserFormula('BITLSHIFT(3, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(3, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number, Boolean. The boolean value FALSE is converted to 0 for shift_amount.');
		// Case #22: Formula. BITLSHIFT used as an argument in a parent SUM formula.
		oParser = new parserFormula('SUM(BITLSHIFT(10, 2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BITLSHIFT(10, 2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 40, 'Test: Positive case: Formula. BITLSHIFT used as an argument in a parent SUM formula.');

		// Negative cases:

		// Case #1: Number, Number. The number argument cannot be negative. Returns #NUM!.
		oParser = new parserFormula('BITLSHIFT(-5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(-5, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. The number argument cannot be negative. Returns #NUM!.');
		// Case #2: String, Number. The number argument is non-numeric text. Returns #VALUE!.
		oParser = new parserFormula('BITLSHIFT("text", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT("text", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. The number argument is non-numeric text. Returns #VALUE!.');
		// Case #3: Number, String. The shift_amount argument is non-numeric text. Returns #VALUE!.
		oParser = new parserFormula('BITLSHIFT(10, "text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(10, "text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. The shift_amount argument is non-numeric text. Returns #VALUE!.');
		// Case #4: Number, Number. The number argument must be an integer. Per clarification, this is a negative case. Returns #NUM!.
		oParser = new parserFormula('BITLSHIFT(10.9, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(10.9, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. The number argument must be an integer. Per clarification, this is a negative case. Returns #NUM!.');
		// Case #5: Error, Number. The number argument is an error. Propagates the #N/A error.
		oParser = new parserFormula('BITLSHIFT(A104, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(A104, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. The number argument is an error. Propagates the #N/A error.');
		// Case #6: Number, Error. The shift_amount argument is an error. Propagates the #N/A error.
		oParser = new parserFormula('BITLSHIFT(10, A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(10, A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. The shift_amount argument is an error. Propagates the #N/A error.');
		// Case #7: Reference link, Number. Reference to a cell containing non-numeric text. Returns #VALUE!.
		oParser = new parserFormula('BITLSHIFT(A103, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(A103, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to a cell containing non-numeric text. Returns #VALUE!.');
		// Case #8: Number. The number argument is exactly 2^48. Returns #NUM!.
		oParser = new parserFormula('BITLSHIFT(281474976710656, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(281474976710656, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. The number argument is exactly 2^48. Returns #NUM!.');
		// Case #9: Number, Number. The result of the operation (2^48) exceeds the maximum limit. Returns #NUM!.
		oParser = new parserFormula('BITLSHIFT(1, 48)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(1, 48) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. The result of the operation (2^48) exceeds the maximum limit. Returns #NUM!.');
		// Case #10: Number, Number. The result of the operation (4 * 2^46 = 2^2 * 2^46 = 2^48) exceeds the maximum limit. Returns #NUM!.
		oParser = new parserFormula('BITLSHIFT(4, 46)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(4, 46) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. The result of the operation (4 * 2^46 = 2^2 * 2^46 = 2^48) exceeds the maximum limit. Returns #NUM!.');
		// Case #11: Formula. An expression resulting in an error as an argument.
		oParser = new parserFormula('BITLSHIFT(1/0, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(1/0, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. An expression resulting in an error as an argument.');
		// Case #12: Array, Number. Array of non-numeric text should spill #VALUE! errors.
		oParser = new parserFormula('BITLSHIFT({"a";"b"}, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT({"a";"b"}, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Number. Array of non-numeric text should spill #VALUE! errors.');
		// Case #13: Area, Number. Area contains a mix of error and text, spilling an errors.
		oParser = new parserFormula('BITLSHIFT(A103:A104, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(A103:A104, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Area contains a mix of error and text, spilling an errors.');
		// Case #14: Ref3D, Number. 3D Reference to a cell with text returns #VALUE!
		oParser = new parserFormula('BITLSHIFT(Sheet2!A3, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(Sheet2!A3, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Number. 3D Reference to a cell with text returns #VALUE!');

		// Bounded cases:

		// Case #1: Number, Number. Minimum valid value for the number argument.
		oParser = new parserFormula('BITLSHIFT(0, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(0, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number. Minimum valid value for the number argument.');
		// Case #2: Number, Number. Maximum valid value for the number argument (2^48 - 1).
		oParser = new parserFormula('BITLSHIFT(281474976710655, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(281474976710655, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 281474976710655, 'Test: Bounded case: Number, Number. Maximum valid value for the number argument (2^48 - 1).');
		// Case #3: Number, Number. Maximum shift_amount for number=1 that produces a valid result (2^47).
		oParser = new parserFormula('BITLSHIFT(1, 47)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(1, 47) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 140737488355328, 'Test: Bounded case: Number, Number. Maximum shift_amount for number=1 that produces a valid result (2^47).');
		// Case #4: Number, Number. A different combination of number and shift_amount that results in a value close to the 2^48 limit.
		oParser = new parserFormula('BITLSHIFT(3, 46)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(3, 46) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 211106232532992, 'Test: Bounded case: Number, Number. A different combination of number and shift_amount that results in a value close to the 2^48 limit.');
		// Case #5: Number, Number. Largest possible number that can be shifted left by 1 without error.
		oParser = new parserFormula('BITLSHIFT(140737488355327, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(140737488355327, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 281474976710654, 'Test: Bounded case: Number, Number. Largest possible number that can be shifted left by 1 without error.');
		// Case #6: Number, Number. A large number with a large negative shift.
		oParser = new parserFormula('BITLSHIFT(281474976710655, -47)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITLSHIFT(281474976710655, -47) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. A large number with a large negative shift.');

        // Need to fix: diff results from MS
        // Case #8: Number. The number argument is exactly 2^48. Returns #NUM!.
        // Case #9: Number, Number. The result of the operation (2^48) exceeds the maximum limit. Returns #NUM!.
        // Case #10: Number, Number. The result of the operation (4 * 2^46 = 2^2 * 2^46 = 2^48) exceeds the maximum limit. Returns #NUM!.

		testArrayFormula2(assert, "BITLSHIFT", 2, 2);
	});

	QUnit.test("Test: \"BITOR\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("23");
		ws.getRange2("A101").setValue("10");
		ws.getRange2("A102").setValue("text");
		ws.getRange2("A103").setValue("23");
		ws.getRange2("A104").setValue("25");
		ws.getRange2("A105").setValue("10");
		ws.getRange2("A106").setValue("4");
		ws.getRange2("A107").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("23"); // Column1
		ws.getRange2("B601").setValue("10"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("23");
		ws2.getRange2("A2").setValue("10");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("23"); // TestName
		ws.getRange2("A202").setValue("10"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("23") // TestName3D
		ws2.getRange2("A12").setValue("10") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Compares the bit positions for the binary representations of the two numbers
		oParser = new parserFormula('BITOR(23,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(23,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Positive case: Number(2). Compares the bit positions for the binary representations of the two numbers');
		// Case #2: Number(2). Basic case with two integers.
		oParser = new parserFormula('BITOR(1,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(1,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number(2). Basic case with two integers.');
		// Case #3: String(2). Both arguments are strings convertible to numbers.
		oParser = new parserFormula('BITOR("9","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR("9","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Positive case: String(2). Both arguments are strings convertible to numbers.');
		// Case #4: Formula(2). Both arguments are formulas returning numbers.
		oParser = new parserFormula('BITOR(INT(9.9),ROUND(5.1,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(INT(9.9),ROUND(5.1,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Positive case: Formula(2). Both arguments are formulas returning numbers.');
		// Case #5: Reference link(2). Both arguments are reference links to cells with numbers.
		oParser = new parserFormula('BITOR(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Positive case: Reference link(2). Both arguments are reference links to cells with numbers.');
		// Case #6: Area(2). Both arguments are single-cell ranges with numbers.
		oParser = new parserFormula('BITOR(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Positive case: Area(2). Both arguments are single-cell ranges with numbers.');
		// Case #7: Array(2). Both arguments are arrays with single numeric elements.
		oParser = new parserFormula('BITOR({12},{5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR({12},{5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Positive case: Array(2). Both arguments are arrays with single numeric elements.');
		// Case #8: Name(2). Both arguments are named ranges with numbers.
		oParser = new parserFormula('BITOR(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Positive case: Name(2). Both arguments are named ranges with numbers.');
		// Case #9: Name3D(2). Both arguments are 3D named ranges with numbers.
		oParser = new parserFormula('BITOR(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Positive case: Name3D(2). Both arguments are 3D named ranges with numbers.');
		// Case #10: Ref3D(2). Both arguments are 3D references to cells with numbers.
		oParser = new parserFormula('BITOR(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Positive case: Ref3D(2). Both arguments are 3D references to cells with numbers.');
		// Case #11: Area3D(2). Both arguments are 3D single-cell ranges with numbers.
		oParser = new parserFormula('BITOR(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Positive case: Area3D(2). Both arguments are 3D single-cell ranges with numbers.');
		// Case #12: Table(2). Both arguments are table references with numbers.
		oParser = new parserFormula('BITOR(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Positive case: Table(2). Both arguments are table references with numbers.');
		// Case #13: Number, String. First argument is number, second is string convertible to number.
		oParser = new parserFormula('BITOR(10,"6")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(10,"6") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 14, 'Test: Positive case: Number, String. First argument is number, second is string convertible to number.');
		// Case #14: Formula, Number. First argument is formula returning number, second is number.
		oParser = new parserFormula('BITOR(MAX(3,7),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(MAX(3,7),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Formula, Number. First argument is formula returning number, second is number.');
		// Case #15: Number, Reference link. First argument is number, second is reference link to cell with number.
		oParser = new parserFormula('BITOR(9,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(9,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11, 'Test: Positive case: Number, Reference link. First argument is number, second is reference link to cell with number.');
		// Case #16: Formula, Number. First argument is date formula returning number, second is number.
		oParser = new parserFormula('BITOR(DATE(2023,1,1),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(DATE(2023,1,1),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 44927, 'Test: Positive case: Formula, Number. First argument is date formula returning number, second is number.');
		// Case #17: Formula. BITOR inside another formula.
		oParser = new parserFormula('SUM(BITOR(5,3),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BITOR(5,3),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 17, 'Test: Positive case: Formula. BITOR inside another formula.');
		// Case #18: Number(2). Both arguments are zero.
		oParser = new parserFormula('BITOR(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Both arguments are zero.');
		// Case #19: Number(2). First argument with all bits set (11111111), second is zero.
		oParser = new parserFormula('BITOR(255,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(255,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Number(2). First argument with all bits set (11111111), second is zero.');
		// Case #20: Number(2). Alternating bits: 10101010 and 01010101.
		oParser = new parserFormula('BITOR(170,85)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(170,85) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Number(2). Alternating bits: 10101010 and 01010101.');
		// Case #21: Number(2). Lower 4 bits (1111) and upper 4 bits (11110000).
		oParser = new parserFormula('BITOR(15,240)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(15,240) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Number(2). Lower 4 bits (1111) and upper 4 bits (11110000).');
		// Case #22: Area, Number. First argument is multi-cell range.
		oParser = new parserFormula('BITOR(A103:A104,5)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(A103:A104,5) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 23, 'Test: Positive case: Area, Number. First argument is multi-cell range.');
		// Case #23: Number, Area. Second argument is multi-cell range.
		oParser = new parserFormula('BITOR(10,A105:A106)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(10,A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 10, 'Test: Positive case: Number, Area. Second argument is multi-cell range.');
		// Case #24: Area(2). Both arguments are multi-cell ranges.
		oParser = new parserFormula('BITOR(A103:A104,A105:A106)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(A103:A104,A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 31, 'Test: Positive case: Area(2). Both arguments are multi-cell ranges.');
		// Case #25: Array, Number. First argument is array with multiple elements.
		oParser = new parserFormula('BITOR({10,20},5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR({10,20},5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Array, Number. First argument is array with multiple elements.');
		// Case #26: Number, Array. Second argument is array with multiple elements.
		oParser = new parserFormula('BITOR(5,{10,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(5,{10,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Number, Array. Second argument is array with multiple elements.');
		// Case #27: Array(2). Both arguments are arrays with multiple elements.
		oParser = new parserFormula('BITOR({5,10},{15,20})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR({5,10},{15,20}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 15, 'Test: Positive case: Array(2). Both arguments are arrays with multiple elements.');
		// Case #28: Empty, Number. First argument is empty.
		oParser = new parserFormula('BITOR(,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Empty, Number. First argument is empty.');
		// Case #29: Number, Empty. Second argument is empty.
		oParser = new parserFormula('BITOR(5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Empty. Second argument is empty.');
		// Case #30: Reference link, Number. First argument is reference to empty cell.
		oParser = new parserFormula('BITOR(A107,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(A107,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Reference link, Number. First argument is reference to empty cell.');
		// Case #31: Number, Reference link. Second argument is reference to empty cell.
		oParser = new parserFormula('BITOR(5,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(5,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Reference link. Second argument is reference to empty cell.');

		// Negative cases:

		// Case #1: String, Number. First argument is non-numeric string.
		oParser = new parserFormula('BITOR("abc",5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR("abc",5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. First argument is non-numeric string.');
		// Case #2: Number, String. Second argument is non-numeric string.
		oParser = new parserFormula('BITOR(10,"xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(10,"xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Second argument is non-numeric string.');
		// Case #3: Error, Number. First argument is error value.
		oParser = new parserFormula('BITOR(NA(),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(NA(),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. First argument is error value.');
		// Case #4: Number, Error. Second argument is error value.
		oParser = new parserFormula('BITOR(5,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(5,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Second argument is error value.');
		// Case #5: Formula, Number. First argument is formula returning error.
		oParser = new parserFormula('BITOR(SQRT(-1),10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(SQRT(-1),10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. First argument is formula returning error.');
		// Case #6: Reference link, Number. First argument is reference to cell with text.
		oParser = new parserFormula('BITOR(A102,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(A102,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. First argument is reference to cell with text.');
		// Case #7: Number, Reference link. Second argument is reference to cell with text.
		oParser = new parserFormula('BITOR(10,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(10,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Second argument is reference to cell with text.');
		// Case #8: Number(2). First argument is negative number.
		oParser = new parserFormula('BITOR(-5,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(-5,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). First argument is negative number.');
		// Case #9: Number(2). Second argument is negative number.
		oParser = new parserFormula('BITOR(10,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(10,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Second argument is negative number.');
		// Case #10: Number(2). First argument exceeds (2^48)-1.
		oParser = new parserFormula('BITOR(281474976710656,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(281474976710656,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). First argument exceeds (2^48)-1.');
		// Case #11: Number(2). Second argument exceeds (2^48)-1.
		oParser = new parserFormula('BITOR(0,281474976710656)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(0,281474976710656) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Second argument exceeds (2^48)-1.');
		// Case #12: Number, Formula. First argument is number, second is time formula returning decimal number.
		oParser = new parserFormula('BITOR(7,TIME(6,0,0) + 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(7,TIME(6,0,0) + 1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. First argument is number, second is time formula returning decimal number.');

		// Bounded cases:

		// Case #1: Number(2). Minimum valid values for both arguments.
		oParser = new parserFormula('BITOR(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Minimum valid values for both arguments.');
		// Case #2: Number(2). Minimum valid non-zero first argument, zero second argument.
		oParser = new parserFormula('BITOR(1,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(1,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Minimum valid non-zero first argument, zero second argument.');
		// Case #3: Number(2). Zero first argument, minimum valid non-zero second argument.
		oParser = new parserFormula('BITOR(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Zero first argument, minimum valid non-zero second argument.');
		// Case #4: Number(2). Maximum allowed value (2^48-1) for first argument.
		oParser = new parserFormula('BITOR(281474976710655,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(281474976710655,0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 281475000000000, 'Test: Bounded case: Number(2). Maximum allowed value (2^48-1) for first argument.');
		// Case #5: Number(2). Zero first argument, maximum allowed value (2^48-1) for second argument.
		oParser = new parserFormula('BITOR(0,281474976710655)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(0,281474976710655) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 281475000000000, 'Test: Bounded case: Number(2). Zero first argument, maximum allowed value (2^48-1) for second argument.');
		// Case #6: Number(2). Maximum allowed values (2^48-1) for both arguments.
		oParser = new parserFormula('BITOR(281474976710655,281474976710655)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITOR(281474976710655,281474976710655) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 281475000000000, 'Test: Bounded case: Number(2). Maximum allowed values (2^48-1) for both arguments.');

        // Need to fix: diff results from MS
        // Case #10: Number(2). First argument exceeds (2^48)-1.
        // Case #11: Number(2). Second argument exceeds (2^48)-1.
        // Case #12: Number, Formula. First argument is number, second is time formula returning decimal number.
        // Case #4: Number(2). Maximum allowed value (2^48-1) for first argument.
        // Case #5: Number(2). Zero first argument, maximum allowed value (2^48-1) for second argument.
        // Case #6: Number(2). Maximum allowed values (2^48-1) for both arguments.

		testArrayFormula2(assert, "BITOR", 2, 2);
	});

	QUnit.test("Test: \"BITRSHIFT\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("13");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("text");
		ws.getRange2("A103").setValue("#N/A");
		ws.getRange2("A104").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("13"); // Column1
		ws.getRange2("B601").setValue("2"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("13");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("text");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("13"); // TestName
		ws.getRange2("A202").setValue("2"); // TestName1
		ws.getRange2("A203").setValue("text"); // TestName2
		ws.getRange2("A206").setValue("13"); // TestNameArea
		ws.getRange2("A207").setValue("15"); // TestNameArea
		ws.getRange2("A208").setValue("text"); // TestNameArea2
		ws.getRange2("B208").setValue("test"); // TestNameArea2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("13") // TestName3D
		ws2.getRange2("A12").setValue("2") // TestName3D1
		ws2.getRange2("A13").setValue("text") // TestName3D2
		ws2.getRange2("A16").setValue("test"); // TestNameArea3D
		ws2.getRange2("A17").setValue("text"); // TestNameArea3D

		// Positive cases:

		// Case #1: Number(2). Shifts bits right for the number by stripping the specified rightmost digits of the number represented in binary.
		oParser = new parserFormula('BITRSHIFT(13,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(13,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Number(2). Shifts bits right for the number by stripping the specified rightmost digits of the number represented in binary.');
		// Case #2: Number, Number. Standard positive integer shift. 2 of 2 arguments used.
		oParser = new parserFormula('BITRSHIFT(100, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, Number. Standard positive integer shift. 2 of 2 arguments used.');
		// Case #3: Number, Number. Shift resulting in 1.
		oParser = new parserFormula('BITRSHIFT(8, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(8, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Number. Shift resulting in 1.');
		// Case #4: Number, Number. Standard positive integer shift.
		oParser = new parserFormula('BITRSHIFT(150, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(150, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Number, Number. Standard positive integer shift.');
		// Case #5: Number, Number. Shift resulting in 1.
		oParser = new parserFormula('BITRSHIFT(1024, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(1024, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Number. Shift resulting in 1.');
		// Case #6: String, Number. Numeric string for number argument. Implicit conversion to number.
		oParser = new parserFormula('BITRSHIFT("123", 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT("123", 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 61, 'Test: Positive case: String, Number. Numeric string for number argument. Implicit conversion to number.');
		// Case #7: Number, String. Numeric string for shift_amount argument. Implicit conversion to number.
		oParser = new parserFormula('BITRSHIFT(64, "2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(64, "2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 16, 'Test: Positive case: Number, String. Numeric string for shift_amount argument. Implicit conversion to number.');
		// Case #8: Number, Number. Floating point number for shift_amount. Expected truncation.
		oParser = new parserFormula('BITRSHIFT(100, 2.7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, 2.7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, Number. Floating point number for shift_amount. Expected truncation.');
		// Case #9: Boolean, Number. Boolean TRUE converted to 1.
		oParser = new parserFormula('BITRSHIFT(TRUE, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(TRUE, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean, Number. Boolean TRUE converted to 1.');
		// Case #10: Boolean, Number. Boolean FALSE converted to 0.
		oParser = new parserFormula('BITRSHIFT(FALSE, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(FALSE, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Boolean, Number. Boolean FALSE converted to 0.');
		// Case #11: Empty, Number. Empty cell for number argument. Treated as 0.
		oParser = new parserFormula('BITRSHIFT(, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Empty, Number. Empty cell for number argument. Treated as 0.');
		// Case #12: Number, Empty. Empty cell for shift_amount argument. Treated as 0.
		oParser = new parserFormula('BITRSHIFT(100,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Number, Empty. Empty cell for shift_amount argument. Treated as 0.');
		// Case #13: Formula, Number. Number argument is a result of a nested formula.
		oParser = new parserFormula('BITRSHIFT(ROUND(10.8, 0), 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(ROUND(10.8, 0), 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula, Number. Number argument is a result of a nested formula.');
		// Case #14: Number, Formula. Shift_amount is a result of a nested formula.
		oParser = new parserFormula('BITRSHIFT(100, INT(3.9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, INT(3.9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 12, 'Test: Positive case: Number, Formula. Shift_amount is a result of a nested formula.');
		// Case #15: Formula. BITRSHIFT as part of a parent formula.
		oParser = new parserFormula('SUM(BITRSHIFT(100, 2), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BITRSHIFT(100, 2), 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 30, 'Test: Positive case: Formula. BITRSHIFT as part of a parent formula.');
		// Case #16: Reference link, Number. Single-cell reference for number argument.
		oParser = new parserFormula('BITRSHIFT(A100, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(A100, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Reference link, Number. Single-cell reference for number argument.');
		// Case #17: Number, Reference link. Single-cell reference for shift_amount argument.
		oParser = new parserFormula('BITRSHIFT(200, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(200, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 50, 'Test: Positive case: Number, Reference link. Single-cell reference for shift_amount argument.');
		// Case #18: Area, Number. Area reference for number argument. Array behavior.
		oParser = new parserFormula('BITRSHIFT(A100:A101, 1)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(A100:A101, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 6, 'Test: Positive case: Area, Number. Area reference for number argument. Array behavior.');
		// Case #19: Reference link, Area. Area reference for shift_amount argument. Array behavior.
		oParser = new parserFormula('BITRSHIFT(A100, A100:A101)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(A100, A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 0, 'Test: Positive case: Reference link, Area. Area reference for shift_amount argument. Array behavior.');
		// Case #20: Ref3D(2). 3D reference for number argument from another sheet.
		oParser = new parserFormula('BITRSHIFT(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Ref3D(2). 3D reference for number argument from another sheet.');
		// Case #21: Name, Number. Single cell named range for number argument.
		oParser = new parserFormula('BITRSHIFT(TestName, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(TestName, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Name, Number. Single cell named range for number argument.');
		// Case #22: Number, Name. Single cell named range for shift_amount argument.
		oParser = new parserFormula('BITRSHIFT(100, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Positive case: Number, Name. Single cell named range for shift_amount argument.');
		// Case #23: Name, Number. Named range area for number argument. Array behavior.
		oParser = new parserFormula('BITRSHIFT(TestNameArea, 2)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(TestNameArea, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 3, 'Test: Positive case: Name, Number. Named range area for number argument. Array behavior.');
		// Case #24: Table(2). Reference to a table with header and data.
		oParser = new parserFormula('BITRSHIFT(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Table(2). Reference to a table with header and data.');
		// Case #25: Name3D(2). 3D named range for number argument.
		oParser = new parserFormula('BITRSHIFT(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Name3D(2). 3D named range for number argument.');
		// Case #26: Area3D(2). 3D area reference for number argument.
		oParser = new parserFormula('BITRSHIFT(Sheet2!A1:A2, Sheet2!A1:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(Sheet2!A1:A2, Sheet2!A1:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D(2). 3D area reference for number argument.');
		// Case #27: Reference link, Number. Reference link to empty cell for number argument. Treated as 0.
		oParser = new parserFormula('BITRSHIFT(A104, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(A104, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link, Number. Reference link to empty cell for number argument. Treated as 0.');
		// Case #28: Number, Reference link. Reference linl to empty cell for shift_amount argument. Treated as 0.
		oParser = new parserFormula('BITRSHIFT(100, A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Number, Reference link. Reference linl to empty cell for shift_amount argument. Treated as 0.');
		// Case #29: Formula, Number. Date to number for first argument
		oParser = new parserFormula('BITRSHIFT(DATE(2023,1,1), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(DATE(2023,1,1), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 11231, 'Test: Positive case: Formula, Number. Date to number for first argument');
		// Case #30: Number, Number. Negative shift_amount.
		oParser = new parserFormula('BITRSHIFT(100, -2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, -2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 400, 'Test: Positive case: Number, Number. Negative shift_amount.');

		// Negative cases:

		// Case #1: String, Number. `#VALUE!` error expected for non-numeric string for number argument.
		oParser = new parserFormula('BITRSHIFT("text", 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT("text", 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. `#VALUE!` error expected for non-numeric string for number argument.');
		// Case #2: Number, String. `#VALUE!` error expected for non-numeric string for shift_amount.
		oParser = new parserFormula('BITRSHIFT(100, "abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, "abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. `#VALUE!` error expected for non-numeric string for shift_amount.');
		// Case #3: Number, Date. `#VALUE!` error expected for Date type input.
		oParser = new parserFormula('BITRSHIFT(100, DATE(2023,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, DATE(2023,1,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Date. `#VALUE!` error expected for Date type input.');
		// Case #4: Error, Number. Error propagation expected when number is an error.
		oParser = new parserFormula('BITRSHIFT(#VALUE!, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(#VALUE!, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error, Number. Error propagation expected when number is an error.');
		// Case #5: Number, Error. Error propagation expected when shift_amount is an error.
		oParser = new parserFormula('BITRSHIFT(100, #VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, #VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Error. Error propagation expected when shift_amount is an error.');
		// Case #6: Number, Number. `#NUM!` error expected for a number exceeding Excel\'s floating-point limit.
		oParser = new parserFormula('BITRSHIFT(9.9E+307, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(9.9E+307, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. `#NUM!` error expected for a number exceeding Excel\'s floating-point limit.');
		// Case #7: Formula, Number. `#DIV/0!` error expected from nested formula.
		oParser = new parserFormula('BITRSHIFT(1/0, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(1/0, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, Number. `#DIV/0!` error expected from nested formula.');
		// Case #8: Formula, Number. `#DIV/0!` error expected from nested formula.
		oParser = new parserFormula('BITRSHIFT(100, 1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, 1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula, Number. `#DIV/0!` error expected from nested formula.');
		// Case #9: Ref3D, Number. `#VALUE!` error expected. The number argument is non-numeric string in this case.
		oParser = new parserFormula('BITRSHIFT(Sheet2!A3, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(Sheet2!A3, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Number. `#VALUE!` error expected. The number argument is non-numeric string in this case.');
		// Case #10: Name, Number. `#VALUE!` error expected. Named range contains non-numeric string.
		oParser = new parserFormula('BITRSHIFT(TestName2, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(TestName2, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number. `#VALUE!` error expected. Named range contains non-numeric string.');
		// Case #11: Name3D, Number. `#VALUE!` error expected. 3D named range contains non-numeric string.
		oParser = new parserFormula('BITRSHIFT(TestName3D2, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(TestName3D2, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D, Number. `#VALUE!` error expected. 3D named range contains non-numeric string.');
		// Case #12: Area, Number. `#VALUE!` error expected. Area reference contains non-numeric string and error.
		oParser = new parserFormula('BITRSHIFT(A102:A103, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(A102:A103, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. `#VALUE!` error expected. Area reference contains non-numeric string and error.');
		// Case #13: Number, Area. `#VALUE!` error expected. Area reference for shift amount contains non-numeric string and error.
		oParser = new parserFormula('BITRSHIFT(100, A102:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, A102:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. `#VALUE!` error expected. Area reference for shift amount contains non-numeric string and error.');
		// Case #14: Number, Name. `#VALUE!` error expected. Named range area for shift amount contains non-numeric strings.
		oParser = new parserFormula('BITRSHIFT(100, TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name. `#VALUE!` error expected. Named range area for shift amount contains non-numeric strings.');
		// Case #15: Number, Name3D. `#VALUE!` error expected. 3D named range area for shift amount contains non-numeric strings.
		oParser = new parserFormula('BITRSHIFT(100, TestNameArea3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Name3D. `#VALUE!` error expected. 3D named range area for shift amount contains non-numeric strings.');
		// Case #16: Number, Area3D. `#VALUE!` error expected. 3D area for shift amount contains non-numeric strings.
		oParser = new parserFormula('BITRSHIFT(100, Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(100, Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area3D. `#VALUE!` error expected. 3D area for shift amount contains non-numeric strings.');
		// Case #17: Number, Number. Floating point number for number argument. Expected truncation.
		oParser = new parserFormula('BITRSHIFT(10.5, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(10.5, 2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Floating point number for number argument. Expected truncation.');

		// Bounded cases:

		// Case #1: Number, Number. Shift amount greater than number of bits. Expected output is 0.
		oParser = new parserFormula('BITRSHIFT(1, 53)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(1, 53) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number. Shift amount greater than number of bits. Expected output is 0.');
		// Case #2: Number, Number. Test logical shift of negative number. -1 (all ones) shifted right once, padded with zero, results in large positive number.
		oParser = new parserFormula('BITRSHIFT(1,- 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(1,- 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Bounded case: Number, Number. Test logical shift of negative number. -1 (all ones) shifted right once, padded with zero, results in large positive number.');
		// Case #3: Number, Number. Max integer representation (2^48-1) shifted right by 1.
		oParser = new parserFormula('BITRSHIFT(2^48-1, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(2^48-1, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 140737488355327, 'Test: Bounded case: Number, Number. Max integer representation (2^48-1) shifted right by 1.');
		// Case #4: Number, Number. Max integer value (2^48-1) shifted right by 53.
		oParser = new parserFormula('BITRSHIFT(2^48-1, 53)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITRSHIFT(2^48-1, 53) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number. Max integer value (2^48-1) shifted right by 53.');

        // Need to fix: diff results from MS
        // Case #3: Number, Date. `#VALUE!` error expected for Date type input.
        // Case #6: Number, Number. `#NUM!` error expected for a number exceeding Excel\'s floating-point limit.
        // Case #17: Number, Number. Floating point number for number argument. Expected truncation.

		testArrayFormula2(assert, "BITRSHIFT", 2, 2);
	});

	QUnit.test("Test: \"BITXOR\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("5");
		ws.getRange2("A101").setValue("3");
		ws.getRange2("A102").setValue("15");
		ws.getRange2("A103").setValue("7");
		ws.getRange2("A104").setValue("5");
		ws.getRange2("A105").setValue("15");
		ws.getRange2("A106").setValue("3");
		ws.getRange2("A107").setValue("7");
		ws.getRange2("A108").setValue("text");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("5"); // Column1
		ws.getRange2("B601").setValue("3"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("5");
		ws2.getRange2("A2").setValue("3");
		ws2.getRange2("A3").setValue("5");
		ws2.getRange2("A4").setValue("15");
		ws2.getRange2("A5").setValue("3");
		ws2.getRange2("A6").setValue("7");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("5"); // TestName
		ws.getRange2("A202").setValue("3"); // TestName1
		ws.getRange2("A206").setValue("5"); // TestNameArea
		ws.getRange2("A207").setValue("15"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("10") // TestName3D
		ws2.getRange2("A12").setValue("7") // TestName3D1
		ws2.getRange2("A16").setValue("3"); // TestNameArea3D
		ws2.getRange2("A17").setValue("7"); // TestNameArea3D

		// Positive cases:

		// Case #1: Number(2). Returns the total of the bitwise "Exclusive Or" comparision at each bit position.
		oParser = new parserFormula('BITXOR(5,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(5,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(2). Returns the total of the bitwise "Exclusive Or" comparision at each bit position.');
		// Case #2: Number(2). Example from documentation. Binary: 101 XOR 011 = 110 (decimal 6).
		oParser = new parserFormula('BITXOR(5, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(5, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Number(2). Example from documentation. Binary: 101 XOR 011 = 110 (decimal 6).');
		// Case #3: Number(2). Zero with another number. Any bit XOR 0 equals that bit.
		oParser = new parserFormula('BITXOR(0, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(0, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: Number(2). Zero with another number. Any bit XOR 0 equals that bit.');
		// Case #4: Number(2). Same numbers return 0. Any bit XOR itself equals 0.
		oParser = new parserFormula('BITXOR(10, 10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(10, 10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Same numbers return 0. Any bit XOR itself equals 0.');
		// Case #5: Number(2). Binary: 1111 XOR 0111 = 1000 (decimal 8).
		oParser = new parserFormula('BITXOR(15, 7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(15, 7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Number(2). Binary: 1111 XOR 0111 = 1000 (decimal 8).');
		// Case #6: String(2). Strings convertible to numbers. Returns 6.
		oParser = new parserFormula('BITXOR("5", "3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR("5", "3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: String(2). Strings convertible to numbers. Returns 6.');
		// Case #7: Formula(2). Nested formulas returning numbers. 5 XOR 3 = 6.
		oParser = new parserFormula('BITXOR(ABS(-5), SQRT(9))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(ABS(-5), SQRT(9)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula(2). Nested formulas returning numbers. 5 XOR 3 = 6.');
		// Case #8: Reference link(2). References to cells with numbers. 5 XOR 3 = 6.
		oParser = new parserFormula('BITXOR(A100, A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(A100, A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Reference link(2). References to cells with numbers. 5 XOR 3 = 6.');
		// Case #9: Area(2). Single-cell areas with numbers. 15 XOR 7 = 8.
		oParser = new parserFormula('BITXOR(A102:A102, A103:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(A102:A102, A103:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Area(2). Single-cell areas with numbers. 15 XOR 7 = 8.');
		// Case #10: Array(2). Arrays with single numbers. 5 XOR 3 = 6.
		oParser = new parserFormula('BITXOR({5}, {3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR({5}, {3}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Array(2). Arrays with single numbers. 5 XOR 3 = 6.');
		// Case #11: Name(2). Named ranges with numbers. 5 XOR 3 = 6.
		oParser = new parserFormula('BITXOR(TestName, TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(TestName, TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Name(2). Named ranges with numbers. 5 XOR 3 = 6.');
		// Case #12: Name3D(2). 3D named ranges with numbers. 10 XOR 7 = 13.
		oParser = new parserFormula('BITXOR(TestName3D, TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(TestName3D, TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Positive case: Name3D(2). 3D named ranges with numbers. 10 XOR 7 = 13.');
		// Case #13: Ref3D(2). 3D references with numbers. 5 XOR 3 = 6.
		oParser = new parserFormula('BITXOR(Sheet2!A1, Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(Sheet2!A1, Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Ref3D(2). 3D references with numbers. 5 XOR 3 = 6.');
		// Case #14: Area3D(2). 3D single-cell areas with numbers. 5 XOR 3 = 6.
		oParser = new parserFormula('BITXOR(Sheet2!A1:A1, Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(Sheet2!A1:A1, Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Area3D(2). 3D single-cell areas with numbers. 5 XOR 3 = 6.');
		// Case #15: Table(2). Table references with numbers. 5 XOR 3 = 6.
		oParser = new parserFormula('BITXOR(Table1[Column1], Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(Table1[Column1], Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Table(2). Table references with numbers. 5 XOR 3 = 6.');
		// Case #16: Boolean(2). Boolean values converted to 1 and 0. 1 XOR 0 = 1.
		oParser = new parserFormula('BITXOR(TRUE, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(TRUE, FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Boolean(2). Boolean values converted to 1 and 0. 1 XOR 0 = 1.');
		// Case #17: Formula(2). Dates as serial numbers. Serial number day difference results in 1.
		oParser = new parserFormula('BITXOR(DATE(2023,1,1), DATE(2023,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(DATE(2023,1,1), DATE(2023,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Formula(2). Dates as serial numbers. Serial number day difference results in 1.');
		// Case #18: Formula. BITXOR inside another formula. 10 XOR 5 = 15, then SUM adds 2.
		oParser = new parserFormula('SUM(BITXOR(10, 5), 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(BITXOR(10, 5), 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 17, 'Test: Positive case: Formula. BITXOR inside another formula. 10 XOR 5 = 15, then SUM adds 2.');
		// Case #19: Number(2). Binary patterns: 11111111 XOR 10101010 = 01010101 (decimal 85).
		oParser = new parserFormula('BITXOR(255, 170)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(255, 170) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 85, 'Test: Positive case: Number(2). Binary patterns: 11111111 XOR 10101010 = 01010101 (decimal 85).');
		// Case #20: Number(2). Binary patterns: 00001111 XOR 11110000 = 11111111 (decimal 255).
		oParser = new parserFormula('BITXOR(15, 240)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(15, 240) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 255, 'Test: Positive case: Number(2). Binary patterns: 00001111 XOR 11110000 = 11111111 (decimal 255).');
		// Case #21: Number(2). Alternating bit patterns: 1010...1010 XOR 0101...0101 = 1111...1111.
		oParser = new parserFormula('BITXOR(43690, 21845)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(43690, 21845) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 65535, 'Test: Positive case: Number(2). Alternating bit patterns: 1010...1010 XOR 0101...0101 = 1111...1111.');
		// Case #22: Number(2). Powers of 2 minus 1. 255 XOR 65535 = 65280.
		oParser = new parserFormula('BITXOR(2^8-1, 2^16-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(2^8-1, 2^16-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 65280, 'Test: Positive case: Number(2). Powers of 2 minus 1. 255 XOR 65535 = 65280.');
		// Case #23: Formula(2). Functions that return integers. 5 XOR 3 = 6.
		oParser = new parserFormula('BITXOR(INT(5.9), ROUND(3.2, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(INT(5.9), ROUND(3.2, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula(2). Functions that return integers. 5 XOR 3 = 6.');
		// Case #24: Formula. BITXOR in conditional statement. 10 XOR 7 = 13.
		oParser = new parserFormula('IF(TRUE, BITXOR(10, 7), 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula IF(TRUE, BITXOR(10, 7), 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 13, 'Test: Positive case: Formula. BITXOR in conditional statement. 10 XOR 7 = 13.');
		// Case #25: Number(2). Testing with power of 2. 1 XOR 65536 = 65537.
		oParser = new parserFormula('BITXOR(1, 2^16)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(1, 2^16) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 65537, 'Test: Positive case: Number(2). Testing with power of 2. 1 XOR 65536 = 65537.');
		// Case #26: Area(2). Multi-cell range with numbers. Returns array result.
		oParser = new parserFormula('BITXOR(A104:A105, A106:A107)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(A104:A105, A106:A107) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 6, 'Test: Positive case: Area(2). Multi-cell range with numbers. Returns array result.');
		// Case #27: Array(2). Arrays with multiple elements. Returns array result.
		oParser = new parserFormula('BITXOR({5, 10}, {3, 7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR({5, 10}, {3, 7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Array(2). Arrays with multiple elements. Returns array result.');
		// Case #28: Name, Name3D. Named range with multiple cells. Returns array result.
		oParser = new parserFormula('BITXOR(TestNameArea, TestNameArea3D)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(TestNameArea, TestNameArea3D) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 6, 'Test: Positive case: Name, Name3D. Named range with multiple cells. Returns array result.');
		// Case #29: Area3D. 3D range with multiple cells. Returns array result.
		oParser = new parserFormula('BITXOR(Sheet2!A3:A4, Sheet2!A5:A6)', 'A2', ws);
        oParser.setArrayFormulaRef(ws.getRange2("A2:B3").bbox);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(Sheet2!A3:A4, Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getElementRowCol(0,0).getValue(), 6, 'Test: Positive case: Area3D. 3D range with multiple cells. Returns array result.');
		// Case #30: Empty, Number. Empty first argument returns #VALUE! error.
		oParser = new parserFormula('BITXOR(, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Empty, Number. Empty first argument returns #VALUE! error.');
		// Case #31: Number, Empty. Empty second argument returns #VALUE! error.
		oParser = new parserFormula('BITXOR(5, )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(5, ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number, Empty. Empty second argument returns #VALUE! error.');

		// Negative cases:

		// Case #1: String, Number. Non-numeric string returns #VALUE! error.
		oParser = new parserFormula('BITXOR("text", 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR("text", 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string returns #VALUE! error.');
		// Case #2: Error, Number. Error value propagates through function.
		oParser = new parserFormula('BITXOR(NA(), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(NA(), 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error value propagates through function.');
		// Case #3: Reference link, Number. Reference to non-numeric cell returns #VALUE! error.
		oParser = new parserFormula('BITXOR(A108, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(A108, 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to non-numeric cell returns #VALUE! error.');
		// Case #4: String(2). Empty strings return #VALUE! error.
		oParser = new parserFormula('BITXOR("", "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR("", "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Empty strings return #VALUE! error.');
		// Case #5: Formula, Number. Formula resulting in error propagates the error.
		oParser = new parserFormula('BITXOR(SQRT(-1), 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(SQRT(-1), 5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in error propagates the error.');
		// Case #6: Number(2). Number exceeding (2^48)-1 returns #NUM! error.
		oParser = new parserFormula('BITXOR(2^48, 5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(2^48, 5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number exceeding (2^48)-1 returns #NUM! error.');
		// Case #7: Number(2). Number exceeding (2^48)-1 returns #NUM! error.
		oParser = new parserFormula('BITXOR(5, 2^48)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(5, 2^48) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number exceeding (2^48)-1 returns #NUM! error.');
		// Case #8: Number(2). Decimal numbers
		oParser = new parserFormula('BITXOR(5.7, 3.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(5.7, 3.2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Decimal numbers');
		// Case #9: Number(2). Negative first argument. Excel uses two\'s complement representation.
		oParser = new parserFormula('BITXOR(-5, 3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(-5, 3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative first argument. Excel uses two\'s complement representation.');
		// Case #10: Number(2). Negative second argument. Excel uses two\'s complement representation.
		oParser = new parserFormula('BITXOR(5, -3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(5, -3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Negative second argument. Excel uses two\'s complement representation.');

		// Bounded cases:

		// Case #1: Number(2). Minimum values. 0 XOR 0 = 0.
		oParser = new parserFormula('BITXOR(0, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(0, 0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Minimum values. 0 XOR 0 = 0.');
		// Case #2: Number(2). Maximum allowed integers (281474976710655). Result is 0.
		oParser = new parserFormula('BITXOR(2^48-1, 2^48-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(2^48-1, 2^48-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Maximum allowed integers (281474976710655). Result is 0.');
		// Case #3: Number(2). Maximum allowed integer with zero. Returns the maximum value.
		oParser = new parserFormula('BITXOR(2^48-1, 0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(2^48-1, 0) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 281475000000000, 'Test: Bounded case: Number(2). Maximum allowed integer with zero. Returns the maximum value.');
		// Case #4: Number(2). Large values near half of max. Returns 1.
		oParser = new parserFormula('BITXOR(2^47, 2^47-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(2^47, 2^47-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 281475000000000, 'Test: Bounded case: Number(2). Large values near half of max. Returns 1.');
		// Case #5: Number(2). Minimum non-zero with maximum allowed. Flips all bits.
		oParser = new parserFormula('BITXOR(1, 2^48-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula BITXOR(1, 2^48-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 281475000000000, 'Test: Bounded case: Number(2). Minimum non-zero with maximum allowed. Flips all bits.');

        // Need to fix: results diff from MS
        // Case #6: Number(2). Number exceeding (2^48)-1 returns #NUM! error.
        // Case #7: Number(2). Number exceeding (2^48)-1 returns #NUM! error.
        // Case #8: Number(2). Decimal numbers
        // Case #3: Number(2). Maximum allowed integer with zero. Returns the maximum value.
        // Case #4: Number(2). Large values near half of max. Returns 1.
        // Case #5: Number(2). Minimum non-zero with maximum allowed. Flips all bits.


		testArrayFormula2(assert, "BITXOR", 2, 2);
	});

	QUnit.test("Test: \"COMPLEX\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("3");
		ws.getRange2("A101").setValue("4");
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("j");
		ws.getRange2("A104").setValue("k");
		ws.getRange2("A105").setValue("");
		ws.getRange2("A106").setValue("I");
		ws.getRange2("A107").setValue("J");
		ws.getRange2("A108").setValue("1");
		ws.getRange2("A109").setValue("text");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("3.5"); // Column1
		ws.getRange2("B601").setValue("-19.6"); // Column2
		ws.getRange2("C601").setValue("j"); // Column3
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0");
		ws2.getRange2("A2").setValue("1");
		ws2.getRange2("A3").setValue("i");
		ws2.getRange2("A4").setValue("j");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("3"); // TestName
		ws.getRange2("A202").setValue("4"); // TestName1
		ws.getRange2("A203").setValue("j"); // TestName2
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("0") // TestName3D
		ws2.getRange2("A12").setValue("1") // TestName3D1
		ws2.getRange2("A13").setValue("i") // TestName3D2

		// Positive cases:

		// Case #1: Number(2). Complex number with -3.5 and 19.6 as the real and imaginary coefficients. 2 of 3 arguments were used.
		oParser = new parserFormula('COMPLEX(-3.5,19.6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(-3.5,19.6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.5+19.6i', 'Test: Positive case: Number(2). Complex number with -3.5 and 19.6 as the real and imaginary coefficients. 2 of 3 arguments were used.');
		// Case #2: Number(2), String. Complex number with 3.5 and -19.6 as the real and imaginary coefficients, and j as the suffix. 3 of 3 arguments were used.
		oParser = new parserFormula('COMPLEX(3.5,-19.6,"j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3.5,-19.6,"j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5-19.6j', 'Test: Positive case: Number(2), String. Complex number with 3.5 and -19.6 as the real and imaginary coefficients, and j as the suffix. 3 of 3 arguments were used.');
		// Case #3: Number(2). Complex number with 3.5 and 0 as the real and imaginary coefficients. 2 of 3 arguments were used.
		oParser = new parserFormula('COMPLEX(3.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5', 'Test: Positive case: Number(2). Complex number with 3.5 and 0 as the real and imaginary coefficients. 2 of 3 arguments were used.');
		// Case #4: Number(2). Complex number with 0 and 2.4 as the real and imaginary coefficients. 2 of 3 arguments were used.
		oParser = new parserFormula('COMPLEX(0,2.4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(0,2.4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.4i', 'Test: Positive case: Number(2). Complex number with 0 and 2.4 as the real and imaginary coefficients. 2 of 3 arguments were used.');
		// Case #5: Number(2). Complex number with 0 and 0 as the real and imaginary coefficients. 2 of 3 arguments were used.
		oParser = new parserFormula('COMPLEX(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Number(2). Complex number with 0 and 0 as the real and imaginary coefficients. 2 of 3 arguments were used.');
		// Case #6: Number(2). Basic numeric real & imaginary, default suffix i (implicit). 2 of 3 args used.
		oParser = new parserFormula('COMPLEX(3,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Number(2). Basic numeric real & imaginary, default suffix i (implicit). 2 of 3 args used.');
		// Case #7: Number(2), String. Explicit literal suffix j. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(3,4,"j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3,4,"j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4j', 'Test: Positive case: Number(2), String. Explicit literal suffix j. 3 of 3 args used.');
		// Case #8: Number(2), String. Float numbers & negative imaginary part. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(3.5,-2.75,"i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3.5,-2.75,"i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5-2.75i', 'Test: Positive case: Number(2), String. Float numbers & negative imaginary part. 3 of 3 args used.');
		// Case #9: String(2). Numeric strings converted to numbers, default suffix. 2 of 3 args used.
		oParser = new parserFormula('COMPLEX("3","4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX("3","4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: String(2). Numeric strings converted to numbers, default suffix. 2 of 3 args used.');
		// Case #10: Formula(2). Formulas returning numbers. 2 of 3 args used.
		oParser = new parserFormula('COMPLEX(SQRT(9),ABS(-4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(SQRT(9),ABS(-4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Formula(2). Formulas returning numbers. 2 of 3 args used.');
		// Case #11: Reference link(3). All three arguments via references (suffix cell with "i"). 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(A100,A101,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A100,A101,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Reference link(3). All three arguments via references (suffix cell with "i"). 3 of 3 args used.');
		// Case #12: Reference link(3). All args via references (suffix cell with "j"). 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(A100,A101,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A100,A101,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4j', 'Test: Positive case: Reference link(3). All args via references (suffix cell with "j"). 3 of 3 args used.');
		// Case #13: Area(3). Single-cell areas emulate scalar args incl. suffix. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(A100:A100,A101:A101,A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A100:A100,A101:A101,A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Area(3). Single-cell areas emulate scalar args incl. suffix. 3 of 3 args used.');
		// Case #14: Table(3). Structured references, third column holds suffix. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(Table1[Column1],Table1[Column2],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(Table1[Column1],Table1[Column2],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5-19.6j', 'Test: Positive case: Table(3). Structured references, third column holds suffix. 3 of 3 args used.');
		// Case #15: Ref3D(3). 3D references including suffix cell. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(Sheet2!A1,Sheet2!A2,Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(Sheet2!A1,Sheet2!A2,Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'i', 'Test: Positive case: Ref3D(3). 3D references including suffix cell. 3 of 3 args used.');
		// Case #16: Area3D(3). 3D single-cell areas. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(Sheet2!A1:A1,Sheet2!A2:A2,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'j', 'Test: Positive case: Area3D(3). 3D single-cell areas. 3 of 3 args used.');
		// Case #17: Name(3). Named ranges incl. suffix name. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(TestName,TestName1,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(TestName,TestName1,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4j', 'Test: Positive case: Name(3). Named ranges incl. suffix name. 3 of 3 args used.');
		// Case #18: Name3D(3). 3D named ranges with suffix. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(TestName3D,TestName3D1,TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(TestName3D,TestName3D1,TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'i', 'Test: Positive case: Name3D(3). 3D named ranges with suffix. 3 of 3 args used.');
		// Case #19: Array(3). Single-element arrays for all three arguments (suffix array). 3 of 3 args used.
		oParser = new parserFormula('COMPLEX({5},{-6},{"i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX({5},{-6},{"i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5-6i', 'Test: Positive case: Array(3). Single-element arrays for all three arguments (suffix array). 3 of 3 args used.');
		// Case #20: Array(3). Multi-element arrays produce spilled complex results with suffix array. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX({1,2},{3,4},{"j","i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX({1,2},{3,4},{"j","i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1+3j', 'Test: Positive case: Array(3). Multi-element arrays produce spilled complex results with suffix array. 3 of 3 args used.');
		// Case #21: Formula(3). Suffix chosen by IF formula. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(ROUND(3.9999,0),ROUND(-4.2,0),IF(TRUE,"i","j"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(ROUND(3.9999,0),ROUND(-4.2,0),IF(TRUE,"i","j")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4-4i', 'Test: Positive case: Formula(3). Suffix chosen by IF formula. 3 of 3 args used.');
		// Case #22: Formula(3). Date & Time numeric conversion; suffix by ref. 3 of 3 args used.
		// Different result with MS
		oParser = new parserFormula('COMPLEX(DATE(2025,1,1),TIME(12,0,0),A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(DATE(2025,1,1),TIME(12,0,0),A104) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '45658+0.5j', 'Test: Positive case: Formula(3). Date & Time numeric conversion; suffix by ref. 3 of 3 args used.');
		// Case #23: Formula. Cross type: ref + formula + ref suffix inside parent formula. 3 of 3 args used.
		oParser = new parserFormula('CONCAT("Z=",COMPLEX(A100,ABS(-5),A103))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONCAT("Z=",COMPLEX(A100,ABS(-5),A103)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'Z=3+5j', 'Test: Positive case: Formula. Cross type: ref + formula + ref suffix inside parent formula. 3 of 3 args used.');
		// Case #24: Reference link(3). Suffix ref to empty cell. 3 args.
		// Different result with MS
		oParser = new parserFormula('COMPLEX(A100,A101,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A100,A101,A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Reference link(3). Suffix ref to empty cell. 3 args.');
		// Case #25: Number(2),Empty. Suffix is empty. 3 of 3 args were used.
		oParser = new parserFormula('COMPLEX(3,4,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3,4,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Number(2),Empty. Suffix is empty. 3 of 3 args were used.');
		// Case #26: Formula(2). Time & Date numeric conversion; suffix by ref. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(TIME(12,0,0),DATE(2025,1,1),A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(TIME(12,0,0),DATE(2025,1,1),A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula(2). Time & Date numeric conversion; suffix by ref. 3 of 3 args used.');

		// Negative cases:

		// Case #1: Number(2), String. Invalid literal suffix \'k\'. 3 of 3 args used.
		oParser = new parserFormula('COMPLEX(1,2,"k")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(1,2,"k") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), String. Invalid literal suffix \'k\'. 3 of 3 args used.');
		// Case #2: Reference link(3). Suffix ref cell contains invalid \'k\'. 3 args.
		oParser = new parserFormula('COMPLEX(A100,A101,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A100,A101,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(3). Suffix ref cell contains invalid \'k\'. 3 args.');
		// Case #3: Reference link(3). Suffix uppercase I invalid. 3 args.
		oParser = new parserFormula('COMPLEX(A100,A101,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A100,A101,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(3). Suffix uppercase I invalid. 3 args.');
		// Case #4: Reference link(3). Suffix uppercase J invalid. 3 args.
		oParser = new parserFormula('COMPLEX(A100,A101,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A100,A101,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(3). Suffix uppercase J invalid. 3 args.');
		// Case #5: String, Number. Non-numeric real string. 2 args.
		oParser = new parserFormula('COMPLEX("abc",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX("abc",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric real string. 2 args.');
		// Case #6: Number, String. Non-numeric imag string. 2 args.
		oParser = new parserFormula('COMPLEX(2,"xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(2,"xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric imag string. 2 args.');
		// Case #7: Error, Number. Error in real propagates. 2 args.
		oParser = new parserFormula('COMPLEX(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error in real propagates. 2 args.');
		// Case #8: Number, Error. Error in imaginary propagates. 2 args.
		oParser = new parserFormula('COMPLEX(2,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(2,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error in imaginary propagates. 2 args.');
		// Case #9: Area, Number. Multi-cell area invalid for scalar real. 2 args.
		oParser = new parserFormula('COMPLEX(A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A100:A101,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell area invalid for scalar real. 2 args.');
		// Case #10: Number, Area. Multi-cell area invalid for scalar imag. 2 args.
		oParser = new parserFormula('COMPLEX(2,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(2,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Multi-cell area invalid for scalar imag. 2 args.');
		// Case #11: Array(3). Invalid non-numeric element in real array. 3 args.
		oParser = new parserFormula('COMPLEX({"x",1},{2,3},{"i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX({"x",1},{2,3},{"i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array(3). Invalid non-numeric element in real array. 3 args.');
		// Case #12: Reference link(3). Suffix numeric \'1\' invalid. 3 args.
		oParser = new parserFormula('COMPLEX(A100,A101,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A100,A101,A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(3). Suffix numeric \'1\' invalid. 3 args.');
		// Case #13: Formula, Number. Formula real returns #NUM!. 2 args.
		oParser = new parserFormula('COMPLEX(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula real returns #NUM!. 2 args.');
		// Case #14: Number, Formula. Formula imag returns #NUM!. 2 args.
		oParser = new parserFormula('COMPLEX(2,SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(2,SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Formula. Formula imag returns #NUM!. 2 args.');
		// Case #15: Reference link(3). All three refs invalid types (real text, imag empty, suffix invalid). 3 args.
		oParser = new parserFormula('COMPLEX(A109,A105,A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A109,A105,A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link(3). All three refs invalid types (real text, imag empty, suffix invalid). 3 args.');
		// Case #16: Array(3). Imag array has non-numeric element. 3 args.
		oParser = new parserFormula('COMPLEX({1,2},{"a",3},{"j","i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX({1,2},{"a",3},{"j","i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array(3). Imag array has non-numeric element. 3 args.');
		// Case #17: Boolean(2). Booleans -> (1;0). 2 of 3 args used.
		// Different result with MS
		oParser = new parserFormula('COMPLEX(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Booleans -> (1;0). 2 of 3 args used.');
		// Case #18: Formula. COMPLEX nested inside SUM (parent formula). 2 of 3 args used for inner COMPLEX.
		oParser = new parserFormula('SUM(1,COMPLEX(2,3))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(1,COMPLEX(2,3)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. COMPLEX nested inside SUM (parent formula). 2 of 3 args used for inner COMPLEX.');
		// Case #19: Empty,Number. Real_num is  empty return #N/A error. 2 of 3 args were used.
		// Different result with MS
		oParser = new parserFormula('COMPLEX(,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty,Number. Real_num is  empty return #N/A error. 2 of 3 args were used.');
		// Case #20: Number, Empty. I_num is empty return #N/A error. 2 of 3 args were used.
		// Different result with MS
		oParser = new parserFormula('COMPLEX(2,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(2,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty. I_num is empty return #N/A error. 2 of 3 args were used.');
		// Case #21: Number(3). Suffix is int number. 3 of 3 args were used.
		oParser = new parserFormula('COMPLEX(3,4,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3,4,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3). Suffix is int number. 3 of 3 args were used.');
		// Case #22: Number(3). Suffix is float number. 3 of 3 args were used.
		oParser = new parserFormula('COMPLEX(3.2,4.3,5.2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3.2,4.3,5.2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(3). Suffix is float number. 3 of 3 args were used.');
		// Case #23: Number(2), Boolean. Suffix is boolean (TRUE). 3 of 3 args were used.
		oParser = new parserFormula('COMPLEX(3,4,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3,4,TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Boolean. Suffix is boolean (TRUE). 3 of 3 args were used.');
		// Case #24: Number(2), Formula. Suffix is Date. 3 of 3 args were used.
		oParser = new parserFormula('COMPLEX(3,4, DATE(1900,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3,4, DATE(1900,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Formula. Suffix is Date. 3 of 3 args were used.');
		// Case #25: Number(2), Formula. Suffix is Time. 3 of 3 args were used.
		oParser = new parserFormula('COMPLEX(3,4, TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3,4, TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number(2), Formula. Suffix is Time. 3 of 3 args were used.');
		// Case #26: Number(2), Error. Suffix is Error return #N/A error. 3 of 3 args  were used.
		oParser = new parserFormula('COMPLEX(3,4,NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(3,4,NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number(2), Error. Suffix is Error return #N/A error. 3 of 3 args  were used.');

		// Bounded cases:

		// Case #1: Number(2). Zero real & imaginary boundary. 2 args.
		oParser = new parserFormula('COMPLEX(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number(2). Zero real & imaginary boundary. 2 args.');
		// Case #2: Number(2), String. Very small magnitude boundary values. 3 args.
		oParser = new parserFormula('COMPLEX(1E-307,-1E-307,"i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(1E-307,-1E-307,"i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e-307-1e-307i', 'Test: Bounded case: Number(2), String. Very small magnitude boundary values. 3 args.');
		// Case #3: Number(2), String. Maximum magnitude values. 3 args.
		oParser = new parserFormula('COMPLEX(9.99999999999999E+307,-9.99999999999999E+307,"j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(9.99999999999999E+307,-9.99999999999999E+307,"j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '9.99999999999999e+307-9.99999999999999e+307j', 'Test: Bounded case: Number(2), String. Maximum magnitude values. 3 args.');
		// Case #4: Area(2). Full column & full row references structural boundary. 2 args.
		oParser = new parserFormula('COMPLEX(A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula COMPLEX(A:A,100:100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3i', 'Test: Bounded case: Area(2). Full column & full row references structural boundary. 2 args.');

        // Need to fix: results diff from MS
        // Case #22: Formula(3). Date & Time numeric conversion; suffix by ref. 3 of 3 args used.
        // Case #24: Reference link(3). Suffix ref to empty cell. 3 args.
        // Case #17: Boolean(2). Booleans -> (1;0). 2 of 3 args used.
        // Case #19: Empty,Number. Real_num is  empty return #N/A error. 2 of 3 args were used.
        // Case #20: Number, Empty. I_num is empty return #N/A error. 2 of 3 args were used.


		testArrayFormula2(assert, "COMPLEX", 2, 3, true);
	});

	QUnit.test("Test: \"CONVERT\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("m");
		ws.getRange2("A102").setValue("ft");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A104").setValue("2");
		ws.getRange2("A105").setValue("m2");
		ws.getRange2("A106").setValue("ft2");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("2"); // Column1
		ws.getRange2("B601").setValue("kg"); // Column2
		ws.getRange2("C601").setValue("lbm"); // Column3
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("5");
		ws2.getRange2("A2").setValue("km");
		ws2.getRange2("A3").setValue("mi");
		ws2.getRange2("A4").setValue("2");
		ws2.getRange2("A5").setValue("3");
		ws2.getRange2("A6").setValue("ozm");
		ws2.getRange2("A7").setValue("grain");
		ws2.getRange2("A8").setValue("cwt");
		ws2.getRange2("A9").setValue("lcwt");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("10"); // TestName
		ws.getRange2("A202").setValue("L"); // TestName1
		ws.getRange2("A203").setValue("gal"); // TestName2
		ws.getRange2("A206").setValue("1"); // TestNameArea
		ws.getRange2("A207").setValue("2"); // TestNameArea
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("1") // TestName3D
		ws2.getRange2("A12").setValue("ton") // TestName3D1
		ws2.getRange2("A13").setValue("kg") // TestName3D2
		ws2.getRange2("A16").setValue("1"); // TestNameArea3D
		ws2.getRange2("A17").setValue("2"); // TestNameArea3D

		// Positive cases:

		// Case #1: Number, String(2). Convert 68 from Fahrenheit to Celsius. Return 20
		oParser = new parserFormula('CONVERT(68, "F", "C")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(68, "F", "C") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 20, 'Test: Positive case: Number, String(2). Convert 68 from Fahrenheit to Celsius. Return 20');
		// Case #2: Formula, String(2). Convert 100 from Foot to Meter. Return 9.290304
		oParser = new parserFormula('CONVERT(CONVERT(100,"ft","m"),"ft","m")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(CONVERT(100,"ft","m"),"ft","m") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 9.290304, 'Test: Positive case: Formula, String(2). Convert 100 from Foot to Meter. Return 9.290304');
		// Case #3: Number, String(2). Convert 7 from Bit to Byte. Return 0.875
		oParser = new parserFormula('CONVERT(7,"bit","byte")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"bit","byte") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 0.875, 'Test: Positive case: Number, String(2). Convert 7 from Bit to Byte. Return 0.875');
		// Case #4: Number, String(2). Convert 7 from Admiralty knot to Knot. Return 6.99999939524838 diff
		// Different result with MS
		oParser = new parserFormula('CONVERT(7,"admkn","kn")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"admkn","kn") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6.999999395248377, 'Test: Positive case: Number, String(2). Convert 7 from Admiralty knot to Knot. Return 6.99999939524838 diff');
		// Case #5: Number, String(2). Convert 7 from Admiral knot to Meters per second. Return 3.6011108 diff
		// Different result with MS
		oParser = new parserFormula('CONVERT(7,"admkn","m/s")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"admkn","m/s") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 3.6011108, 'Test: Positive case: Number, String(2). Convert 7 from Admiral knot to Meters per second. Return 3.6011108 diff');
		// Case #6: Number, String(2). Convert 7 from Admiral knot to Miles per hour. Return 8.0554554 diff
		// Different result with MS
		oParser = new parserFormula('CONVERT(7,"admkn","mph")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"admkn","mph") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 8.0554554, 'Test: Positive case: Number, String(2). Convert 7 from Admiral knot to Miles per hour. Return 8.0554554 diff');
		// Case #7: Number, String(2). Convert 7 from Meter per hour to Meter per second. Return 0.019444
		oParser = new parserFormula('CONVERT(7,"m/h","m/sec")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"m/h","m/sec") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.001944444, 'Test: Positive case: Number, String(2). Convert 7 from Meter per hour to Meter per second. Return 0.019444');
		// Case #8: Number, String(2). Convert 7 from Meter per hour to Miles per hour. Return 0.0043496
		oParser = new parserFormula('CONVERT(7,"m/hr","mph")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"m/hr","mph") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.004349598, 'Test: Positive case: Number, String(2). Convert 7 from Meter per hour to Miles per hour. Return 0.0043496');
		// Case #9: Number, String(2). Convert 7 from Meter to Mile. Return 0.0043496
		oParser = new parserFormula('CONVERT(7,"m","mi")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"m","mi") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.004349598, 'Test: Positive case: Number, String(2). Convert 7 from Meter to Mile. Return 0.0043496');
		// Case #10: Number, String(2). Convert 7  from Meter to Pica (1/72 inch). Return 19842.5196850
		oParser = new parserFormula('CONVERT(7,"m","Pica")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"m","Pica") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 19842.51969, 'Test: Positive case: Number, String(2). Convert 7  from Meter to Pica (1/72 inch). Return 19842.5196850');
		// Case #11: Number, String(2). Convert 7 from Meter to Pica (1/6 inch). Return 1653.5433071
		oParser = new parserFormula('CONVERT(7,"m","pica")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"m","pica") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 1653.543307, 'Test: Positive case: Number, String(2). Convert 7 from Meter to Pica (1/6 inch). Return 1653.5433071');
		// Case #12: Number, String(2). Convert 7 from Natural mile to Pica (1/6 inch). Return 3062362.2047251
		oParser = new parserFormula('CONVERT(7,"Nmi","pica")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"Nmi","pica") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3) - 0, 3062362.205, 'Test: Positive case: Number, String(2). Convert 7 from Natural mile to Pica (1/6 inch). Return 3062362.2047251');
		// Case #13: Number, String(2). Convert 7 from Year to Day. Return  2556.75
		oParser = new parserFormula('CONVERT(7,"yr","day")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"yr","day") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 2556.75, 'Test: Positive case: Number, String(2). Convert 7 from Year to Day. Return  2556.75');
		// Case #14: Number, String(2). Convert 7 from Year to Minutes. Return 3681720
		oParser = new parserFormula('CONVERT(7,"yr","min")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"yr","min") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3681720, 'Test: Positive case: Number, String(2). Convert 7 from Year to Minutes. Return 3681720');
		// Case #15: Number, String(2). Convert 7 from Day to Minutes. Return 10080
		oParser = new parserFormula('CONVERT(7,"day","min")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"day","min") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10080, 'Test: Positive case: Number, String(2). Convert 7 from Day to Minutes. Return 10080');
		// Case #16: Number, String(2). Convert 7 from Hours to Seconds. Return 25200
		oParser = new parserFormula('CONVERT(7,"hr","sec")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"hr","sec") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25200, 'Test: Positive case: Number, String(2). Convert 7 from Hours to Seconds. Return 25200');
		// Case #17: Number, String(2). Convert 7  from Minutes to Seconds. Return 420
		oParser = new parserFormula('CONVERT(7,"min","sec")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"min","sec") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 420, 'Test: Positive case: Number, String(2). Convert 7  from Minutes to Seconds. Return 420');
		// Case #18: Number, String(2). Convert 7  from Pascal to mmHg.Return 0.0525043 diff
		// Different result with MS
		oParser = new parserFormula('CONVERT(7,"Pa","mmHg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"Pa","mmHg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0525043, 'Test: Positive case: Number, String(2). Convert 7  from Pascal to mmHg.Return 0.0525043 diff');
		// Case #19: Number, String(2). Convert 7 from Pascal to PSI. Return 0.0010153
		oParser = new parserFormula('CONVERT(7,"Pa","psi")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"Pa","psi") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.001015264, 'Test: Positive case: Number, String(2). Convert 7 from Pascal to PSI. Return 0.0010153');
		// Case #20: Number, String(2). Convert 7 from Pascal to Torr. Return  0.0525045
		oParser = new parserFormula('CONVERT(7,"Pa","Torr")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"Pa","Torr") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.052504, 'Test: Positive case: Number, String(2). Convert 7 from Pascal to Torr. Return  0.0525045');
		// Case #21: Number, String(2). Convert 7 from Gram  to Slug. Return  0.0004797
		oParser = new parserFormula('CONVERT(7,"g","sg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"g","sg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.00047965, 'Test: Positive case: Number, String(2). Convert 7 from Gram  to Slug. Return  0.0004797');
		// Case #22: Number, String(2). Convert 7 from Gram to Pound. Return  0.0154324
		oParser = new parserFormula('CONVERT(7,"g","lbm")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(7,"g","lbm") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 0.015432358, 'Test: Positive case: Number, String(2). Convert 7 from Gram to Pound. Return  0.0154324');
		// Case #23: Number, String(2). Convert 1  from Pound to Kg. Return 0.4535924
		oParser = new parserFormula('CONVERT(1, "lbm", "kg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "lbm", "kg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.45359237, 'Test: Positive case: Number, String(2). Convert 1  from Pound to Kg. Return 0.4535924');
		// Case #24: Number, String(2). Convert 1 from Pound to Mg. Return  453592
		oParser = new parserFormula('CONVERT(1, "lbm", "mg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "lbm", "mg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 453592.37, 'Test: Positive case: Number, String(2). Convert 1 from Pound to Mg. Return  453592');
		// Case #25: Number, String(2). Convert 1  from Meter to Milimeter. Return 1000
		oParser = new parserFormula('CONVERT(1,"m","mm")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m","mm") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Positive case: Number, String(2). Convert 1  from Meter to Milimeter. Return 1000');
		// Case #26: Number, String(2). Convert 1 from Square meter to Square milimeter. Return 1000000
		oParser = new parserFormula('CONVERT(1,"m2","mm2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m2","mm2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000000, 'Test: Positive case: Number, String(2). Convert 1 from Square meter to Square milimeter. Return 1000000');
		// Case #27: Number, String(2). Convert 1 from Cube meter to Cube milimeter. Return 1000000000
		oParser = new parserFormula('CONVERT(1,"m3","mm3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m3","mm3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1000000000', 'Test: Positive case: Number, String(2). Convert 1 from Cube meter to Cube milimeter. Return 1000000000');
		// Case #28: Number, String(2). Convert 1 from Meter to centimeter. Return 100
		oParser = new parserFormula('CONVERT(1,"m","cm")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m","cm") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 100, 'Test: Positive case: Number, String(2). Convert 1 from Meter to centimeter. Return 100');
		// Case #29: Number, String(2). Convert 1 from Square meter to square centimeter. Return 10000
		oParser = new parserFormula('CONVERT(1,"m2","cm2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m2","cm2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10000, 'Test: Positive case: Number, String(2). Convert 1 from Square meter to square centimeter. Return 10000');
		// Case #30: Number, String(2). Convert 1 from Cube meter to Cube centimeter. Return 100000
		oParser = new parserFormula('CONVERT(1,"m3","cm3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m3","cm3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1000000', 'Test: Positive case: Number, String(2). Convert 1 from Cube meter to Cube centimeter. Return 100000');
		// Case #31: Number, String(2). Convert 1 from Centimeter to Meter . Return 0.01
		oParser = new parserFormula('CONVERT(1,"cm","m")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"cm","m") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.01, 'Test: Positive case: Number, String(2). Convert 1 from Centimeter to Meter . Return 0.01');
		// Case #32: Number, String(2). Convert 1 from Square centimeter to Square meter. Return 0.0001
		oParser = new parserFormula('CONVERT(1,"cm2","m2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"cm2","m2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 0.0001, 'Test: Positive case: Number, String(2). Convert 1 from Square centimeter to Square meter. Return 0.0001');
		// Case #33: Number, String(2). Convert 1 from Cubic centimeter to Cubic meter. Return 0.000001
		oParser = new parserFormula('CONVERT(1,"cm3","m3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"cm3","m3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 0.000001, 'Test: Positive case: Number, String(2). Convert 1 from Cubic centimeter to Cubic meter. Return 0.000001');
		// Case #34: Number, String(2). Convert 1 from Meter to Meter. Return  1
		oParser = new parserFormula('CONVERT(1,"m","m")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m","m") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, String(2). Convert 1 from Meter to Meter. Return  1');
		// Case #35: Number, String(2). Convert 1 from Square Meter to Square Meter. Return 1
		oParser = new parserFormula('CONVERT(1,"m2","m2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m2","m2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, String(2). Convert 1 from Square Meter to Square Meter. Return 1');
		// Case #36: Number, String(2). Convert 1 from Cubic Meter to Cubic Meter. Return 1
		oParser = new parserFormula('CONVERT(1,"m3","m3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m3","m3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, String(2). Convert 1 from Cubic Meter to Cubic Meter. Return 1');
		// Case #37: Number, String(2). Convert 1 from Square Meter to  Square centimeter. Return 10000
		oParser = new parserFormula('CONVERT(1,"m^2","cm^2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m^2","cm^2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10000, 'Test: Positive case: Number, String(2). Convert 1 from Square Meter to  Square centimeter. Return 10000');
		// Case #38: Number, String(2). Convert 1 from Cubic Meter to Cubic centimeter. Return 1000000
		oParser = new parserFormula('CONVERT(1,"m^3","cm^3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m^3","cm^3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '1000000', 'Test: Positive case: Number, String(2). Convert 1 from Cubic Meter to Cubic centimeter. Return 1000000');
		// Case #39: Number, String(2). Convert 100 from Celsius to Kelvin. Return 373.15
		oParser = new parserFormula('CONVERT(100, "C", "K")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(100, "C", "K") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 373.15, 'Test: Positive case: Number, String(2). Convert 100 from Celsius to Kelvin. Return 373.15');
		// Case #40: Number, String(2). Convert 273.15 from Kelvin to Celsius. Return 0
		oParser = new parserFormula('CONVERT(273.15, "K", "C")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(273.15, "K", "C") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, String(2). Convert 273.15 from Kelvin to Celsius. Return 0');
		// Case #41: Number, String(2). Convert 1 from Atmosphere to Pascal. Return 101325
		// Different result with MS
		oParser = new parserFormula('CONVERT(1, "atm", "Pa")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "atm", "Pa") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(), '101325', 'Test: Positive case: Number, String(2). Convert 1 from Atmosphere to Pascal. Return 101325');
		// Case #42: Number, String(2). Convert 10 from Newton to Pound force. Return 2.248089
		oParser = new parserFormula('CONVERT(10, "N", "lbf")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(10, "N", "lbf") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 2.248089, 'Test: Positive case: Number, String(2). Convert 10 from Newton to Pound force. Return 2.248089');
		// Case #43: Number, String(2). Convert 1000 from Watt to Horsepower. Return 1.341022
		oParser = new parserFormula('CONVERT(1000, "W", "HP")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1000, "W", "HP") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(6) - 0, 1.341022, 'Test: Positive case: Number, String(2). Convert 1000 from Watt to Horsepower. Return 1.3410220896');
		// Case #44: Number, String(2). Convert 5 from Joule to IT calorie. Return 1.1942
		// Different result with MS
		oParser = new parserFormula('CONVERT(5, "J", "cal")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(5, "J", "cal") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(4) - 0, 1.1942, 'Test: Positive case: Number, String(2). Convert 5 from Joule to IT calorie. Return 1.1942');
		// Case #45: Number, String(2). Convert 1 from Tesla to Gauss. Return 10000
		oParser = new parserFormula('CONVERT(1, "T", "ga")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "T", "ga") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10000, 'Test: Positive case: Number, String(2). Convert 1 from Tesla to Gauss. Return 10000');
		// Case #46: Number, String(2). Convert 1 from Kilometer to Meter. Return 1000
		oParser = new parserFormula('CONVERT(1, "km", "m")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "km", "m") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1000, 'Test: Positive case: Number, String(2). Convert 1 from Kilometer to Meter. Return 1000');
		// Case #47: Number, String(2). Convert 1,5 from Kilogram to Gram. Return 1500
		oParser = new parserFormula('CONVERT(1.5, "kg", "g")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1.5, "kg", "g") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1500, 'Test: Positive case: Number, String(2). Convert 1,5 from Kilogram to Gram. Return 1500');
		// Case #48: Number, String(2). Convert 1 from Gallon to Liter. Return 3.7854118
		oParser = new parserFormula('CONVERT(1, "gal", "l")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "gal", "l") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.785411784, 'Test: Positive case: Number, String(2). Convert 1 from Gallon to Liter. Return 3.7854118');
		// Case #49: Number, String(2). Convert 1 from Cup to Milliliter. Return 236.5882365
		oParser = new parserFormula('CONVERT(1, "cup", "ml")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "cup", "ml") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 236.5882365, 'Test: Positive case: Number, String(2). Convert 1 from Cup to Milliliter. Return 236.5882365');
		// Case #50: Reference link(3). Convert value 1 from unit "m" to "ft". Return 3.280839895
		oParser = new parserFormula('CONVERT(A100, A101, A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(A100, A101, A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.280839895, 'Test: Positive case: Reference link(3). Convert value 1 from unit "m" to "ft". Return 3.280839895');
		// Case #51: String(3). Convert string "10" from Meter to Kilometer. Return 0.01
		oParser = new parserFormula('CONVERT("10", "m", "km")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT("10", "m", "km") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.01, 'Test: Positive case: String(3). Convert string "10" from Meter to Kilometer. Return 0.01');
		// Case #52: Table(3). Convert table value 2 from "kg" to "lbm". Return 2.204622622
		oParser = new parserFormula('CONVERT(Table1[Column1], Table1[Column2], Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(Table1[Column1], Table1[Column2], Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 4.409245244, 'Test: Positive case: Table(3). Convert table value 2 from "kg" to "lbm". Return 2.204622622');
		// Case #53: Ref3D(3). Convert value 5 from "km" to "mi". Return 3.106855961
		oParser = new parserFormula('CONVERT(Sheet2!A1, Sheet2!A2, Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(Sheet2!A1, Sheet2!A2, Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.106855961, 'Test: Positive case: Ref3D(3). Convert value 5 from "km" to "mi". Return 3.106855961');
		// Case #54: Name(3). Convert value 10 from "L" to "gal". Return 2.641720524
		oParser = new parserFormula('CONVERT(TestName, TestName1, TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(TestName, TestName1, TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.641720524, 'Test: Positive case: Name(3). Convert value 10 from "L" to "gal". Return 2.641720524');
		// Case #55: Name3D(3). Convert value 1 from "ton" to "kg". Return 907.18474
		oParser = new parserFormula('CONVERT(TestName3D, TestName3D1, TestName3D2)', 'A2', ws);
		// Different result with MS
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(TestName3D, TestName3D1, TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(3), '907.185', 'Test: Positive case: Name3D(3). Convert value 1 from "ton" to "kg". Return 907.18474');
		// Case #56: Date, String(2). Convert date serial number 44927 from Day to Hour. Return 1078248
		oParser = new parserFormula('CONVERT(DATE(2023,1,1), "day", "hr")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(DATE(2023,1,1), "day", "hr") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1078248, 'Test: Positive case: Date, String(2). Convert date serial number 44927 from Day to Hour. Return 1078248');
		// Case #57: Time, String(2). Convert time serial number 0.041667 from Hour to Minute. Return 60
		oParser = new parserFormula('CONVERT(TIME(1,0,0), "hr", "min")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(TIME(1,0,0), "hr", "min") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(1) - 0, 2.5, 'Test: Positive case: Time, String(2). Convert time serial number 0.041667 from Hour to Minute. Return 60');
		// Case #58: Formula, String(2). Convert formula result 30 from Meter to Kilometer. Return 0.03
		oParser = new parserFormula('CONVERT(SUM(10,20), "m", "km")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(SUM(10,20), "m", "km") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(2) - 0, 0.03, 'Test: Positive case: Formula, String(2). Convert formula result 30 from Meter to Kilometer. Return 0.03');
		// Case #59: Formula. CONVERT as child formula inside SUM. Convert 10m and 20m to ft and sum results. Return 98.42519685
		oParser = new parserFormula('SUM(CONVERT(10, "m", "ft"), CONVERT(20, "m", "ft"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(CONVERT(10, "m", "ft"), CONVERT(20, "m", "ft")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 98.42519685, 'Test: Positive case: Formula. CONVERT as child formula inside SUM. Convert 10m and 20m to ft and sum results. Return 98.42519685');
		// Case #60: Number, Formula(2). Convert 10 from formula-generated unit "km" to "m". Return 10000
		oParser = new parserFormula('CONVERT(10, CONCATENATE("k","m"), CONCATENATE("m",""))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(10, CONCATENATE("k","m"), CONCATENATE("m","")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10000, 'Test: Positive case: Number, Formula(2). Convert 10 from formula-generated unit "km" to "m". Return 10000');
		// Case #61: Array(3). Convert array values {1, 2, 3} from units {"m", "km"} to {"ft", "cm"}. Return  3.280839895
		oParser = new parserFormula('CONVERT({1,2}, {"m","km"}, {"ft","cm"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT({1,2}, {"m","km"}, {"ft","cm"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 3.280839895, 'Test: Positive case: Array(3). Convert array values {1, 2, 3} from units {"m", "km"} to {"ft", "cm"}. Return  3.280839895');
		// Case #62: Number, String(2). Convert 1 from Stone to Kilogram. Return 6.35029
		// Different result with MS
		oParser = new parserFormula('CONVERT(1, "stone", "kg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "stone", "kg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(5) - 0, 6.35029, 'Test: Positive case: Number, String(2). Convert 1 from Stone to Kilogram. Return 6.35029');
		// Case #63: Number, String(2). Convert 1 from Grain to Gram. Return 0.06479891
		oParser = new parserFormula('CONVERT(1, "grain", "g")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "grain", "g") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(7) - 0, 0.0647989, 'Test: Positive case: Number, String(2). Convert 1 from Grain to Gram. Return 0.06479891');
		// Case #64: Number, String(2). Convert 1 from Atomic mass unit to Gram. Return 1.66053886E-24
		oParser = new parserFormula('CONVERT(1, "u", "g")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "u", "g") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6605401039531317e-24, 'Test: Positive case: Number, String(2). Convert 1 from Atomic mass unit to Gram. Return 1.66053886E-24');
		// Case #65: Number, String(2). Convert 100 from Cubic feet to Cubic meter. Return 2.8316846592
		oParser = new parserFormula('CONVERT(100, "ft3", "m3")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(100, "ft3", "m3") is parsed.');
		assert.strictEqual(oParser.calculate().getValue().toFixed(9) - 0, 2.831684659, 'Test: Positive case: Number, String(2). Convert 100 from Cubic feet to Cubic meter. Return 2.8316846592');

		// Negative cases:

		// Case #1: Number, String(2). Incorrect convert from Foot to Seconds. Return #N/A
		oParser = new parserFormula('CONVERT(2.5, "ft", "sec")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(2.5, "ft", "sec") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Incorrect convert from Foot to Seconds. Return #N/A');
		// Case #2: Number, String(2). Incorrect convert from klbm to milligramm. Return #N/A
		oParser = new parserFormula('CONVERT(1, "klbm", "mg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "klbm", "mg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Incorrect convert from klbm to milligramm. Return #N/A');
		// Case #3: Number, String(2). Incorrect convert incorrect input of units. Return #N/A
		oParser = new parserFormula('CONVERT(1,"m^1","cm^1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1,"m^1","cm^1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Incorrect convert incorrect input of units. Return #N/A');
		// Case #4: Area(3). Convert values  area link to 1, 2 from units "m\m2" to "ft\ft2". Return #VALUE!
		oParser = new parserFormula('CONVERT(A103:A104, A105:A106, A107:A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(A103:A104, A105:A106, A107:A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(3). Convert values  area link to 1, 2 from units "m\m2" to "ft\ft2". Return #VALUE!');
		// Case #5: Boolean, String(2). Convert Boolean TRUE  from Meter to Feet. Return #VALUE!
		oParser = new parserFormula('CONVERT(TRUE, "m", "ft")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(TRUE, "m", "ft") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, String(2). Convert Boolean TRUE  from Meter to Feet. Return #VALUE!');
		// Case #6: Area3D(3). Convert values area link from "ozm\grain" to "cwt/lcwt". Return #VALUE!
		oParser = new parserFormula('CONVERT(Sheet2!A4:A5, Sheet2!A6:A7, Sheet2!A8:A9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(Sheet2!A4:A5, Sheet2!A6:A7, Sheet2!A8:A9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(3). Convert values area link from "ozm\grain" to "cwt/lcwt". Return #VALUE!');
		// Case #7: Name(3). Convert named area values 1, 2 from "l" to "gal". Return #VALUE!
		oParser = new parserFormula('CONVERT(TestNameArea, TestName1, TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(TestNameArea, TestName1, TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name(3). Convert named area values 1, 2 from "l" to "gal". Return #VALUE!');
		// Case #8: Name3D(3). Convert 3D named area values 1, 2 from "ton" to "kg". Return #VALUE!
		oParser = new parserFormula('CONVERT(TestNameArea3D, TestName3D1, TestName3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(TestNameArea3D, TestName3D1, TestName3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name3D(3). Convert 3D named area values 1, 2 from "ton" to "kg". Return #VALUE!');
		// Case #9: Number, String(2). Error when converting between different groups (distance to mass). Return #N/A
		oParser = new parserFormula('CONVERT(1, "m", "kg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "m", "kg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when converting between different groups (distance to mass). Return #N/A');
		// Case #10: Number, String(2). Error when using invalid unit. Return #N/A
		oParser = new parserFormula('CONVERT(1, "invalid", "m")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "invalid", "m") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when using invalid unit. Return #N/A');
		// Case #11: Number, String(2). Error when using invalid target unit. Return #N/A
		oParser = new parserFormula('CONVERT(1, "m", "invalid")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "m", "invalid") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when using invalid target unit. Return #N/A');
		// Case #12: Number, String(2). Error when using non-numeric text as number. Return #VALUE!
		oParser = new parserFormula('CONVERT("text", "m", "ft")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT("text", "m", "ft") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String(2). Error when using non-numeric text as number. Return #VALUE!');
		// Case #13: Number, Number(2). Error when using numbers instead of strings for units. Return #N/A
		oParser = new parserFormula('CONVERT(1, 123, 456)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, 123, 456) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Number(2). Error when using numbers instead of strings for units. Return #N/A');
		// Case #14: Number, Boolean(2). Error when using boolean instead of string for units. Return #VALUE!
		oParser = new parserFormula('CONVERT(1, TRUE, FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, TRUE, FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean(2). Error when using boolean instead of string for units. Return #VALUE!');
		// Case #15: Number, Date(2). Error when using date instead of string for units. Return #N/A
		oParser = new parserFormula('CONVERT(1, DATE(2023,1,1), DATE(2023,1,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, DATE(2023,1,1), DATE(2023,1,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Date(2). Error when using date instead of string for units. Return #N/A');
		// Case #16: Number, Array(2). Error when using array instead of string for units. Return #N/A
		oParser = new parserFormula('CONVERT(1, {1,2}, {3,4})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, {1,2}, {3,4}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Array(2). Error when using array instead of string for units. Return #N/A');
		// Case #17: Number, String(2). Error when using case-sensitive units incorrectly. Return #N/A
		oParser = new parserFormula('CONVERT(1, "m", "M")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "m", "M") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when using case-sensitive units incorrectly. Return #N/A');
		// Case #18: Number, String(2). Error when converting between incompatible units (speed to mass). Return #N/A
		oParser = new parserFormula('CONVERT(1, "km/h", "kg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "km/h", "kg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when converting between incompatible units (speed to mass). Return #N/A');
		// Case #19: Number, String(2). Error when converting between incompatible units (distance to speed). Return #N/A
		oParser = new parserFormula('CONVERT(1, "km", "km/h")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "km", "km/h") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when converting between incompatible units (distance to speed). Return #N/A');
		// Case #20: Number, String(2). Error when using incorrect prefix notation. Return #N/A
		oParser = new parserFormula('CONVERT(1, "kilobit", "bit")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "kilobit", "bit") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when using incorrect prefix notation. Return #N/A');
		// Case #21: Number, String(2). Error when target unit is empty. Return #N/A
		oParser = new parserFormula('CONVERT(1, "km", "")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "km", "") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when target unit is empty. Return #N/A');
		// Case #22: Number, String(2). Error when source unit is empty. Return #N/A
		oParser = new parserFormula('CONVERT(1, "", "km")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "", "km") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when source unit is empty. Return #N/A');
		// Case #23: Formula, String(2). Error propagation from inner formula. Return #VALUE!
		oParser = new parserFormula('CONVERT(SUM("text",1), "m", "ft")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(SUM("text",1), "m", "ft") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula, String(2). Error propagation from inner formula. Return #VALUE!');
		// Case #24: Number, String(2). Error when using incorrect binary prefix. Return #N/A
		oParser = new parserFormula('CONVERT(1, "Kibyte", "byte")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "Kibyte", "byte") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when using incorrect binary prefix. Return #N/A');
		// Case #25: Number, String(2). Error when converting between incompatible units (information to mass). Return #N/A
		oParser = new parserFormula('CONVERT(1, "kibit", "g")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "kibit", "g") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when converting between incompatible units (information to mass). Return #N/A');
		// Case #26: Number, String(2). Error when using unsupported power. Return #N/A
		oParser = new parserFormula('CONVERT(1, "m^4", "cm^4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "m^4", "cm^4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when using unsupported power. Return #N/A');
		// Case #27: Number, String(2). Error when using unsupported complex units. Return #N/A
		oParser = new parserFormula('CONVERT(1, "ml/kg", "l/g")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "ml/kg", "l/g") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String(2). Error when using unsupported complex units. Return #N/A');
		// Case #28: Empty(2), String. Error when multiple arguments are missing. Return #N/A
		oParser = new parserFormula('CONVERT(,, "ft")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(,, "ft") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(2), String. Error when multiple arguments are missing. Return #N/A');
		// Case #29: Empty, String(2). Convert empty value. Return #VALUE!
		oParser = new parserFormula('CONVERT(, "m", "ft")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(, "m", "ft") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, String(2). Convert empty value. Return #VALUE!');
		// Case #30: Number, Empty,String. Convert with empty from_unit. Return #N/A
		oParser = new parserFormula('CONVERT(1, , "ft")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, , "ft") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Empty,String. Convert with empty from_unit. Return #N/A');
		// Case #31: Number, String, Empty. Convert with empty to_unit. Return #N/A
		oParser = new parserFormula('CONVERT(1, "m", )', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "m", ) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, String, Empty. Convert with empty to_unit. Return #N/A');
		// Case #32: Error, String(2). Error propagation. Return #DIV/0!
		oParser = new parserFormula('CONVERT(#DIV/0!, "m", "ft")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(#DIV/0!, "m", "ft") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Error, String(2). Error propagation. Return #DIV/0!');
		// Case #33: Number, Error, String. Error propagation in from_unit. Return #VALUE!
		oParser = new parserFormula('CONVERT(1, #VALUE!, "ft")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, #VALUE!, "ft") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Error, String. Error propagation in from_unit. Return #VALUE!');
		// Case #34: Number, String, Error. Error propagation in to_unit. Return #REF!
		oParser = new parserFormula('CONVERT(1, "m", #REF!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "m", #REF!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#REF!', 'Test: Negative case: Number, String, Error. Error propagation in to_unit. Return #REF!');

		// Bounded cases:

		// Case #1: Number, String(2). Convert maximum possible number from Meter to Kilometer. Return 1E+304
		oParser = new parserFormula('CONVERT(1E+307, "m", "km")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1E+307, "m", "km") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+304, 'Test: Bounded case: Number, String(2). Convert maximum possible number from Meter to Kilometer. Return 1E+304');
		// Case #2: Number, String(2). Convert minimum possible number from Kilometer to Meter. Return 1E-304
		oParser = new parserFormula('CONVERT(1E-307, "km", "m")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1E-307, "km", "m") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-304, 'Test: Bounded case: Number, String(2). Convert minimum possible number from Kilometer to Meter. Return 1E-304');
		// Case #3: Number, String(2). Convert with largest metric prefix (yotta) from Yottagram to Gram. Return 1E+24
		oParser = new parserFormula('CONVERT(1, "Yg", "g")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "Yg", "g") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+24, 'Test: Bounded case: Number, String(2). Convert with largest metric prefix (yotta) from Yottagram to Gram. Return 1E+24');
		// Case #4: Number, String(2). Convert with smallest metric prefix (yocto) from Gram to Yoctogram. Return 1E+24
		oParser = new parserFormula('CONVERT(1, "g", "yg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "g", "yg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0000000000000001e+24, 'Test: Bounded case: Number, String(2). Convert with smallest metric prefix (yocto) from Gram to Yoctogram. Return 1E+24');
		// Case #5: Number, String(2). Convert with largest binary prefix (yobi) from Yobibit to Bit. Return 1.20893E+24
		oParser = new parserFormula('CONVERT(1, "Yibit", "bit")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "Yibit", "bit") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.20892581961463e+24, 'Test: Bounded case: Number, String(2). Convert with largest binary prefix (yobi) from Yobibit to Bit. Return 1.20893E+24');
		// Case #6: Range, String(2). Convert entire columnfrom Meter to Feet. Return #VALUE!
		// Different result with MS
		oParser = new parserFormula('CONVERT(A:A, "m", "ft")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(A:A, "m", "ft") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Range, String(2). Convert entire columnfrom Meter to Feet. Return #VALUE!');
		// Case #7: Range, String(2). Convert entire row from Kilogram to Gram. Return #VALUE!
		// Different result with MS
		oParser = new parserFormula('CONVERT(100:100, "kg", "g")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(100:100, "kg", "g") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Range, String(2). Convert entire row from Kilogram to Gram. Return #VALUE!');
		// Case #8: Number, String(2). Convert very large number 9999999999 from Feet to Meter. Return 3048000000
		// Different result with MS
		oParser = new parserFormula('CONVERT(9999999999, "ft", "m")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(9999999999, "ft", "m") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 3048000000, 'Test: Bounded case: Number, String(2). Convert very large number 9999999999 from Feet to Meter. Return 3048000000');
		// Case #9: Number, String(2). Convert very small number 0.0000000001 from Ton to Milligram. Return 0.0907185
		// Different result with MS
		oParser = new parserFormula('CONVERT(0.0000000001, "ton", "mg")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(0.0000000001, "ton", "mg") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.09071849958859161, 'Test: Bounded case: Number, String(2). Convert very small number 0.0000000001 from Ton to Milligram. Return 0.0907185');
		// Case #10: Number, String(2). Convert 1 from Light-year to Meter (very large conversion). Return 9.46073E+15
		// Different result with MS
		oParser = new parserFormula('CONVERT(1, "ly", "m")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula CONVERT(1, "ly", "m") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 9460730000000000, 'Test: Bounded case: Number, String(2). Convert 1 from Light-year to Meter (very large conversion). Return 9.46073E+15');

        // Need to fix: boundary cases precision, results diff from MS
        // Case #5: Boolean, String(2). Convert Boolean TRUE  from Meter to Feet. Return #VALUE!
        // Case #14: Number, Boolean(2). Error when using boolean instead of string for units. Return #VALUE!
        // Case #29: Empty, String(2). Convert empty value. Return #VALUE!
        // Case #6: Range, String(2). Convert entire columnfrom Meter to Feet. Return #VALUE!
        // Case #7: Range, String(2). Convert entire row from Kilogram to Gram. Return #VALUE!
        // Case #8: Number, String(2). Convert very large number 9999999999 from Feet to Meter. Return 3048000000
        // Case #10: Number, String(2). Convert 1 from Light-year to Meter (very large conversion). Return 9.46073E+15


		testArrayFormula2(assert, "CONVERT", 3, 3, true);
	});


	QUnit.test("Test: \"DEC2BIN\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("9");
		ws.getRange2("A101").setValue("4");
		ws.getRange2("A102").setValue("10");
		ws.getRange2("A103").setValue("9");
		ws.getRange2("A104").setValue("8");
		ws.getRange2("A105").setValue("4");
		ws.getRange2("A106").setValue("");
		ws.getRange2("A107").setValue("text");
		ws.getRange2("A108").setValue("#N/A");
		ws.getRange2("A109").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("9"); // Column1
		ws.getRange2("B601").setValue("4"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("9");
		ws2.getRange2("A2").setValue("4");
		ws2.getRange2("A3").setValue("10");
		ws2.getRange2("A4").setValue("9");
		ws2.getRange2("A5").setValue("8");
		ws2.getRange2("A6").setValue("4");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("9"); // TestName
		ws.getRange2("A202").setValue("4"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("9") // TestName3D
		ws2.getRange2("A12").setValue("4") // TestName3D1

		// Positive cases:

		// Case #1: Number. Return 101010
		oParser = new parserFormula('DEC2BIN(42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '101010', 'Test: Positive case: Number. Return 101010');
		// Case #2: String. Return 101010
		oParser = new parserFormula('DEC2BIN("42")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN("42") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '101010', 'Test: Positive case: String. Return 101010');
		// Case #3: Number. Return 1000000000
		oParser = new parserFormula('DEC2BIN(-512)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(-512) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1000000000', 'Test: Positive case: Number. Return 1000000000');
		// Case #4: Number. Return 1000000001
		oParser = new parserFormula('DEC2BIN(-511)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(-511) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1000000001', 'Test: Positive case: Number. Return 1000000001');
		// Case #5: Number. Return 1111111111
		oParser = new parserFormula('DEC2BIN(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1111111111', 'Test: Positive case: Number. Return 1111111111');
		// Case #6: Number. Return 0
		oParser = new parserFormula('DEC2BIN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Number. Return 0');
		// Case #7: Number. Return 1
		oParser = new parserFormula('DEC2BIN(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Number. Return 1');
		// Case #8: Number. Return 111111110
		oParser = new parserFormula('DEC2BIN(510)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(510) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111111110', 'Test: Positive case: Number. Return 111111110');
		// Case #9: Number. Return 111111111
		oParser = new parserFormula('DEC2BIN(511)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(511) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111111111', 'Test: Positive case: Number. Return 111111111');
		// Case #10: Number(2). Return 101010
		oParser = new parserFormula('DEC2BIN(42, 6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(42, 6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '101010', 'Test: Positive case: Number(2). Return 101010');
		// Case #11: Number(2). Return 00101010
		oParser = new parserFormula('DEC2BIN(42, 8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(42, 8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00101010', 'Test: Positive case: Number(2). Return 00101010');
		// Case #12: Number. Convert decimal 10 to binary. Return 1010. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Number. Convert decimal 10 to binary. Return 1010. 1 of 2 arguments used.');
		// Case #13: Number(2). Convert decimal 10 to binary with 8 characters. Return 00001010. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(10,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(10,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00001010', 'Test: Positive case: Number(2). Convert decimal 10 to binary with 8 characters. Return 00001010. 2 of 2 arguments used.');
		// Case #14: Number(2). Convert decimal 255 to binary with 8 characters. Return 11111111. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(255,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(255,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11111111', 'Test: Positive case: Number(2). Convert decimal 255 to binary with 8 characters. Return 11111111. 2 of 2 arguments used.');
		// Case #15: Number(2). Convert negative decimal -1 to binary. Return 1111111111. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(-1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(-1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1111111111', 'Test: Positive case: Number(2). Convert negative decimal -1 to binary. Return 1111111111. 2 of 2 arguments used.');
		// Case #16: Number(2). Convert zero to binary with 5 characters. Return 00000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(0,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(0,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000', 'Test: Positive case: Number(2). Convert zero to binary with 5 characters. Return 00000. 2 of 2 arguments used.');
		// Case #17: String, Number. Numeric string converted to number. Return 011001. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN("25",6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN("25",6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '011001', 'Test: Positive case: String, Number. Numeric string converted to number. Return 011001. 2 of 2 arguments used.');
		// Case #18: String(2). Both arguments as numeric strings. Return 01100100. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN("100","8")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN("100","8") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '01100100', 'Test: Positive case: String(2). Both arguments as numeric strings. Return 01100100. 2 of 2 arguments used.');
		// Case #19: Number, String. Second argument as numeric string. Return 01111. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(15,"5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(15,"5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '01111', 'Test: Positive case: Number, String. Second argument as numeric string. Return 01111. 2 of 2 arguments used.');
		// Case #20: Number, Empty. Empty second argument converted to 0. Return #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(10,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(10,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1010', 'Test: Positive case: Number, Empty. Empty second argument converted to 0. Return #NUM!. 2 of 2 arguments used.');
		// Case #21: Number(2). Float number truncated to integer. Return 0111. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(7.9,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(7.9,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0111', 'Test: Positive case: Number(2). Float number truncated to integer. Return 0111. 2 of 2 arguments used.');
		// Case #22: Number(2). Places as float truncated to integer. Return 1111. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(15,4.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(15,4.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1111', 'Test: Positive case: Number(2). Places as float truncated to integer. Return 1111. 2 of 2 arguments used.');
		// Case #23: Number(2). Both arguments as float truncated. Return 01000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(8.5,5.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(8.5,5.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '01000', 'Test: Positive case: Number(2). Both arguments as float truncated. Return 01000. 2 of 2 arguments used.');
		// Case #24: Reference link(2). Both arguments as reference links. Return 01100100. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1001', 'Test: Positive case: Reference link(2). Both arguments as reference links. Return 01100100. 2 of 2 arguments used.');
		// Case #25: Name(2). Both arguments as named ranges. Return 01100100. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1001', 'Test: Positive case: Name(2). Both arguments as named ranges. Return 01100100. 2 of 2 arguments used.');
		// Case #26: Name3D(2). Both arguments as 3D named ranges. Return 01100100. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1001', 'Test: Positive case: Name3D(2). Both arguments as 3D named ranges. Return 01100100. 2 of 2 arguments used.');
		// Case #27: Ref3D(2). Both arguments as 3D references. Return 01100100. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1001', 'Test: Positive case: Ref3D(2). Both arguments as 3D references. Return 01100100. 2 of 2 arguments used.');
		// Case #28: Table(2). Both arguments as table references. Return 01100100. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1001', 'Test: Positive case: Table(2). Both arguments as table references. Return 01100100. 2 of 2 arguments used.');
		// Case #29: Formula, Number. Nested mathematical formula. Return 00110010. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(ABS(-50),8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(ABS(-50),8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00110010', 'Test: Positive case: Formula, Number. Nested mathematical formula. Return 00110010. 2 of 2 arguments used.');
		// Case #30: Formula, Formula. Both arguments with nested formulas. Return 0011001. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(INT(25.9),ROUND(7.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(INT(25.9),ROUND(7.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0011001', 'Test: Positive case: Formula, Formula. Both arguments with nested formulas. Return 0011001. 2 of 2 arguments used.');
		// Case #31: Formula. DEC2BIN as part of parent formula. Return 1110. 2 of 2 arguments used.
		oParser = new parserFormula('SUM(DEC2BIN(10,5),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DEC2BIN(10,5),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1110, 'Test: Positive case: Formula. DEC2BIN as part of parent formula. Return 1110. 2 of 2 arguments used.');
		// Case #32: Formula, Number. Date formula converted to number. Return 00001010. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(DATE(1900,1,10),8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(DATE(1900,1,10),8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00001010', 'Test: Positive case: Formula, Number. Date formula converted to number. Return 00001010. 2 of 2 arguments used.');
		// Case #33: Reference link. Reference to empty cell converted to 0. Return 0. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Reference link. Reference to empty cell converted to 0. Return 0. 1 of 2 arguments used.');

		// Negative cases:

		// Case #1: String. Return #VALUE!
		oParser = new parserFormula('DEC2BIN("Hello World!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN("Hello World!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Return #VALUE!');
		// Case #2: String. Return #VALUE!
		oParser = new parserFormula('DEC2BIN("2a")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN("2a") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Return #VALUE!');
		// Case #3: Number. Return #NUM!
		oParser = new parserFormula('DEC2BIN(-513)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(-513) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Return #NUM!');
		// Case #4: Number. Return #NUM!
		oParser = new parserFormula('DEC2BIN(512)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(512) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Return #NUM!');
		// Case #5: Number(2). Return #NUM!
		oParser = new parserFormula('DEC2BIN(42, -8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(42, -8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Return #NUM!');
		// Case #6: Number(2). Number exceeds maximum 511. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(512,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(512,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number exceeds maximum 511. 2 of 2 arguments used.');
		// Case #7: Number(2). Number below minimum -512. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(-513,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(-513,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number below minimum -512. 2 of 2 arguments used.');
		// Case #8: Number(2). Number far exceeds maximum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(1000,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(1000,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number far exceeds maximum. 2 of 2 arguments used.');
		// Case #9: Number(2). Number far below minimum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(-1000,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(-1000,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number far below minimum. 2 of 2 arguments used.');
		// Case #10: String, Number. Non-numeric string in first argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN("abc",5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN("abc",5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string in first argument. 2 of 2 arguments used.');
		// Case #11: Number, String. Non-numeric string in second argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(10,"xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(10,"xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string in second argument. 2 of 2 arguments used.');
		// Case #12: String(2). Both arguments as non-numeric strings. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN("10s","8t")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN("10s","8t") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Both arguments as non-numeric strings. 2 of 2 arguments used.');
		// Case #13: Number(2). Places is zero. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places is zero. 2 of 2 arguments used.');
		// Case #14: Number(2). Places is negative. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(10,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(10,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places is negative. 2 of 2 arguments used.');
		// Case #15: Number(2). Requires more than places characters. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(255,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(255,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires more than places characters. 2 of 2 arguments used.');
		// Case #16: Number(2). Requires 10 characters but places is 8. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(511,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(511,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 10 characters but places is 8. 2 of 2 arguments used.');
		// Case #17: Number(2). Requires 8 characters but places is 7. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(128,7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(128,7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 8 characters but places is 7. 2 of 2 arguments used.');
		// Case #18: Error, Number. Error in first argument propagates. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(#N/A,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(#N/A,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error in first argument propagates. 2 of 2 arguments used.');
		// Case #19: Number, Error. Error in second argument propagates. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(10,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(10,#N/A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error in second argument propagates. 2 of 2 arguments used.');
		// Case #20: Error(2). Both arguments are errors. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(#NUM!,#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(#NUM!,#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error(2). Both arguments are errors. 2 of 2 arguments used.');
		// Case #21: Reference link, Number. Reference to cell with text. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(A107,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(A107,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to cell with text. 2 of 2 arguments used.');
		// Case #22: Number, Reference link. Second argument references cell with text. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(10,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(10,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Second argument references cell with text. 2 of 2 arguments used.');
		// Case #23: Reference link(2). Both arguments reference cells with errors. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(A108,A109) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link(2). Both arguments reference cells with errors. 2 of 2 arguments used.');
		// Case #24: Boolean, Number. Places is negative with boolean first argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(FALSE,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(FALSE,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number. Places is negative with boolean first argument. 2 of 2 arguments used.');
		// Case #25: Number(2). Places truncated to 0 causes error. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(100,0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(100,0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places truncated to 0 causes error. 2 of 2 arguments used.');
		// Case #26: Number(2). Places exceeds maximum 10. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(15,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(15,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places exceeds maximum 10. 2 of 2 arguments used.');
		// Case #27: Number(2). Places far exceeds maximum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(15,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(15,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places far exceeds maximum. 2 of 2 arguments used.');
		// Case #28: String, String. Empty string in first argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN("","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN("","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. Empty string in first argument. 2 of 2 arguments used.');
		// Case #29: Number(2). Requires 7 characters but places is 6. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(64,6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(64,6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 7 characters but places is 6. 2 of 2 arguments used.');
		// Case #30: Number(2). Requires 6 characters but places is 5. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(32,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(32,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 6 characters but places is 5. 2 of 2 arguments used.');
		// Case #31: Boolean, Number. Boolean TRUE converted to 1. Return 00001. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(TRUE,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(TRUE,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean TRUE converted to 1. Return 00001. 2 of 2 arguments used.');
		// Case #32: Boolean, Number. Boolean FALSE converted to 0. Return 00000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(FALSE,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(FALSE,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE converted to 0. Return 00000. 2 of 2 arguments used.');
		// Case #33: Number, Boolean. Second argument boolean TRUE converted to 1. Return 111. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(7,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(7,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Second argument boolean TRUE converted to 1. Return 111. 2 of 2 arguments used.');
		// Case #34: Boolean(2). Both arguments as boolean. Return 1. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(TRUE,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Both arguments as boolean. Return 1. 2 of 2 arguments used.');
		// Case #35: Empty, Number. Empty first argument converted to 0. Return 00000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. Empty first argument converted to 0. Return 00000. 2 of 2 arguments used.');
		// Case #36: Empty(2). Both arguments empty converted to 0. Return #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(2). Both arguments empty converted to 0. Return #NUM!. 2 of 2 arguments used.');
		// Case #37: Area(2). Both arguments as multi-cell ranges. Return 01100100. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2). Both arguments as multi-cell ranges. Return 01100100. 2 of 2 arguments used.');
		// Case #38: Area3D(2). Both arguments as 3D multi-cell ranges. Return 01100100. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(Sheet2!A3:A4,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(Sheet2!A3:A4,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(2). Both arguments as 3D multi-cell ranges. Return 01100100. 2 of 2 arguments used.');

		// Bounded cases:

		// Case #1: Number(2). Maximum positive number with maximum places. Return 0111111111. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(511,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(511,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0111111111', 'Test: Bounded case: Number(2). Maximum positive number with maximum places. Return 0111111111. 2 of 2 arguments used.');
		// Case #2: Number(2). Minimum negative number with maximum places. Return 1000000000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(-512,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(-512,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1000000000', 'Test: Bounded case: Number(2). Minimum negative number with maximum places. Return 1000000000. 2 of 2 arguments used.');
		// Case #3: Number(2). Minimum positive number with minimum places. Return 1. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number(2). Minimum positive number with minimum places. Return 1. 2 of 2 arguments used.');
		// Case #4: Number(2). Zero with minimum places. Return 0. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number(2). Zero with minimum places. Return 0. 2 of 2 arguments used.');
		// Case #5: Area. Entire column reference. Return 1010. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(A:A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area. Entire column reference. Return 1010. 1 of 2 arguments used.');
		// Case #6: Area. Entire row reference. Return 1010. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2BIN(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2BIN(100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area. Entire row reference. Return 1010. 1 of 2 arguments used.');

        // Need to fix: results diff from MS, error types diff, empty handle, error handle
        // Case #20: Number, Empty. Empty second argument converted to 0. Return #NUM!. 2 of 2 arguments used.
        // Case #18: Error, Number. Error in first argument propagates. 2 of 2 arguments used.
        // Case #19: Number, Error. Error in second argument propagates. 2 of 2 arguments used.
        // Case #23: Reference link(2). Both arguments reference cells with errors. 2 of 2 arguments used.
        // Case #31: Boolean, Number. Boolean TRUE converted to 1. Return 00001. 2 of 2 arguments used.
        // Case #32: Boolean, Number. Boolean FALSE converted to 0. Return 00000. 2 of 2 arguments used.
        // Case #33: Number, Boolean. Second argument boolean TRUE converted to 1. Return 111. 2 of 2 arguments used.
        // Case #34: Boolean(2). Both arguments as boolean. Return 1. 2 of 2 arguments used.
        // Case #35: Empty, Number. Empty first argument converted to 0. Return 00000. 2 of 2 arguments used.
        // Case #36: Empty(2). Both arguments empty converted to 0. Return #NUM!. 2 of 2 arguments used.
        // Case #5: Area. Entire column reference. Return 1010. 1 of 2 arguments used.
        // Case #6: Area. Entire row reference. Return 1010. 1 of 2 arguments used.

		testArrayFormula2(assert, "DEC2BIN", 1, 2, true)
	});

	QUnit.test("Test: \"DEC2HEX\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("9");
		ws.getRange2("A101").setValue("4");
		ws.getRange2("A102").setValue("10");
		ws.getRange2("A103").setValue("9");
		ws.getRange2("A104").setValue("8");
		ws.getRange2("A105").setValue("4");
		ws.getRange2("A106").setValue("");
		ws.getRange2("A107").setValue("text");
		ws.getRange2("A108").setValue("#N/A");
		ws.getRange2("A109").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("9"); // Column1
		ws.getRange2("B601").setValue("4"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("9");
		ws2.getRange2("A2").setValue("4");
		ws2.getRange2("A3").setValue("10");
		ws2.getRange2("A4").setValue("9");
		ws2.getRange2("A5").setValue("8");
		ws2.getRange2("A6").setValue("4");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("9"); // TestName
		ws.getRange2("A202").setValue("4"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("9") // TestName3D
		ws2.getRange2("A12").setValue("4") // TestName3D1

		// Positive cases:

		// Case #1: Number. Return 2A
		oParser = new parserFormula('DEC2HEX(42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2A', 'Test: Positive case: Number. Return 2A');
		// Case #2: String. Return 2A
		oParser = new parserFormula('DEC2HEX("42")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX("42") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2A', 'Test: Positive case: String. Return 2A');
		// Case #3: Number. Return 8000000000
		oParser = new parserFormula('DEC2HEX(-549755813888)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(-549755813888) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '8000000000', 'Test: Positive case: Number. Return 8000000000');
		// Case #4: Number. Return 8000000001
		oParser = new parserFormula('DEC2HEX(-549755813887)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(-549755813887) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '8000000001', 'Test: Positive case: Number. Return 8000000001');
		// Case #5: Number. Return FFFFFFFFFF
		oParser = new parserFormula('DEC2HEX(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFFFF', 'Test: Positive case: Number. Return FFFFFFFFFF');
		// Case #6: Number. Return 0
		oParser = new parserFormula('DEC2HEX(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Number. Return 0');
		// Case #7: Number. Return 1
		oParser = new parserFormula('DEC2HEX(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Number. Return 1');
		// Case #8: Number. Return 7FFFFFFFFE
		oParser = new parserFormula('DEC2HEX(549755813886)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(549755813886) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7FFFFFFFFE', 'Test: Positive case: Number. Return 7FFFFFFFFE');
		// Case #9: Number. Return 7FFFFFFFFF
		oParser = new parserFormula('DEC2HEX(549755813887)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(549755813887) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7FFFFFFFFF', 'Test: Positive case: Number. Return 7FFFFFFFFF');
		// Case #10: Number(2). Return 2A
		oParser = new parserFormula('DEC2HEX(42, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(42, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2A', 'Test: Positive case: Number(2). Return 2A');
		// Case #11: Number(2). Return 002A
		oParser = new parserFormula('DEC2HEX(42, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(42, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '002A', 'Test: Positive case: Number(2). Return 002A');
		// Case #12: Number. Convert decimal 10 to hexadecimal. Return A. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'A', 'Test: Positive case: Number. Convert decimal 10 to hexadecimal. Return A. 1 of 2 arguments used.');
		// Case #13: Number(2). Convert decimal 10 to hex with 8 characters. Return 0000000A. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(10,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(10,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0000000A', 'Test: Positive case: Number(2). Convert decimal 10 to hex with 8 characters. Return 0000000A. 2 of 2 arguments used.');
		// Case #14: Number(2). Convert decimal 255 to hex with 4 characters. Return 00FF. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(255,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(255,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00FF', 'Test: Positive case: Number(2). Convert decimal 255 to hex with 4 characters. Return 00FF. 2 of 2 arguments used.');
		// Case #15: Number(2). Convert negative decimal -1 to hex. Return FFFFFFFFFF. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(-1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(-1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFFFFFFFFF', 'Test: Positive case: Number(2). Convert negative decimal -1 to hex. Return FFFFFFFFFF. 2 of 2 arguments used.');
		// Case #16: Number(2). Convert zero to hex with 5 characters. Return 00000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(0,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(0,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000', 'Test: Positive case: Number(2). Convert zero to hex with 5 characters. Return 00000. 2 of 2 arguments used.');
		// Case #17: String, Number. Numeric string converted to number. Return 0019. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX("25",4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX("25",4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0019', 'Test: Positive case: String, Number. Numeric string converted to number. Return 0019. 2 of 2 arguments used.');
		// Case #18: String(2). Both arguments as numeric strings. Return 0064. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX("100","4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX("100","4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0064', 'Test: Positive case: String(2). Both arguments as numeric strings. Return 0064. 2 of 2 arguments used.');
		// Case #19: Number, String. Second argument as numeric string. Return 000F. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(15,"4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(15,"4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000F', 'Test: Positive case: Number, String. Second argument as numeric string. Return 000F. 2 of 2 arguments used.');
		// Case #20: Number, Empty. Empty second argument converted to 0. Return #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(10,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(10,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 'A', 'Test: Positive case: Number, Empty. Empty second argument converted to 0. Return #NUM!. 2 of 2 arguments used.');
		// Case #21: Number(2). Float number truncated to integer. Return 0007. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(7.9,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(7.9,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0007', 'Test: Positive case: Number(2). Float number truncated to integer. Return 0007. 2 of 2 arguments used.');
		// Case #22: Number(2). Places as float truncated to integer. Return 000F. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(15,4.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(15,4.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000F', 'Test: Positive case: Number(2). Places as float truncated to integer. Return 000F. 2 of 2 arguments used.');
		// Case #23: Number(2). Both arguments as float truncated. Return 00008. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(8.5,5.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(8.5,5.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00008', 'Test: Positive case: Number(2). Both arguments as float truncated. Return 00008. 2 of 2 arguments used.');
		// Case #24: Reference link(2). Both arguments as reference links. Return 0064. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0009', 'Test: Positive case: Reference link(2). Both arguments as reference links. Return 0064. 2 of 2 arguments used.');
		// Case #25: Name(2). Both arguments as named ranges. Return 0064. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0009', 'Test: Positive case: Name(2). Both arguments as named ranges. Return 0064. 2 of 2 arguments used.');
		// Case #26: Name3D(2). Both arguments as 3D named ranges. Return 0064. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0009', 'Test: Positive case: Name3D(2). Both arguments as 3D named ranges. Return 0064. 2 of 2 arguments used.');
		// Case #27: Ref3D(2). Both arguments as 3D references. Return 0064. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0009', 'Test: Positive case: Ref3D(2). Both arguments as 3D references. Return 0064. 2 of 2 arguments used.');
		// Case #28: Table(2). Both arguments as table references. Return 0064. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0009', 'Test: Positive case: Table(2). Both arguments as table references. Return 0064. 2 of 2 arguments used.');
		// Case #29: Formula, Number. Nested mathematical formula. Return 0064. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(ABS(-100),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(ABS(-100),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0064', 'Test: Positive case: Formula, Number. Nested mathematical formula. Return 0064. 2 of 2 arguments used.');
		// Case #30: Formula, Formula. Both arguments with nested formulas. Return 00000FF. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(INT(255.9),ROUND(7.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(INT(255.9),ROUND(7.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000FF', 'Test: Positive case: Formula, Formula. Both arguments with nested formulas. Return 00000FF. 2 of 2 arguments used.');
		// Case #31: Formula, Number. Date formula converted to number. Return 000A. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(DATE(1900,1,10),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(DATE(1900,1,10),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000A', 'Test: Positive case: Formula, Number. Date formula converted to number. Return 000A. 2 of 2 arguments used.');
		// Case #32: Reference link. Reference to empty cell converted to 0. Return 0. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Reference link. Reference to empty cell converted to 0. Return 0. 1 of 2 arguments used.');

		// Negative cases:

		// Case #1: Number(2). Number exceeds maximum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(549755813888,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(549755813888,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number exceeds maximum. 2 of 2 arguments used.');
		// Case #2: Number(2). Number below minimum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(-549755813889,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(-549755813889,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number below minimum. 2 of 2 arguments used.');
		// Case #3: Number(2). Number far exceeds maximum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(1000000000000,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(1000000000000,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number far exceeds maximum. 2 of 2 arguments used.');
		// Case #4: Number(2). Number far below minimum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(-1000000000000,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(-1000000000000,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number far below minimum. 2 of 2 arguments used.');
		// Case #5: String, Number. Non-numeric string in first argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX("abc",5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX("abc",5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string in first argument. 2 of 2 arguments used.');
		// Case #6: Number, String. Non-numeric string in second argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(10,"xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(10,"xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string in second argument. 2 of 2 arguments used.');
		// Case #7: String(2). Both arguments as non-numeric strings. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX("10s","8t")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX("10s","8t") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Both arguments as non-numeric strings. 2 of 2 arguments used.');
		// Case #8: Number(2). Places is zero. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places is zero. 2 of 2 arguments used.');
		// Case #9: Number(2). Places is negative. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(10,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(10,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places is negative. 2 of 2 arguments used.');
		// Case #10: Number(2). Requires more than places characters. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(4095,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(4095,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires more than places characters. 2 of 2 arguments used.');
		// Case #11: Number(2). Requires 6 characters but places is 5. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(1048575,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(1048575,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 6 characters but places is 5. 2 of 2 arguments used.');
		// Case #12: Number(2). Requires 5 characters but places is 4. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(65536,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(65536,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 5 characters but places is 4. 2 of 2 arguments used.');
		// Case #13: Error, Number. Error in first argument propagates. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(#N/A,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(#N/A,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error in first argument propagates. 2 of 2 arguments used.');
		// Case #14: Number, Error. Error in second argument propagates. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(10,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(10,#N/A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error in second argument propagates. 2 of 2 arguments used.');
		// Case #15: Error(2). Both arguments are errors. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(#NUM!,#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(#NUM!,#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error(2). Both arguments are errors. 2 of 2 arguments used.');
		// Case #16: Reference link, Number. Reference to cell with text. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(A107,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(A107,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to cell with text. 2 of 2 arguments used.');
		// Case #17: Number, Reference link. Second argument references cell with text. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(10,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(10,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Second argument references cell with text. 2 of 2 arguments used.');
		// Case #18: Reference link(2). Both arguments reference cells with errors. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(A108,A109) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link(2). Both arguments reference cells with errors. 2 of 2 arguments used.');
		// Case #19: Boolean, Number. Places is negative with boolean first argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(FALSE,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(FALSE,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number. Places is negative with boolean first argument. 2 of 2 arguments used.');
		// Case #20: Number(2). Places truncated to 0 causes error. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(100,0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(100,0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places truncated to 0 causes error. 2 of 2 arguments used.');
		// Case #21: Number(2). Places exceeds maximum 10. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(15,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(15,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places exceeds maximum 10. 2 of 2 arguments used.');
		// Case #22: Number(2). Places far exceeds maximum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(15,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(15,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places far exceeds maximum. 2 of 2 arguments used.');
		// Case #23: String, String. Empty string in first argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX("","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX("","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. Empty string in first argument. 2 of 2 arguments used.');
		// Case #24: Number(2). Requires 3 characters but places is 2. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(256,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(256,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 3 characters but places is 2. 2 of 2 arguments used.');
		// Case #25: Number(2). Requires 4 characters but places is 3. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(4096,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(4096,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 4 characters but places is 3. 2 of 2 arguments used.');
		// Case #26: String. Return #VALUE!
		oParser = new parserFormula('DEC2HEX("Hello World!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX("Hello World!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Return #VALUE!');
		// Case #27: String. Return #VALUE!
		oParser = new parserFormula('DEC2HEX("2a")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX("2a") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Return #VALUE!');
		// Case #28: Boolean, Number. Boolean TRUE converted to 1. Return 00001. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(TRUE,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(TRUE,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean TRUE converted to 1. Return 00001. 2 of 2 arguments used.');
		// Case #29: Boolean, Number. Boolean FALSE converted to 0. Return 00000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(FALSE,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(FALSE,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE converted to 0. Return 00000. 2 of 2 arguments used.');
		// Case #30: Number, Boolean. Second argument boolean TRUE converted to 1. Return 7. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(7,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(7,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Second argument boolean TRUE converted to 1. Return 7. 2 of 2 arguments used.');
		// Case #31: Boolean(2). Both arguments as boolean. Return 1. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(TRUE,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Both arguments as boolean. Return 1. 2 of 2 arguments used.');
		// Case #32: Empty, Number. Empty first argument converted to 0. Return 00000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. Empty first argument converted to 0. Return 00000. 2 of 2 arguments used.');
		// Case #33: Empty(2). Both arguments empty converted to 0. Return #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(2). Both arguments empty converted to 0. Return #NUM!. 2 of 2 arguments used.');
		// Case #34: Area(2). Both arguments as multi-cell ranges. Return 00FF. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2). Both arguments as multi-cell ranges. 2 of 2 arguments used.');
		// Case #35: Area3D(2). Both arguments as 3D multi-cell ranges. Return 03E8. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(Sheet2!A3:A4,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(Sheet2!A3:A4,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(2). Both arguments as 3D multi-cell ranges.. 2 of 2 arguments used.');
		// Case #36: Formula. DEC2HEX as part of parent formula. Return 100A. 2 of 2 arguments used.
		oParser = new parserFormula('SUM(DEC2HEX(10,5),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DEC2HEX(10,5),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula. DEC2HEX as part of parent formula. 2 of 2 arguments used.');

		// Bounded cases:

		// Case #1: Number(2). Maximum positive number with maximum places. Return 7FFFFFFFFF. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(549755813887,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(549755813887,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7FFFFFFFFF', 'Test: Bounded case: Number(2). Maximum positive number with maximum places. Return 7FFFFFFFFF. 2 of 2 arguments used.');
		// Case #2: Number(2). Minimum negative number with maximum places. Return 8000000000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(-549755813888,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(-549755813888,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '8000000000', 'Test: Bounded case: Number(2). Minimum negative number with maximum places. Return 8000000000. 2 of 2 arguments used.');
		// Case #3: Number(2). Minimum positive number with minimum places. Return 1. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number(2). Minimum positive number with minimum places. Return 1. 2 of 2 arguments used.');
		// Case #4: Number(2). Zero with minimum places. Return 0. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number(2). Zero with minimum places. Return 0. 2 of 2 arguments used.');
		// Case #5: Area. Entire column reference. Return A. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(A:A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area. Entire column reference. Return A. 1 of 2 arguments used.');
		// Case #6: Area. Entire row reference. Return A. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2HEX(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2HEX(100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area. Entire row reference. Return A. 1 of 2 arguments used.');

        // Need to fix: empty handle, error handle, error types diff, diff results from MS

		testArrayFormula2(assert, "DEC2HEX", 1, 2, true);
	});

	QUnit.test("Test: \"DEC2OCT\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("9");
		ws.getRange2("A101").setValue("4");
		ws.getRange2("A102").setValue("10");
		ws.getRange2("A103").setValue("9");
		ws.getRange2("A104").setValue("8");
		ws.getRange2("A105").setValue("4");
		ws.getRange2("A106").setValue("");
		ws.getRange2("A107").setValue("text");
		ws.getRange2("A108").setValue("#N/A");
		ws.getRange2("A109").setValue("#NULL!");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("9"); // Column1
		ws.getRange2("B601").setValue("4"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("9");
		ws2.getRange2("A2").setValue("4");
		ws2.getRange2("A3").setValue("10");
		ws2.getRange2("A4").setValue("9");
		ws2.getRange2("A5").setValue("8");
		ws2.getRange2("A6").setValue("4");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("9"); // TestName
		ws.getRange2("A202").setValue("4"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("9") // TestName3D
		ws2.getRange2("A12").setValue("4") // TestName3D1

		// Positive cases:

		// Case #1: Number. Return 52
		oParser = new parserFormula('DEC2OCT(42)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(42) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '52', 'Test: Positive case: Number. Return 52');
		// Case #2: String. Return 52
		oParser = new parserFormula('DEC2OCT("42")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT("42") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '52', 'Test: Positive case: String. Return 52');
		// Case #3: Number. Return 4000000000
		oParser = new parserFormula('DEC2OCT(-536870912)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(-536870912) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4000000000', 'Test: Positive case: Number. Return 4000000000');
		// Case #4: Number. Return 4000000001
		oParser = new parserFormula('DEC2OCT(-536870911)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(-536870911) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4000000001', 'Test: Positive case: Number. Return 4000000001');
		// Case #5: Number. Return 7777777777
		oParser = new parserFormula('DEC2OCT(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777777', 'Test: Positive case: Number. Return 7777777777');
		// Case #6: Number. Return 0
		oParser = new parserFormula('DEC2OCT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Number. Return 0');
		// Case #7: Number. Return 0
		oParser = new parserFormula('DEC2OCT(-0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(-0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Number. Return 0');
		// Case #8: Number. Return 1
		oParser = new parserFormula('DEC2OCT(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Number. Return 1');
		// Case #9: Number. Return 3777777776
		oParser = new parserFormula('DEC2OCT(536870910)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(536870910) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3777777776', 'Test: Positive case: Number. Return 3777777776');
		// Case #10: Number. Return 3777777777
		oParser = new parserFormula('DEC2OCT(536870911)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(536870911) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3777777777', 'Test: Positive case: Number. Return 3777777777');
		// Case #11: Number(2). Return 52
		oParser = new parserFormula('DEC2OCT(42, 2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(42, 2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '52', 'Test: Positive case: Number(2). Return 52');
		// Case #12: Number(2). Return 0052
		oParser = new parserFormula('DEC2OCT(42, 4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(42, 4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0052', 'Test: Positive case: Number(2). Return 0052');
		// Case #13: Number. Convert decimal 10 to octal. Return 12. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '12', 'Test: Positive case: Number. Convert decimal 10 to octal. Return 12. 1 of 2 arguments used.');
		// Case #14: Number(2). Convert decimal 10 to octal with 8 characters. Return 00000012. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(10,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(10,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000012', 'Test: Positive case: Number(2). Convert decimal 10 to octal with 8 characters. Return 00000012. 2 of 2 arguments used.');
		// Case #15: Number(2). Convert decimal 255 to octal with 4 characters. Return 0377. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(255,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(255,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0377', 'Test: Positive case: Number(2). Convert decimal 255 to octal with 4 characters. Return 0377. 2 of 2 arguments used.');
		// Case #16: Number(2). Convert negative decimal -1 to octal. Return 7777777777. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(-1,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(-1,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777777', 'Test: Positive case: Number(2). Convert negative decimal -1 to octal. Return 7777777777. 2 of 2 arguments used.');
		// Case #17: Number(2). Convert zero to octal with 5 characters. Return 00000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(0,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(0,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000', 'Test: Positive case: Number(2). Convert zero to octal with 5 characters. Return 00000. 2 of 2 arguments used.');
		// Case #18: String, Number. Numeric string converted to number. Return 0031. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT("25",4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT("25",4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0031', 'Test: Positive case: String, Number. Numeric string converted to number. Return 0031. 2 of 2 arguments used.');
		// Case #19: String(2). Both arguments as numeric strings. Return 0144. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT("100","4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT("100","4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0144', 'Test: Positive case: String(2). Both arguments as numeric strings. Return 0144. 2 of 2 arguments used.');
		// Case #20: Number, String. Second argument as numeric string. Return 0017. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(15,"4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(15,"4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0017', 'Test: Positive case: Number, String. Second argument as numeric string. Return 0017. 2 of 2 arguments used.');
		// Case #21: Number, Empty. Empty second argument converted to 0. Return #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(10,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(10,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '12', 'Test: Positive case: Number, Empty. Empty second argument converted to 0. Return #NUM!. 2 of 2 arguments used.');
		// Case #22: Number(2). Float number truncated to integer. Return 0007. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(7.9,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(7.9,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0007', 'Test: Positive case: Number(2). Float number truncated to integer. Return 0007. 2 of 2 arguments used.');
		// Case #23: Number(2). Places as float truncated to integer. Return 0017. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(15,4.8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(15,4.8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0017', 'Test: Positive case: Number(2). Places as float truncated to integer. Return 0017. 2 of 2 arguments used.');
		// Case #24: Number(2). Both arguments as float truncated. Return 00010. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(8.5,5.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(8.5,5.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00010', 'Test: Positive case: Number(2). Both arguments as float truncated. Return 00010. 2 of 2 arguments used.');
		// Case #25: Reference link(2). Both arguments as reference links. Return 0144. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0011', 'Test: Positive case: Reference link(2). Both arguments as reference links. Return 0144. 2 of 2 arguments used.');
		// Case #26: Name(2). Both arguments as named ranges. Return 0144. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0011', 'Test: Positive case: Name(2). Both arguments as named ranges. Return 0144. 2 of 2 arguments used.');
		// Case #27: Name3D(2). Both arguments as 3D named ranges. Return 0144. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0011', 'Test: Positive case: Name3D(2). Both arguments as 3D named ranges. Return 0144. 2 of 2 arguments used.');
		// Case #28: Ref3D(2). Both arguments as 3D references. Return 0144. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0011', 'Test: Positive case: Ref3D(2). Both arguments as 3D references. Return 0144. 2 of 2 arguments used.');
		// Case #29: Table(2). Both arguments as table references. Return 0144. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0011', 'Test: Positive case: Table(2). Both arguments as table references. Return 0144. 2 of 2 arguments used.');
		// Case #30: Formula, Number. Nested mathematical formula. Return 0144. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(ABS(-100),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(ABS(-100),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0144', 'Test: Positive case: Formula, Number. Nested mathematical formula. Return 0144. 2 of 2 arguments used.');
		// Case #31: Formula, Formula. Both arguments with nested formulas. Return 000000377. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(INT(255.9),ROUND(9.4,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(INT(255.9),ROUND(9.4,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000000377', 'Test: Positive case: Formula, Formula. Both arguments with nested formulas. Return 000000377. 2 of 2 arguments used.');
		// Case #32: Formula. DEC2OCT as part of parent formula. Return 112. 2 of 2 arguments used.
		oParser = new parserFormula('SUM(DEC2OCT(10,5),100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DEC2OCT(10,5),100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 112, 'Test: Positive case: Formula. DEC2OCT as part of parent formula. Return 112. 2 of 2 arguments used.');
		// Case #33: Formula, Number. Date formula converted to number. Return 0012. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(DATE(1900,1,10),4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(DATE(1900,1,10),4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0012', 'Test: Positive case: Formula, Number. Date formula converted to number. Return 0012. 2 of 2 arguments used.');
		// Case #34: Reference link. Reference to empty cell converted to 0. Return 0. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Reference link. Reference to empty cell converted to 0. Return 0. 1 of 2 arguments used.');

		// Negative cases:

		// Case #1: Number(2). Number exceeds maximum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(536870912,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(536870912,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number exceeds maximum. 2 of 2 arguments used.');
		// Case #2: Number(2). Number below minimum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(-536870913,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(-536870913,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number below minimum. 2 of 2 arguments used.');
		// Case #3: Number(2). Number far exceeds maximum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(1000000000,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(1000000000,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number far exceeds maximum. 2 of 2 arguments used.');
		// Case #4: Number(2). Number far below minimum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(-1000000000,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(-1000000000,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Number far below minimum. 2 of 2 arguments used.');
		// Case #5: String, Number. Non-numeric string in first argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT("abc",5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT("abc",5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Non-numeric string in first argument. 2 of 2 arguments used.');
		// Case #6: Number, String. Non-numeric string in second argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(10,"xyz")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(10,"xyz") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric string in second argument. 2 of 2 arguments used.');
		// Case #7: String(2). Both arguments as non-numeric strings. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT("10s","8t")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT("10s","8t") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Both arguments as non-numeric strings. 2 of 2 arguments used.');
		// Case #8: Number(2). Places is zero. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(10,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(10,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places is zero. 2 of 2 arguments used.');
		// Case #9: Number(2). Places is negative. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(10,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(10,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places is negative. 2 of 2 arguments used.');
		// Case #10: Number(2). Requires more than places characters. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(511,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(511,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires more than places characters. 2 of 2 arguments used.');
		// Case #11: Number(2). Requires 3 characters but places is 4. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(4095,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(4095,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 3 characters but places is 4. 2 of 2 arguments used.');
		// Case #12: Number(2). Requires 3 characters but places is 3. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(512,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(512,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 3 characters but places is 3. 2 of 2 arguments used.');
		// Case #13: Error, Number. Error in first argument propagates. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(#N/A,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(#N/A,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error in first argument propagates. 2 of 2 arguments used.');
		// Case #14: Number, Error. Error in second argument propagates. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(10,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(10,#N/A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Error in second argument propagates. 2 of 2 arguments used.');
		// Case #15: Error(2). Both arguments are errors. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(#NUM!,#VALUE!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(#NUM!,#VALUE!) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Error(2). Both arguments are errors. 2 of 2 arguments used.');
		// Case #16: Reference link, Number. Reference to cell with text. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(A107,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(A107,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Reference to cell with text. 2 of 2 arguments used.');
		// Case #17: Number, Reference link. Second argument references cell with text. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(10,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(10,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Second argument references cell with text. 2 of 2 arguments used.');
		// Case #18: Reference link(2). Both arguments reference cells with errors. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(A108,A109) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link(2). Both arguments reference cells with errors. 2 of 2 arguments used.');
		// Case #19: Boolean, Number. Places is negative with boolean first argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(FALSE,-2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(FALSE,-2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Boolean, Number. Places is negative with boolean first argument. 2 of 2 arguments used.');
		// Case #20: Number(2). Places truncated to 0 causes error. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(100,0.9)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(100,0.9) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places truncated to 0 causes error. 2 of 2 arguments used.');
		// Case #21: Number(2). Places exceeds maximum 10. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(15,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(15,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places exceeds maximum 10. 2 of 2 arguments used.');
		// Case #22: Number(2). Places far exceeds maximum. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(15,100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(15,100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Places far exceeds maximum. 2 of 2 arguments used.');
		// Case #23: String, String. Empty string in first argument. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT("","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT("","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. Empty string in first argument. 2 of 2 arguments used.');
		// Case #24: Number(2). Requires 3 characters but places is 2. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(64,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(64,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 3 characters but places is 2. 2 of 2 arguments used.');
		// Case #25: Number(2). Requires 5 characters but places is 4. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(1024,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(1024,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Requires 5 characters but places is 4. 2 of 2 arguments used.');
		// Case #26: Boolean, Number. Boolean TRUE converted to 1. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(TRUE,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(TRUE,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean TRUE converted to 1. 2 of 2 arguments used.');
		// Case #27: Boolean, Number. Boolean FALSE converted to 0. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(FALSE,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(FALSE,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE converted to 0. 2 of 2 arguments used.');
		// Case #28: Number, Boolean. Second argument boolean TRUE converted to 1. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(7,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(7,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Second argument boolean TRUE converted to 1. 2 of 2 arguments used.');
		// Case #29: Boolean(2). Both arguments as boolean. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(TRUE,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Both arguments as boolean. 2 of 2 arguments used.');
		// Case #30: Empty, Number. Empty first argument converted to 0. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(,5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty, Number. Empty first argument converted to 0. 2 of 2 arguments used.');
		// Case #31: String. Return #VALUE!
		oParser = new parserFormula('DEC2OCT("Hello World!")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT("Hello World!") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Return #VALUE!');
		// Case #32: String. Return #VALUE!
		oParser = new parserFormula('DEC2OCT("2a")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT("2a") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Return #VALUE!');
		// Case #33: Number. Return #NUM!
		oParser = new parserFormula('DEC2OCT(-536870913)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(-536870913) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Return #NUM!');
		// Case #34: Number. Return #NUM!
		oParser = new parserFormula('DEC2OCT(536870912)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(536870912) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Return #NUM!');
		// Case #35: Number(2). Return #NUM!
		oParser = new parserFormula('DEC2OCT(42, 1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(42, 1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number(2). Return #NUM!');
		// Case #36: Empty(2). Both arguments empty converted to 0. Return #NUM!. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(2). Both arguments empty converted to 0. Return #NUM!. 2 of 2 arguments used.');
		// Case #37: Area(2). Both arguments as multi-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2). Both arguments as multi-cell ranges. 2 of 2 arguments used.');
		// Case #38: Area3D(2). Both arguments as 3D multi-cell ranges. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(Sheet2!A3:A4,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(Sheet2!A3:A4,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(2). Both arguments as 3D multi-cell ranges. 2 of 2 arguments used.');

		// Bounded cases:

		// Case #1: Number(2). Maximum positive number with maximum places. Return 3777777777. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(536870911,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(536870911,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3777777777', 'Test: Bounded case: Number(2). Maximum positive number with maximum places. Return 3777777777. 2 of 2 arguments used.');
		// Case #2: Number(2). Minimum negative number with maximum places. Return 4000000000. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(-536870912,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(-536870912,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4000000000', 'Test: Bounded case: Number(2). Minimum negative number with maximum places. Return 4000000000. 2 of 2 arguments used.');
		// Case #3: Number(2). Minimum positive number with minimum places. Return 1. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number(2). Minimum positive number with minimum places. Return 1. 2 of 2 arguments used.');
		// Case #4: Number(2). Zero with minimum places. Return 0. 2 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number(2). Zero with minimum places. Return 0. 2 of 2 arguments used.');
		// Case #5: Area. Entire column reference. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(A:A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(A:A) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area. Entire column reference. 1 of 2 arguments used.');
		// Case #6: Area. Entire row reference. 1 of 2 arguments used.
		oParser = new parserFormula('DEC2OCT(100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DEC2OCT(100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area. Entire row reference. 1 of 2 arguments used.');

        // Need to fix: empty handle, error handle, error types diff, results diff from MS

		testArrayFormula2(assert, "DEC2OCT", 1, 2, true);
	});

	QUnit.test("Test: \"DELTA\"", function (assert) {
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("5");
		ws.getRange2("A101").setValue("4");
		ws.getRange2("A102").setValue("5");
		ws.getRange2("A103").setValue("5");
		ws.getRange2("A104").setValue("4");
		ws.getRange2("A105").setValue("5");
		ws.getRange2("A106").setValue("text");
		ws.getRange2("A107").setValue("#NULL!");
		ws.getRange2("A108").setValue("");
		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("5"); // Column1
		ws.getRange2("B601").setValue("4"); // Column2
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("5");
		ws2.getRange2("A2").setValue("4");
		ws2.getRange2("A3").setValue("5");
		ws2.getRange2("A4").setValue("5");
		ws2.getRange2("A5").setValue("4");
		ws2.getRange2("A6").setValue("5");
		// DefNames. Use A201-A208, B208
		ws.getRange2("A201").setValue("5"); // TestName
		ws.getRange2("A202").setValue("4"); // TestName1
		// DefNames 3D. Use A11-A18, B18
		ws2.getRange2("A11").setValue("5") // TestName3D
		ws2.getRange2("A12").setValue("4") // TestName3D1

		// Positive cases:

		// Case #1: Number(2). Return 1
		oParser = new parserFormula('DELTA(10.5,10.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(10.5,10.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Return 1');
		// Case #2: Number(2). Return 0
		oParser = new parserFormula('DELTA(10.5,10.6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(10.5,10.6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Return 0');
		// Case #3: Number. Return 0
		oParser = new parserFormula('DELTA(10.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(10.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Return 0');
		// Case #4: Number. Return 1
		oParser = new parserFormula('DELTA(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Return 1');
		// Case #5: Number(2). Basic integer comparison, not equal. Returns 0
		oParser = new parserFormula('DELTA(5,4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5,4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Basic integer comparison, not equal. Returns 0');
		// Case #6: Number(2). Basic integer comparison, equal. Returns 1
		oParser = new parserFormula('DELTA(5,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Basic integer comparison, equal. Returns 1');
		// Case #7: Number(2). Float and integer comparison, not equal. Returns 0
		oParser = new parserFormula('DELTA(0.5,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(0.5,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Float and integer comparison, not equal. Returns 0');
		// Case #8: Number, Empty. Second argument omitted, defaults to 0. Returns 0
		oParser = new parserFormula('DELTA(5,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number, Empty. Second argument omitted, defaults to 0. Returns 0');
		// Case #9: Number, Empty. First argument 0, second omitted. Returns 1
		oParser = new parserFormula('DELTA(0,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(0,) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Empty. First argument 0, second omitted. Returns 1');
		// Case #10: Number(2). Equal float numbers. Returns 1
		oParser = new parserFormula('DELTA(1.5,1.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(1.5,1.5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Equal float numbers. Returns 1');
		// Case #11: Number(2). Equal negative numbers. Returns 1
		oParser = new parserFormula('DELTA(-5,-5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(-5,-5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Equal negative numbers. Returns 1');
		// Case #12: Number(2). Negative and positive, not equal. Returns 0
		oParser = new parserFormula('DELTA(-5,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(-5,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Negative and positive, not equal. Returns 0');
		// Case #13: String(2). String numbers converted to numbers, equal. Returns 1
		oParser = new parserFormula('DELTA("5","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("5","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String(2). String numbers converted to numbers, equal. Returns 1');
		// Case #14: String, Number. String converted to number, equal. Returns 1
		oParser = new parserFormula('DELTA("5",5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("5",5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String, Number. String converted to number, equal. Returns 1');
		// Case #15: Number, String. Number and string number, equal. Returns 1
		oParser = new parserFormula('DELTA(5,"5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5,"5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, String. Number and string number, equal. Returns 1');
		// Case #16: Reference link(2). Both arguments as ref links to 5 and 5. Returns 1
		oParser = new parserFormula('DELTA(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link(2). Both arguments as ref links to 5 and 5. Returns 1');
		// Case #17: Formula(2). Both formulas round to 5, equal. Returns 1
		oParser = new parserFormula('DELTA(ROUND(5.4,0),ROUND(5.6,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(ROUND(5.4,0),ROUND(5.6,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula(2). Both formulas round to 5, equal. Returns 1');
		// Case #18: Formula(2). Both formulas result in 5, equal. Returns 1
		oParser = new parserFormula('DELTA(ABS(-5),ABS(5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(ABS(-5),ABS(5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2). Both formulas result in 5, equal. Returns 1');
		// Case #19: Formula. DELTA as part of SUM formula. Returns 2
		oParser = new parserFormula('SUM(DELTA(5,5),DELTA(4,4),DELTA(3,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula SUM(DELTA(5,5),DELTA(4,4),DELTA(3,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. DELTA as part of SUM formula. Returns 2');
		// Case #20: Formula(2). Equal dates as serial numbers. Returns 1
		oParser = new parserFormula('DELTA(DATE(2025,1,1),DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(DATE(2025,1,1),DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2). Equal dates as serial numbers. Returns 1');
		// Case #21: Formula(2). Equal time values. Returns 1
		oParser = new parserFormula('DELTA(TIME(12,0,0),TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(TIME(12,0,0),TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula(2). Equal time values. Returns 1');
		// Case #22: Name(2). Both named ranges to 5 and 5. Returns 1
		oParser = new parserFormula('DELTA(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name(2). Both named ranges to 5 and 5. Returns 1');
		// Case #23: Name3D(2). Both 3D named ranges to 5 and 5. Returns 1
		oParser = new parserFormula('DELTA(TestName3D,TestName3D1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(TestName3D,TestName3D1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D(2). Both 3D named ranges to 5 and 5. Returns 1');
		// Case #24: Ref3D(2). Both 3D refs to 5 and 5. Returns 1
		oParser = new parserFormula('DELTA(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D(2). Both 3D refs to 5 and 5. Returns 1');
		// Case #25: Table(2). Table references to 5 and 5. Returns 1
		oParser = new parserFormula('DELTA(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table(2). Table references to 5 and 5. Returns 1');
		// Case #26: Number(2). Float 5.0 equals integer 5. Returns 1
		oParser = new parserFormula('DELTA(5.0,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5.0,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Float 5.0 equals integer 5. Returns 1');
		// Case #27: Number(2). Both arguments zero. Returns 1
		oParser = new parserFormula('DELTA(0,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(0,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Both arguments zero. Returns 1');
		// Case #28: Number(2). Values very close, testing precision. Returns 1
		oParser = new parserFormula('DELTA(1.0000000000000001,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(1.0000000000000001,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number(2). Values very close, testing precision. Returns 1');
		// Case #29: Number(2). Slightly different values within precision. Returns 0
		oParser = new parserFormula('DELTA(1.00000000000001,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(1.00000000000001,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number(2). Slightly different values within precision. Returns 0');
		// Case #30: String(2). String numbers with different formats. Returns 1
		oParser = new parserFormula('DELTA("5.0","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("5.0","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String(2). String numbers with different formats. Returns 1');
		// Case #31: Reference link(2). Both refs to same empty cell. Returns 1
		oParser = new parserFormula('DELTA(A108,A108)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(A108,A108) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link(2). Both refs to same empty cell. Returns 1');

		// Negative cases:

		// Case #1: String, Number. First argument non-numeric string. Returns #VALUE!
		oParser = new parserFormula('DELTA("text",5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("text",5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. First argument non-numeric string. Returns #VALUE!');
		// Case #2: Number, String. Second argument non-numeric string. Returns #VALUE!
		oParser = new parserFormula('DELTA(5,"text")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5,"text") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Second argument non-numeric string. Returns #VALUE!');
		// Case #3: String(2). Both arguments non-numeric strings. Returns #VALUE!
		oParser = new parserFormula('DELTA("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("abc","def") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Both arguments non-numeric strings. Returns #VALUE!');
		// Case #4: Error, Number. First argument error. Returns #N/A
		oParser = new parserFormula('DELTA(#N/A,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(#N/A,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. First argument error. Returns #N/A');
		// Case #5: Number, Error. Second argument error. Returns #N/A
		oParser = new parserFormula('DELTA(5,#N/A)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5,#N/A) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Number, Error. Second argument error. Returns #N/A');
		// Case #6: Error(2). Both arguments errors, first error returned. Returns #VALUE!
		oParser = new parserFormula('DELTA(#VALUE!,#NUM!)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(#VALUE!,#NUM!) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Error(2). Both arguments errors, first error returned. Returns #VALUE!');
		// Case #7: Reference link, Number. Ref to cell with text. Returns #VALUE!
		oParser = new parserFormula('DELTA(A106,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(A106,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Reference link, Number. Ref to cell with text. Returns #VALUE!');
		// Case #8: Number, Reference link. Second ref to cell with text. Returns #VALUE!
		oParser = new parserFormula('DELTA(5,A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5,A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Reference link. Second ref to cell with text. Returns #VALUE!');
		// Case #9: Reference link, Number. Ref to cell with error. Returns #NULL!
		oParser = new parserFormula('DELTA(A107,5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(A107,5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Reference link, Number. Ref to cell with error. Returns #NULL!');
		// Case #10: Number, Reference link. Second ref to cell with error. Returns #NULL!
		oParser = new parserFormula('DELTA(5,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NULL!', 'Test: Negative case: Number, Reference link. Second ref to cell with error. Returns #NULL!');
		// Case #11: String(2). First string not convertible to number. Returns #VALUE!
		oParser = new parserFormula('DELTA("5a","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("5a","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). First string not convertible to number. Returns #VALUE!');
		// Case #12: String(2). Second string not convertible to number. Returns #VALUE!
		oParser = new parserFormula('DELTA("5","5b")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("5","5b") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Second string not convertible to number. Returns #VALUE!');
		// Case #13: Formula, Number. Formula resulting in #NUM! error. Returns #NUM!
		oParser = new parserFormula('DELTA(SQRT(-1),5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(SQRT(-1),5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in #NUM! error. Returns #NUM!');
		// Case #14: Number, Formula. Formula resulting in #DIV/0! error. Returns #DIV/0!
		oParser = new parserFormula('DELTA(5,1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(5,1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Number, Formula. Formula resulting in #DIV/0! error. Returns #DIV/0!');
		// Case #15: String(2). Empty string and number string. Returns #VALUE!
		oParser = new parserFormula('DELTA("","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Empty string and number string. Returns #VALUE!');
		// Case #16: String(2). Invalid numeric format. Returns #VALUE!
		oParser = new parserFormula('DELTA("5.5.5","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("5.5.5","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String(2). Invalid numeric format. Returns #VALUE!');
		// Case #17: String(2). Date string not equal to 5. Returns 0
		oParser = new parserFormula('DELTA("12/25","5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA("12/25","5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String(2). Date string not equal to 5. Returns 0');
		// Case #18: Boolean(2). Both TRUE.
		oParser = new parserFormula('DELTA(TRUE,TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(TRUE,TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Both TRUE.');
		// Case #19: Boolean(2). Both FALSE.
		oParser = new parserFormula('DELTA(FALSE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(FALSE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). Both FALSE.');
		// Case #20: Boolean(2). TRUE (1) and FALSE (0), not equal.
		oParser = new parserFormula('DELTA(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean(2). TRUE (1) and FALSE (0), not equal.');
		// Case #21: Boolean, Number. TRUE, equal to 1.
		oParser = new parserFormula('DELTA(TRUE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(TRUE,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. TRUE, equal to 1.');
		// Case #22: Number, Boolean. 0 equal to FALSE.
		oParser = new parserFormula('DELTA(0,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(0,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. 0 equal to FALSE.');
		// Case #23: Empty(2). Both arguments empty.
		oParser = new parserFormula('DELTA(,)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(,) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Empty(2). Both arguments empty.');
		// Case #24: Area3D(2). Both 3D multiple-cell
		oParser = new parserFormula('DELTA(Sheet2!A3:A4,Sheet2!A5:A6)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(Sheet2!A3:A4,Sheet2!A5:A6) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D(2). Both 3D multiple-cell');
		// Case #25: Area(2). Multi-cell ranges to 5 and 5.
		oParser = new parserFormula('DELTA(A102:A103,A104:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(A102:A103,A104:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area(2). Multi-cell ranges to 5 and 5.');

		// Bounded cases:

		// Case #1: Number(2). Maximum Excel numbers, equal. Returns 1
		oParser = new parserFormula('DELTA(1E+307,1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(1E+307,1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Maximum Excel numbers, equal. Returns 1');
		// Case #2: Number(2). Minimum Excel numbers, equal. Returns 1
		oParser = new parserFormula('DELTA(-1E+307,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(-1E+307,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Minimum Excel numbers, equal. Returns 1');
		// Case #3: Number(2). Maximum and minimum numbers, not equal. Returns 0
		oParser = new parserFormula('DELTA(1E+307,-1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(1E+307,-1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number(2). Maximum and minimum numbers, not equal. Returns 0');
		// Case #4: Number(2). Very small positive numbers, equal. Returns 1
		oParser = new parserFormula('DELTA(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Very small positive numbers, equal. Returns 1');
		// Case #5: Number(2). Near maximum Excel numbers, equal. Returns 1
		oParser = new parserFormula('DELTA(9.99999999999999E+307,9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(9.99999999999999E+307,9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number(2). Near maximum Excel numbers, equal. Returns 1');
		// Case #6: Area(2). Whole column and row intersection. Returns 1
		oParser = new parserFormula('DELTA(A:A,100:100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: Formula DELTA(A:A,100:100) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Bounded case: Area(2). Whole column and row intersection. Returns 1');

        // Need to fix: boolean handle, error handle, results diff from MS

		testArrayFormula2(assert, "DELTA", 1, 2, true);
	});

	QUnit.test("Test: \"ERF\"", function (assert) {

		oParser = new parserFormula("ERF(1.234,4.5432)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.08096058291050978.toFixed(14) - 0);

		oParser = new parserFormula("ERF(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.8427007929497149.toFixed(14) - 0);

		oParser = new parserFormula("ERF(0,1.345)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.9428441710878559.toFixed(14) - 0);

		oParser = new parserFormula("ERF(1.234)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.9190394169576684.toFixed(14) - 0);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A104").setValue("Text");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: zero as lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Number. Basic valid input: zero as lower_limit. 1 argument used.');
		// Case #2: Number, Number. Valid numeric inputs for lower and upper limits. 2 arguments used.
		oParser = new parserFormula('ERF(0,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(0,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Number, Number. Valid numeric inputs for lower and upper limits. 2 arguments used.');
		// Case #3: Formula. Nested formula for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(SQRT(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(SQRT(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Formula. Nested formula for lower_limit. 1 argument used.');
		// Case #4: Formula, Formula. Nested formulas for both limits. 2 arguments used.
		oParser = new parserFormula('ERF(SQRT(1),SQRT(4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(SQRT(1),SQRT(4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15262147206923782, 'Test: Positive case: Formula, Formula. Nested formulas for both limits. 2 arguments used.');
		// Case #5: String. String convertible to number for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5204998778130466, 'Test: Positive case: String. String convertible to number for lower_limit. 1 argument used.');
		// Case #6: String, String. Strings convertible to numbers for both limits. 2 arguments used.
		oParser = new parserFormula('ERF("0.5","1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF("0.5","1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.32220091513666826, 'Test: Positive case: String, String. Strings convertible to numbers for both limits. 2 arguments used.');
		// Case #7: Reference link. Reference link to valid number. 1 argument used.
		oParser = new parserFormula('ERF(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Reference link. Reference link to valid number. 1 argument used.');
		// Case #8: Reference link, Reference link. Reference links to valid numbers. 2 arguments used.
		oParser = new parserFormula('ERF(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15262147206923782, 'Test: Positive case: Reference link, Reference link. Reference links to valid numbers. 2 arguments used.');
		// Case #9: Area. Single-cell range for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Area. Single-cell range for lower_limit. 1 argument used.');
		// Case #10: Area, Area. Single-cell ranges for both limits. 2 arguments used.
		oParser = new parserFormula('ERF(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15262147206923782, 'Test: Positive case: Area, Area. Single-cell ranges for both limits. 2 arguments used.');
		// Case #11: Array. Array with single element for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5204998778130466, 'Test: Positive case: Array. Array with single element for lower_limit. 1 argument used.');
		// Case #12: Array, Array. Arrays with single elements for both limits. 2 arguments used.
		oParser = new parserFormula('ERF({0.5},{1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF({0.5},{1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.32220091513666826, 'Test: Positive case: Array, Array. Arrays with single elements for both limits. 2 arguments used.');
		// Case #13: Name. Named range for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5204998778130466, 'Test: Positive case: Name. Named range for lower_limit. 1 argument used.');
		// Case #14: Name, Name. Named ranges for both limits. 2 arguments used.
		oParser = new parserFormula('ERF(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0409997556260933, 'Test: Positive case: Name, Name. Named ranges for both limits. 2 arguments used.');
		// Case #15: Name3D. 3D named range for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5204998778130466, 'Test: Positive case: Name3D. 3D named range for lower_limit. 1 argument used.');
		// Case #16: Name3D, Name3D. 3D named ranges for both limits. 2 arguments used.
		oParser = new parserFormula('ERF(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D, Name3D. 3D named ranges for both limits. 2 arguments used.');
		// Case #17: Ref3D. 3D reference to cell for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Ref3D. 3D reference to cell for lower_limit. 1 argument used.');
		// Case #18: Ref3D, Ref3D. 3D references to cells for both limits. 2 arguments used.
		oParser = new parserFormula('ERF(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15262147206923782, 'Test: Positive case: Ref3D, Ref3D. 3D references to cells for both limits. 2 arguments used.');
		// Case #19: Area3D. 3D single-cell range for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Area3D. 3D single-cell range for lower_limit. 1 argument used.');
		// Case #20: Area3D, Area3D. 3D single-cell ranges for both limits. 2 arguments used.
		oParser = new parserFormula('ERF(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15262147206923782, 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges for both limits. 2 arguments used.');
		// Case #21: Table. Table structured reference for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9999999999984626, 'Test: Positive case: Table. Table structured reference for lower_limit. 1 argument used.');
		// Case #22: Table, Table. Table structured references for both limits. 2 arguments used.
		oParser = new parserFormula('ERF(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5374368445009168e-12, 'Test: Positive case: Table, Table. Table structured references for both limits. 2 arguments used.');
		// Case #23: Date. Date as serial number for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number for lower_limit. 1 argument used.');
		// Case #24: Time. Time adjusted to valid number for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9661051464753108, 'Test: Positive case: Time. Time adjusted to valid number for lower_limit. 1 argument used.');

		// Negative cases:
		// Case #1: String. Nonnumeric lower_limit returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Nonnumeric lower_limit returns #VALUE!. 1 argument used.');
		// Case #2: String, String. Nonnumeric lower_limit and upper_limit return #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF("abc","def") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. Nonnumeric lower_limit and upper_limit return #VALUE!. 2 arguments used.');
		// Case #3: String, Number. Nonnumeric lower_limit returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF("abc",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF("abc",1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, Number. Nonnumeric lower_limit returns #VALUE!. 2 arguments used.');
		// Case #4: Number, String. Nonnumeric upper_limit returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF(0.5,"abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(0.5,"abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Nonnumeric upper_limit returns #VALUE!. 2 arguments used.');
		// Case #5: Empty. Empty lower_limit reference returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9999999845827421, 'Test: Negative case: Empty. Empty lower_limit reference returns #VALUE!. 1 argument used.');
		// Case #6: Empty, Number. Empty lower_limit reference returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF(A103,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(A103,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.1572991916330272, 'Test: Negative case: Empty, Number. Empty lower_limit reference returns #VALUE!. 2 arguments used.');
		// Case #7: Number, Empty. Empty upper_limit reference returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF(0.5,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(0.5,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47950010676969546, 'Test: Negative case: Number, Empty. Empty upper_limit reference returns #VALUE!. 2 arguments used.');
		// Case #8: Error. Propagates #N/A error for lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for lower_limit. 1 argument used.');
		// Case #9: Error, Number. Propagates #N/A error for lower_limit. 2 arguments used.
		oParser = new parserFormula('ERF(NA(),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(NA(),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Propagates #N/A error for lower_limit. 2 arguments used.');
		// Case #10: Boolean. Boolean lower_limit returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean lower_limit returns #VALUE!. 1 argument used.');
		// Case #11: Boolean, Number. Boolean lower_limit returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF(FALSE,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(FALSE,1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean lower_limit returns #VALUE!. 2 arguments used.');
		// Case #12: Number, Boolean. Boolean upper_limit returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF(0.5,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(0.5,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Boolean. Boolean upper_limit returns #VALUE!. 2 arguments used.');
		// Case #13: Area. Multi-cell range for lower_limit returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for lower_limit returns #VALUE!. 1 argument used.');
		// Case #14: Area, Number. Multi-cell range for lower_limit returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF(A100:A102,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(A100:A102,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell range for lower_limit returns #VALUE!. 2 arguments used.');
		// Case #15: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #16: Name, Number. Named range with text for lower_limit returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF(TestNameArea,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(TestNameArea,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name, Number. Named range with text for lower_limit returns #VALUE!. 2 arguments used.');
		// Case #17: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #18: Ref3D, Number. 3D reference to text for lower_limit returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF(Sheet2!A3,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Sheet2!A3,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D, Number. 3D reference to text for lower_limit returns #VALUE!. 2 arguments used.');
		// Case #19: Area3D. 3D multi-cell range for lower_limit returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF(Sheet2!A1:B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Sheet2!A1:B1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Negative case: Area3D. 3D multi-cell range for lower_limit returns #VALUE!. 1 argument used.');
		// Case #20: Area3D, Number. 3D multi-cell range for lower_limit returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('ERF(Sheet2!A1:B1,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(Sheet2!A1:B1,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Area3D, Number. 3D multi-cell range for lower_limit returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid numeric lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1283791670955124e-307, 'Test: Bounded case: Number. Minimum valid numeric lower_limit. 1 argument used.');
		// Case #2: Number, Number. Minimum valid numeric values for both limits. 2 arguments used.
		oParser = new parserFormula('ERF(1E-307,1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(1E-307,1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number. Minimum valid numeric values for both limits. 2 arguments used.');
		// Case #3: Number. Maximum valid numeric lower_limit. 1 argument used.
		oParser = new parserFormula('ERF(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid numeric lower_limit. 1 argument used.');
		// Case #4: Number, Number. Maximum valid numeric values for both limits. 2 arguments used.
		oParser = new parserFormula('ERF(9.99999999999999E+307,9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF(9.99999999999999E+307,9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number. Maximum valid numeric values for both limits. 2 arguments used.');

		// TODO
		// Need to fix: different results from ms
		// Case #10: Boolean. Boolean lower_limit returns #VALUE!. 1 argument used.
		// Case #11: Boolean, Number. Boolean lower_limit returns #VALUE!. 2 arguments used.
		// Case #12: Number, Boolean. Boolean upper_limit returns #VALUE!. 2 arguments used.

		testArrayFormula2(assert, "ERF", 1, 2, true);
	});

	QUnit.test("Test: \"ERF.PRECISE\"", function (assert) {

		oParser = new parserFormula("ERF.PRECISE(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.8427007929497149.toFixed(14) - 0);

		oParser = new parserFormula("ERF.PRECISE(1.234)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.9190394169576684.toFixed(14) - 0);

		oParser = new parserFormula("ERF.PRECISE(0.745)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.70792892);

		oParser = new parserFormula("ERF.PRECISE(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.84270079);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A104").setValue("5");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: zero as x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Basic valid input: zero as x. 1 argument used.');
		// Case #2: Number. Valid numeric input for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Number. Valid numeric input for x. 1 argument used.');
		// Case #3: Formula. Nested formula for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(SQRT(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(SQRT(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Formula. Nested formula for x. 1 argument used.');
		// Case #4: Formula. Nested IF formula for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(IF(TRUE,0.5,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(IF(TRUE,0.5,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5204998778130466, 'Test: Positive case: Formula. Nested IF formula for x. 1 argument used.');
		// Case #5: String. String convertible to number for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5204998778130466, 'Test: Positive case: String. String convertible to number for x. 1 argument used.');
		// Case #6: String. String convertible to number for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE("1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE("1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: String. String convertible to number for x. 1 argument used.');
		// Case #7: Reference link. Reference link to valid number. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Reference link. Reference link to valid number. 1 argument used.');
		// Case #8: Reference link. Reference link to valid number. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9953222650189527, 'Test: Positive case: Reference link. Reference link to valid number. 1 argument used.');
		// Case #9: Area. Single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Area. Single-cell range for x. 1 argument used.');
		// Case #10: Area. Single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9953222650189527, 'Test: Positive case: Area. Single-cell range for x. 1 argument used.');
		// Case #11: Array. Array with single element for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5204998778130466, 'Test: Positive case: Array. Array with single element for x. 1 argument used.');
		// Case #12: Array. Array with single element for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE({1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE({1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Array. Array with single element for x. 1 argument used.');
		// Case #13: Name. Named range for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5204998778130466, 'Test: Positive case: Name. Named range for x. 1 argument used.');
		// Case #14: Name. Named range for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5204998778130466, 'Test: Positive case: Name. Named range for x. 1 argument used.');
		// Case #15: Name3D. 3D named range for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5204998778130466, 'Test: Positive case: Name3D. 3D named range for x. 1 argument used.');
		// Case #17: Ref3D. 3D reference to cell for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Ref3D. 3D reference to cell for x. 1 argument used.');
		// Case #18: Ref3D. 3D reference to cell for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9953222650189527, 'Test: Positive case: Ref3D. 3D reference to cell for x. 1 argument used.');
		// Case #19: Area3D. 3D single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Positive case: Area3D. 3D single-cell range for x. 1 argument used.');
		// Case #20: Area3D. 3D single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9953222650189527, 'Test: Positive case: Area3D. 3D single-cell range for x. 1 argument used.');
		// Case #21: Table. Table structured reference for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9999999999984626, 'Test: Positive case: Table. Table structured reference for x. 1 argument used.');
		// Case #22: Table. Table structured reference for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference for x. 1 argument used.');
		// Case #23: Date. Date as serial number for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number for x. 1 argument used.');
		// Case #24: Time. Time adjusted to valid number for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9661051464753108, 'Test: Positive case: Time. Time adjusted to valid number for x. 1 argument used.');

		// Negative cases:
		// Case #1: String. Nonnumeric x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Nonnumeric x returns #VALUE!. 1 argument used.');
		// Case #2: String. Empty string for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string for x returns #VALUE!. 1 argument used.');
		// Case #3: Empty. Empty reference for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9999999845827421, 'Test: Negative case: Empty. Empty reference for x returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for x. 1 argument used.');
		// Case #5: Boolean. Boolean x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean x returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean x returns #VALUE!. 1 argument used.');
		// Case #7: Area. Multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #8: Area. Multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(A101:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(A101:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #9: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7421009647076604, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7421009647076604, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #13: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #14: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #15: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Sheet2!A1:B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Sheet2!A1:B1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8427007929497149, 'Test: Negative case: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #16: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Sheet2!A2:B2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Sheet2!A2:B2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9953222650189527, 'Test: Negative case: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #17: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #NUM! error for x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error for x. 1 argument used.');
		// Case #20: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid numeric x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1283791670955124e-307, 'Test: Bounded case: Number. Minimum valid numeric x. 1 argument used.');
		// Case #2: Number. Maximum valid numeric x. 1 argument used.
		oParser = new parserFormula('ERF.PRECISE(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERF.PRECISE(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid numeric x. 1 argument used.');

		// Need to fix: boolean handle
		// Case #5: Boolean. Boolean x returns #VALUE!. 1 argument used.
		// Case #6: Boolean. Boolean x returns #VALUE!. 1 argument used.
		// Case #20: Array. Array with boolean returns #VALUE!. 1 argument used.

		testArrayFormula2(assert, "ERF.PRECISE", 1, 1, true);
	});

	QUnit.test("Test: \"ERFC\"", function (assert) {

		oParser = new parserFormula("ERFC(1.234)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.08096058304233157.toFixed(14) - 0);

		oParser = new parserFormula("ERFC(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.15729920705028513.toFixed(14) - 0);

		oParser = new parserFormula("ERFC(0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("ERFC(-1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 1.8427007929497148.toFixed(14) - 0);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A104").setValue("5");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: zero as x. 1 argument used.
		oParser = new parserFormula('ERFC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Basic valid input: zero as x. 1 argument used.');
		// Case #2: Number. Valid numeric input for x. 1 argument used.
		oParser = new parserFormula('ERFC(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Number. Valid numeric input for x. 1 argument used.');
		// Case #3: Formula. Nested formula for x. 1 argument used.
		oParser = new parserFormula('ERFC(SQRT(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(SQRT(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Formula. Nested formula for x. 1 argument used.');
		// Case #4: Formula. Nested IF formula for x. 1 argument used.
		oParser = new parserFormula('ERFC(IF(TRUE,0.5,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(IF(TRUE,0.5,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47950012218695337, 'Test: Positive case: Formula. Nested IF formula for x. 1 argument used.');
		// Case #5: String. String convertible to number for x. 1 argument used.
		oParser = new parserFormula('ERFC("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47950012218695337, 'Test: Positive case: String. String convertible to number for x. 1 argument used.');
		// Case #6: String. String convertible to number for x. 1 argument used.
		oParser = new parserFormula('ERFC("1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC("1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: String. String convertible to number for x. 1 argument used.');
		// Case #7: Reference link. Reference link to valid number. 1 argument used.
		oParser = new parserFormula('ERFC(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Reference link. Reference link to valid number. 1 argument used.');
		// Case #8: Reference link. Reference link to valid number. 1 argument used.
		oParser = new parserFormula('ERFC(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Positive case: Reference link. Reference link to valid number. 1 argument used.');
		// Case #9: Area. Single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERFC(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Area. Single-cell range for x. 1 argument used.');
		// Case #10: Area. Single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERFC(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Positive case: Area. Single-cell range for x. 1 argument used.');
		// Case #11: Array. Array with single element for x. 1 argument used.
		oParser = new parserFormula('ERFC({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47950012218695337, 'Test: Positive case: Array. Array with single element for x. 1 argument used.');
		// Case #12: Array. Array with single element for x. 1 argument used.
		oParser = new parserFormula('ERFC({1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC({1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Array. Array with single element for x. 1 argument used.');
		// Case #13: Name. Named range for x. 1 argument used.
		oParser = new parserFormula('ERFC(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5204998778130467, 'Test: Positive case: Name. Named range for x. 1 argument used.');
		// Case #14: Name. Named range for x. 1 argument used.
		oParser = new parserFormula('ERFC(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47950012218695337, 'Test: Positive case: Name. Named range for x. 1 argument used.');
		// Case #15: Name3D. 3D named range for x. 1 argument used.
		oParser = new parserFormula('ERFC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5204998778130467, 'Test: Positive case: Name3D. 3D named range for x. 1 argument used.');
		// Case #17: Ref3D. 3D reference to cell for x. 1 argument used.
		oParser = new parserFormula('ERFC(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Ref3D. 3D reference to cell for x. 1 argument used.');
		// Case #18: Ref3D. 3D reference to cell for x. 1 argument used.
		oParser = new parserFormula('ERFC(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Positive case: Ref3D. 3D reference to cell for x. 1 argument used.');
		// Case #19: Area3D. 3D single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERFC(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Area3D. 3D single-cell range for x. 1 argument used.');
		// Case #20: Area3D. 3D single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERFC(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Positive case: Area3D. 3D single-cell range for x. 1 argument used.');
		// Case #21: Table. Table structured reference for x. 1 argument used.
		oParser = new parserFormula('ERFC(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.537459794428035e-12, 'Test: Positive case: Table. Table structured reference for x. 1 argument used.');
		// Case #22: Table. Table structured reference for x. 1 argument used.
		oParser = new parserFormula('ERFC(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.088487583762545e-45, 'Test: Positive case: Table. Table structured reference for x. 1 argument used.');
		// Case #23: Date. Date as serial number for x. 1 argument used.
		oParser = new parserFormula('ERFC(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date. Date as serial number for x. 1 argument used.');
		// Case #24: Time. Time adjusted to valid number for x. 1 argument used.
		oParser = new parserFormula('ERFC(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03389485352468928, 'Test: Positive case: Time. Time adjusted to valid number for x. 1 argument used.');

		// Negative cases:
		// Case #1: String. Nonnumeric x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Nonnumeric x returns #VALUE!. 1 argument used.');
		// Case #2: String. Empty string for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string for x returns #VALUE!. 1 argument used.');
		// Case #3: Empty. Empty reference for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.541725790028002e-8, 'Test: Negative case: Empty. Empty reference for x returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error for x. 1 argument used.
		oParser = new parserFormula('ERFC(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for x. 1 argument used.');
		// Case #5: Boolean. Boolean x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean x returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean x returns #VALUE!. 1 argument used.');
		// Case #7: Area. Multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #8: Area. Multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(A101:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(A101:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #9: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2578990352923396, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2578990352923396, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #13: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #14: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #15: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(Sheet2!A1:B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Sheet2!A1:B1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Negative case: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #16: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(Sheet2!A2:B2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Sheet2!A2:B2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Negative case: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #17: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #NUM! error for x. 1 argument used.
		oParser = new parserFormula('ERFC(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error for x. 1 argument used.');
		// Case #20: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid numeric x. 1 argument used.
		oParser = new parserFormula('ERFC(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid numeric x. 1 argument used.');
		// Case #2: Number. Maximum valid numeric x. 1 argument used.
		oParser = new parserFormula('ERFC(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid numeric x. 1 argument used.');

		// Need to fix: boolean handle
		// Case #5: Boolean. Boolean x returns #VALUE!. 1 argument used.
		// Case #6: Boolean. Boolean x returns #VALUE!. 1 argument used.
		// Case #20: Array. Array with boolean returns #VALUE!. 1 argument used.

		testArrayFormula2(assert, "ERFC", 1, 1, true);
	});

	QUnit.test("Test: \"ERFC.PRECISE\"", function (assert) {

		oParser = new parserFormula("ERFC.PRECISE(1.234)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.08096058304233157.toFixed(14) - 0);

		oParser = new parserFormula("ERFC.PRECISE(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 0.15729920705028513.toFixed(14) - 0);

		oParser = new parserFormula("ERFC.PRECISE(0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("ERFC.PRECISE(-1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue().toFixed(14) - 0, 1.8427007929497148.toFixed(14) - 0);

		ws.getRange2("A100:C214").cleanAll();
		// Data for reference link. Use A100-A115
		ws.getRange2("A100").setValue("1");
		ws.getRange2("A101").setValue("2");
		ws.getRange2("A102").setValue("3");
		ws.getRange2("A103").setValue("4");
		ws.getRange2("A104").setValue("5");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("5"); // Num (Column1)
		ws.getRange2("B601").setValue("10"); // Num (Column2)
		ws.getRange2("C601").setValue("Text"); // Text (Column3)

		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid input: zero as x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Basic valid input: zero as x. 1 argument used.');
		// Case #2: Number. Valid numeric input for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Number. Valid numeric input for x. 1 argument used.');
		// Case #3: Formula. Nested formula for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(SQRT(1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(SQRT(1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Formula. Nested formula for x. 1 argument used.');
		// Case #4: Formula. Nested IF formula for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(IF(TRUE,0.5,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(IF(TRUE,0.5,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47950012218695337, 'Test: Positive case: Formula. Nested IF formula for x. 1 argument used.');
		// Case #5: String. String convertible to number for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE("0.5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE("0.5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47950012218695337, 'Test: Positive case: String. String convertible to number for x. 1 argument used.');
		// Case #6: String. String convertible to number for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE("1")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE("1") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: String. String convertible to number for x. 1 argument used.');
		// Case #7: Reference link. Reference link to valid number. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Reference link. Reference link to valid number. 1 argument used.');
		// Case #8: Reference link. Reference link to valid number. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Positive case: Reference link. Reference link to valid number. 1 argument used.');
		// Case #9: Area. Single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Area. Single-cell range for x. 1 argument used.');
		// Case #10: Area. Single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Positive case: Area. Single-cell range for x. 1 argument used.');
		// Case #11: Array. Array with single element for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE({0.5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE({0.5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47950012218695337, 'Test: Positive case: Array. Array with single element for x. 1 argument used.');
		// Case #12: Array. Array with single element for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE({1})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE({1}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Array. Array with single element for x. 1 argument used.');
		// Case #13: Name. Named range for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5204998778130467, 'Test: Positive case: Name. Named range for x. 1 argument used.');
		// Case #14: Name. Named range for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.47950012218695337, 'Test: Positive case: Name. Named range for x. 1 argument used.');
		// Case #15: Name3D. 3D named range for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5204998778130467, 'Test: Positive case: Name3D. 3D named range for x. 1 argument used.');
		// Case #17: Ref3D. 3D reference to cell for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Ref3D. 3D reference to cell for x. 1 argument used.');
		// Case #18: Ref3D. 3D reference to cell for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Positive case: Ref3D. 3D reference to cell for x. 1 argument used.');
		// Case #19: Area3D. 3D single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Positive case: Area3D. 3D single-cell range for x. 1 argument used.');
		// Case #20: Area3D. 3D single-cell range for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Positive case: Area3D. 3D single-cell range for x. 1 argument used.');
		// Case #21: Table. Table structured reference for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.537459794428035e-12, 'Test: Positive case: Table. Table structured reference for x. 1 argument used.');
		// Case #22: Table. Table structured reference for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.088487583762545e-45, 'Test: Positive case: Table. Table structured reference for x. 1 argument used.');
		// Case #23: Date. Date as serial number for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Date. Date as serial number for x. 1 argument used.');
		// Case #24: Time. Time adjusted to valid number for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(TIME(12,0,0)+1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(TIME(12,0,0)+1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.03389485352468928, 'Test: Positive case: Time. Time adjusted to valid number for x. 1 argument used.');

		// Negative cases:
		// Case #1: String. Nonnumeric x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Nonnumeric x returns #VALUE!. 1 argument used.');
		// Case #2: String. Empty string for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Empty string for x returns #VALUE!. 1 argument used.');
		// Case #3: Empty. Empty reference for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.541725790028002e-8, 'Test: Negative case: Empty. Empty reference for x returns #VALUE!. 1 argument used.');
		// Case #4: Error. Propagates #N/A error for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error for x. 1 argument used.');
		// Case #5: Boolean. Boolean x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean x returns #VALUE!. 1 argument used.');
		// Case #6: Boolean. Boolean x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean x returns #VALUE!. 1 argument used.');
		// Case #7: Area. Multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(A100:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(A100:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #8: Area. Multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(A101:A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(A101:A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #9: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #10: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2578990352923396, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #11: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.2578990352923396, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #13: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #14: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Ref3D. 3D reference to text returns #VALUE!. 1 argument used.');
		// Case #15: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Sheet2!A1:B1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Sheet2!A1:B1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.15729920705028513, 'Test: Negative case: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #16: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Sheet2!A2:B2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Sheet2!A2:B2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.004677734981047265, 'Test: Negative case: Area3D. 3D multi-cell range for x returns #VALUE!. 1 argument used.');
		// Case #17: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #19: Formula. Formula resulting in #NUM! error for x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error for x. 1 argument used.');
		// Case #20: Array. Array with boolean returns #VALUE!. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid numeric x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Minimum valid numeric x. 1 argument used.');
		// Case #2: Number. Maximum valid numeric x. 1 argument used.
		oParser = new parserFormula('ERFC.PRECISE(9.99999999999999E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: ERFC.PRECISE(9.99999999999999E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid numeric x. 1 argument used.');

		// Need to fix: boolean handle
		// Case #5: Boolean. Boolean x returns #VALUE!. 1 argument used.
		// Case #6: Boolean. Boolean x returns #VALUE!. 1 argument used.
		// Case #20: Array. Array with boolean returns #VALUE!. 1 argument used.

	});

	QUnit.test("Test: \"GESTEP\"", function (assert) {

		oParser = new parserFormula("GESTEP(5, 4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("GESTEP(5, 5)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("GESTEP(-4, -5)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("GESTEP(-1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.strictEqual(oParser.calculate().getValue(), 0);

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("0.1");
		ws.getRange2("A101").setValue("0.2");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("0.3");
		ws.getRange2("A103").setValue("0.4");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // NumberText (Column2)
		ws.getRange2("C601").setValue("str"); // Text (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Basic valid input: integer number. 1 argument used.
		oParser = new parserFormula('GESTEP(5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number. Basic valid input: integer number. 1 argument used.');
		// Case #1: Number, Number. Basic valid input: integer number and step. 2 arguments used.
		oParser = new parserFormula('GESTEP(5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Number, Number. Basic valid input: integer number and step. 2 arguments used.');
		// Case #4: String. String convertible to number. 1 argument used.
		oParser = new parserFormula('GESTEP("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String. String convertible to number. 1 argument used.');
		// Case #5: String, String. Strings convertible to numbers for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP("5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP("5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: String, String. Strings convertible to numbers for both arguments. 2 arguments used.');
		// Case #6: Formula. Nested formula returning valid number. 1 argument used.
		oParser = new parserFormula('GESTEP(SQRT(25))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(SQRT(25)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula. Nested formula returning valid number. 1 argument used.');
		// Case #7: Formula, Formula. Nested formulas for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP(SQRT(25),ABS(-2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(SQRT(25),ABS(-2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Formula, Formula. Nested formulas for both arguments. 2 arguments used.');
		// Case #8: Reference link. Reference to cell with valid number. 1 argument used.
		oParser = new parserFormula('GESTEP(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference to cell with valid number. 1 argument used.');
		// Case #9: Reference link, Reference link. References to cells with valid numbers. 2 arguments used.
		oParser = new parserFormula('GESTEP(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link, Reference link. References to cells with valid numbers. 2 arguments used.');
		// Case #10: Area. Single-cell range for number. 1 argument used.
		oParser = new parserFormula('GESTEP(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area. Single-cell range for number. 1 argument used.');
		// Case #11: Area, Area. Single-cell ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area, Area. Single-cell ranges for both arguments. 2 arguments used.');
		// Case #12: Array. Array with single element for number. 1 argument used.
		oParser = new parserFormula('GESTEP({5})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP({5}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Array with single element for number. 1 argument used.');
		// Case #13: Array, Array. Arrays with single elements for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP({5},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP({5},{2}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array, Array. Arrays with single elements for both arguments. 2 arguments used.');
		// Case #14: Name. Named range with valid number. 1 argument used.
		oParser = new parserFormula('GESTEP(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name. Named range with valid number. 1 argument used.');
		// Case #15: Name, Name. Named ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name, Name. Named ranges for both arguments. 2 arguments used.');
		// Case #16: Name3D. 3D named range for number. 1 argument used.
		oParser = new parserFormula('GESTEP(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named range for number. 1 argument used.');
		// Case #17: Name3D, Name3D. 3D named ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP(TestName3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(TestName3D,TestNameArea3D2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NAME?', 'Test: Positive case: Name3D, Name3D. 3D named ranges for both arguments. 2 arguments used.');
		// Case #18: Ref3D. 3D reference to cell for number. 1 argument used.
		oParser = new parserFormula('GESTEP(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell for number. 1 argument used.');
		// Case #19: Ref3D, Ref3D. 3D references to cells for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D, Ref3D. 3D references to cells for both arguments. 2 arguments used.');
		// Case #20: Area3D. 3D single-cell range for number. 1 argument used.
		oParser = new parserFormula('GESTEP(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell range for number. 1 argument used.');
		// Case #21: Area3D, Area3D. 3D single-cell ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges for both arguments. 2 arguments used.');
		// Case #22: Table. Table structured reference for number. 1 argument used.
		oParser = new parserFormula('GESTEP(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference for number. 1 argument used.');
		// Case #23: Table, Table. Table structured references for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!", 'Test: Positive case: Table, Table. Table structured references for both arguments. 2 arguments used.');
		// Case #24: Date. Date as serial number for number. 1 argument used.
		oParser = new parserFormula('GESTEP(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number for number. 1 argument used.');
		// Case #25: Time. Time as serial number for number. 1 argument used.
		oParser = new parserFormula('GESTEP(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Time. Time as serial number for number. 1 argument used.');
		// Case #26: Formula. GESTEP inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(GESTEP(5,2),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(GESTEP(5,2),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Formula. GESTEP inside SUM formula. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GESTEP("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #2: String, String. Non-numeric strings for both arguments return #VALUE!. 2 arguments used.
		oParser = new parserFormula('GESTEP("abc","def")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP("abc","def") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. Non-numeric strings for both arguments return #VALUE!. 2 arguments used.');
		// Case #3: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('GESTEP(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #4: Error, Number. Error in first argument propagates #N/A. 2 arguments used.
		oParser = new parserFormula('GESTEP(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Error in first argument propagates #N/A. 2 arguments used.');
		// Case #5: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GESTEP(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #6: Empty, Number. Empty reference for number returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('GESTEP(A102,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(A102,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Empty, Number. Empty reference for number returns #VALUE!. 2 arguments used.');
		// Case #7: Number, Empty. Empty reference for step returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('GESTEP(5,A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(5,A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Number, Empty. Empty reference for step returns #VALUE!. 2 arguments used.');
		// Case #8: Boolean. Boolean FALSE returns 0 (treated as 0). 1 argument used.
		oParser = new parserFormula('GESTEP(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns 0 (treated as 0). 1 argument used.');
		// Case #9: Boolean, Boolean. Booleans treated as numbers (1, 0). 2 arguments used.
		oParser = new parserFormula('GESTEP(TRUE,FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(TRUE,FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Boolean. Booleans treated as numbers (1, 0). 2 arguments used.');
		// Case #10: Area. Multi-cell range for number returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GESTEP(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for number returns #VALUE!. 1 argument used.');
		// Case #11: Area, Number. Multi-cell range for number returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('GESTEP(A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(A100:A101,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell range for number returns #VALUE!. 2 arguments used.');
		// Case #12: Number, Area. Multi-cell range for step returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('GESTEP(5,A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(5,A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Multi-cell range for step returns #VALUE!. 2 arguments used.');
		// Case #13: Ref3D. 3D reference to text cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GESTEP(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Ref3D. 3D reference to text cell returns #VALUE!. 1 argument used.');
		// Case #14: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GESTEP(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(TestNameArea) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #14/2: Name. Named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GESTEP(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name. Named range with text returns #VALUE!. 1 argument used.');
		// Case #15: Name3D. 3D named range with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GESTEP(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!. 1 argument used.');
		// Case #16: Table. Table column with text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GESTEP(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Table. Table column with text returns #VALUE!. 1 argument used.');
		// Case #17: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('GESTEP(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #18: Array. Array with boolean treated as 0. 1 argument used.
		oParser = new parserFormula('GESTEP({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean treated as 0. 1 argument used.');
		// Case #19: Array. Multi-element array returns #VALUE!. 1 argument used.
		oParser = new parserFormula('GESTEP({TRUE,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP({TRUE,FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Multi-element array returns #VALUE!. 1 argument used.');
		// Case #20: Array, Array. Multi-element arrays for both arguments return #VALUE!. 2 arguments used.
		oParser = new parserFormula('GESTEP({5,TRUE},{2,FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP({5,TRUE},{2,FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Array, Array. Multi-element arrays for both arguments return #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Maximum valid Excel number for number. 1 argument used.
		oParser = new parserFormula('GESTEP(1.7976931348623157E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(1.7976931348623157E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number. Maximum valid Excel number for number. 1 argument used.');
		// Case #2: Number, Number. Maximum valid Excel numbers for both arguments. 2 arguments used.
		oParser = new parserFormula('GESTEP(1.7976931348623157E+307,1.7976931348623157E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(1.7976931348623157E+307,1.7976931348623157E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Maximum valid Excel numbers for both arguments. 2 arguments used.');
		// Case #3: Number. Minimum valid Excel number for number. 1 argument used.
		oParser = new parserFormula('GESTEP(-1.7976931348623157E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(-1.7976931348623157E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid Excel number for number. 1 argument used.');
		// Case #4: Number, Number. Smallest positive number for number, step is 0. 2 arguments used.
		oParser = new parserFormula('GESTEP(1E-307,0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: GESTEP(1E-307,0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Smallest positive number for number, step is 0. 2 arguments used.');

		// TODO crit problem with .cross method, tocNumber method
		// Need to fix: bool handle
		// Case #17: Name3D, Name3D. 3D named ranges for both arguments. 2 arguments used. - critical
		// Case #8: Boolean. Boolean FALSE returns 0 (treated as 0). 1 argument used. - diff res
		// Case #9: Boolean, Boolean. Booleans treated as numbers (1, 0). 2 arguments used. - diff res
		// Case #14: Name. Named range with text returns #VALUE!. 1 argument used. - critical
		// Case #18: Array. Array with boolean treated as 0. 1 argument used.
		// Case #19: Array. Multi-element array returns #VALUE!. 1 argument used.

		testArrayFormula2(assert, "GESTEP", 1, 2, true);
	});

	QUnit.test("Test: \"HEX2BIN\"", function (assert) {

		oParser = new parserFormula("HEX2BIN(\"2a\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"2a\")");
		assert.strictEqual(oParser.calculate().getValue(), "101010");

		oParser = new parserFormula("HEX2BIN(\"fffffffe00\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"fffffffe00\")");
		assert.strictEqual(oParser.calculate().getValue(), "1000000000");

		oParser = new parserFormula("HEX2BIN(\"fffffffe01\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"fffffffe01\")");
		assert.strictEqual(oParser.calculate().getValue(), "1000000001");

		oParser = new parserFormula("HEX2BIN(\"ffffffffff\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"ffffffffff\")");
		assert.strictEqual(oParser.calculate().getValue(), "1111111111");

		oParser = new parserFormula("HEX2BIN(0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(0)");
		assert.strictEqual(oParser.calculate().getValue(), "0");

		oParser = new parserFormula("HEX2BIN(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(1)");
		assert.strictEqual(oParser.calculate().getValue(), "1");

		oParser = new parserFormula("HEX2BIN(\"1fe\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"1fe\")");
		assert.strictEqual(oParser.calculate().getValue(), "111111110");

		oParser = new parserFormula("HEX2BIN(\"1ff\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"1ff\")");
		assert.strictEqual(oParser.calculate().getValue(), "111111111");

		oParser = new parserFormula("HEX2BIN(\"2a\",6)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"2a\",6)");
		assert.strictEqual(oParser.calculate().getValue(), "101010");

		oParser = new parserFormula("HEX2BIN(\"2a\",8)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"2a\",8)");
		assert.strictEqual(oParser.calculate().getValue(), "00101010");

		oParser = new parserFormula("HEX2BIN(\"Hello World!\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"Hello World!\")");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("HEX2BIN(\"fffffffdff\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"fffffffdff\")");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("HEX2BIN(\"200\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"200\")");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("HEX2BIN(\"2a\", 5)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"2a\",5)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("HEX2BIN(\"2a\", -8)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"2a\",-8)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("HEX2BIN(\"2a\", \"Hello World!\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2BIN(\"2a\",\"Hello World!\")");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("F8");
		ws.getRange2("A101").setValue("2D");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("3D");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Text (Column2)
		ws.getRange2("C601").setValue("1F"); // HEXNumber (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Maximum positive hex number (511 decimal). 1 argument used.
		oParser = new parserFormula('HEX2BIN("1F")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1F") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11111', 'Test: Positive case: Number. Maximum positive hex number (511 decimal). 1 argument used.');
		// Case #1: Number, Number. Positive hex with valid places (8 chars). 2 arguments used.
		oParser = new parserFormula('HEX2BIN("1FF",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1FF",8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number, Number. Positive hex with valid places (8 chars). 2 arguments used.');
		// Case #2: String. String convertible to valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2BIN("1FF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1FF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111111111', 'Test: Positive case: String. String convertible to valid hex number. 1 argument used.');
		// Case #3: String, Number. String hex with valid places. 2 arguments used.
		oParser = new parserFormula('HEX2BIN("1FF",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1FF",8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String, Number. String hex with valid places. 2 arguments used.');
		// Case #4: Formula. Nested formula returning valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2BIN(HEX2DEC("1FF"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(HEX2DEC("1FF")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Nested formula returning valid hex number. 1 argument used.');
		// Case #5: Formula, Formula. Nested formulas for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(HEX2DEC("1FF"),ABS(-8))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(HEX2DEC("1FF"),ABS(-8)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula, Formula. Nested formulas for both arguments. 2 arguments used.');
		// Case #6: Reference link. Reference to cell with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2BIN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11111000', 'Test: Positive case: Reference link. Reference to cell with valid hex number. 1 argument used.');
		// Case #7: Reference link, Reference link. References to cells with valid hex and places. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link, Reference link. References to cells with valid hex and places. 2 arguments used.');
		// Case #8: Area. Single-cell range for number. 1 argument used.
		oParser = new parserFormula('HEX2BIN(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11111000', 'Test: Positive case: Area. Single-cell range for number. 1 argument used.');
		// Case #9: Area, Area. Single-cell ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area, Area. Single-cell ranges for both arguments. 2 arguments used.');
		// Case #10: Array. Array with single valid hex element. 1 argument used.
		oParser = new parserFormula('HEX2BIN({"1FF"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN({"1FF"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111111111', 'Test: Positive case: Array. Array with single valid hex element. 1 argument used.');
		// Case #11: Array, Array. Arrays with single elements for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2BIN({"1FF"},{8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN({"1FF"},{8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Array, Array. Arrays with single elements for both arguments. 2 arguments used.');
		// Case #12: Name. Named range with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2BIN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid hex number. 1 argument used.');
		// Case #13: Name, Name. Named ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Name. Named ranges for both arguments. 2 arguments used.');
		// Case #14: Name3D. 3D named range with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2BIN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid hex number. 1 argument used.');
		// Case #15: Name3D, Name3D. 3D named ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(TestName3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(TestName3D,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Name3D. 3D named ranges for both arguments. 2 arguments used.');
		// Case #16: Ref3D. 3D reference to cell with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2BIN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Ref3D. 3D reference to cell with valid hex number. 1 argument used.');
		// Case #17: Ref3D, Ref3D. 3D references to cells for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '01', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells for both arguments. 2 arguments used.');
		// Case #18: Area3D. 3D single-cell range for number. 1 argument used.
		oParser = new parserFormula('HEX2BIN(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D. 3D single-cell range for number. 1 argument used.');
		// Case #19: Area3D, Area3D. 3D single-cell ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '01', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges for both arguments. 2 arguments used.');
		// Case #20: Table. Table structured reference with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2BIN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Table. Table structured reference with valid hex number. 1 argument used.');
		// Case #21: Table, Table. Table references for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Table, Table. Table references for both arguments. 2 arguments used.');
		// Case #22: Formula. HEX2BIN inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(HEX2BIN("1FF"),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(HEX2BIN("1FF"),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 111111111, 'Test: Positive case: Formula. HEX2BIN inside SUM formula. 2 arguments used.');
		// Case #24: Number. Minimum negative hex number (-512 decimal), 10-char output. 1 argument used.
		oParser = new parserFormula('HEX2BIN("FFFFFFFE00")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("FFFFFFFE00") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1000000000', 'Test: Positive case: Number. Minimum negative hex number (-512 decimal), 10-char output. 1 argument used.');
		// Case #25: Number, Number. Negative hex ignores places, returns 10-char binary. 2 arguments used.
		oParser = new parserFormula('HEX2BIN("FFFFFFFE00",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("FFFFFFFE00",8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1000000000', 'Test: Positive case: Number, Number. Negative hex ignores places, returns 10-char binary. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Invalid hex string returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2BIN("XYZ")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("XYZ") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Invalid hex string returns #NUM!. 1 argument used.');
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('HEX2BIN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #3: Empty. Empty reference for number returns #VALUE!. 1 argument used.
		oParser = new parserFormula('HEX2BIN(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111101', 'Test: Negative case: Empty. Empty reference for number returns #VALUE!. 1 argument used.');
		// Case #4: Empty, Number. Empty reference for number returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(A102,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(A102,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00111101', 'Test: Negative case: Empty, Number. Empty reference for number returns #VALUE!. 2 arguments used.');
		// Case #5: Number, Empty. Empty reference for places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2BIN("1BB",A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1BB",A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Empty. Empty reference for places returns #VALUE!. 2 arguments used.');
		// Case #6: Boolean. Boolean TRUE treated as invalid hex, returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2BIN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean TRUE treated as invalid hex, returns #NUM!. 1 argument used.');
		// Case #7: Boolean, Number. Boolean FALSE treated as invalid hex, returns #NUM!. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(FALSE,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(FALSE,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE treated as invalid hex, returns #NUM!. 2 arguments used.');
		// Case #8: Area. Multi-cell range for number returns #VALUE!. 1 argument used.
		oParser = new parserFormula('HEX2BIN(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for number returns #VALUE!. 1 argument used.');
		// Case #9: Area, Number. Multi-cell range for number returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2BIN(A100:A101,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(A100:A101,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell range for number returns #VALUE!. 2 arguments used.');
		// Case #10: Number, Area. Multi-cell range for places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2BIN("1FF0",A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1FF0",A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Multi-cell range for places returns #VALUE!. 2 arguments used.');
		// Case #11: Name. Named range with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2BIN(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #NUM!. 1 argument used.');
		// Case #12: Name3D. 3D named range with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2BIN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with text returns #NUM!. 1 argument used.');
		// Case #13: Ref3D. 3D reference to text cell returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2BIN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to text cell returns #NUM!. 1 argument used.');
		// Case #14: Table. Table column with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2BIN(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '11111', 'Test: Negative case: Table. Table column with text returns #NUM!. 1 argument used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('HEX2BIN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(SQRT(-1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #16: Number. Positive hex > 1FF returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2BIN(200)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(200) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Positive hex > 1FF returns #NUM!. 1 argument used.');
		// Case #17: Number. Negative hex < FFFFFFFE00 returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2BIN("FFFFFFFDFF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("FFFFFFFDFF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative hex < FFFFFFFE00 returns #NUM!. 1 argument used.');
		// Case #18: Number, Number. Places too small for binary result returns #NUM!. 2 arguments used.
		oParser = new parserFormula('HEX2BIN("1FF",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1FF",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Places too small for binary result returns #NUM!. 2 arguments used.');
		// Case #19: Number, Number. Negative places returns #NUM!. 2 arguments used.
		oParser = new parserFormula('HEX2BIN("1FF",-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1FF",-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative places returns #NUM!. 2 arguments used.');
		// Case #20: Number, String. Non-numeric places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2BIN("1FF","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1FF","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric places returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive hex number (0). 1 argument used.
		oParser = new parserFormula('HEX2BIN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number. Minimum positive hex number (0). 1 argument used.');
		// Case #2: Number. Maximum positive hex number (511 decimal). 1 argument used.
		oParser = new parserFormula('HEX2BIN(0.00001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN(0.00001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum positive hex number (511 decimal). 1 argument used.');
		// Case #3: Number. Minimum negative hex number (-512 decimal). 1 argument used.
		oParser = new parserFormula('HEX2BIN("FFFFFFFE00")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("FFFFFFFE00") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1000000000', 'Test: Bounded case: Number. Minimum negative hex number (-512 decimal). 1 argument used.');
		// Case #4: Number. Maximum negative hex number (-1 decimal). 1 argument used.
		oParser = new parserFormula('HEX2BIN("FFFFFFFFFF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("FFFFFFFFFF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1111111111', 'Test: Bounded case: Number. Maximum negative hex number (-1 decimal). 1 argument used.');
		// Case #5: Number, Number. Maximum places for 1FF (9 bits needed, 10 allowed). 2 arguments used.
		oParser = new parserFormula('HEX2BIN("1FF",1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2BIN("1FF",1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number. Maximum places for 1FF (9 bits needed, 10 allowed). 2 arguments used.');

		// Need to fix: error and boolean handle
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		// Case #6: Boolean. Boolean TRUE treated as invalid hex, returns #NUM!. 1 argument used.
		// Case #7: Boolean, Number. Boolean FALSE treated as invalid hex, returns #NUM!. 2 arguments used.
		// Case #15: Formula. Formula resulting in #NUM! error. 1 argument used.

		testArrayFormula2(assert, "HEX2BIN", 1, 2, true);
	});

	QUnit.test("Test: \"HEX2DEC\"", function (assert) {

		oParser = new parserFormula("HEX2DEC(\"2a\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2DEC(\"2a\")");
		assert.strictEqual(oParser.calculate().getValue(), 42);

		oParser = new parserFormula("HEX2DEC(\"8000000000\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2DEC(\"8000000000\")");
		assert.strictEqual(oParser.calculate().getValue(), -549755813888);

		oParser = new parserFormula("HEX2DEC(\"ffffffffff\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2DEC(\"ffffffffff\")");
		assert.strictEqual(oParser.calculate().getValue(), -1);

		oParser = new parserFormula("HEX2DEC(\"0\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2DEC(\"0\")");
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("HEX2DEC(\"1\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2DEC(\"1\")");
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("HEX2DEC(0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2DEC(0)");
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("HEX2DEC(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2DEC(1)");
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("HEX2DEC(\"7fffffffff\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2DEC(\"7fffffffff\")");
		assert.strictEqual(oParser.calculate().getValue(), 549755813887);

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("F8");
		ws.getRange2("A101").setValue("2D");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("3D");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Text (Column2)
		ws.getRange2("C601").setValue("1F"); // HEXNumber (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #0: Number. Valid positive hex number (511 decimal). 1 argument used.
		oParser = new parserFormula('HEX2DEC(12)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(12) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 18, 'Test: Positive case: Number. Valid positive hex number (511 decimal). 1 argument used.');
		// Case #1: String. String convertible to valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC("1FF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC("1FF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 511, 'Test: Positive case: String. String convertible to valid hex number. 1 argument used.');
		// Case #2: Formula. Nested formula returning valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(DEC2HEX(511))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(DEC2HEX(511)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 511, 'Test: Positive case: Formula. Nested formula returning valid hex number. 1 argument used.');
		// Case #3: Reference link. Reference to cell with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 248, 'Test: Positive case: Reference link. Reference to cell with valid hex number. 1 argument used.');
		// Case #4: Area. Single-cell range for number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 248, 'Test: Positive case: Area. Single-cell range for number. 1 argument used.');
		// Case #5: Array. Array with single valid hex element. 1 argument used.
		oParser = new parserFormula('HEX2DEC({"1FF"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC({"1FF"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 511, 'Test: Positive case: Array. Array with single valid hex element. 1 argument used.');
		// Case #6: Name. Named range with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid hex number. 1 argument used.');
		// Case #7: Name3D. 3D named range with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid hex number. 1 argument used.');
		// Case #8: Ref3D. 3D reference to cell with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with valid hex number. 1 argument used.');
		// Case #9: Area3D. 3D single-cell range for number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Area3D. 3D single-cell range for number. 1 argument used.');
		// Case #10: Table. Table structured reference with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid hex number. 1 argument used.');
		// Case #11: Formula. HEX2DEC inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(HEX2DEC("1FF"),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(HEX2DEC("1FF"),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 511, 'Test: Positive case: Formula. HEX2DEC inside SUM formula. 1 argument used.');
		// Case #12: String. Single-digit hex string (10 decimal). 1 argument used.
		oParser = new parserFormula('HEX2DEC("A")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC("A") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 10, 'Test: Positive case: String. Single-digit hex string (10 decimal). 1 argument used.');
		// Case #13: Number. Zero hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero hex number. 1 argument used.');
		// Case #14: Number. Maximum negative hex number (-1 decimal). 1 argument used.
		oParser = new parserFormula('HEX2DEC("0FFFFFFFFFF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC("0FFFFFFFFFF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Number. Maximum negative hex number (-1 decimal). 1 argument used.');
		// Case #15: String. String for maximum negative hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC("FFFFFFFFFF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC("FFFFFFFFFF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: String. String for maximum negative hex number. 1 argument used.');
		// Case #16: Formula. Nested formula for negative hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(DEC2HEX(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(DEC2HEX(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Formula. Nested formula for negative hex number. 1 argument used.');
		// Case #17: Reference link. Reference to cell with negative hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45, 'Test: Positive case: Reference link. Reference to cell with negative hex number. 1 argument used.');
		// Case #18: Name. Named range with negative hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with negative hex number. 1 argument used.');
		// Case #19: Ref3D. 3D reference to cell with negative hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Ref3D. 3D reference to cell with negative hex number. 1 argument used.');
		// Case #20: Table. Table reference with negative hex number. 1 argument used.
		oParser = new parserFormula('HEX2DEC(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table reference with negative hex number. 1 argument used.');
		// Case #21: Date. Date serial number converted to hex then back to decimal. 1 argument used.
		oParser = new parserFormula('HEX2DEC(DEC2HEX(DATE(2025,1,1)))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(DEC2HEX(DATE(2025,1,1))) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Positive case: Date. Date serial number converted to hex then back to decimal. 1 argument used.');
		// Case #22: Time. Time serial number converted to hex then back to decimal. 1 argument used.
		oParser = new parserFormula('HEX2DEC(DEC2HEX(TIME(12,0,0)))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(DEC2HEX(TIME(12,0,0))) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Time. Time serial number converted to hex then back to decimal. 1 argument used.');

		// Negative cases:
		// Case #1: String. Invalid hex string returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC("XYZ")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC("XYZ") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Invalid hex string returns #NUM!. 1 argument used.');
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('HEX2DEC(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #3: Empty. Empty reference returns #VALUE!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 61, 'Test: Negative case: Empty. Empty reference returns #VALUE!. 1 argument used.');
		// Case #4: Boolean. Boolean TRUE treated as invalid hex, returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean TRUE treated as invalid hex, returns #NUM!. 1 argument used.');
		// Case #5: Boolean. Boolean FALSE treated as invalid hex, returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE treated as invalid hex, returns #NUM!. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #7: Name. Named range with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #NUM!. 1 argument used.');
		// Case #8: Name3D. 3D named range with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with text returns #NUM!. 1 argument used.');
		// Case #9: Ref3D. 3D reference to text cell returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to text cell returns #NUM!. 1 argument used.');
		// Case #10: Table. Table column with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 31, 'Test: Negative case: Table. Table column with text returns #NUM!. 1 argument used.');
		// Case #11: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('HEX2DEC(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #12: Number. Hex number > 7FFFFFFFFF returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(8000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(8000000000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -549756000000, 'Test: Negative case: Number. Hex number > 7FFFFFFFFF returns #NUM!. 1 argument used.');
		// Case #13: String. String for hex number > 7FFFFFFFFF returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC("8000000000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC("8000000000") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -549756000000, 'Test: Negative case: String. String for hex number > 7FFFFFFFFF returns #NUM!. 1 argument used.');
		// Case #14: Array. Multi-element array returns #VALUE!. 1 argument used.
		oParser = new parserFormula('HEX2DEC({"1FF","FFFFFFFFFF"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC({"1FF","FFFFFFFFFF"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 511, 'Test: Negative case: Array. Multi-element array returns #VALUE!. 1 argument used.');
		// Case #15: Array. Array with invalid hex element returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC({"XYZ"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC({"XYZ"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with invalid hex element returns #NUM!. 1 argument used.');
		// Case #16: Reference link. Reference to cell with invalid hex returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Negative case: Reference link. Reference to cell with invalid hex returns #NUM!. 1 argument used.');
		// Case #17: Name. Named range with invalid hex returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name. Named range with invalid hex returns #NUM!. 1 argument used.');
		// Case #18: Ref3D. 3D reference to invalid hex cell returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC(Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to invalid hex cell returns #NUM!. 1 argument used.');
		// Case #20: String. Empty string returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2DEC("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String. Empty string returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive hex number (0 decimal). 1 argument used.
		oParser = new parserFormula('HEX2DEC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum positive hex number (0 decimal). 1 argument used.');
		// Case #2: Number. Maximum positive hex number (549,755,813,887 decimal). 1 argument used.
		oParser = new parserFormula('HEX2DEC("7FFFFFFFFF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC("7FFFFFFFFF") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 549756000000, 'Test: Bounded case: Number. Maximum positive hex number (549,755,813,887 decimal). 1 argument used.');
		// Case #3: Number. Maximum negative hex number (-1 decimal). 1 argument used.
		oParser = new parserFormula('HEX2DEC("FFFFFFFFFFFFFF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC("FFFFFFFFFFFFFF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum negative hex number (-1 decimal). 1 argument used.');
		// Case #4: Number. Minimum negative hex number (-549,755,813,888 decimal). 1 argument used.
		oParser = new parserFormula('HEX2DEC(8000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2DEC(8000000000) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -549756000000, 'Test: Bounded case: Number. Minimum negative hex number (-549,755,813,888 decimal). 1 argument used.');

		// Need to fix: boolean and error handle, different results with big numbers
		// Case #4: Boolean. Boolean TRUE treated as invalid hex, returns #NUM!. 1 argument used.
		// Case #5: Boolean. Boolean FALSE treated as invalid hex, returns #NUM!. 1 argument used.
		// Case #12: Number. Hex number > 7FFFFFFFFF returns #NUM!. 1 argument used.
		// Case #13: String. String for hex number > 7FFFFFFFFF returns #NUM!. 1 argument used.
		// Case #2: Number. Maximum positive hex number (549,755,813,887 decimal). 1 argument used.
		// Case #4: Number. Minimum negative hex number (-549,755,813,888 decimal). 1 argument used.

		testArrayFormula2(assert, "HEX2DEC", 1, 1, true);
	});

	QUnit.test("Test: \"HEX2OCT\"", function (assert) {

		oParser = new parserFormula("HEX2OCT(\"2a\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"2a\")");
		assert.strictEqual(oParser.calculate().getValue(), "52");

		oParser = new parserFormula("HEX2OCT(\"ffe0000000\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"ffe0000000\")");
		assert.strictEqual(oParser.calculate().getValue(), "4000000000");

		oParser = new parserFormula("HEX2OCT(\"ffe0000001\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"ffe0000001\")");
		assert.strictEqual(oParser.calculate().getValue(), "4000000001");

		oParser = new parserFormula("HEX2OCT(0)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(0)");
		assert.strictEqual(oParser.calculate().getValue(), "0");

		oParser = new parserFormula("HEX2OCT(1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(1)");
		assert.strictEqual(oParser.calculate().getValue(), "1");

		oParser = new parserFormula("HEX2OCT(\"1ffffffe\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"1ffffffe\")");
		assert.strictEqual(oParser.calculate().getValue(), "3777777776");

		oParser = new parserFormula("HEX2OCT(\"1fffffff\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"1fffffff\")");
		assert.strictEqual(oParser.calculate().getValue(), "3777777777");

		oParser = new parserFormula("HEX2OCT(\"2a\",2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"2a\",2)");
		assert.strictEqual(oParser.calculate().getValue(), "52");

		oParser = new parserFormula("HEX2OCT(\"2a\",4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"2a\",4)");
		assert.strictEqual(oParser.calculate().getValue(), "0052");

		oParser = new parserFormula("HEX2OCT(\"Hello World!\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"Hello World!\")");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("HEX2OCT(\"ffdfffffff\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"ffdfffffff\")");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("HEX2OCT(\"2a\", 1)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "HEX2OCT(\"2a\",1)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		// 	Data for reference link. Use A100-A111
		ws.getRange2("A1:C214").cleanAll();
		ws.getRange2("A100").setValue("F8");
		ws.getRange2("A101").setValue("2D");
		ws.getRange2("A104").setValue("0.5");
		// For area
		ws.getRange2("A102").setValue("3D");
		ws.getRange2("A103").setValue("1");
		ws.getRange2("A105").setValue("0.6");
		ws.getRange2("A106").setValue("0.7");
		ws.getRange2("A107").setValue("0.8");
		ws.getRange2("A108").setValue("0.9");
		ws.getRange2("A109").setValue("1");
		ws.getRange2("A110").setValue("2");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1.005"); // Number (Column1)
		ws.getRange2("B601").setValue("123s"); // Number (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:D10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #0: Number. Maximum positive hex number (511 decimal). 1 argument used.
		oParser = new parserFormula('HEX2OCT("1F")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1F") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '37', 'Test: Positive case: Number. Maximum positive hex number (511 decimal). 1 argument used.');
		// Case #1: Number, Number. Positive hex with valid places (8 chars). 2 arguments used.
		oParser = new parserFormula('HEX2OCT("1FF",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1FF",8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000777', 'Test: Positive case: Number, Number. Positive hex with valid places (8 chars). 2 arguments used.');
		// Case #2: String. String convertible to valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2OCT("1FF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1FF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '777', 'Test: Positive case: String. String convertible to valid hex number. 1 argument used.');
		// Case #3: String, Number. String hex with valid places. 2 arguments used.
		oParser = new parserFormula('HEX2OCT("1FF",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1FF",8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000777', 'Test: Positive case: String, Number. String hex with valid places. 2 arguments used.');
		// Case #4: Formula. Nested formula returning valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2OCT(HEX2DEC("1FF"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(HEX2DEC("1FF")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2421', 'Test: Positive case: Formula. Nested formula returning valid hex number. 1 argument used.');
		// Case #5: Formula, Formula. Nested formulas for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(HEX2DEC("1FF"),ABS(-8))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(HEX2DEC("1FF"),ABS(-8)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00002421', 'Test: Positive case: Formula, Formula. Nested formulas for both arguments. 2 arguments used.');
		// Case #6: Reference link. Reference to cell with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2OCT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '370', 'Test: Positive case: Reference link. Reference to cell with valid hex number. 1 argument used.');
		// Case #7: Reference link, Reference link. References to cells with valid hex and places. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link, Reference link. References to cells with valid hex and places. 2 arguments used.');
		// Case #8: Area. Single-cell range for number. 1 argument used.
		oParser = new parserFormula('HEX2OCT(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '370', 'Test: Positive case: Area. Single-cell range for number. 1 argument used.');
		// Case #9: Area, Area. Single-cell ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area, Area. Single-cell ranges for both arguments. 2 arguments used.');
		// Case #10: Array. Array with single valid hex element. 1 argument used.
		oParser = new parserFormula('HEX2OCT({"1FF"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT({"1FF"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '777', 'Test: Positive case: Array. Array with single valid hex element. 1 argument used.');
		// Case #11: Array, Array. Arrays with single elements for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2OCT({"1FF"},{8})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT({"1FF"},{8}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000777', 'Test: Positive case: Array, Array. Arrays with single elements for both arguments. 2 arguments used.');
		// Case #12: Name. Named range with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2OCT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid hex number. 1 argument used.');
		// Case #13: Name, Name. Named ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Name. Named ranges for both arguments. 2 arguments used.');
		// Case #14: Name3D. 3D named range with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2OCT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid hex number. 1 argument used.');
		// Case #15: Name3D, Name3D. 3D named ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(TestName3D,TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(TestName3D,TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Name3D. 3D named ranges for both arguments. 2 arguments used.');
		// Case #16: Ref3D. 3D reference to cell with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2OCT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Ref3D. 3D reference to cell with valid hex number. 1 argument used.');
		// Case #17: Ref3D, Ref3D. 3D references to cells for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '01', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells for both arguments. 2 arguments used.');
		// Case #18: Area3D. 3D single-cell range for number. 1 argument used.
		oParser = new parserFormula('HEX2OCT(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D. 3D single-cell range for number. 1 argument used.');
		// Case #19: Area3D, Area3D. 3D single-cell ranges for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '01', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges for both arguments. 2 arguments used.');
		// Case #20: Table. Table structured reference with valid hex number. 1 argument used.
		oParser = new parserFormula('HEX2OCT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with valid hex number. 1 argument used.');
		// Case #21: Table, Table. Table references for both arguments. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Table, Table. Table references for both arguments. 2 arguments used.');
		// Case #22: Formula. HEX2BIN inside SUM formula. 2 arguments used.
		oParser = new parserFormula('SUM(HEX2OCT("1FF"),0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(HEX2OCT("1FF"),0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 777, 'Test: Positive case: Formula. HEX2BIN inside SUM formula. 2 arguments used.');
		// Case #24: Number. Minimum negative hex number (-512 decimal), 10-char output. 1 argument used.
		oParser = new parserFormula('HEX2OCT("FFFFFFFE00")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("FFFFFFFE00") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777000', 'Test: Positive case: Number. Minimum negative hex number (-512 decimal), 10-char output. 1 argument used.');
		// Case #25: Number, Number. Negative hex ignores places, returns 10-char binary. 2 arguments used.
		oParser = new parserFormula('HEX2OCT("FFFFFFFE00",8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("FFFFFFFE00",8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777000', 'Test: Positive case: Number, Number. Negative hex ignores places, returns 10-char binary. 2 arguments used.');

		// Negative cases:
		// Case #1: String. Invalid hex string returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2OCT("XYZ")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("XYZ") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Invalid hex string returns #NUM!. 1 argument used.');
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('HEX2OCT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #3: Empty. Empty reference for number returns #VALUE!. 1 argument used.
		oParser = new parserFormula('HEX2OCT(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '75', 'Test: Negative case: Empty. Empty reference for number returns #VALUE!. 1 argument used.');
		// Case #4: Empty, Number. Empty reference for number returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(A102,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(A102,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000075', 'Test: Negative case: Empty, Number. Empty reference for number returns #VALUE!. 2 arguments used.');
		// Case #5: Number, Empty. Empty reference for places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2OCT("1BB",A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1BB",A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Empty. Empty reference for places returns #VALUE!. 2 arguments used.');
		// Case #6: Boolean. Boolean TRUE treated as invalid hex, returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2OCT(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean TRUE treated as invalid hex, returns #NUM!. 1 argument used.');
		// Case #7: Boolean, Number. Boolean FALSE treated as invalid hex, returns #NUM!. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(FALSE,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(FALSE,8) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE treated as invalid hex, returns #NUM!. 2 arguments used.');
		// Case #8: Area. Multi-cell range for number returns #VALUE!. 1 argument used.
		oParser = new parserFormula('HEX2OCT(A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range for number returns #VALUE!. 1 argument used.');
		// Case #9: Area, Number. Multi-cell range for number returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2OCT(A100:A101,8)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(A100:A101,8) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell range for number returns #VALUE!. 2 arguments used.');
		// Case #10: Number, Area. Multi-cell range for places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2OCT("1FF0",A100:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1FF0",A100:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, Area. Multi-cell range for places returns #VALUE!. 2 arguments used.');
		// Case #11: Name. Named range with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2OCT(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with text returns #NUM!. 1 argument used.');
		// Case #12: Name3D. 3D named range with text returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2OCT(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with text returns #NUM!. 1 argument used.');
		// Case #13: Ref3D. 3D reference to text cell returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2OCT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to text cell returns #NUM!. 1 argument used.');
		// Case #15: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('HEX2OCT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(SQRT(-1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #16: Number. Positive hex > 1FF returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2OCT(200)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(200) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1000', 'Test: Negative case: Number. Positive hex > 1FF returns #NUM!. 1 argument used.');
		// Case #17: Number. Negative hex < FFFFFFFE00 returns #NUM!. 1 argument used.
		oParser = new parserFormula('HEX2OCT("FFFFFFFDFF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("FFFFFFFDFF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777776777', 'Test: Negative case: Number. Negative hex < FFFFFFFE00 returns #NUM!. 1 argument used.');
		// Case #18: Number, Number. Places too small for binary result returns #NUM!. 2 arguments used.
		oParser = new parserFormula('HEX2OCT("1FF",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1FF",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Places too small for binary result returns #NUM!. 2 arguments used.');
		// Case #19: Number, Number. Negative places returns #NUM!. 2 arguments used.
		oParser = new parserFormula('HEX2OCT("1FF",-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1FF",-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative places returns #NUM!. 2 arguments used.');
		// Case #20: Number, String. Non-numeric places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('HEX2OCT("1FF","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1FF","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Number, String. Non-numeric places returns #VALUE!. 2 arguments used.');

		// Bounded cases:
		// Case #1: Number. Minimum positive hex number (0). 1 argument used.
		oParser = new parserFormula('HEX2OCT(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number. Minimum positive hex number (0). 1 argument used.');
		// Case #2: Number. Maximum positive hex number (511 decimal). 1 argument used.
		oParser = new parserFormula('HEX2OCT(0.00001)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT(0.00001) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum positive hex number (511 decimal). 1 argument used.');
		// Case #3: Number. Minimum negative hex number (-512 decimal). 1 argument used.
		oParser = new parserFormula('HEX2OCT("FFFFFFFE00")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("FFFFFFFE00") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777000', 'Test: Bounded case: Number. Minimum negative hex number (-512 decimal). 1 argument used.');
		// Case #4: Number. Maximum negative hex number (-1 decimal). 1 argument used.
		oParser = new parserFormula('HEX2OCT("FFFFFFFFFF")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("FFFFFFFFFF") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7777777777', 'Test: Bounded case: Number. Maximum negative hex number (-1 decimal). 1 argument used.');
		// Case #5: Number, Number. Maximum places for 1FF (9 bits needed, 10 allowed). 2 arguments used.
		oParser = new parserFormula('HEX2OCT("1FF",1E+307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: HEX2OCT("1FF",1E+307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number. Maximum places for 1FF (9 bits needed, 10 allowed). 2 arguments used.');

		// Need to fix: error and boolean handle
		// Case #2: Error. Propagates #N/A error. 1 argument used.
		// Case #6: Boolean. Boolean TRUE treated as invalid hex, returns #NUM!. 1 argument used.
		// Case #7: Boolean, Number. Boolean FALSE treated as invalid hex, returns #NUM!. 2 arguments used.
		// Case #15: Formula. Formula resulting in #NUM! error. 1 argument used.

		testArrayFormula2(assert, "HEX2OCT", 1, 2, true);
	});

	QUnit.test("Test: \"IMABS\"", function (assert) {
		oParser = new parserFormula('IMABS("5+12i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMABS("5+12i"');
		assert.strictEqual(oParser.calculate().getValue(), 13, 'IMABS("5+12i"');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 1);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMABS("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMABS("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMABS(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21.02379604162864, 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21, 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMABS("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMABS(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMABS("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMABS("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMABS("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.9154759474226504, 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMABS({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMABS(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMABS(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMABS("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMABS("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 33.55964838909967, 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMABS("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 33.55964838909967, 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMABS(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 42.14558102577303, 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.6870057685088806, 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4.1012193308819755, 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99.04544411531506, 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMABS(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMABS(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMABS("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMABS(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.020761493398643, 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMABS(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 9, 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMABS(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMABS({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.23606797749979, 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMABS(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMABS(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMABS("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMABS(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMABS(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 57.697486947006624, 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMABS(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMABS(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMABS(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMABS(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMABS(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(SQRT(-1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMABS("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMABS(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMABS(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMABS({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMABS(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMABS(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMABS("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMABS("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMABS(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMABS({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS({"3+4i";"abc"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMABS(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMABS("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.4142e+307, 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMABS("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.4142e-307, 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMABS("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMABS("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');

		// Need to fix: error handle, error type diff, ms result diff, boundary cases
		// Case #2: Error. Propagates #N/A error.
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		// Case #10: String. Empty string returns #VALUE!.
		// Case #13: Array. Array with boolean returns #VALUE!.
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.

		testArrayFormula(assert, "IMABS", true);
	});

	QUnit.test("Test: \"IMAGINARY\"", function (assert) {
		oParser = new parserFormula('IMAGINARY("3+4i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMAGINARY("3+4i")');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'IMAGINARY("3+4i")');

		oParser = new parserFormula('IMAGINARY("0-j")', "A2", ws);
		assert.ok(oParser.parse(), 'IMAGINARY("0-j")');
		assert.strictEqual(oParser.calculate().getValue(), -1, 'IMAGINARY("0-j")');

		oParser = new parserFormula('IMAGINARY("4")', "A2", ws);
		assert.ok(oParser.parse(), 'IMAGINARY("4")');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'IMAGINARY("4")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMAGINARY("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMAGINARY("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -4, 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21, 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMAGINARY("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMAGINARY(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMAGINARY("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMAGINARY("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMAGINARY("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.5, 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMAGINARY("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMAGINARY("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMAGINARY("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -42, 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9, 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.9, 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 99, 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMAGINARY(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2.75, 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMAGINARY(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -9, 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMAGINARY({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMAGINARY(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -2, 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMAGINARY("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMAGINARY(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -52, 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 123, 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMAGINARY(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMAGINARY("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMAGINARY({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMAGINARY("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMAGINARY("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMAGINARY({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMAGINARY(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMAGINARY("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMAGINARY("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMAGINARY("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMAGINARY("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');

		// Need to fix:
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		// Case #10: String. Empty string returns #VALUE!.
		// Case #13: Array. Array with boolean returns #VALUE!.

		testArrayFormula(assert, "IMAGINARY", true);
	});

	QUnit.test("Test: \"IMARGUMENT\"", function (assert) {
		oParser = new parserFormula('IMARGUMENT("3+4i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMARGUMENT("3+4i")');
		assert.strictEqual(oParser.calculate().getValue().toFixed(8) - 0, 0.92729522, 'IMARGUMENT("3+4i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMARGUMENT("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9272952180016123, 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMARGUMENT("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.9272952180016123, 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9272952180016123, 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.04758310327698479, 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9272952180016123, 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.141592653589793, 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.141592653589793, 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9272952180016123, 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMARGUMENT("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMARGUMENT(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMARGUMENT("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMARGUMENT("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9272952180016123, 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMARGUMENT("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.0303768265243125, 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9272952180016123, 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9272952180016123, 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMARGUMENT("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMARGUMENT("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.081961940458623, 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMARGUMENT("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.081961940458623, 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.6539375586833378, 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7853981633974484, 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.7853981633974483, 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.6010900867136717, 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.141592653589793, 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3.141592653589793, 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMARGUMENT(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.1441688336680205, 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMARGUMENT(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.5707963267948966, 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9272952180016123, 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMARGUMENT({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.1071487177940904, 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMARGUMENT(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.5707963267948966, 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMARGUMENT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -1.122651351719107, 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5707963267948966, 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMARGUMENT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9272952180016123, 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMARGUMENT({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.9272952180016123, 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMARGUMENT(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMARGUMENT("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.785398163, 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMARGUMENT("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0.785398163, 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMARGUMENT("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMARGUMENT("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1.570796327, 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');

		// Need to fix:
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		// Case #10: String. Empty string returns #VALUE!.
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.

		testArrayFormula(assert, "IMARGUMENT", true);
	});

	QUnit.test("Test: \"IMCONJUGATE\"", function (assert) {
		oParser = new parserFormula('IMCONJUGATE("3+4i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMCONJUGATE("3+4i")');
		assert.strictEqual(oParser.calculate().getValue(), "3-4i", 'IMCONJUGATE("3+4i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMCONJUGATE("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3-4i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCONJUGATE("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3-4i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '21-i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-21i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3-4i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3-4i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMCONJUGATE("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMCONJUGATE(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMCONJUGATE("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMCONJUGATE("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMCONJUGATE("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5-2.5i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3-4i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3-4i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMCONJUGATE("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMCONJUGATE("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-33.5-2i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCONJUGATE("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-33.5+2i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.5+42i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.9-1.9i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.9-2.9i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3-99i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-5i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMCONJUGATE(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.25+2.75i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMCONJUGATE(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '9i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3-4i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMCONJUGATE({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1-2i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMCONJUGATE(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMCONJUGATE(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '25+52i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-123i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMCONJUGATE(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '45658', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("3+4j") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '3-4j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMCONJUGATE({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3-4i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMCONJUGATE(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMCONJUGATE("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1E+307-1E+307i', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMCONJUGATE("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1E-307-1E-307i', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMCONJUGATE("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCONJUGATE("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-1E-307i', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');

		// Need to fix: [obj Obj] problem, ms result diff, error handle, boundary case problem, suffix j instead of i
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5. - [obj obj]
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		// Case #10: String. Empty string returns #VALUE!.
		// Case #13: Array. Array with boolean returns #VALUE!.
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!

		testArrayFormula(assert, "IMCONJUGATE", true);
	});

	QUnit.test("Test: \"IMCOS\"", function (assert) {
		oParser = new parserFormula('IMCOS("1+i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMCOS("1+i")');
		assert.strictEqual(oParser.calculate().getValue(), "0.8337300251311491-0.9888977057628651i", 'IMCOS("1+i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMCOS("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422-3.8511533348117766i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCOS("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422+3.8511533348117766i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "0.28366218546322625", 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCOS(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422-3.8511533348117766i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.8451904145737479-0.9832387050763899i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "659407867.2416066", 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422-3.8511533348117766i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "0.8775825618903728", 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "0.8775825618903728", 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "0.5403023058681398", 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "-0.4161468365471424", 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5403023058681398', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422-3.8511533348117766i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMCOS("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "27.308232836016483", 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMCOS(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "27.308232836016483", 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMCOS("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMCOS("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMCOS("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.433780997607703-6.035048637766572i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMCOS({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422-3.8511533348117766i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMCOS(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "1.5430806348152437", 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMCOS(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422-3.8511533348117766i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMCOS("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "1", 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMCOS("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.8473687225427908+3.1595031763054306i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCOS("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.8473687225427908-3.1595031763054306i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMCOS(COMPLEX(-3.5,-4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-25.572977257381744+9.572845237790935i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.1049169462322135-3.092662849756002i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-8.849880042931476-2.1674939100934836i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4.895032907403866e+42+6.977700191852525e+41i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "0.8775825618903728", 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8775825618903728', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "1", 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOS(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMCOS(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMCOS("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "74.20994852478783", 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMCOS(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.4763147620101713+7.391975253651201i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMCOS(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "4051.542025492592", 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCOS(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422-3.8511533348117766i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMCOS({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.0327230070196656-3.0518977991517997i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMCOS(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMCOS(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "3.762195691083631", 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMCOS("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMCOS(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMCOS(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.898652951290862e+22-2.53520306766704e+21i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCOS(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMCOS(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMCOS(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMCOS(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6967067093471654', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMCOS(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.3097586593745228e+53', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMCOS(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMCOS("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCOS(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "-0.33049778329909046", 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCOS(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "0.8775825618903728", 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMCOS({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMCOS(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6967067093471654', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCOS(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMCOS("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422-3.8511533348117766j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMCOS("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMCOS(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMCOS({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-27.03494560307422-3.8511533348117766i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMCOS(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMCOS("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMCOS("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMCOS("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOS("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMCOS", true);
	});

	QUnit.test("Test: \"IMCOSH\"", function (assert) {
		oParser = new parserFormula('IMCOSH("4+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMCOSH("4+3i")');
		assert.strictEqual(oParser.calculate().getValue(), "-27.03494560307422+3.8511533348117766i", 'IMCOSH("4+3i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMCOSH("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155-7.581552742746543i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCOSH("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155+7.581552742746543i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "74.20994852478783", 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155-7.581552742746543i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '356279591.17823225+554872587.4378694i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5477292602242684', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155-7.581552742746543i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1276259652063807', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1276259652063807', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5430806348152437', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.762195691083631', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5430806348152437', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155-7.581552742746543i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMCOSH("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.6536436208636119', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMCOSH(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.6536436208636119', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMCOSH("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMCOSH("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMCOSH("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.8846179444033462+1.2743144408870997i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMCOSH({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155-7.581552742746543i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5403023058681398', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155-7.581552742746543i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMCOSH("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMCOSH("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-73634568411911.11-160894467294083.22i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCOSH("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-73634568411911.11+160894467294083.22i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.628886496299578-15.161674368254626i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.1049169462322135+3.092662849756002i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-8.849880042931476+2.1674939100934836i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.4009031641724164+10.009929091492095i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1276259652063807', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1276259652063807', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMCOSH("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.28366218546322625', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMCOSH(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.7454746815262658-0.6113900253751718i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMCOSH(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.9111302618846769', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155-7.581552742746543i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMCOSH({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.64214812471552+1.0686074213827783i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMCOSH(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMCOSH(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.4161468365471424', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMCOSH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMCOSH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMCOSH(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-5868067382.058341-35521010224.18123i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCOSH(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMCOSH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMCOSH(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMCOSH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.3374349463048445', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMCOSH(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.8879689066918555', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMCOSH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMCOSH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCOSH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCOSH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1276259652063807', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMCOSH({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns num!.
		oParser = new parserFormula('IMCOSH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.3374349463048445', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCOSH(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Another complex number suffix (j instead of i) returns complex number with 'J'.
		oParser = new parserFormula('IMCOSH("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155-7.581552742746543j', 'Test: Negative case: String. Another complex number suffix (j instead of i) returns complex number with J');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMCOSH("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMCOSH(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMCOSH({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.580663040551155-7.581552742746543i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMCOSH(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMCOSH("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMCOSH("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMCOSH("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOSH("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMCOSH", true);
	});

	QUnit.test("Test: \"IMCOT\"", function (assert) {
		oParser = new parserFormula('IMCOT("4+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMCOT("4+3i")');
		assert.strictEqual(oParser.calculate().getValue(), "0.004901182394304475-0.9992669278059015i", 'IMCOT("4+3i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMCOT("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928-1.0006443924715591i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCOT("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928+1.0006443924715591i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.2958129155327455', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCOT(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928-1.0006443924715591i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.22020223209383968-0.8713845944123975i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928-1.0006443924715591i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.830487721712452', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.830487721712452', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6420926159343306', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.45765755436028577', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6420926159343306', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928-1.0006443924715591i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMCOT("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.0006711504016825i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMCOT(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.0006711504016825i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMCOT("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMCOT("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMCOT("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.001876597323656544-0.9867455954078999i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMCOT({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928-1.0006443924715591i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMCOT(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.3130352854993315i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMCOT(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928-1.0006443924715591i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMCOT("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMCOT("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.030745342411290327-0.9807343711673333i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCOT("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.030745342411290327+0.9807343711673333i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMCOT(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4.343602022316227e-37+i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.02642701251358319-0.9648707541300694i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.0028283565559124794-1.0053723422691785i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5.71443201249831e-87-i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.830487721712452', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.830487721712452', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCOT(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMCOT(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMCOT("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.0000908039820193i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMCOT(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.0048597341425140215+0.9934613404437033i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMCOT(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.0000000304599599i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCOT(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928-1.0006443924715591i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMCOT({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.0327977555337526-0.984329226458191i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMCOT(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMCOT(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.037314720727548i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMCOT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMCOT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMCOT(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.575411948512727e-46+i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCOT(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMCOT(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMCOT(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMCOT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.9712146006504743', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMCOT(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMCOT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMCOT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCOT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.350175263116418', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCOT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.830487721712452', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMCOT({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMCOT(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.9712146006504743', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCOT(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Another complex number suffix (j instead of i) returns complex num.
		oParser = new parserFormula('IMCOT("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928-1.0006443924715591j', 'Test: Negative case: String. Another complex number suffix (j instead of i) returns complex num');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMCOT("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMCOT(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMCOT({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018758773798365928-1.0006443924715591i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMCOT(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMCOT("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-i', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMCOT("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMCOT("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCOT("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMCOT", true);
	});

	QUnit.test("Test: \"IMCSC\"", function (assert) {
		oParser = new parserFormula('IMCSC("4+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMCSC("4+3i")');
		assert.strictEqual(oParser.calculate().getValue(), "-0.0754898329158637+0.06487747137063551i", 'IMCSC("4+3i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMCSC("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398+0.03627588962862602i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCSC("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398-0.03627588962862602i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.0428352127714058', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCSC(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398+0.03627588962862602i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6203608694338667+0.3093051837342723i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.516512085582383e-9i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398+0.03627588962862602i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.085829642933488', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.085829642933488', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1883951057781212', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.0997501702946164', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1883951057781212', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398+0.03627588962862602i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMCSC("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.03664357032586561i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMCSC(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.03664357032586561i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMCSC("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMCSC("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMCSC("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.16268438323986295-0.01138231037666445i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMCSC({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398+0.03627588962862602i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMCSC(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-0.850918128239322i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMCSC(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398+0.03627588962862602i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMCSC("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("0+0i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMCSC("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.23556377808645587+0.1280036103215941i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCSC("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.23556377808645587-0.1280036103215941i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMCSC(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.0336719550844614e-19-1.0768357146250074e-18i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.27937936509209277+0.09126891488560936i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.026550365576770908+0.10710027502890425i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.854071703749964e-44+2.002203380170904e-43i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.085829642933488', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.085829642933488', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSC(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMCSC(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMCSC("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.01347650583058909i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMCSC(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.12103439806221165+0.03988913955634696i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMCSC(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.00024681961193241686i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCSC(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398+0.03627588962862602i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMCSC({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.2283750655996866-0.14136302161240782i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMCSC(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMCSC(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.27572056477178325i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMCSC("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMCSC(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMCSC(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.90950006228217e-24+5.1746319072060156e-23i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCSC(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMCSC(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMCSC(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMCSC(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.394007819388636', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMCSC(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-7.634994377342399e-54i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMCSC(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMCSC("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCSC(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.0595389161794164', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCSC(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.085829642933488', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMCSC({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMCSC(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.394007819388636', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCSC(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMCSC("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("3+4j") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398+0.03627588962862602j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMCSC("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMCSC(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMCSC({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.005174473184019398+0.03627588962862602i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMCSC(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMCSC("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMCSC("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMCSC("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSC("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');

		// Need to fix:
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5. [obj Obj]
		// Case #21: String. Zero complex number. Returns modulus 0. - Infinity
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!. - j
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2). - NaN
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2). - NaN
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307. - NaN

		testArrayFormula(assert, "IMCSC", true);
	});

	QUnit.test("Test: \"IMCSCH\"", function (assert) {

		oParser = new parserFormula('IMCSCH("4+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMCSCH("4+3i")');
		//assert.strictEqual( oParser.calculate().getValue(), "-0.03627588962862601-0.0051744731840193976i", 'IMCSCH("4+3i")' );

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMCSCH("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551+0.0754898329158637i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCSCH("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551-0.0754898329158637i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.01347650583058909', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551+0.0754898329158637i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '8.193749767170633e-10-1.276100918128085e-9i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.1952348779358697i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551+0.0754898329158637i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.9190347513349437', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.9190347513349437', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8509181282393216', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.27572056477178325', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8509181282393216', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551+0.0754898329158637i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMCSCH("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.3213487088109024i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMCSCH(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.3213487088109024i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMCSCH("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMCSCH("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMCSCH("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.348703735534849-0.2877865195298138i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMCSCH({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551+0.0754898329158637i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-1.18839510577812i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551+0.0754898329158637i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMCSCH("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("0+0i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMCSCH("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.3518599117663976e-15-5.138907660016298e-15i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMCSCH("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.3518599117663976e-15+5.138907660016298e-15i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.02410507627359925-0.0553349081985277i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.09126891488560936-0.27937936509209277i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.10710027502890425-0.026550365576770908i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.0039358270329739944+0.09925069664050738i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.9190347513349437', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.9190347513349437', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMCSCH("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.0428352127714058i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMCSCH(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5460034798649691+0.2657773846712184i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMCSCH(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.4264866435519896i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551+0.0754898329158637i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMCSCH({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.2215009308505094-0.6354937992538999i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMCSCH(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMCSCH(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.0997501702946166i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMCSCH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMCSCH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMCSCH(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4.5272136283948326e-12+2.74044572277658e-11i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCSCH(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMCSCH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMCSCH(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMCSCH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1259917397884818', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMCSCH(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.1743692323373627i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMCSCH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMCSCH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCSCH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMCSCH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.9190347513349437', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMCSCH({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMCSCH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1259917397884818', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMCSCH(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMCSCH("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("3+4j") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551+0.0754898329158637j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMCSCH("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMCSCH(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMCSCH({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06487747137063551+0.0754898329158637i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMCSCH(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMCSCH("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMCSCH("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMCSCH("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMCSCH("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');

		// Need to fix: ms res diff, nan, infinity, obj problems
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5. [obj Obj]
		// Case #21: String. Zero complex number. Returns modulus 0. - Infinity
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!. - j
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2). - NaN
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2). - NaN
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307. - NaN


		testArrayFormula(assert, "IMCSCH", true);
	});

	QUnit.test("Test: \"IMDIV\"", function (assert) {
		oParser = new parserFormula('IMDIV("-238+240i","10+24i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMDIV("-238+240i","10+24i")');
		assert.strictEqual(oParser.calculate().getValue(), "5+12i", 'IMDIV("-238+240i","10+24i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String, String. Divides two complex numbers as strings. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV("3+4i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("3+4i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5+0.5i', 'Test: Positive case: String, String. Divides two complex numbers as strings. Returns 3.5+0.5i.');
		// Case #2: String, String. Complex numbers with negative imaginary parts. Returns 3.5-0.5i.
		oParser = new parserFormula('IMDIV("3-4i","1-1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("3-4i","1-1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5-0.5i', 'Test: Positive case: String, String. Complex numbers with negative imaginary parts. Returns 3.5-0.5i.');
		// Case #3: Number, Number. Real numbers as strings convertible to complex. Returns 2.5.
		oParser = new parserFormula('IMDIV("5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.5', 'Test: Positive case: Number, Number. Real numbers as strings convertible to complex. Returns 2.5.');
		// Case #4: Formula, Formula. Complex numbers via COMPLEX formula. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(COMPLEX(3,4),COMPLEX(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(COMPLEX(3,4),COMPLEX(1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5+0.5i', 'Test: Positive case: Formula, Formula. Complex numbers via COMPLEX formula. Returns 3.5+0.5i.');
		// Case #5: Reference link, Reference link. References to cells with complex numbers. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.04761904761904762-i', 'Test: Positive case: Reference link, Reference link. References to cells with complex numbers. Returns 3.5+0.5i.');
		// Case #6: Area, Area. Single-cell ranges with complex numbers. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.04761904761904762-i', 'Test: Positive case: Area, Area. Single-cell ranges with complex numbers. Returns 3.5+0.5i.');
		// Case #7: Array, Array. Arrays with single complex numbers. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV({"3+4i"},{"1+1i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV({"3+4i"},{"1+1i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5+0.5i', 'Test: Positive case: Array, Array. Arrays with single complex numbers. Returns 3.5+0.5i.');
		// Case #8: Name, Name. Named ranges with complex numbers. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1', 'Test: Positive case: Name, Name. Named ranges with complex numbers. Returns 3.5+0.5i.');
		// Case #9: Name3D, Name3D. 3D named ranges with complex numbers. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Name3D, Name3D. 3D named ranges with complex numbers. Returns 3.5+0.5i.');
		// Case #10: Ref3D, Ref3D. 3D references to cells with complex numbers. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells with complex numbers. Returns 3.5+0.5i.');
		// Case #11: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns 3.5+0.5i.');
		// Case #12: Table, Table. Table structured references with complex numbers. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table, Table. Table structured references with complex numbers. Returns 3.5+0.5i.');
		// Case #13: Formula, String. Nested IF returning complex number, divided by string. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(IF(TRUE, "3+4i", "1+2i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(IF(TRUE, "3+4i", "1+2i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5+0.5i', 'Test: Positive case: Formula, String. Nested IF returning complex number, divided by string. Returns 3.5+0.5i.');
		// Case #14: String, String. Pure imaginary numbers as strings. Returns 2.
		oParser = new parserFormula('IMDIV("4i","2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("4i","2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2', 'Test: Positive case: String, String. Pure imaginary numbers as strings. Returns 2.');
		// Case #15: Formula, Formula. Pure imaginary numbers via COMPLEX. Returns 2.
		oParser = new parserFormula('IMDIV(COMPLEX(0,4),COMPLEX(0,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(COMPLEX(0,4),COMPLEX(0,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2', 'Test: Positive case: Formula, Formula. Pure imaginary numbers via COMPLEX. Returns 2.');
		// Case #16: Formula, String. IMDIV inside SUM formula for numerator. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(SUM("3+4i","0+0i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(SUM("3+4i","0+0i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula, String. IMDIV inside SUM formula for numerator. Returns 3.5+0.5i.');
		// Case #17: String, String. Complex numbers with decimal values. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV("1.5+2.5i","0.5+0.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("1.5+2.5i","0.5+0.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4+i', 'Test: Positive case: String, String. Complex numbers with decimal values. Returns 3.5+0.5i.');
		// Case #18: Array, Array. Multi-element arrays, processes first elements. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV({"3+4i";"1+2i"},{"1+1i";"2+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV({"3+4i";"1+2i"},{"1+1i";"2+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5+0.5i', 'Test: Positive case: Array, Array. Multi-element arrays, processes first elements. Returns 3.5+0.5i.');
		// Case #19: Reference link, Reference link. References to cells with real numbers as complex. Returns 2.5.
		oParser = new parserFormula('IMDIV(A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A102,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '0.263157894736842+0.263157894736842i', 'Test: Positive case: Reference link, Reference link. References to cells with real numbers as complex. Returns 2.5.');
		// Case #20: Formula, String. Complex number string built by CONCATENATE. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(CONCATENATE("3+","4i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(CONCATENATE("3+","4i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5+0.5i', 'Test: Positive case: Formula, String. Complex number string built by CONCATENATE. Returns 3.5+0.5i.');
		// Case #21: String, String. Complex number with negative real part. Returns -1.5+2.5i.
		oParser = new parserFormula('IMDIV("-3+4i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("-3+4i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5+3.5i', 'Test: Positive case: String, String. Complex number with negative real part. Returns -1.5+2.5i.');
		// Case #22: String, String. Complex number with both negative parts. Returns -3.5-0.5i.
		oParser = new parserFormula('IMDIV("-3-4i","1-1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("-3-4i","1-1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5-3.5i', 'Test: Positive case: String, String. Complex number with both negative parts. Returns -3.5-0.5i.');
		// Case #23: Formula, Formula. Complex numbers with negative parts via COMPLEX. Returns -3.5-0.5i.
		oParser = new parserFormula('IMDIV(COMPLEX(-3,-4),COMPLEX(1,-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(COMPLEX(-3,-4),COMPLEX(1,-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5-3.5i', 'Test: Positive case: Formula, Formula. Complex numbers with negative parts via COMPLEX. Returns -3.5-0.5i.');
		// Case #24: Reference link, Reference link. References to cells with negative complex numbers. Returns -1.5+2.5i.
		oParser = new parserFormula('IMDIV(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.3222222222222222+0.3222222222222222i', 'Test: Positive case: Reference link, Reference link. References to cells with negative complex numbers. Returns -1.5+2.5i.');
		// Case #25: Area, Area. Single-cell ranges with negative complex numbers. Returns -1.5+2.5i.
		oParser = new parserFormula('IMDIV(A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.3222222222222222+0.3222222222222222i', 'Test: Positive case: Area, Area. Single-cell ranges with negative complex numbers. Returns -1.5+2.5i.');
		// Case #26: Array, Array. Arrays with single negative complex numbers. Returns -1.5+2.5i.
		oParser = new parserFormula('IMDIV({"-3+4i"},{"1+1i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV({"-3+4i"},{"1+1i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5+3.5i', 'Test: Positive case: Array, Array. Arrays with single negative complex numbers. Returns -1.5+2.5i.');
		// Case #27: Name, Name. Named ranges with negative complex numbers. Returns -1.5+2.5i.
		oParser = new parserFormula('IMDIV(TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Name, Name. Named ranges with negative complex numbers. Returns -1.5+2.5i.');
		// Case #29: Ref3D, Ref3D. 3D references to cells with negative complex numbers. Returns -1.5+2.5i.
		oParser = new parserFormula('IMDIV(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells with negative complex numbers. Returns -1.5+2.5i.');
		// Case #30: Area3D, Area3D. 3D single-cell ranges with negative complex numbers. Returns -1.5+2.5i.
		oParser = new parserFormula('IMDIV(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges with negative complex numbers. Returns -1.5+2.5i.');
		// Case #31: Table, Table. Table structured references with negative complex numbers. Returns -1.5+2.5i.
		oParser = new parserFormula('IMDIV(Table1[Column3],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(Table1[Column3],Table1[Column3]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '', 'Test: Positive case: Table, Table. Table structured references with negative complex numbers. Returns -1.5+2.5i.');
		// Case #32: Formula, String. Complex number formatted by TEXT function. Returns -1.5+2.5i.
		oParser = new parserFormula('IMDIV(TEXT("-3+4i","0+0i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(TEXT("-3+4i","0+0i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5+3.5i', 'Test: Positive case: Formula, String. Complex number formatted by TEXT function. Returns -1.5+2.5i.');
		// Case #33: String, String. Pure imaginary numbers with zero real parts. Returns 2.5.
		oParser = new parserFormula('IMDIV("0+5i","0+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("0+5i","0+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.5', 'Test: Positive case: String, String. Pure imaginary numbers with zero real parts. Returns 2.5.');
		// Case #34: Formula, Formula. Complex numbers with decimal coefficients via COMPLEX. Returns -2.5-0.5i.
		oParser = new parserFormula('IMDIV(COMPLEX(1.25,-2.75),COMPLEX(0.5,-0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(COMPLEX(1.25,-2.75),COMPLEX(0.5,-0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4-1.5i', 'Test: Positive case: Formula, Formula. Complex numbers with decimal coefficients via COMPLEX. Returns -2.5-0.5i.');
		// Case #35: Reference link, Reference link. References to cells with decimal complex numbers. Returns -2.5-0.5i.
		oParser = new parserFormula('IMDIV(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.031240612796635626-0.015019525382997898i', 'Test: Positive case: Reference link, Reference link. References to cells with decimal complex numbers. Returns -2.5-0.5i.');
		// Case #36: Formula, Formula. Nested IF with COMPLEX formula for numerator. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(IF(1>0, COMPLEX(3,4), "1+2i"),COMPLEX(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(IF(1>0, COMPLEX(3,4), "1+2i"),COMPLEX(1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5+0.5i', 'Test: Positive case: Formula, Formula. Nested IF with COMPLEX formula for numerator. Returns 3.5+0.5i.');
		// Case #37: Array, Array. Multi-element arrays, processes first elements. Returns 0.5.
		oParser = new parserFormula('IMDIV({"1+2i";"3+4i"},{"2+2i";"1+1i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV({"1+2i";"3+4i"},{"2+2i";"1+1i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.75+0.25i', 'Test: Positive case: Array, Array. Multi-element arrays, processes first elements. Returns 0.5.');
		// Case #38: Formula, String. Complex number string converted by VALUE. Returns 3.5+0.5i.
		oParser = new parserFormula('IMDIV(VALUE("3+4i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(VALUE("3+4i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula, String. Complex number string converted by VALUE. Returns 3.5+0.5i.');
		// Case #39: Reference link, Reference link. References to cells with pure imaginary numbers. Returns 2.
		oParser = new parserFormula('IMDIV(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.13676358877567352+0.22564190256170907i', 'Test: Positive case: Reference link, Reference link. References to cells with pure imaginary numbers. Returns 2.');
		// Case #40: String, Number. Complex number divided by real number as string. Returns 5+5i.
		oParser = new parserFormula('IMDIV("10+10i","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("10+10i","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5+5i', 'Test: Positive case: String, Number. Complex number divided by real number as string. Returns 5+5i.');

		// Negative cases:
		// Case #1: String, String. Non-numeric string numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV("abc","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("abc","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, String. Non-numeric string numerator returns #VALUE!.');
		// Case #2: String, String. Non-numeric string denominator returns #VALUE!.
		oParser = new parserFormula('IMDIV("3+4i","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("3+4i","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, String. Non-numeric string denominator returns #VALUE!.');
		// Case #3: Error, String. Propagates #N/A error in numerator.
		oParser = new parserFormula('IMDIV(NA(),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(NA(),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, String. Propagates #N/A error in numerator.');
		// Case #4: Empty, String. Reference to empty cell in numerator. Returns #VALUE!.
		oParser = new parserFormula('IMDIV(A110,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A110,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Empty, String. Reference to empty cell in numerator. Returns #VALUE!.');
		// Case #5: Area, String. Multi-cell range in numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV(A100:A101,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A100:A101,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, String. Multi-cell range in numerator returns #VALUE!.');
		// Case #6: Boolean, String. Boolean FALSE in numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV(FALSE,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(FALSE,"1+1i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, String. Boolean FALSE in numerator returns #VALUE!.');
		// Case #7: Ref3D, String. 3D reference to cell with text in numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV(Sheet2!A5,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(Sheet2!A5,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Ref3D, String. 3D reference to cell with text in numerator returns #VALUE!.');
		// Case #8: Name, String. Named range with text in numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV(TestNameArea2,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(TestNameArea2,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.4-0.4i', 'Test: Negative case: Name, String. Named range with text in numerator returns #VALUE!.');
		// Case #9: Table, String. Table column with text in numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV(Table1[Column1],"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(Table1[Column1],"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5-0.5i', 'Test: Negative case: Table, String. Table column with text in numerator returns #VALUE!.');
		// Case #10: Formula, String. Formula resulting in #NUM! in numerator propagates error.
		oParser = new parserFormula('IMDIV(SQRT(-1),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(SQRT(-1),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, String. Formula resulting in #NUM! in numerator propagates error.');
		// Case #11: String, Empty. Reference to empty cell in denominator. Returns #VALUE!.
		oParser = new parserFormula('IMDIV("3+4i",A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("3+4i",A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Empty. Reference to empty cell in denominator. Returns #VALUE!.');
		// Case #12: Date, String. Date serial number in numerator not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMDIV(DATE(2025,1,1),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(DATE(2025,1,1),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '22829-22829i', 'Test: Negative case: Date, String. Date serial number in numerator not valid complex number, returns #VALUE!.');
		// Case #13: Time, String. Time value in numerator not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMDIV(TIME(12,0,0),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(TIME(12,0,0),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.25-0.25i', 'Test: Negative case: Time, String. Time value in numerator not valid complex number, returns #VALUE!.');
		// Case #14: Array, String. Array with boolean in numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV({FALSE},"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV({FALSE},"1+1i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, String. Array with boolean in numerator returns #VALUE!.');
		// Case #15: Name3D, String. 3D named range with text in numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV(TestNameArea3D2,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(TestNameArea3D2,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.4-0.4i', 'Test: Negative case: Name3D, String. 3D named range with text in numerator returns #VALUE!.');
		// Case #16: Area3D, String. 3D multi-cell range in numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV(Sheet2!A6:A7,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(Sheet2!A6:A7,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, String. 3D multi-cell range in numerator returns #VALUE!.');
		// Case #17: String, String. Division by zero complex number returns #NUM!.
		oParser = new parserFormula('IMDIV("3+4i","0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("3+4i","0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, String. Division by zero complex number returns #NUM!.');
		// Case #18: Formula, String. Invalid complex number format in denominator returns #VALUE!.
		oParser = new parserFormula('IMDIV("3+4i","3+4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("3+4i","3+4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, String. Invalid complex number format in denominator returns #VALUE!.');
		// Case #19: Reference link, Reference link. Reference to cell with invalid complex number in denominator. Returns #VALUE!.
		oParser = new parserFormula('IMDIV(A100,A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(A100,A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link, Reference link. Reference to cell with invalid complex number in denominator. Returns #VALUE!.');
		// Case #20: Formula, String. Nested IF returning invalid string in numerator returns #VALUE!.
		oParser = new parserFormula('IMDIV(IF(FALSE, "3+4i", "abc"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV(IF(FALSE, "3+4i", "abc"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, String. Nested IF returning invalid string in numerator returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number, Number. Maximum valid complex number in numerator. Returns large complex number.
		oParser = new parserFormula('IMDIV("1E+307+1E+307i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("1E+307+1E+307i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e+307', 'Test: Bounded case: Number, Number. Maximum valid complex number in numerator. Returns large complex number.');
		// Case #2: Number, Number. Minimum positive complex number in numerator. Returns small complex number.
		oParser = new parserFormula('IMDIV("1E-307+1E-307i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("1E-307+1E-307i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e-307', 'Test: Bounded case: Number, Number. Minimum positive complex number in numerator. Returns small complex number.');
		// Case #3: Number, Number. Minimum positive complex number in denominator. Returns large complex number.
		oParser = new parserFormula('IMDIV("3+4i","1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("3+4i","1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '3.5E+307+5E+306i', 'Test: Bounded case: Number, Number. Minimum positive complex number in denominator. Returns large complex number.');
		// Case #4: Number, Number. Minimum positive imaginary components. Returns 1.
		oParser = new parserFormula('IMDIV("0+1E-307i","0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMDIV("0+1E-307i","0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Bounded case: Number, Number. Minimum positive imaginary components. Returns 1.');

		// Need to fix: bool handle
		// Case #19: Reference link, Reference link. References to cells with real numbers as complex. Returns 2.5. - [obj Obj]
		// Case #31: Table, Table. Table structured references with negative complex numbers. Returns -1.5+2.5i.
		// Case #6: Boolean, String. Boolean FALSE in numerator returns #VALUE!.
		// Case #14: Array, String. Array with boolean in numerator returns #VALUE!.
		// Case #3: Number, Number. Minimum positive complex number in denominator. Returns large complex number.
		// Case #4: Number, Number. Minimum positive imaginary components. Returns 1.


		testArrayFormula2(assert, "IMDIV", 2, 2, true, null);
	});

	QUnit.test("Test: \"IMEXP\"", function (assert) {
		//TODO в excel результат данной формулы - "1.46869393991589+2.28735528717884i"
		oParser = new parserFormula('IMEXP("1+i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMEXP("1+i")');
		assert.strictEqual(oParser.calculate().getValue(), "1.4686939399158851+2.2873552871788423i", 'IMEXP("1+i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMEXP("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158-15.200784463067954i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMEXP("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158+15.200784463067954i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '148.4131591025766', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMEXP(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158-15.200784463067954i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '712559182.3564652+1109745174.87574i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5477292602242684+0.8366556385360561i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158-15.200784463067954i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6065306597126334', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6065306597126334', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.718281828459045', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7.38905609893065', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.718281828459045', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158-15.200784463067954i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMEXP("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.6536436208636119-0.7568024953079282i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMEXP(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.6536436208636119-0.7568024953079282i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMEXP("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMEXP("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMEXP("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.590476585567813+2.6821660671324894i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMEXP({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158-15.200784463067954i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMEXP(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '0.54030230586814+0.841470984807897i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMEXP(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158-15.200784463067954i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMEXP("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMEXP("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.175929955883197e-15+2.5694538300081447e-15i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMEXP("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.175929955883197e-15-2.5694538300081447e-15i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMEXP(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.012078509920000082+0.027676552597225252i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.161479918339569+6.326862496997669i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-17.64633484107636+4.348152088676657i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.001982564894601739-0.04974757896727288i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6487212707001282', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6065306597126334', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMEXP(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMEXP(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMEXP("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.28366218546322625-0.9589242746631385i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMEXP(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.2261322978250475-1.3321277557477558i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMEXP(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.9111302618846769-0.4121184852417566i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMEXP(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158-15.200784463067954i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMEXP({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.1312043837568135+2.4717266720048188i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMEXP(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMEXP(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.4161468365471424-0.9092974268256817i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMEXP("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMEXP(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMEXP(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-11736134764.116701-71042020448.36256i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMEXP(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMEXP(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMEXP(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMEXP(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.225540928492468', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMEXP(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.8879689066918555-0.45990349068959124i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMEXP(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMEXP("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMEXP(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(DATE(2025,1,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMEXP(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6487212707001282', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMEXP({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMEXP(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.225540928492468', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMEXP(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Another complex number suffix (j instead of i) returns complex number with j.
		oParser = new parserFormula('IMEXP("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158-15.200784463067954j', 'Test: Negative case: String. Another complex number suffix (j instead of i) returns complex number with j.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMEXP("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMEXP(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMEXP({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-13.128783081462158-15.200784463067954i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMEXP(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMEXP("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMEXP("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1+1e-307i', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMEXP("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMEXP("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1+1e-307i', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');

		// Need to fix: infinityNaN, Object object, empty and bool handle
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5. - [obj Obj]
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		// Case #10: String. Empty string returns #VALUE!.
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!. - InfinityNaN
		// Case #13: Array. Array with boolean returns #VALUE!.
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2). - Infinity

		testArrayFormula(assert, "IMEXP", true);
	});

	QUnit.test("Test: \"IMLN\"", function (assert) {
		oParser = new parserFormula('IMLN("3+4i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMLN("3+4i")');
		assert.strictEqual(oParser.calculate().getValue(), "1.6094379124341003+0.9272952180016123i", 'IMLN("3+4i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMLN("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+0.9272952180016123i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMLN("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003-0.9272952180016123i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMLN(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+0.9272952180016123i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.045654941038849+0.04758310327698479i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.044522437723423+1.5707963267948966i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+0.9272952180016123i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.6931471805599453+3.141592653589793i', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.6931471805599453+3.141592653589793i', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6931471805599453', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+0.9272952180016123i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMLN("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.3862943611198906+1.5707963267948966i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMLN(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.3862943611198906+1.5707963267948966i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMLN("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMLN("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMLN("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.0700330817481354+1.0303768265243125i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMLN({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+0.9272952180016123i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMLN(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5707963267948966i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMLN(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+0.9272952180016123i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMLN("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMLN("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5133244044612737+3.081961940458623i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMLN("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5133244044612737-3.081961940458623i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMLN(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.741129839705655-1.6539375586833378i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.9884274764523675+0.7853981633974484i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.411284327272401+0.7853981633974483i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.595578776279704+1.6010900867136717i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.6931471805599453', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.6931471805599453+3.141592653589793i', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMLN(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMLN("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+1.5707963267948966i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMLN(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1055089497342776-1.1441688336680205i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMLN(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.1972245773362196-1.5707963267948966i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMLN(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+0.9272952180016123i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMLN({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8047189562170503+1.1071487177940904i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMLN(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMLN(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6931471805599453-1.5707963267948966i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMLN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMLN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMLN(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.055213618787512-1.122651351719107i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMLN(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMLN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMLN(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMLN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.2231435513142097', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMLN(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.812184355372417+1.5707963267948966i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMLN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMLN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMLN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '10.728934117109558', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMLN(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.6931471805599453', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMLN({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMLN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.2231435513142097', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMLN(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Another complex number suffix (j instead of i) returns complex value with J.
		oParser = new parserFormula('IMLN("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+0.9272952180016123j', 'Test: Negative case: String. Another complex number suffix (j instead of i) returns complex value with J');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMLN("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMLN(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMLN({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6094379124341003+0.9272952180016123i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMLN(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMLN("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMLN("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMLN("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLN("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-706.893623549172+1.5707963267949i', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMLN", true);
	});

	QUnit.test("Test: \"IMLOG2\"", function (assert) {
		oParser = new parserFormula('IMLOG2("3+4i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMLOG2("3+4i")');
		assert.strictEqual(oParser.calculate().getValue(), "2.321928094887362+1.3378042124509761i", 'IMLOG2("3+4i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMLOG2("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+1.3378042124509761i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMLOG2("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362-1.3378042124509761i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+1.3378042124509761i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.393951279695715+0.06864790712781334i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.392317422778761+2.266180070913597i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+1.3378042124509761i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(TestName) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-1+4.53236014182719i', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(TestName3D) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-1+4.53236014182719i', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+1.3378042124509761i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMLOG2("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("4i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+2.2661800709136i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMLOG2(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(COMPLEX(0,4)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+2.2661800709136i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMLOG2("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMLOG2("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMLOG2("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5437314206251695+1.4865195378735332i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMLOG2({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+1.3378042124509761i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.266180070913597i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+1.3378042124509761i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMLOG2("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMLOG2("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5.06865569535045+4.446331207708182i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMLOG2("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5.06865569535045-4.446331207708182i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5.397309467065071-2.3861275138524505i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.4259994185562233+1.1330900354567985i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.0360529002402097+1.1330900354567985i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '6.6300187105532995+2.3098847281182944i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(TestName1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), -1, 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMLOG2("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+2.266180070913597i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMLOG2(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5949122794400086-1.6506867022725622i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMLOG2(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.169925001442312-2.266180070913597i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+1.3378042124509761i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMLOG2({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1609640474436813+1.5972779646881086i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMLOG2(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMLOG2(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1-2.2661800709136i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMLOG2("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMLOG2(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMLOG2(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5.850436577570131-1.6196435377724472i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMLOG2(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMLOG2(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMLOG2(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMLOG2(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.32192809488736224', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMLOG2(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '6.942514505339238+2.266180070913597i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMLOG2(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMLOG2("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMLOG2(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '15.478580044778367', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMLOG2(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.9999999999999999', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMLOG2({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMLOG2(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.32192809488736224', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMLOG2(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMLOG2("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+1.3378042124509761j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMLOG2("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMLOG2(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMLOG2({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.321928094887362+1.3378042124509761i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMLOG2(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMLOG2("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("1E+307+1E+307i") is parsed.');debugger
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMLOG2("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMLOG2("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG2("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-1019.83192513042+2.2661800709136i', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMLOG2", true);
	});

	QUnit.test("Test: \"IMLOG10\"", function (assert) {
		oParser = new parserFormula('IMLOG10("3+4i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMLOG10("3+4i")');
		assert.strictEqual(oParser.calculate().getValue(), "0.6989700043360186+0.40271919627337305i", 'IMLOG10("3+4i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMLOG10("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.40271919627337305i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMLOG10("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186-0.40271919627337305i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.40271919627337305i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.3227111346745455+0.020665079185027028i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.322219294733919+0.6821881769209205i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.40271919627337305i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.30102999566398114+1.364376353841841i', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.30102999566398114+1.364376353841841i', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.30102999566398114', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.40271919627337305i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMLOG10("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6020599913279623+0.6821881769209205i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMLOG10(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6020599913279623+0.6821881769209205i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMLOG10("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMLOG10("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMLOG10("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.4647094628571463+0.44748697004049304i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMLOG10({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.40271919627337305i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns complex num.
		oParser = new parserFormula('IMLOG10(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6821881769209205i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns complex num.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.40271919627337305i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMLOG10("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMLOG10("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5258174019935593+1.3384790641770181i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMLOG10("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5258174019935593-1.3384790641770181i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.6247520454677629-0.7182959551487093i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.4292685987848195+0.3410940884604603i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6129129957309465+0.34109408846046024i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.9958345036899738+0.6953445896897464i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.30102999566398114', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.30102999566398114+1.364376353841841i', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMLOG10("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.6821881769209205i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMLOG10(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.48011643656425607-0.49690621082770076i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMLOG10(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.9542425094393248-0.6821881769209205i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.40271919627337305i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMLOG10({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.3494850021680093+0.48082857878423396i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMLOG10(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMLOG10(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.30102999566398114-0.6821881769209205i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMLOG10("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMLOG10(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMLOG10(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.7611568975783332-0.4875612871528348i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMLOG10(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMLOG10(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMLOG10(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMLOG10(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.09691001300805636', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMLOG10(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.0899051114393976+0.6821881769209205i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMLOG10(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMLOG10("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMLOG10(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.659516883764217', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMLOG10(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.30102999566398114', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMLOG10({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMLOG10(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.09691001300805636', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMLOG10(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMLOG10("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.40271919627337305j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMLOG10("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMLOG10(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMLOG10({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6989700043360186+0.40271919627337305i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMLOG10(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMLOG10("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMLOG10("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMLOG10("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMLOG10("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-307+0.682188176920921i', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMLOG10", true);
	});

	QUnit.test("Test: \"IMPOWER\"", function (assert) {

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: String, Number. Complex number raised to integer power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER("3+4i",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("3+4i",2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7+24i', 'Test: Positive case: String, Number. Complex number raised to integer power. Returns -7+24i.');
		// Case #2: String, Number. Complex number with negative imaginary part raised to integer power. Returns -7-24i.
		oParser = new parserFormula('IMPOWER("3-4i",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("3-4i",2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7-24i', 'Test: Positive case: String, Number. Complex number with negative imaginary part raised to integer power. Returns -7-24i.');
		// Case #3: Number, Number. Real number as string raised to integer power. Returns 25.
		oParser = new parserFormula('IMPOWER("5",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("5",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '25', 'Test: Positive case: Number, Number. Real number as string raised to integer power. Returns 25.');
		// Case #4: Formula, Number. Complex number via COMPLEX raised to integer power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(COMPLEX(3,4),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(COMPLEX(3,4),2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7+24i', 'Test: Positive case: Formula, Number. Complex number via COMPLEX raised to integer power. Returns -7+24i.');
		// Case #5: Reference link, Reference link. References to cells with complex number and power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link, Reference link. References to cells with complex number and power. Returns -7+24i.');
		// Case #6: Area, Area. Single-cell ranges with complex number and power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area, Area. Single-cell ranges with complex number and power. Returns -7+24i.');
		// Case #7: Array, Array. Arrays with single complex number and power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER({"3+4i"},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER({"3+4i"},{2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7+24i', 'Test: Positive case: Array, Array. Arrays with single complex number and power. Returns -7+24i.');
		// Case #8: Name, Name. Named ranges with complex number and power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.329780281177467e-17+0.7071067811865476i', 'Test: Positive case: Name, Name. Named ranges with complex number and power. Returns -7+24i.');
		// Case #9: Name3D, Name3D. 3D named ranges with complex number and power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '8.659560562354934e-17-1.4142135623730951i', 'Test: Positive case: Name3D, Name3D. 3D named ranges with complex number and power. Returns -7+24i.');
		// Case #10: Ref3D, Ref3D. 3D references to cells with complex number and power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells with complex number and power. Returns -7+24i.');
		// Case #11: Area3D, Area3D. 3D single-cell ranges with complex number and power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges with complex number and power. Returns -7+24i.');
		// Case #12: Table, Table. Table structured references with complex number and power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Table, Table. Table structured references with complex number and power. Returns -7+24i.');
		// Case #13: Formula, Formula. Nested IF returning complex number, raised to integer power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(IF(TRUE, "3+4i", "1+2i"),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(IF(TRUE, "3+4i", "1+2i"),2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7+24i', 'Test: Positive case: Formula, Formula. Nested IF returning complex number, raised to integer power. Returns -7+24i.');
		// Case #14: String, Number. Pure imaginary number raised to integer power. Returns -16.
		oParser = new parserFormula('IMPOWER("4i",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("4i",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-16+1.959434878635765e-15i', 'Test: Positive case: String, Number. Pure imaginary number raised to integer power. Returns -16.');
		// Case #15: Formula, Number. Pure imaginary number via COMPLEX raised to integer power. Returns -16.
		oParser = new parserFormula('IMPOWER(COMPLEX(0,4),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(COMPLEX(0,4),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-16+1.959434878635765e-15i', 'Test: Positive case: Formula, Number. Pure imaginary number via COMPLEX raised to integer power. Returns -16.');
		// Case #16: Formula, Number. IMPOWER with SUM formula for power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER("3+4i",SUM(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("3+4i",SUM(1,1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7+24i', 'Test: Positive case: Formula, Number. IMPOWER with SUM formula for power. Returns -7+24i.');
		// Case #17: String, Number. Complex number with decimal values raised to integer power. Returns -4+7.5i.
		oParser = new parserFormula('IMPOWER("1.5+2.5i",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("1.5+2.5i",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4+7.5i', 'Test: Positive case: String, Number. Complex number with decimal values raised to integer power. Returns -4+7.5i.');
		// Case #18: Array, Array. Multi-element arrays, processes first elements. Returns -7+24i.
		oParser = new parserFormula('IMPOWER({"3+4i";"1+2i"},{2;3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER({"3+4i";"1+2i"},{2;3}) is parsed.');
		// ?assert.strictEqual(oParser.calculate().getValue(), '-7+24i', 'Test: Positive case: Array, Array. Multi-element arrays, processes first elements. Returns -7+24i.');
		// Case #19: Reference link, Reference link. References to cells with real number and power. Returns 25.
		oParser = new parserFormula('IMPOWER(A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A102,A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link, Reference link. References to cells with real number and power. Returns 25.');
		// Case #20: Formula, Number. Complex number string built by CONCATENATE. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(CONCATENATE("3+","4i"),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(CONCATENATE("3+","4i"),2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7+24i', 'Test: Positive case: Formula, Number. Complex number string built by CONCATENATE. Returns -7+24i.');
		// Case #21: String, Number. Complex number with negative real part raised to integer power. Returns -7-24i.
		oParser = new parserFormula('IMPOWER("-3+4i",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("-3+4i",2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7.00000000000001-24i', 'Test: Positive case: String, Number. Complex number with negative real part raised to integer power. Returns -7-24i.');
		// Case #22: String, Number. Complex number with both negative parts raised to integer power. Returns -7+24i.
		oParser = new parserFormula('IMPOWER("-3-4i",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("-3-4i",2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7.00000000000001+24i', 'Test: Positive case: String, Number. Complex number with both negative parts raised to integer power. Returns -7+24i.');
		// Case #23: Formula, Number. Complex number with negative parts via COMPLEX. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(COMPLEX(-3,-4),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(COMPLEX(-3,-4),2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7.00000000000001+24i', 'Test: Positive case: Formula, Number. Complex number with negative parts via COMPLEX. Returns -7+24i.');
		// Case #24: Reference link, Reference link. References to cells with negative complex number and power. Returns -7-24i.
		oParser = new parserFormula('IMPOWER(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link, Reference link. References to cells with negative complex number and power. Returns -7-24i.');
		// Case #25: Area, Area. Single-cell ranges with negative complex number and power. Returns -7-24i.
		oParser = new parserFormula('IMPOWER(A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Area, Area. Single-cell ranges with negative complex number and power. Returns -7-24i.');
		// Case #26: Array, Array. Arrays with single negative complex number and power. Returns -7-24i.
		oParser = new parserFormula('IMPOWER({"-3+4i"},{2})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER({"-3+4i"},{2}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7.00000000000001+24i', 'Test: Positive case: Array, Array. Arrays with single negative complex number and power. Returns -7-24i.');
		// Case #27: Name, Name. Named ranges with negative complex number and power. Returns -7-24i.
		oParser = new parserFormula('IMPOWER(TestName2,TestName2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(TestName2,TestName2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '52782218505.87223', 'Test: Positive case: Name, Name. Named ranges with negative complex number and power. Returns -7-24i.');
		// Case #29: Ref3D, Ref3D. 3D references to cells with negative complex number and power. Returns -7-24i.
		oParser = new parserFormula('IMPOWER(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells with negative complex number and power. Returns -7-24i.');
		// Case #30: Area3D, Area3D. 3D single-cell ranges with negative complex number and power. Returns -7-24i.
		oParser = new parserFormula('IMPOWER(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges with negative complex number and power. Returns -7-24i.');
		// Case #31: Table, Table. Table structured references with negative complex number and power. Returns -7-24i.
		oParser = new parserFormula('IMPOWER(Table1[Column3],Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(Table1[Column3],Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Table, Table. Table structured references with negative complex number and power. Returns -7-24i.');
		// Case #32: Formula, Number. Complex number formatted by TEXT function. Returns -7-24i.
		oParser = new parserFormula('IMPOWER(TEXT("-3+4i","0+0i"),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(TEXT("-3+4i","0+0i"),2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7.00000000000001-24i', 'Test: Positive case: Formula, Number. Complex number formatted by TEXT function. Returns -7-24i.');
		// Case #33: String, Number. Pure imaginary number with zero real part raised to integer power. Returns -25.
		oParser = new parserFormula('IMPOWER("0+5i",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("0+5i",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-25+3.061616997868383e-15i', 'Test: Positive case: String, Number. Pure imaginary number with zero real part raised to integer power. Returns -25.');
		// Case #34: Formula, Number. Complex number with decimal coefficients via COMPLEX. Returns -5.9375-6.875i.
		oParser = new parserFormula('IMPOWER(COMPLEX(1.25,-2.75),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(COMPLEX(1.25,-2.75),2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-6-6.875i', 'Test: Positive case: Formula, Number. Complex number with decimal coefficients via COMPLEX. Returns -5.9375-6.875i.');
		// Case #35: Reference link, Reference link. References to cells with decimal complex number and power. Returns -5.9375-6.875i.
		oParser = new parserFormula('IMPOWER(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link, Reference link. References to cells with decimal complex number and power. Returns -5.9375-6.875i.');
		// Case #36: Formula, Formula. Nested IF with COMPLEX formula for complex number. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(IF(1>0, COMPLEX(3,4), "1+2i"),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(IF(1>0, COMPLEX(3,4), "1+2i"),2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7+24i', 'Test: Positive case: Formula, Formula. Nested IF with COMPLEX formula for complex number. Returns -7+24i.');
		// Case #37: Array, Array. Multi-element arrays, processes first elements. Returns -3+4i.
		oParser = new parserFormula('IMPOWER({"1+2i";"3+4i"},{2;3})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER({"1+2i";"3+4i"},{2;3}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-3+4i', 'Test: Positive case: Array, Array. Multi-element arrays, processes first elements. Returns -3+4i.');
		// Case #38: Formula, Number. Complex number string converted by VALUE. Returns -7+24i.
		oParser = new parserFormula('IMPOWER(VALUE("3+4i"),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(VALUE("3+4i"),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula, Number. Complex number string converted by VALUE. Returns -7+24i.');
		// Case #39: Reference link, Reference link. References to cells with pure imaginary number and power. Returns -16.
		oParser = new parserFormula('IMPOWER(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Reference link, Reference link. References to cells with pure imaginary number and power. Returns -16.');
		// Case #40: String, Number. Complex number raised to fractional power. Returns 2+1i (approx).
		oParser = new parserFormula('IMPOWER("3+4i",0.5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("3+4i",0.5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+i', 'Test: Positive case: String, Number. Complex number raised to fractional power. Returns 2+1i (approx).');

		// Negative cases:
		// Case #1: String, String. Non-numeric string inumber returns #VALUE!.
		oParser = new parserFormula('IMPOWER("abc",2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("abc",2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, String. Non-numeric string inumber returns #VALUE!.');
		// Case #2: Error, Number. Propagates #N/A error in inumber.
		oParser = new parserFormula('IMPOWER(NA(),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(NA(),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, Number. Propagates #N/A error in inumber.');
		// Case #3: Empty, Number. Reference to empty cell in inumber. Returns #VALUE!.
		oParser = new parserFormula('IMPOWER(A110,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A110,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Empty, Number. Reference to empty cell in inumber. Returns #VALUE!.');
		// Case #4: Area, Number. Multi-cell range in inumber returns #VALUE!.
		oParser = new parserFormula('IMPOWER(A100:A101,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A100:A101,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, Number. Multi-cell range in inumber returns #VALUE!.');
		// Case #5: Boolean, Number. Boolean FALSE in inumber returns #VALUE!.
		oParser = new parserFormula('IMPOWER(FALSE,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(FALSE,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE in inumber returns #VALUE!.');
		// Case #6: Ref3D, Number. 3D reference to cell with text in inumber returns #VALUE!.
		oParser = new parserFormula('IMPOWER(Sheet2!A5,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(Sheet2!A5,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Ref3D, Number. 3D reference to cell with text in inumber returns #VALUE!.');
		// Case #7: Name, Number. Named range with text in inumber returns #VALUE!.
		oParser = new parserFormula('IMPOWER(TestNameArea2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(TestNameArea2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '0.64', 'Test: Negative case: Name, Number. Named range with text in inumber returns #VALUE!.');
		// Case #9: Formula, Number. Formula resulting in #NUM! in inumber propagates error.
		oParser = new parserFormula('IMPOWER(SQRT(-1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(SQRT(-1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, Number. Formula resulting in #NUM! in inumber propagates error.');
		// Case #10: String, String. Non-numeric string in number returns #VALUE!.
		oParser = new parserFormula('IMPOWER("3+4i","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("3+4i","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. Non-numeric string in number returns #VALUE!.');
		// Case #11: Date, Number. Date serial number in inumber not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMPOWER(DATE(2025,1,1),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(DATE(2025,1,1),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2084652964', 'Test: Negative case: Date, Number. Date serial number in inumber not valid complex number, returns #VALUE!.');
		// Case #12: Time, Number. Time value in inumber not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMPOWER(TIME(12,0,0),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(TIME(12,0,0),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.25', 'Test: Negative case: Time, Number. Time value in inumber not valid complex number, returns #VALUE!.');
		// Case #13: Array, Number. Array with boolean in inumber returns #VALUE!.
		oParser = new parserFormula('IMPOWER({FALSE},2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER({FALSE},2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, Number. Array with boolean in inumber returns #VALUE!.');
		// Case #14: Name3D, Number. 3D named range with text in inumber returns #VALUE!.
		oParser = new parserFormula('IMPOWER(TestNameArea3D2,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(TestNameArea3D2,2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '0.64', 'Test: Negative case: Name3D, Number. 3D named range with text in inumber returns #VALUE!.');
		// Case #15: Area3D, Number. 3D multi-cell range in inumber returns #VALUE!.
		oParser = new parserFormula('IMPOWER(Sheet2!A6:A7,2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(Sheet2!A6:A7,2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, Number. 3D multi-cell range in inumber returns #VALUE!.');
		// Case #16: String, String. Invalid complex number suffix in number returns #VALUE!.
		oParser = new parserFormula('IMPOWER("3+4i","3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("3+4i","3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: String, String. Invalid complex number suffix in number returns #VALUE!.');
		// Case #17: Formula, String. Invalid complex number format in number returns #VALUE!.
		oParser = new parserFormula('IMPOWER("3+4i","3+4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("3+4i","3+4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Formula, String. Invalid complex number format in number returns #VALUE!.');
		// Case #18: Reference link, Reference link. Reference to cell with invalid complex number in number. Returns #VALUE!.
		oParser = new parserFormula('IMPOWER(A100,A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(A100,A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Reference link, Reference link. Reference to cell with invalid complex number in number. Returns #VALUE!.');
		// Case #19: Formula, String. Nested IF returning invalid string in inumber returns #VALUE!.
		oParser = new parserFormula('IMPOWER(IF(FALSE, "3+4i", "abc"),2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER(IF(FALSE, "3+4i", "abc"),2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, String. Nested IF returning invalid string in inumber returns #VALUE!.');
		// Case #20: Array, String. Array with mixed valid and invalid elements in inumber, processes first valid element. Returns -7+24i.
		oParser = new parserFormula('IMPOWER({"3+4i";"abc"},"2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER({"3+4i";"abc"},"2") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-7+24i', 'Test: Negative case: Array, String. Array with mixed valid and invalid elements in inumber, processes first valid element. Returns -7+24i.');

		// Bounded cases:
		// Case #1: Number, Number. Maximum valid complex number raised to power 1. Returns 1E+307+1E+307i.
		oParser = new parserFormula('IMPOWER("1E+307+1E+307i",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("1E+307+1E+307i",1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number. Maximum valid complex number raised to power 1. Returns 1E+307+1E+307i.');
		// Case #2: Number, Number. Minimum positive complex number raised to power 1. Returns 1E-307+1E-307i.
		oParser = new parserFormula('IMPOWER("1E-307+1E-307i",1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("1E-307+1E-307i",1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number, Number. Minimum positive complex number raised to power 1. Returns 1E-307+1E-307i.');
		// Case #3: Number, Number. Complex number raised to minimum positive power. Returns approximately 1.
		oParser = new parserFormula('IMPOWER("3+4i",1E-307)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("3+4i",1E-307) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1+9.272952180016121e-308i', 'Test: Bounded case: Number, Number. Complex number raised to minimum positive power. Returns approximately 1.');
		// Case #4: Number, Number. Minimum positive imaginary component raised to negative power. Returns 0-1E+307i.
		oParser = new parserFormula('IMPOWER("0+1E-307i",-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPOWER("0+1E-307i",-1) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '6.1257422745431E+290-1E+307i', 'Test: Bounded case: Number, Number. Minimum positive imaginary component raised to negative power. Returns 0-1E+307i.');

		// Need to fix:
		// Many problems with num precision, error and bool handle, boundary cases(NaN, Infinity and other variation)

		testArrayFormula2(assert, "IMPOWER", 2, 2, true, null);
	});

	QUnit.test("Test: \"IMPRODUCT\"", function (assert) {
		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Single complex number as string. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: String. Single complex number as string. Returns 3+4i.');
		// Case #2: String, String. Product of two complex numbers as strings. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT("3+4i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("3+4i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1+7i', 'Test: Positive case: String, String. Product of two complex numbers as strings. Returns -1+7i.');
		// Case #3: String, String. Complex numbers with negative imaginary parts. Returns -1-7i.
		oParser = new parserFormula('IMPRODUCT("3-4i","1-1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("3-4i","1-1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1-7i', 'Test: Positive case: String, String. Complex numbers with negative imaginary parts. Returns -1-7i.');
		// Case #4: Number, Number. Real numbers as strings convertible to complex. Returns 10.
		oParser = new parserFormula('IMPRODUCT("5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '10', 'Test: Positive case: Number, Number. Real numbers as strings convertible to complex. Returns 10.');
		// Case #5: Formula. Single complex number via COMPLEX formula. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Formula. Single complex number via COMPLEX formula. Returns 3+4i.');
		// Case #6: Formula, Formula. Complex numbers via COMPLEX formula. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT(COMPLEX(3,4),COMPLEX(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(COMPLEX(3,4),COMPLEX(1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1+7i', 'Test: Positive case: Formula, Formula. Complex numbers via COMPLEX formula. Returns -1+7i.');
		// Case #7: Reference link. Reference to cell with complex number. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '21+i', 'Test: Positive case: Reference link. Reference to cell with complex number. Returns 3+4i.');
		// Case #8: Reference link, Reference link. References to cells with complex numbers. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-21+441i', 'Test: Positive case: Reference link, Reference link. References to cells with complex numbers. Returns -1+7i.');
		// Case #9: Area. Single-cell range with complex number. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '21+i', 'Test: Positive case: Area. Single-cell range with complex number. Returns 3+4i.');
		// Case #10: Area, Area. Single-cell ranges with complex numbers. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A100:A100,A101:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-21+441i', 'Test: Positive case: Area, Area. Single-cell ranges with complex numbers. Returns -1+7i.');
		// Case #11: Array. Array with single complex number. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Array. Array with single complex number. Returns 3+4i.');
		// Case #12: Array, Array. Arrays with single complex numbers. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT({"3+4i"},{"1+1i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT({"3+4i"},{"1+1i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1+7i', 'Test: Positive case: Array, Array. Arrays with single complex numbers. Returns -1+7i.');
		// Case #13: Name. Named range with complex number. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5', 'Test: Positive case: Name. Named range with complex number. Returns 3+4i.');
		// Case #14: Name, Name. Named ranges with complex numbers. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.25', 'Test: Positive case: Name, Name. Named ranges with complex numbers. Returns -1+7i.');
		// Case #15: Name3D. 3D named range with complex number. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5', 'Test: Positive case: Name3D. 3D named range with complex number. Returns 3+4i.');
		// Case #16: Name3D, Name3D. 3D named ranges with complex numbers. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.25', 'Test: Positive case: Name3D, Name3D. 3D named ranges with complex numbers. Returns -1+7i.');
		// Case #17: Ref3D. 3D reference to cell with complex number. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns 3+4i.');
		// Case #18: Ref3D, Ref3D. 3D references to cells with complex numbers. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells with complex numbers. Returns -1+7i.');
		// Case #19: Area3D. 3D single-cell range with complex number. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns 3+4i.');
		// Case #20: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns -1+7i.');
		// Case #21: Table. Table structured reference with complex number. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Table. Table structured reference with complex number. Returns 3+4i.');
		// Case #22: Table, Table. Table structured references with complex numbers. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(Table1[Column1],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table, Table. Table structured references with complex numbers. Returns -1+7i.');
		// Case #23: Formula. Nested IF returning complex number. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Formula. Nested IF returning complex number. Returns 3+4i.');
		// Case #24: Formula, String. Nested IF with complex number string. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT(IF(TRUE, "3+4i", "1+2i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(IF(TRUE, "3+4i", "1+2i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1+7i', 'Test: Positive case: Formula, String. Nested IF with complex number string. Returns -1+7i.');
		// Case #25: String. Single pure imaginary number as string. Returns 4i.
		oParser = new parserFormula('IMPRODUCT("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4i', 'Test: Positive case: String. Single pure imaginary number as string. Returns 4i.');
		// Case #26: Formula. Single pure imaginary number via COMPLEX. Returns 4i.
		oParser = new parserFormula('IMPRODUCT(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4i', 'Test: Positive case: Formula. Single pure imaginary number via COMPLEX. Returns 4i.');
		// Case #27: Formula, Number. IMPRODUCT with SUM formula for second argument. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT("3+4i",SUM(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("3+4i",SUM(1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '6+8i', 'Test: Positive case: Formula, Number. IMPRODUCT with SUM formula for second argument. Returns -1+7i.');
		// Case #28: String, String, String. Product of three complex numbers as strings. Returns -50+10i.
		oParser = new parserFormula('IMPRODUCT("3+4i","1+1i","2+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("3+4i","1+1i","2+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-16+12i', 'Test: Positive case: String, String, String. Product of three complex numbers as strings. Returns -50+10i.');
		// Case #29: String. Single complex number with decimal values. Returns 1.5+2.5i.
		oParser = new parserFormula('IMPRODUCT("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5+2.5i', 'Test: Positive case: String. Single complex number with decimal values. Returns 1.5+2.5i.');
		// Case #30: String, String. Complex numbers with decimal values. Returns -0.5+2i.
		oParser = new parserFormula('IMPRODUCT("1.5+2.5i","0.5+0.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("1.5+2.5i","0.5+0.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5+2i', 'Test: Positive case: String, String. Complex numbers with decimal values. Returns -0.5+2i.');
		// Case #31: Array. Multi-element array, processes first element. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT({"3+4i";"1+2i"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-5+10i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns 3+4i.');
		// Case #32: Array, Array. Multi-element arrays, processes first elements. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT({"3+4i";"1+2i"},{"1+1i";"2+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT({"3+4i";"1+2i"},{"1+1i";"2+2i"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-40-20i', 'Test: Positive case: Array, Array. Multi-element arrays, processes first elements. Returns -1+7i.');
		// Case #33: Reference link, Reference link. References to cells with real numbers as complex. Returns 10.
		oParser = new parserFormula('IMPRODUCT(A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A102,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-1.9+1.9i', 'Test: Positive case: Reference link, Reference link. References to cells with real numbers as complex. Returns 10.');
		// Case #34: Formula. Single complex number string built by CONCATENATE. Returns 3+4i.
		oParser = new parserFormula('IMPRODUCT(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Formula. Single complex number string built by CONCATENATE. Returns 3+4i.');
		// Case #35: String. Single complex number with negative real part. Returns -3+4i.
		oParser = new parserFormula('IMPRODUCT("-3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("-3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3+4i', 'Test: Positive case: String. Single complex number with negative real part. Returns -3+4i.');
		// Case #36: String, String. Complex number with negative real part. Returns -7-1i.
		oParser = new parserFormula('IMPRODUCT("-3+4i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("-3+4i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-7+i', 'Test: Positive case: String, String. Complex number with negative real part. Returns -7-1i.');
		// Case #37: Formula. Single complex number with negative parts via COMPLEX. Returns -3-4i.
		oParser = new parserFormula('IMPRODUCT(COMPLEX(-3,-4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(COMPLEX(-3,-4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3-4i', 'Test: Positive case: Formula. Single complex number with negative parts via COMPLEX. Returns -3-4i.');
		// Case #38: Reference link, Reference link. References to cells with negative complex numbers. Returns -7-1i.
		oParser = new parserFormula('IMPRODUCT(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A104,A105) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '26.1-26.1i', 'Test: Positive case: Reference link, Reference link. References to cells with negative complex numbers. Returns -7-1i.');
		// Case #39: Formula. Single complex number formatted by TEXT function. Returns -3+4i.
		oParser = new parserFormula('IMPRODUCT(TEXT("-3+4i","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(TEXT("-3+4i","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3+4i', 'Test: Positive case: Formula. Single complex number formatted by TEXT function. Returns -3+4i.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns 4i.
		oParser = new parserFormula('IMPRODUCT(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns 4i.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMPRODUCT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '25-52i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A108:A109) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '55.396+32.901i', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '123i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMPRODUCT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String, String. Non-numeric string in second argument returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT("3+4i","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("3+4i","abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, String. Non-numeric string in second argument returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '45658', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(Sheet2!A4:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("3+4j") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '3+4j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array, String. Array with mixed valid and invalid elements, processes first valid element. Returns -1+7i.
		oParser = new parserFormula('IMPRODUCT({"3+4i";"abc"},"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT({"3+4i";"abc"},"1+1i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, String. Array with mixed valid and invalid elements, processes first valid element. Returns -1+7i.');
		// Case #20: Formula, String. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMPRODUCT(IF(FALSE, "3+4i", "abc"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT(IF(FALSE, "3+4i", "abc"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, String. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns 1E+307+1E+307i.
		oParser = new parserFormula('IMPRODUCT("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e+307+1e+307i', 'Test: Bounded case: Number. Maximum valid complex number. Returns 1E+307+1E+307i.');
		// Case #2: Number. Minimum positive complex number. Returns 1E-307+1E-307i.
		oParser = new parserFormula('IMPRODUCT("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e-307+1e-307i', 'Test: Bounded case: Number. Minimum positive complex number. Returns 1E-307+1E-307i.');
		// Case #3: Number, Number. Product with minimum positive complex number. Returns small complex number.
		oParser = new parserFormula('IMPRODUCT("3+4i","1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("3+4i","1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-1E-307+7E-307i', 'Test: Bounded case: Number, Number. Product with minimum positive complex number. Returns small complex number.');
		// Case #4: Number. Minimum positive imaginary component. Returns 0+1E-307i.
		oParser = new parserFormula('IMPRODUCT("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMPRODUCT("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e-307i', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns 0+1E-307i.');

		// Need to fix: crit error in tests but works in app, bool handle, ms result diff, NaN
		// Case #20: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns -1+7i. - err in tests but work in app?
		// Case #22: Table, Table. Table structured references with complex numbers. Returns -1+7i. - NaNi
		// Case #31: Array. Multi-element array, processes first element. Returns 3+4i.
		// Case #32: Array, Array. Multi-element arrays, processes first elements. Returns -1+7i.
		// Case #33: Reference link, Reference link. References to cells with real numbers as complex. Returns 10.
		// Case #38: Reference link, Reference link. References to cells with negative complex numbers. Returns -7-1i.
		// Case #4: Area. Multi-cell range returns #VALUE!.
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		// Case #10: String, String. Non-numeric string in second argument returns #VALUE!.
		// Case #13: Array. Array with boolean returns #VALUE!.
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!. - j
		// Case #19: Array, String. Array with mixed valid and invalid elements, processes first valid element. Returns -1+7i.


	});

	QUnit.test("Test: \"IMREAL\"", function (assert) {
		oParser = new parserFormula('IMREAL("6-9i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMREAL("6-9i")');
		assert.strictEqual(oParser.calculate().getValue(), 6, 'IMREAL("6-9i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMREAL("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMREAL("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 5, 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMREAL(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 21, 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2, 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMREAL("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMREAL(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMREAL("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMREAL("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 4, 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMREAL("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.5, 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMREAL({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMREAL(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMREAL(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMREAL("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMREAL("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -33.5, 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMREAL("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -33.5, 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMREAL(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3.5, 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.9, 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 2.9, 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -3, 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), -0.5, 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMREAL(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMREAL(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMREAL("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMREAL(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1.25, 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMREAL(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMREAL(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMREAL({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMREAL(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMREAL(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMREAL("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMREAL(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMREAL(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 25, 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMREAL(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMREAL(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMREAL(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMREAL(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMREAL(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMREAL(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMREAL("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMREAL(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 45658, 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMREAL(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.5, 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMREAL({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMREAL(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0.8, 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMREAL(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMREAL("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMREAL("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMREAL(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMREAL({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 3, 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMREAL(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMREAL("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e+307, 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMREAL("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1e-307, 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMREAL("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMREAL("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMREAL", true);
	});

	QUnit.test("Test: \"IMSEC\"", function (assert) {
		oParser = new parserFormula('IMSEC("4+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMSEC("4+3i")');
		assert.strictEqual(oParser.calculate().getValue(), "-0.06529402785794705-0.07522496030277323i", 'IMSEC("4+3i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMSEC("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884+0.005164344607753181i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSEC("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884-0.005164344607753181i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.5253200858160887', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSEC(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884+0.005164344607753181i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5027587925984062+0.5848763730354549i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.516512085582383e-9', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884+0.005164344607753181i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.139493927324549', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.139493927324549', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.8508157176809255', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.402997961722381', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.8508157176809255', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884+0.005164344607753181i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMSEC("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.036618993473686544', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMSEC(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.036618993473686544', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMSEC("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMSEC("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMSEC("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.011848709590612454+0.16484709811743858i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMSEC({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884+0.005164344607753181i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMSEC(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6480542736638853', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMSEC(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884+0.005164344607753181i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMSEC("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMSEC("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.13791241458161554-0.23586775428502618i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSEC("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.13791241458161554+0.23586775428502618i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMSEC(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.0768357146250074e-18-4.0336719550844614e-19i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.10244556883084321+0.28674517657246984i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.10660142012786321+0.02610859444575293i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.002203380170904e-43-2.854071703749964e-44i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.139493927324549', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.139493927324549', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSEC(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMSEC(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMSEC("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.013475282221304563', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMSEC(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.040746665800515225-0.12163168830028041i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMSEC(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.00024681960441430166', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSEC(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884+0.005164344607753181i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMSEC({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.15117629826557724+0.2269736753937216i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMSEC(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMSEC(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.26580222883407967', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMSEC("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMSEC(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMSEC(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5.1746319072060156e-23+6.90950006228217e-24i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSEC(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMSEC(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMSEC(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "1", 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMSEC(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.43532419967224', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMSEC(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7.634994377342399e-54', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMSEC(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMSEC("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSEC(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.0257389021427423', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSEC(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.139493927324549', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMSEC({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMSEC(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.43532419967224', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSEC(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMSEC("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884+0.005164344607753181j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMSEC("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMSEC(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMSEC({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.036253496915868884+0.005164344607753181i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMSEC(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMSEC("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMSEC("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMSEC("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSEC("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMSEC", true);
	});

	QUnit.test("Test: \"IMSECH\"", function (assert) {
		oParser = new parserFormula('IMSECH("4+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMSECH("4+3i")');
		assert.strictEqual( oParser.calculate().getValue(), "-0.036253496915868884-0.005164344607753181i", 'IMSECH("4+3i")' );

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMSECH("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705+0.07522496030277323i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSECH("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705-0.07522496030277323i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.01347528222130456', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSECH(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705+0.07522496030277323i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '8.193749767170633e-10-1.276100918128085e-9i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.825719516226956', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705+0.07522496030277323i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.886818883970074', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.886818883970074', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6480542736638855', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.2658022288340797', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.6480542736638855', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705+0.07522496030277323i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMSECH("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.5298856564663976', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMSECH(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.5298856564663976', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMSECH("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMSECH("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMSECH("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.36413079358845946-0.24621283587977164i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMSECH({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705+0.07522496030277323i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMSECH(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.8508157176809257', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMSECH(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705+0.07522496030277323i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMSECH("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMSECH("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.3518599117663976e-15+5.138907660016298e-15i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSECH("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.3518599117663976e-15-5.138907660016298e-15i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMSECH(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.02420905218298014+0.055371255212670445i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.10244556883084321-0.28674517657246984i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.10660142012786321-0.02610859444575293i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.0039946746307519465-0.0997408186586734i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.886818883970074', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.886818883970074', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSECH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMSECH(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMSECH("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.525320085816088', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMSECH(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5103011483417795+0.1787439458937606i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMSECH(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.0975379063049617', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSECH(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705+0.07522496030277323i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMSECH({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.41314934426694006-0.687527438655479i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMSECH(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMSECH(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.4029979617223813', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMSECH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMSECH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMSECH(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4.5272136283948326e-12+2.74044572277658e-11i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSECH(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMSECH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMSECH(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMSECH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.7476999182374197', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMSECH(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.1261655587981323', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMSECH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMSECH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSECH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSECH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.886818883970074', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMSECH({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMSECH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.7476999182374197', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSECH(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMSECH("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705+0.07522496030277323j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMSECH("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMSECH(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMSECH({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.06529402785794705+0.07522496030277323i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMSECH(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMSECH("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMSECH("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMSECH("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSECH("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMSECH", true);
	});

	QUnit.test("Test: \"IMSIN\"", function (assert) {
		oParser = new parserFormula('IMSIN("4+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMSIN("4+3i")');
		assert.strictEqual(oParser.calculate().getValue(), "-7.619231720321408-6.548120040911002i", 'IMSIN("4+3i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMSIN("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764-27.01681325800393i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSIN("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764+27.01681325800393i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.9589242746631385', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSIN(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764-27.01681325800393i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.2910271138339704-0.6436920804091965i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '659407867.2416066i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764-27.01681325800393i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.479425538604203', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.479425538604203', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8414709848078965', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.9092974268256817', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8414709848078965', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764-27.01681325800393i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMSIN("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '27.289917197127746i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMSIN(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '27.289917197127746i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMSIN("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMSIN("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMSIN("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '6.1169280123693115+0.4279745345061512i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMSIN({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764-27.01681325800393i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMSIN(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1752011936438014i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMSIN(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764-27.01681325800393i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMSIN("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMSIN("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.277399154967069-1.78091439910068i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSIN("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.277399154967069+1.78091439910068i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMSIN(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '305054238913117400+814377825012089100i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.234199647241667-1.0565629721073555i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.1806581785831725-8.796454798144882i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.977700191852525e+41-4.895032907403866e+42i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.479425538604203', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.479425538604203', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSIN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMSIN(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMSIN("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '74.20321057778874i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMSIN(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7.452641810684665-2.4561568777915954i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMSIN(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4051.5419020827876i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSIN(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764-27.01681325800393i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMSIN({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.1657785132161678+1.959601041421606i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMSIN(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMSIN(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.6268604078470186i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMSIN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMSIN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMSIN(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.53520306766704e+21-1.898652951290862e+22i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSIN(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMSIN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMSIN(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMSIN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.7173560908995228', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMSIN(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.3097586593745228e+53i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMSIN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMSIN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSIN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.9438067679532646', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSIN(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.479425538604203', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMSIN({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMSIN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.7173560908995228', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSIN(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Another complex number suffix (j instead of i) returns complex num with J.
		oParser = new parserFormula('IMSIN("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764-27.01681325800393j', 'Test: Negative case: String. Another complex number suffix (j instead of i) returns complex num with J.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMSIN("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMSIN(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMSIN({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.8537380379193764-27.01681325800393i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMSIN(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMSIN("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMSIN("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e-307', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMSIN("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSIN("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMSIN", true);
	});

	QUnit.test("Test: \"IMSINH\"", function (assert) {
		oParser = new parserFormula('IMSINH("4+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMSINH("4+3i")');
		assert.strictEqual(oParser.calculate().getValue(), "-27.01681325800393+3.8537380379193764i", 'IMSINH("4+3i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMSINH("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002-7.619231720321408i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSINH("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002+7.619231720321408i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '74.20321057778874', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSINH(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002-7.619231720321408i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '356279591.17823225+554872587.4378694i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8366556385360561i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002-7.619231720321408i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5210953054937474', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5210953054937474', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1752011936438014', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.6268604078470186', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.1752011936438014', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002-7.619231720321408i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMSINH("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.7568024953079282i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMSINH(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.7568024953079282i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMSINH("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMSINH("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMSINH("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.7058586411644667+1.4078516262453897i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMSINH({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002-7.619231720321408i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMSINH(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8414709848078965i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMSINH(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002-7.619231720321408i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMSINH("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMSINH("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '73634568411911.11+160894467294083.22i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSINH("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '73634568411911.11-160894467294083.22i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMSINH(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '6.616807986379578+15.189350920851851i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.0565629721073555+3.234199647241667i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-8.796454798144882+2.1806581785831725i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.3989205992778147-10.059676670459366i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5210953054937474', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5210953054937474', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSINH(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMSINH(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMSINH("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.9589242746631385i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMSINH(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1.4806576162987812-0.7207377303725837i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMSINH(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.4121184852417566i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSINH(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002-7.619231720321408i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMSINH({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.4890562590412937+1.4031192506220405i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMSINH(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMSINH(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.9092974268256817i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMSINH("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMSINH(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMSINH(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-5868067382.058341-35521010224.18123i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSINH(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMSINH(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(FALSE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMSINH(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMSINH(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8881059821876229', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMSINH(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.45990349068959124i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMSINH(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMSINH("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSINH(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSINH(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5210953054937474', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMSINH({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH({FALSE}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMSINH(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8881059821876229', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSINH(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMSINH("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("3+4j") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002-7.619231720321408j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMSINH("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMSINH(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMSINH({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-6.548120040911002-7.619231720321408i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMSINH(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMSINH("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMSINH("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1E-307+1E-307i', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMSINH("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSINH("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e-307i', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');


		testArrayFormula(assert, "IMSINH", true);
	});

	QUnit.test("Test: \"IMSQRT\"", function (assert) {
		oParser = new parserFormula('IMSQRT("1+i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMSQRT("1+i")');
		//assert.strictEqual( oParser.calculate().getValue(), "1.0986841134678098+0.4550898605622274i", 'IMSQRT("1+i")' );

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMSQRT("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("3+4i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSQRT("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("3-4i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2-i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.23606797749979', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(COMPLEX(3,4)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.583873691629638+0.10907804918644191i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3.24037034920393+3.2403703492039297i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT({"3+4i"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.329780281177467e-17+0.7071067811865476i', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.329780281177467e-17+0.7071067811865476i', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.4142135623730951', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMSQRT("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.4142135623730951+1.414213562373095i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMSQRT(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.4142135623730951+1.414213562373095i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMSQRT("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMSQRT("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMSQRT("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.4858458781822983+0.8412716408576514i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMSQRT({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT({"3+4i";"1+2i"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '0.7071067811865476+0.7071067811865475', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(CONCATENATE("3+","4i")) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMSQRT("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMSQRT("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.17269682843015716+5.790494296219437i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMSQRT("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.17269682843015716-5.790494296219437i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.395769615537934-4.777320432301618i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.514431538318732+0.6272980824571683i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.8709916262348658+0.7749901066729742i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '6.929842859521242+7.143019113628181i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.7071067811865476', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4.329780281177467e-17+0.7071067811865476i', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMSQRT("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5811388300841898+1.5811388300841895i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMSQRT(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.4612942026502813-0.9409467289381059i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMSQRT(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.121320343559643-2.1213203435596424i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMSQRT({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.272019649514069+0.7861513777574233i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMSQRT(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMSQRT(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A106) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1-i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMSQRT("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMSQRT(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMSQRT(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '6.430298863466869-4.04335794526076i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSQRT(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMSQRT(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMSQRT(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMSQRT(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8944271909999159', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMSQRT(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7.842193570679062+7.84219357067906i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMSQRT(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMSQRT("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSQRT(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '213.67732682715777', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSQRT(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.7071067811865476', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMSQRT({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMSQRT(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8944271909999159', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSQRT(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMSQRT("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("3+4j") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMSQRT("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMSQRT(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMSQRT({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT({"3+4i";"abc"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '2+i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMSQRT(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMSQRT("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMSQRT("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMSQRT("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSQRT("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');

		// TODO many problems in this formula
		// Need to fix: empty and boolean handle, precision problem in many cases, boundary cases errors(NaN, Infinity)
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5. - precision
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5. - precision
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5. - precision
		// Case #7: Array. Array with single complex number. Returns modulus 5. - precision
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5. - precision
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5. - precision
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5. - precision
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5. - [object Object]
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5. - precision
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4. - precision
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		// Case #10: String. Empty string returns #VALUE!.
		// Case #13: Array. Array with boolean returns #VALUE!.
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!. - precision and j coeff
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5. - precision
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2). - Infinity+Infinityi
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).  - NaNNaNi
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.  - NaNNaNi

		testArrayFormula(assert, "IMSQRT", true);
	});

	QUnit.test("Test: \"IMSUB\"", function (assert) {
		oParser = new parserFormula('IMSUB("13+4i","5+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMSUB("13+4i","5+3i")');
		assert.strictEqual(oParser.calculate().getValue(), "8+i", 'IMSUB("13+4i","5+3i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String, String. Subtracts two complex numbers as strings. Returns 2+3i.
		oParser = new parserFormula('IMSUB("3+4i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("3+4i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2+3i', 'Test: Positive case: String, String. Subtracts two complex numbers as strings. Returns 2+3i.');
		// Case #2: String, String. Complex numbers with negative imaginary parts. Returns 2-3i.
		oParser = new parserFormula('IMSUB("3-4i","1-1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("3-4i","1-1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2-3i', 'Test: Positive case: String, String. Complex numbers with negative imaginary parts. Returns 2-3i.');
		// Case #3: Number, Number. Real numbers as strings convertible to complex. Returns 3.
		oParser = new parserFormula('IMSUB("5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3', 'Test: Positive case: Number, Number. Real numbers as strings convertible to complex. Returns 3.');
		// Case #4: Formula, Formula. Complex numbers via COMPLEX formula. Returns 2+3i.
		oParser = new parserFormula('IMSUB(COMPLEX(3,4),COMPLEX(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(COMPLEX(3,4),COMPLEX(1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2+3i', 'Test: Positive case: Formula, Formula. Complex numbers via COMPLEX formula. Returns 2+3i.');
		// Case #5: Reference link, Reference link. References to cells with complex numbers. Returns 2+3i.
		oParser = new parserFormula('IMSUB(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '21-20i', 'Test: Positive case: Reference link, Reference link. References to cells with complex numbers. Returns 2+3i.');
		// Case #6: Area, Area. Single-cell ranges with complex numbers. Returns 2+3i.
		oParser = new parserFormula('IMSUB(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A100:A100,A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '21-20i', 'Test: Positive case: Area, Area. Single-cell ranges with complex numbers. Returns 2+3i.');
		// Case #7: Array, Array. Arrays with single complex numbers. Returns 2+3i.
		oParser = new parserFormula('IMSUB({"3+4i"},{"1+1i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB({"3+4i"},{"1+1i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2+3i', 'Test: Positive case: Array, Array. Arrays with single complex numbers. Returns 2+3i.');
		// Case #8: Name, Name. Named ranges with complex numbers. Returns 2+3i.
		oParser = new parserFormula('IMSUB(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1', 'Test: Positive case: Name, Name. Named ranges with complex numbers. Returns 2+3i.');
		// Case #9: Name3D, Name3D. 3D named ranges with complex numbers. Returns 2+3i.
		oParser = new parserFormula('IMSUB(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Name3D, Name3D. 3D named ranges with complex numbers. Returns 2+3i.');
		// Case #10: Ref3D, Ref3D. 3D references to cells with complex numbers. Returns 2+3i.
		oParser = new parserFormula('IMSUB(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells with complex numbers. Returns 2+3i.');
		// Case #11: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns 2+3i.
		oParser = new parserFormula('IMSUB(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns 2+3i.');
		// Case #12: Table, Table. Table structured references with complex numbers. Returns 2+3i.
		oParser = new parserFormula('IMSUB(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(Table1[Column1],Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table, Table. Table structured references with complex numbers. Returns 2+3i.');
		// Case #13: Formula, String. Nested IF returning complex number, subtracted by string. Returns 2+3i.
		oParser = new parserFormula('IMSUB(IF(TRUE, "3+4i", "1+2i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(IF(TRUE, "3+4i", "1+2i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2+3i', 'Test: Positive case: Formula, String. Nested IF returning complex number, subtracted by string. Returns 2+3i.');
		// Case #14: String, String. Pure imaginary numbers as strings. Returns 2i.
		oParser = new parserFormula('IMSUB("4i","2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("4i","2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2i', 'Test: Positive case: String, String. Pure imaginary numbers as strings. Returns 2i.');
		// Case #15: Formula, Formula. Pure imaginary numbers via COMPLEX. Returns 2i.
		oParser = new parserFormula('IMSUB(COMPLEX(0,4),COMPLEX(0,2))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(COMPLEX(0,4),COMPLEX(0,2)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2i', 'Test: Positive case: Formula, Formula. Pure imaginary numbers via COMPLEX. Returns 2i.');
		// Case #16: Formula, String. IMSUB with SUM formula for first argument. Returns 2+3i.
		oParser = new parserFormula('IMSUB(SUM("3+4i","0+0i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(SUM("3+4i","0+0i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula, String. IMSUB with SUM formula for first argument. Returns 2+3i.');
		// Case #17: String, String. Complex numbers with decimal values. Returns 1+2i.
		oParser = new parserFormula('IMSUB("1.5+2.5i","0.5+0.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("1.5+2.5i","0.5+0.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1+2i', 'Test: Positive case: String, String. Complex numbers with decimal values. Returns 1+2i.');
		// Case #18: Array, Array. Multi-element arrays, processes first elements. Returns 2+3i.
		oParser = new parserFormula('IMSUB({"3+4i";"1+2i"},{"1+1i";"2+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB({"3+4i";"1+2i"},{"1+1i";"2+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2+3i', 'Test: Positive case: Array, Array. Multi-element arrays, processes first elements. Returns 2+3i.');
		// Case #19: Reference link, Reference link. References to cells with real numbers as complex. Returns 3.
		oParser = new parserFormula('IMSUB(A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A102,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-1.9-0.9i', 'Test: Positive case: Reference link, Reference link. References to cells with real numbers as complex. Returns 3.');
		// Case #20: Formula, String. Complex number string built by CONCATENATE. Returns 2+3i.
		oParser = new parserFormula('IMSUB(CONCATENATE("3+","4i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(CONCATENATE("3+","4i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2+3i', 'Test: Positive case: Formula, String. Complex number string built by CONCATENATE. Returns 2+3i.');
		// Case #21: String, String. Complex number with negative real part. Returns -4+3i.
		oParser = new parserFormula('IMSUB("-3+4i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("-3+4i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4+3i', 'Test: Positive case: String, String. Complex number with negative real part. Returns -4+3i.');
		// Case #22: String, String. Complex number with negative parts. Returns -4-3i.
		oParser = new parserFormula('IMSUB("-3-4i","1-1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("-3-4i","1-1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4-3i', 'Test: Positive case: String, String. Complex number with negative parts. Returns -4-3i.');
		// Case #23: Formula, Formula. Complex numbers with negative parts via COMPLEX. Returns -4-3i.
		oParser = new parserFormula('IMSUB(COMPLEX(-3,-4),COMPLEX(1,-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(COMPLEX(-3,-4),COMPLEX(1,-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4-3i', 'Test: Positive case: Formula, Formula. Complex numbers with negative parts via COMPLEX. Returns -4-3i.');
		// Case #24: Reference link, Reference link. References to cells with negative complex numbers. Returns -4+3i.
		oParser = new parserFormula('IMSUB(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.9+11.9i', 'Test: Positive case: Reference link, Reference link. References to cells with negative complex numbers. Returns -4+3i.');
		// Case #25: Area, Area. Single-cell ranges with negative complex numbers. Returns -4+3i.
		oParser = new parserFormula('IMSUB(A104:A104,A105:A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A104:A104,A105:A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.9+11.9i', 'Test: Positive case: Area, Area. Single-cell ranges with negative complex numbers. Returns -4+3i.');
		// Case #26: Array, Array. Arrays with single negative complex numbers. Returns -4+3i.
		oParser = new parserFormula('IMSUB({"-3+4i"},{"1+1i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB({"-3+4i"},{"1+1i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4+3i', 'Test: Positive case: Array, Array. Arrays with single negative complex numbers. Returns -4+3i.');
		// Case #27: Name, Name. Named ranges with negative complex numbers. Returns -4+3i.
		oParser = new parserFormula('IMSUB(TestName2,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(TestName2,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '10', 'Test: Positive case: Name, Name. Named ranges with negative complex numbers. Returns -4+3i.');
		// Case #29: Ref3D, Ref3D. 3D references to cells with negative complex numbers. Returns -4+3i.
		oParser = new parserFormula('IMSUB(Sheet2!A3,Sheet2!A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(Sheet2!A3,Sheet2!A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells with negative complex numbers. Returns -4+3i.');
		// Case #30: Area3D, Area3D. 3D single-cell ranges with negative complex numbers. Returns -4+3i.
		oParser = new parserFormula('IMSUB(Sheet2!A3:A3,Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(Sheet2!A3:A3,Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges with negative complex numbers. Returns -4+3i.');
		// Case #32: Formula, String. Complex number formatted by TEXT function. Returns -4+3i.
		oParser = new parserFormula('IMSUB(TEXT("-3+4i","0+0i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(TEXT("-3+4i","0+0i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4+3i', 'Test: Positive case: Formula, String. Complex number formatted by TEXT function. Returns -4+3i.');
		// Case #33: String, String. Pure imaginary numbers with zero real parts. Returns 0+3i.
		oParser = new parserFormula('IMSUB("0+5i","0+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("0+5i","0+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3i', 'Test: Positive case: String, String. Pure imaginary numbers with zero real parts. Returns 0+3i.');
		// Case #34: Formula, Formula. Complex numbers with decimal coefficients via COMPLEX. Returns 0.75-2.25i.
		oParser = new parserFormula('IMSUB(COMPLEX(1.25,-2.75),COMPLEX(0.5,-0.5))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(COMPLEX(1.25,-2.75),COMPLEX(0.5,-0.5)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.75-2.25i', 'Test: Positive case: Formula, Formula. Complex numbers with decimal coefficients via COMPLEX. Returns 0.75-2.25i.');
		// Case #35: Reference link, Reference link. References to cells with decimal complex numbers. Returns 0.75-2.25i.
		oParser = new parserFormula('IMSUB(A106,A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A106,A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-25+50i', 'Test: Positive case: Reference link, Reference link. References to cells with decimal complex numbers. Returns 0.75-2.25i.');
		// Case #36: Formula, Formula. Nested IF with COMPLEX formula for first argument. Returns 2+3i.
		oParser = new parserFormula('IMSUB(IF(1>0, COMPLEX(3,4), "1+2i"),COMPLEX(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(IF(1>0, COMPLEX(3,4), "1+2i"),COMPLEX(1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2+3i', 'Test: Positive case: Formula, Formula. Nested IF with COMPLEX formula for first argument. Returns 2+3i.');
		// Case #37: Array, Array. Multi-element arrays, processes first elements. Returns -1.
		oParser = new parserFormula('IMSUB({"1+2i";"3+4i"},{"2+2i";"1+1i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB({"1+2i";"3+4i"},{"2+2i";"1+1i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1', 'Test: Positive case: Array, Array. Multi-element arrays, processes first elements. Returns -1.');
		// Case #38: Formula, String. Complex number string converted by VALUE. Returns 2+3i.
		oParser = new parserFormula('IMSUB(VALUE("3+4i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(VALUE("3+4i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula, String. Complex number string converted by VALUE. Returns 2+3i.');
		// Case #39: Reference link, Reference link. References to cells with pure imaginary numbers. Returns 2i.
		oParser = new parserFormula('IMSUB(A108,A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A108,A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-10+15.099i', 'Test: Positive case: Reference link, Reference link. References to cells with pure imaginary numbers. Returns 2i.');
		// Case #40: String, Number. Complex number minus real number as string. Returns 8+10i.
		oParser = new parserFormula('IMSUB("10+10i","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("10+10i","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '8+10i', 'Test: Positive case: String, Number. Complex number minus real number as string. Returns 8+10i.');

		// Negative cases:
		// Case #1: String, String. Non-numeric string in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB("abc","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("abc","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, String. Non-numeric string in first argument returns #VALUE!.');
		// Case #2: String, String. Non-numeric string in second argument returns #VALUE!.
		oParser = new parserFormula('IMSUB("3+4i","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("3+4i","abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, String. Non-numeric string in second argument returns #VALUE!.');
		// Case #3: Error, String. Propagates #N/A error in first argument.
		oParser = new parserFormula('IMSUB(NA(),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(NA(),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error, String. Propagates #N/A error in first argument.');
		// Case #4: Empty, String. Reference to empty cell in first argument. Returns #VALUE!.
		oParser = new parserFormula('IMSUB(A110,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A110,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1-i', 'Test: Negative case: Empty, String. Reference to empty cell in first argument. Returns #VALUE!.');
		// Case #5: Area, String. Multi-cell range in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB(A100:A101,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A100:A101,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area, String. Multi-cell range in first argument returns #VALUE!.');
		// Case #6: Boolean, String. Boolean FALSE in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB(FALSE,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(FALSE,"1+1i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, String. Boolean FALSE in first argument returns #VALUE!.');
		// Case #7: Ref3D, String. 3D reference to cell with text in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB(Sheet2!A5,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(Sheet2!A5,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1-i', 'Test: Negative case: Ref3D, String. 3D reference to cell with text in first argument returns #VALUE!.');
		// Case #8: Name, String. Named range with text in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB(TestNameArea2,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(TestNameArea2,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.19999999999999996-i', 'Test: Negative case: Name, String. Named range with text in first argument returns #VALUE!.');
		// Case #9: Table, String. Table column with text in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB(Table1[Column3],"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(Table1[Column3],"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1+122i', 'Test: Negative case: Table, String. Table column with text in first argument returns #VALUE!.');
		// Case #10: Formula, String. Formula resulting in #NUM! in first argument propagates error.
		oParser = new parserFormula('IMSUB(SQRT(-1),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(SQRT(-1),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, String. Formula resulting in #NUM! in first argument propagates error.');
		// Case #11: String, Empty. Reference to empty cell in second argument. Returns #VALUE!.
		oParser = new parserFormula('IMSUB("3+4i",A111)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("3+4i",A111) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Negative case: String, Empty. Reference to empty cell in second argument. Returns #VALUE!.');
		// Case #12: Date, String. Date serial number in first argument not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSUB(DATE(2025,1,1),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(DATE(2025,1,1),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '45657-i', 'Test: Negative case: Date, String. Date serial number in first argument not valid complex number, returns #VALUE!.');
		// Case #13: Time, String. Time value in first argument not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSUB(TIME(12,0,0),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(TIME(12,0,0),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5-i', 'Test: Negative case: Time, String. Time value in first argument not valid complex number, returns #VALUE!.');
		// Case #14: Array, String. Array with boolean in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB({FALSE},"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB({FALSE},"1+1i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array, String. Array with boolean in first argument returns #VALUE!.');
		// Case #15: Name3D, String. 3D named range with text in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB(TestNameArea3D2,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(TestNameArea3D2,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.19999999999999996-i', 'Test: Negative case: Name3D, String. 3D named range with text in first argument returns #VALUE!.');
		// Case #16: Area3D, String. 3D multi-cell range in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB(Sheet2!A6:A7,"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(Sheet2!A6:A7,"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D, String. 3D multi-cell range in first argument returns #VALUE!.');
		// Case #17: String, String. Invalid complex number suffix (j instead of i) in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB("3+4j","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("3+4j","1+1i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, String. Invalid complex number suffix (j instead of i) in first argument returns #VALUE!.');
		// Case #18: Formula, String. Invalid complex number format in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB("3+4","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("3+4","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, String. Invalid complex number format in first argument returns #VALUE!.');
		// Case #19: Reference link, Reference link. Reference to cell with invalid complex number in second argument. Returns #VALUE!.
		oParser = new parserFormula('IMSUB(A100,A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(A100,A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '21+i', 'Test: Negative case: Reference link, Reference link. Reference to cell with invalid complex number in second argument. Returns #VALUE!.');
		// Case #20: Formula, String. Nested IF returning invalid string in first argument returns #VALUE!.
		oParser = new parserFormula('IMSUB(IF(FALSE, "3+4i", "abc"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB(IF(FALSE, "3+4i", "abc"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, String. Nested IF returning invalid string in first argument returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number, Number. Maximum valid complex number minus small complex number. Returns large complex number.
		oParser = new parserFormula('IMSUB("1E+307+1E+307i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("1E+307+1E+307i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e+307+1e+307i', 'Test: Bounded case: Number, Number. Maximum valid complex number minus small complex number. Returns large complex number.');
		// Case #2: Number, Number. Minimum positive complex numbers subtraction. Returns small complex number.
		oParser = new parserFormula('IMSUB("1E-307+1E-307i","1E-308+1E-308i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("1E-307+1E-307i","1E-308+1E-308i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1E-307+1E-307i', 'Test: Bounded case: Number, Number. Minimum positive complex numbers subtraction. Returns small complex number.');
		// Case #3: Number, Number. Complex number minus minimum positive complex number. Returns approximately 3+4i.
		oParser = new parserFormula('IMSUB("3+4i","1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("3+4i","1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Bounded case: Number, Number. Complex number minus minimum positive complex number. Returns approximately 3+4i.');
		// Case #4: Number, Number. Minimum positive imaginary components subtraction. Returns small imaginary number.
		oParser = new parserFormula('IMSUB("0+1E-307i","0+1E-308i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUB("0+1E-307i","0+1E-308i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1E-307i', 'Test: Bounded case: Number, Number. Minimum positive imaginary components subtraction. Returns small imaginary number.');

		// Need to fix: bool handle
		// Case #19: Reference link, Reference link. References to cells with real numbers as complex. Returns 3. - [obj Obj]
		// Case #6: Boolean, String. Boolean FALSE in first argument returns #VALUE!.
		// Case #14: Array, String. Array with boolean in first argument returns #VALUE!.
		// Case #17: String, String. Invalid complex number suffix (j instead of i) in first argument returns #VALUE!.


		testArrayFormula2(assert, "IMSUB", 2, 2, true, null);
	});

	QUnit.test("Test: \"IMSUM\"", function (assert) {

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Single complex number as string. Returns 3+4i.
		oParser = new parserFormula('IMSUM("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: String. Single complex number as string. Returns 3+4i.');
		// Case #2: String, String. Sum of two complex numbers as strings. Returns 4+5i.
		oParser = new parserFormula('IMSUM("3+4i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("3+4i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4+5i', 'Test: Positive case: String, String. Sum of two complex numbers as strings. Returns 4+5i.');
		// Case #3: String, String. Complex numbers with negative imaginary parts. Returns 4-5i.
		oParser = new parserFormula('IMSUM("3-4i","1-1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("3-4i","1-1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4-5i', 'Test: Positive case: String, String. Complex numbers with negative imaginary parts. Returns 4-5i.');
		// Case #4: Number, Number. Real numbers as strings convertible to complex. Returns 7.
		oParser = new parserFormula('IMSUM("5","2")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("5","2") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7', 'Test: Positive case: Number, Number. Real numbers as strings convertible to complex. Returns 7.');
		// Case #5: Formula. Single complex number via COMPLEX formula. Returns 3+4i.
		oParser = new parserFormula('IMSUM(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Formula. Single complex number via COMPLEX formula. Returns 3+4i.');
		// Case #6: Formula, Formula. Complex numbers via COMPLEX formula. Returns 4+5i.
		oParser = new parserFormula('IMSUM(COMPLEX(3,4),COMPLEX(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(COMPLEX(3,4),COMPLEX(1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4+5i', 'Test: Positive case: Formula, Formula. Complex numbers via COMPLEX formula. Returns 4+5i.');
		// Case #7: Reference link. Reference to cell with complex number. Returns 3+4i.
		oParser = new parserFormula('IMSUM(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '21+i', 'Test: Positive case: Reference link. Reference to cell with complex number. Returns 3+4i.');
		// Case #8: Reference link, Reference link. References to cells with complex numbers. Returns 4+5i.
		oParser = new parserFormula('IMSUM(A100,A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A100,A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '21+22i', 'Test: Positive case: Reference link, Reference link. References to cells with complex numbers. Returns 4+5i.');
		// Case #9: Area. Single-cell range with complex number. Returns 3+4i.
		oParser = new parserFormula('IMSUM(A100:A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A100:A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '21+i', 'Test: Positive case: Area. Single-cell range with complex number. Returns 3+4i.');
		// Case #10: Area, Area. Single-cell ranges with complex numbers. Returns 4+5i.
		oParser = new parserFormula('IMSUM(A100:A100,A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A100:A100,A101:A101) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '21+22i', 'Test: Positive case: Area, Area. Single-cell ranges with complex numbers. Returns 4+5i.');
		// Case #11: Array. Array with single complex number. Returns 3+4i.
		oParser = new parserFormula('IMSUM({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Array. Array with single complex number. Returns 3+4i.');
		// Case #12: Array, Array. Arrays with single complex numbers. Returns 4+5i.
		oParser = new parserFormula('IMSUM({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM({"3+4i"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '4+5i', 'Test: Positive case: Array, Array. Arrays with single complex numbers. Returns 4+5i.');
		// Case #13: Name. Named range with complex number. Returns 3+4i.
		oParser = new parserFormula('IMSUM(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5', 'Test: Positive case: Name. Named range with complex number. Returns 3+4i.');
		// Case #14: Name, Name. Named ranges with complex numbers. Returns 4+5i.
		oParser = new parserFormula('IMSUM(TestName,TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(TestName,TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Name, Name. Named ranges with complex numbers. Returns 4+5i.');
		// Case #15: Name3D. 3D named range with complex number. Returns 3+4i.
		oParser = new parserFormula('IMSUM(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5', 'Test: Positive case: Name3D. 3D named range with complex number. Returns 3+4i.');
		// Case #16: Name3D, Name3D. 3D named ranges with complex numbers. Returns 4+5i.
		oParser = new parserFormula('IMSUM(TestName3D,TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(TestName3D,TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-1', 'Test: Positive case: Name3D, Name3D. 3D named ranges with complex numbers. Returns 4+5i.');
		// Case #17: Ref3D. 3D reference to cell with complex number. Returns 3+4i.
		oParser = new parserFormula('IMSUM(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns 3+4i.');
		// Case #18: Ref3D, Ref3D. 3D references to cells with complex numbers. Returns 4+5i.
		oParser = new parserFormula('IMSUM(Sheet2!A1,Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(Sheet2!A1,Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3', 'Test: Positive case: Ref3D, Ref3D. 3D references to cells with complex numbers. Returns 4+5i.');
		// Case #19: Area3D. 3D single-cell range with complex number. Returns 3+4i.
		oParser = new parserFormula('IMSUM(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns 3+4i.');
		// Case #20: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns 4+5i.
		oParser = new parserFormula('IMSUM(Sheet2!A1:A1,Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(Sheet2!A1:A1,Sheet2!A2:A2) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '3', 'Test: Positive case: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns 4+5i.');
		// Case #21: Table. Table structured reference with complex number. Returns 3+4i.
		oParser = new parserFormula('IMSUM(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Table. Table structured reference with complex number. Returns 3+4i.');
		// Case #22: Table, Table. Table structured references with complex numbers. Returns 4+5i.
		oParser = new parserFormula('IMSUM(Table1[Column1],Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(Table1[Column1],Table1[Column2]) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table, Table. Table structured references with complex numbers. Returns 4+5i.');
		// Case #23: Formula. Nested IF returning complex number. Returns 3+4i.
		oParser = new parserFormula('IMSUM(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Formula. Nested IF returning complex number. Returns 3+4i.');
		// Case #24: Formula, String. Nested IF with complex number string. Returns 4+5i.
		oParser = new parserFormula('IMSUM(IF(TRUE, "3+4i", "1+2i"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(IF(TRUE, "3+4i", "1+2i"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4+5i', 'Test: Positive case: Formula, String. Nested IF with complex number string. Returns 4+5i.');
		// Case #25: String. Single pure imaginary number as string. Returns 4i.
		oParser = new parserFormula('IMSUM("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4i', 'Test: Positive case: String. Single pure imaginary number as string. Returns 4i.');
		// Case #26: Formula. Single pure imaginary number via COMPLEX. Returns 4i.
		oParser = new parserFormula('IMSUM(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '4i', 'Test: Positive case: Formula. Single pure imaginary number via COMPLEX. Returns 4i.');
		// Case #27: Formula, Number. IMSUM with SUM formula for second argument (real number). Returns 5+4i.
		oParser = new parserFormula('IMSUM("3+4i",SUM(1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("3+4i",SUM(1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5+4i', 'Test: Positive case: Formula, Number. IMSUM with SUM formula for second argument (real number). Returns 5+4i.');
		// Case #28: String, String, String. Sum of three complex numbers as strings. Returns 6+7i.
		oParser = new parserFormula('IMSUM("3+4i","1+1i","2+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("3+4i","1+1i","2+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '6+7i', 'Test: Positive case: String, String, String. Sum of three complex numbers as strings. Returns 6+7i.');
		// Case #29: String. Single complex number with decimal values. Returns 1.5+2.5i.
		oParser = new parserFormula('IMSUM("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5+2.5i', 'Test: Positive case: String. Single complex number with decimal values. Returns 1.5+2.5i.');
		// Case #30: String, String. Complex numbers with decimal values. Returns 2+3i.
		oParser = new parserFormula('IMSUM("1.5+2.5i","0.5+0.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("1.5+2.5i","0.5+0.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2+3i', 'Test: Positive case: String, String. Complex numbers with decimal values. Returns 2+3i.');
		// Case #31: Array. Multi-element array, processes first element. Returns 3+4i.
		oParser = new parserFormula('IMSUM({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM({"3+4i";"1+2i"}) is parsed.');
		//?	assert.strictEqual(oParser.calculate().getValue(), '4+6i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns 3+4i.');
		// Case #32: Array, Array. Multi-element arrays, processes first elements. Returns 4+5i.
		oParser = new parserFormula('IMSUM({"3+4i";"1+2i"},{"1+1i";"2+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM({"3+4i";"1+2i"},{"1+1i";"2+2i"}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '7+9i', 'Test: Positive case: Array, Array. Multi-element arrays, processes first elements. Returns 4+5i.');
		// Case #33: Reference link, Reference link. References to cells with real numbers as complex. Returns 7.
		oParser = new parserFormula('IMSUM(A102,A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A102,A103) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1.9+2.9i', 'Test: Positive case: Reference link, Reference link. References to cells with real numbers as complex. Returns 7.');
		// Case #34: Formula. Single complex number string built by CONCATENATE. Returns 3+4i.
		oParser = new parserFormula('IMSUM(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Positive case: Formula. Single complex number string built by CONCATENATE. Returns 3+4i.');
		// Case #35: String. Single complex number with negative real part. Returns -3+4i.
		oParser = new parserFormula('IMSUM("-3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("-3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3+4i', 'Test: Positive case: String. Single complex number with negative real part. Returns -3+4i.');
		// Case #36: String, String. Complex number with negative real part. Returns -2+5i.
		oParser = new parserFormula('IMSUM("-3+4i","1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("-3+4i","1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2+5i', 'Test: Positive case: String, String. Complex number with negative real part. Returns -2+5i.');
		// Case #37: Formula. Single complex number with negative parts via COMPLEX. Returns -3-4i.
		oParser = new parserFormula('IMSUM(COMPLEX(-3,-4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(COMPLEX(-3,-4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3-4i', 'Test: Positive case: Formula. Single complex number with negative parts via COMPLEX. Returns -3-4i.');
		// Case #38: Reference link, Reference link. References to cells with negative complex numbers. Returns -2+5i.
		oParser = new parserFormula('IMSUM(A104,A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A104,A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.9-6.1i', 'Test: Positive case: Reference link, Reference link. References to cells with negative complex numbers. Returns -2+5i.');
		// Case #39: Formula. Single complex number formatted by TEXT function. Returns -3+4i.
		oParser = new parserFormula('IMSUM(TEXT("-3+4i","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(TEXT("-3+4i","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3+4i', 'Test: Positive case: Formula. Single complex number formatted by TEXT function. Returns -3+4i.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns 4i.
		oParser = new parserFormula('IMSUM(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns 4i.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMSUM("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMSUM(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMSUM(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '25-52i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSUM(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A108:A109) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '12-7.099i', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMSUM(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMSUM(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMSUM(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMSUM(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '123i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMSUM(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String, String. Non-numeric string in second argument returns #VALUE!.
		oParser = new parserFormula('IMSUM("3+4i","abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("3+4i","abc") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, String. Non-numeric string in second argument returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSUM(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '45658', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMSUM(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMSUM({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMSUM(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.8', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMSUM(Sheet2!A4:A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(Sheet2!A4:A5) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMSUM("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("3+4j") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '3+4j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMSUM("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMSUM(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array, String. Array with mixed valid and invalid elements, processes first valid element. Returns 4+5i.
		oParser = new parserFormula('IMSUM({"3+4i";"abc"},"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM({"3+4i";"abc"},"1+1i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array, String. Array with mixed valid and invalid elements, processes first valid element. Returns 4+5i.');
		// Case #20: Formula, String. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMSUM(IF(FALSE, "3+4i", "abc"),"1+1i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM(IF(FALSE, "3+4i", "abc"),"1+1i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula, String. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns 1E+307+1E+307i.
		oParser = new parserFormula('IMSUM("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("1E+307+1E+307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e+307+1e+307i', 'Test: Bounded case: Number. Maximum valid complex number. Returns 1E+307+1E+307i.');
		// Case #2: Number. Minimum positive complex number. Returns 1E-307+1E-307i.
		oParser = new parserFormula('IMSUM("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e-307+1e-307i', 'Test: Bounded case: Number. Minimum positive complex number. Returns 1E-307+1E-307i.');
		// Case #3: Number, Number. Sum with minimum positive complex number. Returns approximately 3+4i.
		oParser = new parserFormula('IMSUM("3+4i","1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("3+4i","1E-307+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '3+4i', 'Test: Bounded case: Number, Number. Sum with minimum positive complex number. Returns approximately 3+4i.');
		// Case #4: Number. Minimum positive imaginary component. Returns 0+1E-307i.
		oParser = new parserFormula('IMSUM("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMSUM("0+1E-307i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1e-307i', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns 0+1E-307i.');

		// TODO function doesn't work correctly when we have more than 1 argument
		// Need to fix: ms res diff, bool handle, tocString method error in tests
		// Case #10: Area, Area. Single-cell ranges with complex numbers. Returns 4+5i. - err in tests but work in app
		// Case #12: Array, Array. Arrays with single complex numbers. Returns 4+5i.
		// Case #20: Area3D, Area3D. 3D single-cell ranges with complex numbers. Returns 4+5i. - err in tests but work in app
		// Case #22: Table, Table. Table structured references with complex numbers. Returns 4+5i. - NaNNaNi
		// Case #31: Array. Multi-element array, processes first element. Returns 3+4i.
		// Case #32: Array, Array. Multi-element arrays, processes first elements. Returns 4+5i.
		// Case #33: Reference link, Reference link. References to cells with real numbers as complex. Returns 7.
		// Case #4: Area. Multi-cell range returns #VALUE!.
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		// Case #10: String, String. Non-numeric string in second argument returns #VALUE!.
		// Case #13: Array. Array with boolean returns #VALUE!.
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!. - j?
		// Case #19: Array, String. Array with mixed valid and invalid elements, processes first valid element. Returns 4+5i.


		testArrayFormula2(assert, "IMSUB", 2, 2, true, null);
	});

	QUnit.test("Test: \"IMTAN\"", function (assert) {
		oParser = new parserFormula('IMTAN("4+3i")', "A2", ws);
		assert.ok(oParser.parse(), 'IMTAN("4+3i")');
		assert.strictEqual(oParser.calculate().getValue(), "0.004908258067496062+1.000709536067233i", 'IMTAN("4+3i")');

		ws.getRange2("A1:C214").cleanAll();
		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("21+i");
		ws.getRange2("A101").setValue("21i");
		ws.getRange2("A104").setValue("2.9+2.9i");
		// For area
		ws.getRange2("A102").setValue("i");
		ws.getRange2("A103").setValue("1.9+1.9i");
		ws.getRange2("A105").setValue("0-09i");
		ws.getRange2("A106").setValue("0-2i");
		ws.getRange2("A107").setValue("25-52i");
		ws.getRange2("A108").setValue("1+4i");
		ws.getRange2("A109").setValue("11-11.099i");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 2);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		ws.getRange2("B601").setValue("1s"); // Text (Column2)
		ws.getRange2("C601").setValue("123i"); // TextNum (Column3)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1:C10").cleanAll();
		ws2.getRange2("A1").setValue("1");
		ws2.getRange2("A2").setValue("2");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("3");
		ws2.getRange2("B2").setValue("4");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.
		oParser = new parserFormula('IMTAN("3+4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("3+4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853+0.9993559873814732i', 'Test: Positive case: String. Complex number as string. Returns modulus sqrt(3^2 + 4^2) = 5.');
		// Case #2: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMTAN("3-4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("3-4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853-0.9993559873814732i', 'Test: Positive case: String. Complex number with negative imaginary part. Returns modulus sqrt(3^2 + (-4)^2) = 5.');
		// Case #3: Number. Real number as string convertible to complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN("5")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("5") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.380515006246586', 'Test: Positive case: Number. Real number as string convertible to complex number. Returns modulus 5.');
		// Case #4: Formula. Complex number created by COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMTAN(COMPLEX(3,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(COMPLEX(3,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853+0.9993559873814732i', 'Test: Positive case: Formula. Complex number created by COMPLEX formula. Returns modulus 5.');
		// Case #5: Reference link. Reference to cell with valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.2725949436215948+1.0787131089813278i', 'Test: Positive case: Reference link. Reference to cell with valid complex number. Returns modulus 5.');
		// Case #6: Area. Single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'i', 'Test: Positive case: Area. Single-cell range with complex number. Returns modulus 5.');
		// Case #7: Array. Array with single complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN({"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN({"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853+0.9993559873814732i', 'Test: Positive case: Array. Array with single complex number. Returns modulus 5.');
		// Case #8: Name. Named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5463024898437905', 'Test: Positive case: Name. Named range with complex number. Returns modulus 5.');
		// Case #9: Name3D. 3D named range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5463024898437905', 'Test: Positive case: Name3D. 3D named range with complex number. Returns modulus 5.');
		// Case #10: Ref3D. 3D reference to cell with complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5574077246549023', 'Test: Positive case: Ref3D. 3D reference to cell with complex number. Returns modulus 5.');
		// Case #11: Area3D. 3D single-cell range with complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(Sheet2!A2:A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(Sheet2!A2:A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-2.185039863261519', 'Test: Positive case: Area3D. 3D single-cell range with complex number. Returns modulus 5.');
		// Case #12: Table. Table structured reference with complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.5574077246549023', 'Test: Positive case: Table. Table structured reference with complex number. Returns modulus 5.');
		// Case #13: Formula. Nested IF returning valid complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(IF(TRUE, "3+4i", "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(IF(TRUE, "3+4i", "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853+0.9993559873814732i', 'Test: Positive case: Formula. Nested IF returning valid complex number. Returns modulus 5.');
		// Case #14: String. Pure imaginary number as string. Returns modulus 4.
		oParser = new parserFormula('IMTAN("4i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("4i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.999329299739067i', 'Test: Positive case: String. Pure imaginary number as string. Returns modulus 4.');
		// Case #15: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.
		oParser = new parserFormula('IMTAN(COMPLEX(0,4))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(COMPLEX(0,4)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.999329299739067i', 'Test: Positive case: Formula. Pure imaginary number via COMPLEX formula. Returns modulus 4.');
		// Case #16: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.
		oParser = new parserFormula('SUM(IMTAN("3+4i"),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(IMTAN("3+4i"),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. IMABS inside SUM formula. Returns 5 + 1 = 6.');
		// Case #17: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.
		oParser = new parserFormula('IMTAN("1.5+2.5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("1.5+2.5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.0019273435237456363+1.0134287782038933i', 'Test: Positive case: String. Complex number with decimal values. Returns modulus sqrt(1.5^2 + 2.5^2) ? 2.915.');
		// Case #18: Array. Multi-element array, processes first element. Returns modulus 5.
		oParser = new parserFormula('IMTAN({"3+4i";"1+2i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN({"3+4i";"1+2i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853+0.9993559873814732i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus 5.');
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		oParser = new parserFormula('IMTAN(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A102) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '0.761594155955765i', 'Test: Positive case: Reference link. Reference to cell with real number as complex. Returns modulus 5.');
		// Case #20: Formula. Complex number string built by CONCATENATE. Returns modulus 5.
		oParser = new parserFormula('IMTAN(CONCATENATE("3+","4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(CONCATENATE("3+","4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853+0.9993559873814732i', 'Test: Positive case: Formula. Complex number string built by CONCATENATE. Returns modulus 5.');
		// Case #21: String. Zero complex number. Returns modulus 0.
		oParser = new parserFormula('IMTAN("0+0i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("0+0i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: String. Zero complex number. Returns modulus 0.');
		// Case #22: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.
		oParser = new parserFormula('IMTAN("-33.5+2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("-33.5+2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.03193375111951066+1.0186429835208668i', 'Test: Positive case: String. Complex number with negative real part. Returns modulus sqrt((-3)^2 + 4^2) = 5.');
		// Case #23: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.
		oParser = new parserFormula('IMTAN("-33.5-2i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("-33.5-2i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.03193375111951066-1.0186429835208668i', 'Test: Positive case: String. Complex number with both negative parts. Returns modulus sqrt((-3)^2 + (-4)^2) = 5.');
		// Case #24: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.
		oParser = new parserFormula('IMTAN(COMPLEX(-3.5,-42))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(COMPLEX(-3.5,-42)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-4.343602022316227e-37-i', 'Test: Positive case: Formula. Complex number with negative parts via COMPLEX. Returns modulus 5.');
		// Case #25: Reference link. Reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.02836508657732785+1.0356313436020759i', 'Test: Positive case: Reference link. Reference to cell with negative complex number. Returns modulus 5.');
		// Case #26: Area. Single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(A104:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A104:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.0027981877652434933+0.994648493582243i', 'Test: Positive case: Area. Single-cell range with negative complex number. Returns modulus 5.');
		// Case #27: Array. Array with single negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN({"-3+99i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN({"-3+99i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '5.71443201249831e-87+i', 'Test: Positive case: Array. Array with single negative complex number. Returns modulus 5.');
		// Case #28: Name. Named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(TestName1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(TestName1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5463024898437905', 'Test: Positive case: Name. Named range with negative complex number. Returns modulus 5.');
		// Case #29: Name3D. 3D named range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.5463024898437905', 'Test: Positive case: Name3D. 3D named range with negative complex number. Returns modulus 5.');
		// Case #30: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(Sheet2!A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(Sheet2!A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with negative complex number. Returns modulus 5.');
		// Case #31: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(Sheet2!A4:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(Sheet2!A4:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Positive case: Area3D. 3D single-cell range with negative complex number. Returns modulus 5.');
		// Case #32: Table. Table structured reference with negative complex number. Returns modulus 5.
		oParser = new parserFormula('IMTAN(Table1[Column2])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(Table1[Column2]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Table. Table structured reference with negative complex number. Returns modulus 5.');
		// Case #33: Formula. Complex number formatted by TEXT function. Returns modulus 5.
		oParser = new parserFormula('IMTAN(TEXT("3+i4","0+0i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(TEXT("3+i4","0+0i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Formula. Complex number formatted by TEXT function. Returns modulus 5.');
		// Case #34: String. Pure imaginary number with zero real part. Returns modulus 5.
		oParser = new parserFormula('IMTAN("0+5i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("0+5i") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.999909204262595i', 'Test: Positive case: String. Pure imaginary number with zero real part. Returns modulus 5.');
		// Case #35: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.
		oParser = new parserFormula('IMTAN(COMPLEX(1.25,-2.75))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(COMPLEX(1.25,-2.75)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.004923797414777423-1.0065576091838457i', 'Test: Positive case: Formula. Complex number with decimal coefficients via COMPLEX. Returns modulus sqrt(1.25^2 + (-2.75)^2) ? 3.021.');
		// Case #36: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.
		oParser = new parserFormula('IMTAN(A105)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A105) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.999999969540041i', 'Test: Positive case: Reference link. Reference to cell with decimal complex number. Returns modulus ? 3.021.');
		// Case #37: Formula. Nested IF with COMPLEX formula. Returns modulus 5.
		oParser = new parserFormula('IMTAN(IF(1>0, COMPLEX(3,4), "1+2i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(IF(1>0, COMPLEX(3,4), "1+2i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853+0.9993559873814732i', 'Test: Positive case: Formula. Nested IF with COMPLEX formula. Returns modulus 5.');
		// Case #38: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.
		oParser = new parserFormula('IMTAN({"1+2i";"3+4i"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN({"1+2i";"3+4i"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.0338128260798967+1.0147936161466335i', 'Test: Positive case: Array. Multi-element array, processes first element. Returns modulus sqrt(1^2 + 2^2) ? 2.236.');
		// Case #39: Formula. Complex number string converted by VALUE. Returns modulus 5.
		oParser = new parserFormula('IMTAN(VALUE("3+4i"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(VALUE("3+4i")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Positive case: Formula. Complex number string converted by VALUE. Returns modulus 5.');
		// Case #40: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.
		oParser = new parserFormula('IMTAN(A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.9640275800758168i', 'Test: Positive case: Reference link. Reference to cell with pure imaginary number. Returns modulus 4.');

		// Negative cases:
		// Case #1: String. Non-numeric string returns #VALUE!.
		oParser = new parserFormula('IMTAN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!.');
		// Case #2: Error. Propagates #N/A error.
		oParser = new parserFormula('IMTAN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error.');
		// Case #3: Empty. Reference to empty cell. Returns #VALUE!.
		oParser = new parserFormula('IMTAN(A107)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A107) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-3.575411948512727e-46-i', 'Test: Negative case: Empty. Reference to empty cell. Returns #VALUE!.');
		// Case #4: Area. Multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMTAN(A108:A109)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A108:A109) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!.');
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		oParser = new parserFormula('IMTAN(FALSE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(FALSE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean FALSE returns #VALUE!.');
		// Case #6: Ref3D. 3D reference to cell with text returns #VALUE!.
		oParser = new parserFormula('IMTAN(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Ref3D. 3D reference to cell with text returns #VALUE!.');
		// Case #7: Name. Named range with text returns #VALUE!.
		oParser = new parserFormula('IMTAN(TestNameArea2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(TestNameArea2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.0296385570503641', 'Test: Negative case: Name. Named range with text returns #VALUE!.');
		// Case #8: Table. Table column with text returns #VALUE!.
		oParser = new parserFormula('IMTAN(Table1[Column3])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(Table1[Column3]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'i', 'Test: Negative case: Table. Table column with text returns #VALUE!.');
		// Case #9: Formula. Formula resulting in #NUM! propagates error.
		oParser = new parserFormula('IMTAN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error.');
		// Case #10: String. Empty string returns #VALUE!.
		oParser = new parserFormula('IMTAN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Empty string returns #VALUE!.');
		// Case #11: Date. Date serial number not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMTAN(DATE(2025,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(DATE(2025,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '2.855712853901801', 'Test: Negative case: Date. Date serial number not valid complex number, returns #VALUE!.');
		// Case #12: Time. Time value not valid complex number, returns #VALUE!.
		oParser = new parserFormula('IMTAN(TIME(12,0,0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(TIME(12,0,0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0.5463024898437905', 'Test: Negative case: Time. Time value not valid complex number, returns #VALUE!.');
		// Case #13: Array. Array with boolean returns #VALUE!.
		oParser = new parserFormula('IMTAN({FALSE})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN({FALSE}) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Array. Array with boolean returns #VALUE!.');
		// Case #14: Name3D. 3D named range with text returns #VALUE!.
		oParser = new parserFormula('IMTAN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1.0296385570503641', 'Test: Negative case: Name3D. 3D named range with text returns #VALUE!.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!.
		oParser = new parserFormula('IMTAN(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!.');
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!.
		oParser = new parserFormula('IMTAN("3+4j")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("3+4j") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853+0.9993559873814732j', 'Test: Negative case: String. Invalid complex number suffix (j instead of i) returns #VALUE!.');
		// Case #17: Formula. Invalid complex number format returns #VALUE!.
		oParser = new parserFormula('IMTAN("3+" & "4")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("3+" & "4") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Invalid complex number format returns #VALUE!.');
		// Case #18: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.
		oParser = new parserFormula('IMTAN(A110)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(A110) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Reference link. Reference to cell with invalid complex number. Returns #VALUE!.');
		// Case #19: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.
		oParser = new parserFormula('IMTAN({"3+4i";"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN({"3+4i";"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '-0.00018734620462947853+0.9993559873814732i', 'Test: Negative case: Array. Array with mixed valid and invalid elements, processes first valid element. Returns modulus 5.');
		// Case #20: Formula. Nested IF returning invalid string returns #VALUE!.
		oParser = new parserFormula('IMTAN(IF(FALSE, "3+4i", "abc"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN(IF(FALSE, "3+4i", "abc")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Nested IF returning invalid string returns #VALUE!.');

		// Bounded cases:
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).
		oParser = new parserFormula('IMTAN("1E+307+1E+307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("1E+307+1E+307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), 'i', 'Test: Bounded case: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2).');
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		oParser = new parserFormula('IMTAN("1E-307+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("1E-307+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1E-307+1E-307i', 'Test: Bounded case: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).');
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.
		oParser = new parserFormula('IMTAN("0+1E-307i")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: IMTAN("0+1E-307i") is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '1E-307i', 'Test: Bounded case: Number. Minimum positive imaginary component. Returns modulus 1E-307.');

		// Need to fix: bool and empty handle, diff results from ms
		// Case #19: Reference link. Reference to cell with real number as complex. Returns modulus 5.
		// Case #5: Boolean. Boolean FALSE returns #VALUE!.
		// Case #10: String. Empty string returns #VALUE!.
		// Case #13: Array. Array with boolean returns #VALUE!.
		// Case #16: String. Invalid complex number suffix (j instead of i) returns #VALUE!. - j
		// Case #1: Number. Maximum valid complex number. Returns modulus sqrt(1E+307^2 + 1E+307^2). - NaN
		// Case #2: Number. Minimum positive complex number. Returns modulus sqrt(1E-307^2 + 1E-307^2).
		// Case #3: Number. Minimum positive imaginary component. Returns modulus 1E-307.

		testArrayFormula(assert, "IMTAN", true);
	});

	QUnit.test("Test: \"OCT2BIN\"", function (assert) {

		oParser = new parserFormula("OCT2BIN(\"52\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"52\")");
		assert.strictEqual(oParser.calculate().getValue(), "101010");

		oParser = new parserFormula("OCT2BIN(\"7777777000\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"7777777000\")");
		assert.strictEqual(oParser.calculate().getValue(), "1000000000");

		oParser = new parserFormula("OCT2BIN(\"7777777001\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"7777777001\")");
		assert.strictEqual(oParser.calculate().getValue(), "1000000001");

		oParser = new parserFormula("OCT2BIN(\"7777777777\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"7777777777\")");
		assert.strictEqual(oParser.calculate().getValue(), "1111111111");

		oParser = new parserFormula("OCT2BIN(\"0\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"0\")");
		assert.strictEqual(oParser.calculate().getValue(), "0");

		oParser = new parserFormula("OCT2BIN(\"1\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"1\")");
		assert.strictEqual(oParser.calculate().getValue(), "1");

		oParser = new parserFormula("OCT2BIN(\"776\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"776\")");
		assert.strictEqual(oParser.calculate().getValue(), "111111110");

		oParser = new parserFormula("OCT2BIN(\"777\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"777\")");
		assert.strictEqual(oParser.calculate().getValue(), "111111111");

		oParser = new parserFormula("OCT2BIN(\"52\", 6)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"52\",6)");
		assert.strictEqual(oParser.calculate().getValue(), "101010");

		oParser = new parserFormula("OCT2BIN(\"52\", 8)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"52\",8)");
		assert.strictEqual(oParser.calculate().getValue(), "00101010");

		oParser = new parserFormula("OCT2BIN(\"Hello World!\", 8)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"Hello World!\",8)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("OCT2BIN(\"52\",\"Hello World!\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2BIN(\"52\",\"Hello World!\")");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: small positive octal number. 1 argument used.
		oParser = new parserFormula('OCT2BIN(7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111', 'Test: Positive case: Number. Basic valid input: small positive octal number. 1 argument used.');
		// Case #2: Number, Number. Positive octal with fixed places (3 digits). 2 arguments used.
		oParser = new parserFormula('OCT2BIN(7,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(7,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111', 'Test: Positive case: Number, Number. Positive octal with fixed places (3 digits). 2 arguments used.');
		// Case #3: String. String convertible to valid octal number. 1 argument used.
		oParser = new parserFormula('OCT2BIN("7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN("7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111', 'Test: Positive case: String. String convertible to valid octal number. 1 argument used.');
		// Case #4: String, Number. String convertible to octal with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN("7",3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN("7",3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111', 'Test: Positive case: String, Number. String convertible to octal with fixed places. 2 arguments used.');
		// Case #5: Formula. Nested formula converting decimal to octal. 1 argument used.
		oParser = new parserFormula('OCT2BIN(OCT2DEC("7"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(OCT2DEC("7")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111', 'Test: Positive case: Formula. Nested formula converting decimal to octal. 1 argument used.');
		// Case #6: Formula, Number. Nested formula with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(OCT2DEC("7"),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(OCT2DEC("7"),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111', 'Test: Positive case: Formula, Number. Nested formula with fixed places. 2 arguments used.');
		// Case #7: Reference link. Reference to cell with valid octal number. 1 argument used.
		oParser = new parserFormula('OCT2BIN(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. Reference to cell with valid octal number. 1 argument used.');
		// Case #8: Reference link, Number. Reference to cell with octal and fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(A101,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(A101,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link, Number. Reference to cell with octal and fixed places. 2 arguments used.');
		// Case #9: Area. Single-cell range with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2BIN(A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell range with valid octal. 1 argument used.');
		// Case #10: Area, Number. Single-cell range with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(A103:A103,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(A103:A103,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000', 'Test: Positive case: Area, Number. Single-cell range with fixed places. 2 arguments used.');
		// Case #11: Array. Array with single valid octal element. 1 argument used.
		oParser = new parserFormula('OCT2BIN({7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN({7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111', 'Test: Positive case: Array. Array with single valid octal element. 1 argument used.');
		// Case #12: Array, Number. Array with single octal and fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN({7},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN({7},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111', 'Test: Positive case: Array, Number. Array with single octal and fixed places. 2 arguments used.');
		// Case #13: Name. Named range with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2BIN(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid octal. 1 argument used.');
		// Case #14: Name, Number. Named range with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(TestName1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(TestName1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Number. Named range with fixed places. 2 arguments used.');
		// Case #15: Name3D. 3D named range with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2BIN(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid octal. 1 argument used.');
		// Case #16: Name3D, Number. 3D named range with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(TestName3D,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(TestName3D,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Number. 3D named range with fixed places. 2 arguments used.');
		// Case #17: Ref3D. 3D reference to cell with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2BIN(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with valid octal. 1 argument used.');
		// Case #18: Ref3D, Number. 3D reference with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(Sheet2!A2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(Sheet2!A2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D, Number. 3D reference with fixed places. 2 arguments used.');
		// Case #19: Area3D. 3D single-cell range with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2BIN(Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with valid octal. 1 argument used.');
		// Case #20: Area3D, Number. 3D single-cell range with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(Sheet2!A4:A4,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(Sheet2!A4:A4,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D, Number. 3D single-cell range with fixed places. 2 arguments used.');
		// Case #21: Table. Table structured reference with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2BIN(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Table. Table structured reference with valid octal. 1 argument used.');
		// Case #23: Formula. OCT2BIN inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(OCT2BIN(7),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(OCT2BIN(7),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 112, 'Test: Positive case: Formula. OCT2BIN inside SUM formula. 1 argument used.');
		// Case #24: String. Larger octal number as string. 1 argument used.
		oParser = new parserFormula('OCT2BIN("777")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN("777") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '111111111', 'Test: Positive case: String. Larger octal number as string. 1 argument used.');
		// Case #25: Number, Number. Octal with maximum valid places (10). 2 arguments used.
		oParser = new parserFormula('OCT2BIN(777,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(777,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0111111111', 'Test: Positive case: Number, Number. Octal with maximum valid places (10). 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Invalid octal number (>3777777777) returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2BIN(4000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(4000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Invalid octal number (>3777777777) returns #NUM!. 1 argument used.');
		// Case #2: Number, Number. Negative places returns #NUM!. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(7,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(7,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative places returns #NUM!. 2 arguments used.');
		// Case #3: Number, Number. Places > 10 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(7,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(7,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Places > 10 returns #NUM!. 2 arguments used.');
		// Case #4: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2BIN("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #5: String, Number. Non-numeric string with places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('OCT2BIN("abc",3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN("abc",3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Non-numeric string with places returns #VALUE!. 2 arguments used.');
		// Case #6: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('OCT2BIN(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(NA()) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #7: Empty. Empty cell reference returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2BIN(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty cell reference returns #VALUE!. 1 argument used.');
		// Case #8: Empty, Number. Empty cell reference with places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(A104,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(A104,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty cell reference with places returns #VALUE!. 2 arguments used.');
		// Case #9: Boolean. Boolean TRUE returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2BIN(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean TRUE returns #NUM!. 1 argument used.');
		// Case #10: Boolean, Number. Boolean FALSE with places returns #NUM!. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(FALSE,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(FALSE,3) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE with places returns #NUM!. 2 arguments used.');
		// Case #11: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2BIN(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #12: Name. Named range with multi-cell area returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2BIN(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with multi-cell area returns #VALUE!. 1 argument used.');
		// Case #13: Name3D. 3D named range with multi-cell area returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2BIN(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with multi-cell area returns #VALUE!. 1 argument used.');
		// Case #14: Ref3D. 3D reference to non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2BIN(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Ref3D. 3D reference to non-numeric value returns #VALUE!. 1 argument used.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2BIN(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #17: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('OCT2BIN(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(SQRT(-1)) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #18: Number. Invalid negative octal number returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2BIN(-4000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(-4000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Invalid negative octal number returns #NUM!. 1 argument used.');
		// Case #19: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2BIN("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #20: Array. Array with invalid octal returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2BIN({4000000000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN({4000000000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with invalid octal returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid octal number. 1 argument used.
		oParser = new parserFormula('OCT2BIN(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number. Minimum valid octal number. 1 argument used.');
		// Case #2: Number. Maximum valid positive octal number. 1 argument used.
		oParser = new parserFormula('OCT2BIN(3777777777)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(3777777777) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid positive octal number. 1 argument used.');
		// Case #3: Number. Maximum valid negative octal number. 1 argument used.
		oParser = new parserFormula('OCT2BIN(-3777777777)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(-3777777777) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid negative octal number. 1 argument used.');
		// Case #4: Number, Number. Minimum valid places (1). 2 arguments used.
		oParser = new parserFormula('OCT2BIN(7,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(7,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number. Minimum valid places (1). 2 arguments used.');
		// Case #5: Number, Number. Maximum valid octal with maximum places. 2 arguments used.
		oParser = new parserFormula('OCT2BIN(3777777777,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2BIN(3777777777,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number, Number. Maximum valid octal with maximum places. 2 arguments used.');


		// Need to fix: error handle, error types diff from MS, Boolean handle
		// Case #20: Area3D, Number. 3D single-cell range with fixed places. 2 arguments used.
		// Case #6: Error. Propagates #N/A error. 1 argument used.
		// Case #9: Boolean. Boolean TRUE returns #NUM!. 1 argument used.
		// Case #10: Boolean, Number. Boolean FALSE with places returns #NUM!. 2 arguments used.
		// Case #17: Formula. Formula resulting in #NUM! error. 1 argument used.

		testArrayFormula2(assert, "OCT2BIN", 1, 2, true)
	});

	QUnit.test("Test: \"OCT2DEC\"", function (assert) {

		oParser = new parserFormula("OCT2DEC(\"52\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2DEC(\"52\")");
		assert.strictEqual(oParser.calculate().getValue(), 42);

		oParser = new parserFormula("OCT2DEC(\"4000000000\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2DEC(\"4000000000\")");
		assert.strictEqual(oParser.calculate().getValue(), -536870912);

		oParser = new parserFormula("OCT2DEC(\"7777777777\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2DEC(\"7777777777\")");
		assert.strictEqual(oParser.calculate().getValue(), -1);

		oParser = new parserFormula("OCT2DEC(\"0\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2DEC(\"0\")");
		assert.strictEqual(oParser.calculate().getValue(), 0);

		oParser = new parserFormula("OCT2DEC(\"1\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2DEC(\"1\")");
		assert.strictEqual(oParser.calculate().getValue(), 1);

		oParser = new parserFormula("OCT2DEC(\"3777777776\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2DEC(\"3777777776\")");
		assert.strictEqual(oParser.calculate().getValue(), 536870910);

		oParser = new parserFormula("OCT2DEC(\"3777777777\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2DEC(\"3777777777\")");
		assert.strictEqual(oParser.calculate().getValue(), 536870911);

		oParser = new parserFormula("OCT2DEC(\"3777777777\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2DEC(\"3777777777\")");
		assert.strictEqual(oParser.calculate().getValue(), 536870911);

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2


		// Positive cases:
		// Case #1: Number. Basic valid integer input (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(77)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(77) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 63, 'Test: Positive case: Number. Basic valid integer input (octal 77 = decimal 63). 1 argument used.');
		// Case #2: Number. Zero input (octal 0 = decimal 0). 1 argument used.
		oParser = new parserFormula('OCT2DEC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Number. Zero input (octal 0 = decimal 0). 1 argument used.');
		// Case #3: String. String convertible to valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC("77")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC("77") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 63, 'Test: Positive case: String. String convertible to valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #4: String. String with leading zeros (octal 007 = decimal 7). 1 argument used.
		oParser = new parserFormula('OCT2DEC("007")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC("007") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 7, 'Test: Positive case: String. String with leading zeros (octal 007 = decimal 7). 1 argument used.');
		// Case #5: Formula. Nested formula returning valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(ABS(-77))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(ABS(-77)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 63, 'Test: Positive case: Formula. Nested formula returning valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #6: Formula. Nested IF formula returning valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(IF(TRUE, 77, 0))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(IF(TRUE, 77, 0)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 63, 'Test: Positive case: Formula. Nested IF formula returning valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #7: Reference link. Reference to cell with valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. Reference to cell with valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #8: Area. Single-cell range with valid octal (octal 0 = decimal 0). 1 argument used.
		oParser = new parserFormula('OCT2DEC(A101:A101)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(A101:A101) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell range with valid octal (octal 0 = decimal 0). 1 argument used.');
		// Case #9: Array. Array with single valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC({77})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC({77}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 63, 'Test: Positive case: Array. Array with single valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #10: Array. Array with multiple valid octals (takes first: octal 0 = decimal 0). 1 argument used.
		oParser = new parserFormula('OCT2DEC({0, 77})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC({0, 77}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Positive case: Array. Array with multiple valid octals (takes first: octal 0 = decimal 0). 1 argument used.');
		// Case #11: Name. Named range with valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #12: Name3D. 3D named range with valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #13: Ref3D. 3D reference to cell with valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #14: Area3D. 3D single-cell range with valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(Sheet2!A1:A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(Sheet2!A1:A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #15: Table. Table structured reference with valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Table. Table structured reference with valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #16: Formula. Nested DEC2OCT returning valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(DEC2OCT(63))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(DEC2OCT(63)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 63, 'Test: Positive case: Formula. Nested DEC2OCT returning valid octal (octal 77 = decimal 63). 1 argument used.');
		// Case #17: String. Larger valid octal string (octal 777 = decimal 511). 1 argument used.
		oParser = new parserFormula('OCT2DEC("777")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC("777") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 511, 'Test: Positive case: String. Larger valid octal string (octal 777 = decimal 511). 1 argument used.');
		// Case #18: Date. Date as serial number treated as octal (1 = decimal 1). 1 argument used.
		oParser = new parserFormula('OCT2DEC(DATE(1900,1,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(DATE(1900,1,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 1, 'Test: Positive case: Date. Date as serial number treated as octal (1 = decimal 1). 1 argument used.');
		// Case #19: Time. Time as fraction treated as octal (small number). 1 argument used.
		oParser = new parserFormula('OCT2DEC(TIME(0,0,1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(TIME(0,0,1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Time. Time as fraction treated as octal (small number). 1 argument used.');
		// Case #20: Formula. Nested CONCATENATE forming valid octal (octal 77 = decimal 63). 1 argument used.
		oParser = new parserFormula('OCT2DEC(CONCATENATE("7","7"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(CONCATENATE("7","7")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 63, 'Test: Positive case: Formula. Nested CONCATENATE forming valid octal (octal 77 = decimal 63). 1 argument used.');

		// Negative cases:
		// Case #1: Number. Negative number returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Negative number returns #NUM!. 1 argument used.');
		// Case #2: String. Non-octal string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-octal string returns #VALUE!. 1 argument used.');
		// Case #3: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('OCT2DEC(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #4: Empty. Reference to empty cell returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Reference to empty cell returns #VALUE!. 1 argument used.');
		// Case #5: Boolean. Boolean TRUE returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(TRUE) is parsed.');
		//? assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean TRUE returns #VALUE!. 1 argument used.');
		// Case #6: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(A103:A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(A103:A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #7: Ref3D. 3D reference to non-octal text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(Sheet2!A2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(Sheet2!A2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Ref3D. 3D reference to non-octal text returns #VALUE!. 1 argument used.');
		// Case #8: Name. Named range with non-octal text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with non-octal text returns #VALUE!. 1 argument used.');
		// Case #9: Name3D. 3D named range with non-octal text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with non-octal text returns #VALUE!. 1 argument used.');
		// Case #11: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #12: Formula. Formula resulting in #NUM! propagates error. 1 argument used.
		oParser = new parserFormula('OCT2DEC(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! propagates error. 1 argument used.');
		// Case #13: Number. Number exceeding octal limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(10000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(10000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number exceeding octal limit returns #NUM!. 1 argument used.');
		// Case #14: String. String exceeding octal limit returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2DEC("10000000000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC("10000000000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. String exceeding octal limit returns #NUM!. 1 argument used.');
		// Case #15: Array. Array with non-octal text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC({"abc"})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC({"abc"}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Array. Array with non-octal text returns #VALUE!. 1 argument used.');
		// Case #16: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.
		oParser = new parserFormula('OCT2DEC(1/0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(1/0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#DIV/0!', 'Test: Negative case: Formula. Formula resulting in #DIV/0! propagates error. 1 argument used.');
		// Case #17: Reference link. Reference to cell with non-octal text returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(A103)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(A103) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Negative case: Reference link. Reference to cell with non-octal text returns #VALUE!. 1 argument used.');
		// Case #18: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(Sheet2!A3:A4)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(Sheet2!A3:A4) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #19: String. Single non-octal digit (8) returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2DEC("8")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC("8") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Single non-octal digit (8) returns #NUM!. 1 argument used.');
		// Case #20: Number. Number with non-octal digit (8) returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2DEC(7777777778)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(7777777778) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Number with non-octal digit (8) returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid octal (0 = decimal 0). 1 argument used.
		oParser = new parserFormula('OCT2DEC(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 0, 'Test: Bounded case: Number. Minimum valid octal (0 = decimal 0). 1 argument used.');
		// Case #2: Number. Maximum valid octal (17777777777 = decimal 536870911). 1 argument used.
		oParser = new parserFormula('OCT2DEC(17777777777)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC(17777777777) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid octal (17777777777 = decimal 536870911). 1 argument used.');
		// Case #3: String. Minimum negative octal (2000000000 = decimal -536870912). 1 argument used.
		oParser = new parserFormula('OCT2DEC("2000000000")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2DEC("2000000000") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 268435456, 'Test: Bounded case: String. Minimum negative octal (2000000000 = decimal -536870912). 1 argument used.');


		// Need to fix: Boolean handle
		// Case #5: Boolean. Boolean TRUE returns #VALUE!. 1 argument used.

		testArrayFormula2(assert, "OCT2DEC", 1, 1, true);
	});

	QUnit.test("Test: \"OCT2HEX\"", function (assert) {

		oParser = new parserFormula("OCT2HEX(\"52\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"52\")");
		assert.strictEqual(oParser.calculate().getValue(), "2A");

		oParser = new parserFormula("OCT2HEX(\"4000000000\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"4000000000\")");
		assert.strictEqual(oParser.calculate().getValue(), "FFE0000000");

		oParser = new parserFormula("OCT2HEX(\"4000000001\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"4000000001\")");
		assert.strictEqual(oParser.calculate().getValue(), "FFE0000001");

		oParser = new parserFormula("OCT2HEX(\"7777777777\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"7777777777\")");
		assert.strictEqual(oParser.calculate().getValue(), "FFFFFFFFFF");

		oParser = new parserFormula("OCT2HEX(\"0\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"0\")");
		assert.strictEqual(oParser.calculate().getValue(), "0");

		oParser = new parserFormula("OCT2HEX(\"1\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"1\")");
		assert.strictEqual(oParser.calculate().getValue(), "1");

		oParser = new parserFormula("OCT2HEX(\"3777777776\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"3777777776\")");
		assert.strictEqual(oParser.calculate().getValue(), "1FFFFFFE");

		oParser = new parserFormula("OCT2HEX(\"3777777777\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"3777777777\")");
		assert.strictEqual(oParser.calculate().getValue(), "1FFFFFFF");

		oParser = new parserFormula("OCT2HEX(\"52\", 2)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"52\",2)");
		assert.strictEqual(oParser.calculate().getValue(), "2A");

		oParser = new parserFormula("OCT2HEX(\"52\", 4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"52\",4)");
		assert.strictEqual(oParser.calculate().getValue(), "002A");

		oParser = new parserFormula("OCT2HEX(\"Hello World!\", 4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"Hello World!\",4)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("OCT2HEX(\"52\", -4)", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"52\",-4)");
		assert.strictEqual(oParser.calculate().getValue(), "#NUM!");

		oParser = new parserFormula("OCT2HEX(\"52\", \"Hello World!\")", "A2", ws);
		assert.ok(oParser.parse());
		assert.ok(oParser.assemble() == "OCT2HEX(\"52\",\"Hello World!\")");
		assert.strictEqual(oParser.calculate().getValue(), "#VALUE!");

		// Data for reference link. Use A100-A111
		ws.getRange2("A100").setValue("0.5");
		ws.getRange2("A101").setValue("1.5");
		ws.getRange2("A104").setValue("-1");
		// For area
		ws.getRange2("A102").setValue("0.5");
		ws.getRange2("A103").setValue("");
		ws.getRange2("A105").setValue("1");
		ws.getRange2("A110").setValue("TRUE");
		ws.getRange2("A111").setValue("FALSE");

		// Table type. Use A601:L6**
		getTableType(599, 0, 600, 0);
		ws.getRange2("A601").setValue("1"); // Number (Column1)
		// 3D links. Use A1:Z10
		let ws2 = getSecondSheet();
		ws2.getRange2("A1").setValue("0.5");
		ws2.getRange2("A2").setValue("1.5");
		ws2.getRange2("A3").setValue("Text");
		ws2.getRange2("A4").setValue("123");
		ws2.getRange2("B1").setValue("-1");
		ws2.getRange2("C1").setValue("1");
		// DefNames.
		initDefNames();
		ws.getRange2("A201").setValue("-0.5"); // TestName
		ws.getRange2("A202").setValue("0.5"); // TestName1
		ws.getRange2("A203").setValue("10.5"); // TestName2
		ws2.getRange2("A11").setValue("-0.5"); // TestName3D
		ws.getRange2("A208").setValue("0.8"); // TestNameArea2
		ws.getRange2("B208").setValue("-0.8"); // TestNameArea2
		ws2.getRange2("A18").setValue("0.8"); // TestNameArea3D2
		ws2.getRange2("B18").setValue("-0.8"); // TestNameArea3D2

		// Positive cases:
		// Case #1: Number. Basic valid input: small positive octal number. 1 argument used.
		oParser = new parserFormula('OCT2HEX(7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7', 'Test: Positive case: Number. Basic valid input: small positive octal number. 1 argument used.');
		// Case #2: Number, Number. Positive octal with fixed places (3 digits). 2 arguments used.
		oParser = new parserFormula('OCT2HEX(7,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(7,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '007', 'Test: Positive case: Number, Number. Positive octal with fixed places (3 digits). 2 arguments used.');
		// Case #3: String. String convertible to valid octal number. 1 argument used.
		oParser = new parserFormula('OCT2HEX("7")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX("7") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7', 'Test: Positive case: String. String convertible to valid octal number. 1 argument used.');
		// Case #4: String, Number. String convertible to octal with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX("7",3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX("7",3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '007', 'Test: Positive case: String, Number. String convertible to octal with fixed places. 2 arguments used.');
		// Case #5: Formula. Nested formula converting decimal to octal. 1 argument used.
		oParser = new parserFormula('OCT2HEX(OCT2DEC("7"))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(OCT2DEC("7")) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7', 'Test: Positive case: Formula. Nested formula converting decimal to octal. 1 argument used.');
		// Case #6: Formula, Number. Nested formula with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(OCT2DEC("7"),3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(OCT2DEC("7"),3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '007', 'Test: Positive case: Formula, Number. Nested formula with fixed places. 2 arguments used.');
		// Case #7: Reference link. Reference to cell with valid octal number. 1 argument used.
		oParser = new parserFormula('OCT2HEX(A100)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(A100) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link. Reference to cell with valid octal number. 1 argument used.');
		// Case #8: Reference link, Number. Reference to cell with octal and fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(A101,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(A101,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Reference link, Number. Reference to cell with octal and fixed places. 2 arguments used.');
		// Case #9: Area. Single-cell range with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2HEX(A102:A102)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(A102:A102) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area. Single-cell range with valid octal. 1 argument used.');
		// Case #10: Area, Number. Single-cell range with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(A103:A103,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(A103:A103,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '000', 'Test: Positive case: Area, Number. Single-cell range with fixed places. 2 arguments used.');
		// Case #11: Array. Array with single valid octal element. 1 argument used.
		oParser = new parserFormula('OCT2HEX({7})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX({7}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7', 'Test: Positive case: Array. Array with single valid octal element. 1 argument used.');
		// Case #12: Array, Number. Array with single octal and fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX({7},3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX({7},3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '007', 'Test: Positive case: Array, Number. Array with single octal and fixed places. 2 arguments used.');
		// Case #13: Name. Named range with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2HEX(TestName)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(TestName) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name. Named range with valid octal. 1 argument used.');
		// Case #14: Name, Number. Named range with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(TestName1,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(TestName1,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name, Number. Named range with fixed places. 2 arguments used.');
		// Case #15: Name3D. 3D named range with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2HEX(TestName3D)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(TestName3D) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D. 3D named range with valid octal. 1 argument used.');
		// Case #16: Name3D, Number. 3D named range with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(TestName3D,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(TestName3D,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Name3D, Number. 3D named range with fixed places. 2 arguments used.');
		// Case #17: Ref3D. 3D reference to cell with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2HEX(Sheet2!A1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(Sheet2!A1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D. 3D reference to cell with valid octal. 1 argument used.');
		// Case #18: Ref3D, Number. 3D reference with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(Sheet2!A2,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(Sheet2!A2,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Ref3D, Number. 3D reference with fixed places. 2 arguments used.');
		// Case #19: Area3D. 3D single-cell range with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2HEX(Sheet2!A3:A3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(Sheet2!A3:A3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Positive case: Area3D. 3D single-cell range with valid octal. 1 argument used.');
		// Case #20: Area3D, Number. 3D single-cell range with fixed places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(Sheet2!A4:A4,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(Sheet2!A4:A4,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), "053", 'Test: Positive case: Area3D, Number. 3D single-cell range with fixed places. 2 arguments used.');
		// Case #21: Table. Table structured reference with valid octal. 1 argument used.
		oParser = new parserFormula('OCT2HEX(Table1[Column1])', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(Table1[Column1]) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1', 'Test: Positive case: Table. Table structured reference with valid octal. 1 argument used.');
		// Case #23: Formula. OCT2BIN inside SUM formula. 1 argument used.
		oParser = new parserFormula('SUM(OCT2HEX(7),1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: SUM(OCT2HEX(7),1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 8, 'Test: Positive case: Formula. OCT2BIN inside SUM formula. 1 argument used.');
		// Case #24: String. Larger octal number as string. 1 argument used.
		oParser = new parserFormula('OCT2HEX("777")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX("777") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1FF', 'Test: Positive case: String. Larger octal number as string. 1 argument used.');
		// Case #25: Number, Number. Octal with maximum valid places (10). 2 arguments used.
		oParser = new parserFormula('OCT2HEX(777,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(777,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '00000001FF', 'Test: Positive case: Number, Number. Octal with maximum valid places (10). 2 arguments used.');

		// Negative cases:
		// Case #1: Number. Invalid octal number (>3777777777) returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2HEX(4000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(4000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFE0000000', 'Test: Negative case: Number. Invalid octal number (>3777777777) returns #NUM!. 1 argument used.');
		// Case #2: Number, Number. Negative places returns #NUM!. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(7,-1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(7,-1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Negative places returns #NUM!. 2 arguments used.');
		// Case #3: Number, Number. Places > 10 returns #NUM!. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(7,11)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(7,11) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number, Number. Places > 10 returns #NUM!. 2 arguments used.');
		// Case #4: String. Non-numeric string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2HEX("abc")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX("abc") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String. Non-numeric string returns #VALUE!. 1 argument used.');
		// Case #5: String, Number. Non-numeric string with places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('OCT2HEX("abc",3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX("abc",3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: String, Number. Non-numeric string with places returns #VALUE!. 2 arguments used.');
		// Case #6: Error. Propagates #N/A error. 1 argument used.
		oParser = new parserFormula('OCT2HEX(NA())', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(NA()) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#N/A', 'Test: Negative case: Error. Propagates #N/A error. 1 argument used.');
		// Case #7: Empty. Empty cell reference returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2HEX(A104)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(A104) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty. Empty cell reference returns #VALUE!. 1 argument used.');
		// Case #8: Empty, Number. Empty cell reference with places returns #VALUE!. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(A104,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(A104,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Empty, Number. Empty cell reference with places returns #VALUE!. 2 arguments used.');
		// Case #9: Boolean. Boolean TRUE returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2HEX(TRUE)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(TRUE) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean. Boolean TRUE returns #NUM!. 1 argument used.');
		// Case #10: Boolean, Number. Boolean FALSE with places returns #NUM!. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(FALSE,3)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(FALSE,3) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Boolean, Number. Boolean FALSE with places returns #NUM!. 2 arguments used.');
		// Case #11: Area. Multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2HEX(A105:A106)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(A105:A106) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area. Multi-cell range returns #VALUE!. 1 argument used.');
		// Case #12: Name. Named range with multi-cell area returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2HEX(TestNameArea)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(TestNameArea) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Name. Named range with multi-cell area returns #VALUE!. 1 argument used.');
		// Case #13: Name3D. 3D named range with multi-cell area returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2HEX(TestNameArea3D2)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(TestNameArea3D2) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Name3D. 3D named range with multi-cell area returns #VALUE!. 1 argument used.');
		// Case #14: Ref3D. 3D reference to non-numeric value returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2HEX(Sheet2!A5)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(Sheet2!A5) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: Ref3D. 3D reference to non-numeric value returns #VALUE!. 1 argument used.');
		// Case #15: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2HEX(Sheet2!A6:A7)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(Sheet2!A6:A7) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#VALUE!', 'Test: Negative case: Area3D. 3D multi-cell range returns #VALUE!. 1 argument used.');
		// Case #17: Formula. Formula resulting in #NUM! error. 1 argument used.
		oParser = new parserFormula('OCT2HEX(SQRT(-1))', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(SQRT(-1)) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Formula. Formula resulting in #NUM! error. 1 argument used.');
		// Case #18: Number. Invalid negative octal number returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2HEX(-4000000000)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(-4000000000) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Negative case: Number. Invalid negative octal number returns #NUM!. 1 argument used.');
		// Case #19: String. Empty string returns #VALUE!. 1 argument used.
		oParser = new parserFormula('OCT2HEX("")', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX("") is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Negative case: String. Empty string returns #VALUE!. 1 argument used.');
		// Case #20: Array. Array with invalid octal returns #NUM!. 1 argument used.
		oParser = new parserFormula('OCT2HEX({4000000000})', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX({4000000000}) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), 'FFE0000000', 'Test: Negative case: Array. Array with invalid octal returns #NUM!. 1 argument used.');

		// Bounded cases:
		// Case #1: Number. Minimum valid octal number. 1 argument used.
		oParser = new parserFormula('OCT2HEX(0)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(0) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '0', 'Test: Bounded case: Number. Minimum valid octal number. 1 argument used.');
		// Case #2: Number. Maximum valid positive octal number. 1 argument used.
		oParser = new parserFormula('OCT2HEX(3777777777)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(3777777777) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '1FFFFFFF', 'Test: Bounded case: Number. Maximum valid positive octal number. 1 argument used.');
		// Case #3: Number. Maximum valid negative octal number. 1 argument used.
		oParser = new parserFormula('OCT2HEX(-3777777777)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(-3777777777) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '#NUM!', 'Test: Bounded case: Number. Maximum valid negative octal number. 1 argument used.');
		// Case #4: Number, Number. Minimum valid places (1). 2 arguments used.
		oParser = new parserFormula('OCT2HEX(7,1)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(7,1) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '7', 'Test: Bounded case: Number, Number. Minimum valid places (1). 2 arguments used.');
		// Case #5: Number, Number. Maximum valid octal with maximum places. 2 arguments used.
		oParser = new parserFormula('OCT2HEX(3777777777,10)', 'A2', ws);
		assert.ok(oParser.parse(), 'Test: OCT2HEX(3777777777,10) is parsed.');
		assert.strictEqual(oParser.calculate().getValue(), '001FFFFFFF', 'Test: Bounded case: Number, Number. Maximum valid octal with maximum places. 2 arguments used.');


		testArrayFormula2(assert, "OCT2HEX", 1, 2, true)

	});

	wb.dependencyFormulas.unlockRecal();
});
